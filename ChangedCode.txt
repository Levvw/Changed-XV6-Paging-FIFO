diff --git a/xv6-public/.git/FETCH_HEAD b/xv6-public/.git/FETCH_HEAD
deleted file mode 100644
index c9e3149..0000000
--- a/xv6-public/.git/FETCH_HEAD
+++ /dev/null
@@ -1 +0,0 @@
-76aa66ed504c2c666101df30defe5bc13c2cef84	not-for-merge	branch 'main' of Operating-System-Project
diff --git a/xv6-public/.git/config b/xv6-paging/.git/config
index 40c3529..0f982a7 100644
--- a/xv6-public/.git/config
+++ b/xv6-paging/.git/config
@@ -4,11 +4,8 @@
 	bare = false
 	logallrefupdates = true
 [remote "origin"]
-	url = https://github.com/mit-pdos/xv6-public.git
+	url = https://github.com/asafch/xv6-paging.git
 	fetch = +refs/heads/*:refs/remotes/origin/*
 [branch "master"]
 	remote = origin
 	merge = refs/heads/master
-[remote "d1"]
-	url = Operating-System-Project
-	fetch = +refs/heads/*:refs/remotes/d1/*
diff --git a/xv6-public/.git/index b/xv6-paging/.git/index
index ac6c243..35c0b6b 100644
Binary files a/xv6-public/.git/index and b/xv6-paging/.git/index differ
diff --git a/xv6-public/.git/logs/HEAD b/xv6-paging/.git/logs/HEAD
index dc2c96b..cb2bb85 100644
--- a/xv6-public/.git/logs/HEAD
+++ b/xv6-paging/.git/logs/HEAD
@@ -1 +1 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 DoubleM01 <mahmoudmohamed200284@hotmail.com> 1641653035 +0200	clone: from https://github.com/mit-pdos/xv6-public.git
+0000000000000000000000000000000000000000 ee33bd0f07d4d5e99dddad828ae6bf33c81b68db DoubleM01 <mahmoudmohamed200284@hotmail.com> 1641657201 +0200	clone: from https://github.com/asafch/xv6-paging.git
diff --git a/xv6-public/.git/logs/refs/heads/master b/xv6-paging/.git/logs/refs/heads/master
index dc2c96b..cb2bb85 100644
--- a/xv6-public/.git/logs/refs/heads/master
+++ b/xv6-paging/.git/logs/refs/heads/master
@@ -1 +1 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 DoubleM01 <mahmoudmohamed200284@hotmail.com> 1641653035 +0200	clone: from https://github.com/mit-pdos/xv6-public.git
+0000000000000000000000000000000000000000 ee33bd0f07d4d5e99dddad828ae6bf33c81b68db DoubleM01 <mahmoudmohamed200284@hotmail.com> 1641657201 +0200	clone: from https://github.com/asafch/xv6-paging.git
diff --git a/xv6-public/.git/logs/refs/remotes/d1/main b/xv6-public/.git/logs/refs/remotes/d1/main
deleted file mode 100644
index 0cd803c..0000000
--- a/xv6-public/.git/logs/refs/remotes/d1/main
+++ /dev/null
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 76aa66ed504c2c666101df30defe5bc13c2cef84 DoubleM01 <mahmoudmohamed200284@hotmail.com> 1641653192 +0200	fetch d1: storing head
diff --git a/xv6-public/.git/logs/refs/remotes/origin/HEAD b/xv6-paging/.git/logs/refs/remotes/origin/HEAD
index dc2c96b..cb2bb85 100644
--- a/xv6-public/.git/logs/refs/remotes/origin/HEAD
+++ b/xv6-paging/.git/logs/refs/remotes/origin/HEAD
@@ -1 +1 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 DoubleM01 <mahmoudmohamed200284@hotmail.com> 1641653035 +0200	clone: from https://github.com/mit-pdos/xv6-public.git
+0000000000000000000000000000000000000000 ee33bd0f07d4d5e99dddad828ae6bf33c81b68db DoubleM01 <mahmoudmohamed200284@hotmail.com> 1641657201 +0200	clone: from https://github.com/asafch/xv6-paging.git
diff --git a/xv6-public/.git/objects/pack/pack-52923efd63d0a59edddfcbe1221e42831049b666.idx b/xv6-public/.git/objects/pack/pack-52923efd63d0a59edddfcbe1221e42831049b666.idx
deleted file mode 100644
index eabf5f1..0000000
Binary files a/xv6-public/.git/objects/pack/pack-52923efd63d0a59edddfcbe1221e42831049b666.idx and /dev/null differ
diff --git a/xv6-public/.git/objects/pack/pack-52923efd63d0a59edddfcbe1221e42831049b666.pack b/xv6-public/.git/objects/pack/pack-52923efd63d0a59edddfcbe1221e42831049b666.pack
deleted file mode 100644
index 7909876..0000000
Binary files a/xv6-public/.git/objects/pack/pack-52923efd63d0a59edddfcbe1221e42831049b666.pack and /dev/null differ
diff --git a/xv6-paging/.git/objects/pack/pack-e4694c7010b666ce04d6c0e338695b4d1a385a02.idx b/xv6-paging/.git/objects/pack/pack-e4694c7010b666ce04d6c0e338695b4d1a385a02.idx
new file mode 100644
index 0000000..6159daa
Binary files /dev/null and b/xv6-paging/.git/objects/pack/pack-e4694c7010b666ce04d6c0e338695b4d1a385a02.idx differ
diff --git a/xv6-paging/.git/objects/pack/pack-e4694c7010b666ce04d6c0e338695b4d1a385a02.pack b/xv6-paging/.git/objects/pack/pack-e4694c7010b666ce04d6c0e338695b4d1a385a02.pack
new file mode 100644
index 0000000..32f25ed
Binary files /dev/null and b/xv6-paging/.git/objects/pack/pack-e4694c7010b666ce04d6c0e338695b4d1a385a02.pack differ
diff --git a/xv6-public/.git/objects/pack/pack-eaa744f62176b6b46f56f06876c1b6c3743f3289.idx b/xv6-public/.git/objects/pack/pack-eaa744f62176b6b46f56f06876c1b6c3743f3289.idx
deleted file mode 100644
index 5050891..0000000
Binary files a/xv6-public/.git/objects/pack/pack-eaa744f62176b6b46f56f06876c1b6c3743f3289.idx and /dev/null differ
diff --git a/xv6-public/.git/objects/pack/pack-eaa744f62176b6b46f56f06876c1b6c3743f3289.pack b/xv6-public/.git/objects/pack/pack-eaa744f62176b6b46f56f06876c1b6c3743f3289.pack
deleted file mode 100644
index 2688881..0000000
Binary files a/xv6-public/.git/objects/pack/pack-eaa744f62176b6b46f56f06876c1b6c3743f3289.pack and /dev/null differ
diff --git a/xv6-public/.git/packed-refs b/xv6-paging/.git/packed-refs
index 0a3e432..09d1056 100644
--- a/xv6-public/.git/packed-refs
+++ b/xv6-paging/.git/packed-refs
@@ -1,28 +1,6 @@
 # pack-refs with: peeled fully-peeled sorted 
-eeb7b415dbcb12cc362d0783e41c3d1f44066b17 refs/remotes/origin/master
-af0e851a3a8a7d13bc2f2d596b58500594040892 refs/tags/osdi12-submit
-^8286b58087750e09bac3815219e0382a0bb2b159
-9e698c587b135db17b38a5838976805b9c01e338 refs/tags/symlinks
-05e0b1218dcebe1f40028531b51926df8ae52be0 refs/tags/xv6-2006
-^5cc0bd5ceaf805ab44f851e6a3f1952a29e9d7b7
-42f3c3f7be9717b66ba6e133a113c0f751c53133 refs/tags/xv6-2007
-adcd16c3f7588b4a28d37495f05e94278c9e3a1e refs/tags/xv6-2008
-124fe7e457c0dc9b671c7ffccb56004eb61da4f0 refs/tags/xv6-2010
-5922cdbbcc4fdbd76eec9e0dad9f650e4c86ee99 refs/tags/xv6-rev0
-^5cc0bd5ceaf805ab44f851e6a3f1952a29e9d7b7
-81f31a773dd49b001437eaed3975438585ff9911 refs/tags/xv6-rev1
-^42f3c3f7be9717b66ba6e133a113c0f751c53133
-b818915f793cd20c5d1e24f668534a9d690f3cc8 refs/tags/xv6-rev11
-30dab73b68b816877dc8f78504ceca0808c976eb refs/tags/xv6-rev3
-^074ac7ccd43c08d01a237ce6f14cac10715a51ef
-113005d48f09a4e3939940d72a77bf6973ea8755 refs/tags/xv6-rev4
-^124fe7e457c0dc9b671c7ffccb56004eb61da4f0
-d6aa754494b37e32862b1f78d53deedc53f66a15 refs/tags/xv6-rev5
-^ae603ff5e79bb7b5eea4147425752f33d29fe558
-3e9d6413d331b4c912d55bfac253af1629d4bac9 refs/tags/xv6-rev6
-^e64c661ae8b91bd7e858bb1895bef96e6ac2b4bb
-ccc25c0fac59067d88af52ad9f3b8cee97c3810a refs/tags/xv6-rev7
-^2ae8392a5c203a7b1bc5b8bff5eabc8b5eab8972
-7d6f95e327f1c18570d5dd187e3d92e1aadae2cf refs/tags/xv6-rev8
-^9ba21267e796eb462a657392906e3cbccaedcc99
-5bf3fbee00fb27cb8cb4eca72dcd9fc4c288ed71 refs/tags/xv6-rev9
+ee33bd0f07d4d5e99dddad828ae6bf33c81b68db refs/remotes/origin/asafchel
+6286a19b5954601af84f7ace474e8324763fa883 refs/remotes/origin/asafchel-task1
+ee33bd0f07d4d5e99dddad828ae6bf33c81b68db refs/remotes/origin/master
+6730e0eaeb521d7c3aca34f8167faed0f3087df3 refs/remotes/origin/part1
+738adef52884ccaa07879e56135a2ea3bd216c5f refs/remotes/origin/parts_3_4
diff --git a/xv6-public/.git/refs/heads/master b/xv6-paging/.git/refs/heads/master
index 4d13f29..21dae02 100644
--- a/xv6-public/.git/refs/heads/master
+++ b/xv6-paging/.git/refs/heads/master
@@ -1 +1 @@
-eeb7b415dbcb12cc362d0783e41c3d1f44066b17
+ee33bd0f07d4d5e99dddad828ae6bf33c81b68db
diff --git a/xv6-public/.git/refs/remotes/d1/main b/xv6-public/.git/refs/remotes/d1/main
deleted file mode 100644
index 62a0e58..0000000
--- a/xv6-public/.git/refs/remotes/d1/main
+++ /dev/null
@@ -1 +0,0 @@
-76aa66ed504c2c666101df30defe5bc13c2cef84
diff --git a/xv6-paging/.project b/xv6-paging/.project
new file mode 100644
index 0000000..05fa8b3
--- /dev/null
+++ b/xv6-paging/.project
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>xv6-a3</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+</projectDescription>
diff --git a/xv6-public/LICENSE b/xv6-paging/LICENSE
index 422c0cc..46fd1cc 100644
--- a/xv6-public/LICENSE
+++ b/xv6-paging/LICENSE
@@ -1,6 +1,6 @@
 The xv6 software is:
 
-Copyright (c) 2006-2018 Frans Kaashoek, Robert Morris, Russ Cox,
+Copyright (c) 2006-2009 Frans Kaashoek, Robert Morris, Russ Cox,
                         Massachusetts Institute of Technology
 
 Permission is hereby granted, free of charge, to any person obtaining
diff --git a/xv6-public/Makefile b/xv6-paging/Makefile
index 09d790c..8f266bf 100644
--- a/xv6-public/Makefile
+++ b/xv6-paging/Makefile
@@ -15,13 +15,13 @@ OBJS = \
 	picirq.o\
 	pipe.o\
 	proc.o\
-	sleeplock.o\
 	spinlock.o\
 	string.o\
 	swtch.o\
 	syscall.o\
 	sysfile.o\
 	sysproc.o\
+	timer.o\
 	trapasm.o\
 	trap.o\
 	uart.o\
@@ -32,7 +32,7 @@ OBJS = \
 # TOOLPREFIX = i386-jos-elf
 
 # Using native tools (e.g., on X86 Linux)
-#TOOLPREFIX = 
+#TOOLPREFIX =
 
 # Try to infer the correct TOOLPREFIX if not set
 ifndef TOOLPREFIX
@@ -59,8 +59,6 @@ QEMU = $(shell if which qemu > /dev/null; \
 	then echo qemu; exit; \
 	elif which qemu-system-i386 > /dev/null; \
 	then echo qemu-system-i386; exit; \
-	elif which qemu-system-x86_64 > /dev/null; \
-	then echo qemu-system-x86_64; exit; \
 	else \
 	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
 	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
@@ -71,26 +69,28 @@ QEMU = $(shell if which qemu > /dev/null; \
 	echo "***" 1>&2; exit 1)
 endif
 
+ifndef SELECTION
+SELECTION := NFU
+endif
+
+ifndef VERBOSE_PRINT
+VERBOSE_PRINT := FALSE
+endif
+
 CC = $(TOOLPREFIX)gcc
 AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+#CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+CFLAGS += -D$(SELECTION) -D$(VERBOSE_PRINT)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
-LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
-
-# Disable PIE when possible (for Ubuntu 16.10 toolchain)
-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
-CFLAGS += -fno-pie -no-pie
-endif
-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
-CFLAGS += -fno-pie -nopie
-endif
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null)
 
-xv6.img: bootblock kernel
+xv6.img: bootblock kernel fs.img
 	dd if=/dev/zero of=xv6.img count=10000
 	dd if=bootblock of=xv6.img conv=notrunc
 	dd if=kernel of=xv6.img seek=1 conv=notrunc
@@ -141,7 +141,7 @@ tags: $(OBJS) entryother.S _init
 	etags *.S *.c
 
 vectors.S: vectors.pl
-	./vectors.pl > vectors.S
+	perl vectors.pl > vectors.S
 
 ULIB = ulib.o usys.o printf.o umalloc.o
 
@@ -181,17 +181,19 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_myMemTest\
+	_m\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
 
 -include *.d
 
-clean: 
+clean:
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*.o *.d *.asm *.sym vectors.S bootblock entryother \
-	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
-	xv6memfs.img mkfs .gdbinit \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs mkfs \
+	.gdbinit \
 	$(UPROGS)
 
 # make a printout
@@ -219,13 +221,13 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 ifndef CPUS
 CPUS := 2
 endif
-QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+QEMUOPTS = -hdb fs.img xv6.img -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
 qemu: fs.img xv6.img
 	$(QEMU) -serial mon:stdio $(QEMUOPTS)
 
 qemu-memfs: xv6memfs.img
-	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+	$(QEMU) xv6memfs.img -smp $(CPUS) -m 256
 
 qemu-nox: fs.img xv6.img
 	$(QEMU) -nographic $(QEMUOPTS)
@@ -281,6 +283,6 @@ tar:
 	rm -rf /tmp/xv6
 	mkdir -p /tmp/xv6
 	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
-	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev9.tar.gz  # the next one will be 9 (6/27/15)
 
 .PHONY: dist-test dist
diff --git a/xv6-public/Operating-System-Project/.cvsignore b/xv6-public/Operating-System-Project/.cvsignore
deleted file mode 100644
index 081a43c..0000000
--- a/xv6-public/Operating-System-Project/.cvsignore
+++ /dev/null
@@ -1,16 +0,0 @@
-*.asm
-*.d
-*.sym
-_*
-kernel
-user1
-userfs
-usertests
-xv6.img
-vectors.S
-bochsout.txt
-bootblock
-bootother
-bootother.out
-parport.out
-fmt
diff --git a/xv6-public/Operating-System-Project/.dir-locals.el b/xv6-public/Operating-System-Project/.dir-locals.el
deleted file mode 100644
index da72247..0000000
--- a/xv6-public/Operating-System-Project/.dir-locals.el
+++ /dev/null
@@ -1,4 +0,0 @@
-((c-mode
-  (indent-tabs-mode . nil)
-  (c-file-style . "bsd")
-  (c-basic-offset . 2)))
diff --git a/xv6-public/Operating-System-Project/.gdbinit.tmpl b/xv6-public/Operating-System-Project/.gdbinit.tmpl
deleted file mode 100644
index f71681a..0000000
--- a/xv6-public/Operating-System-Project/.gdbinit.tmpl
+++ /dev/null
@@ -1,27 +0,0 @@
-set $lastcs = -1
-
-define hook-stop
-  # There doesn't seem to be a good way to detect if we're in 16- or
-  # 32-bit mode, but in 32-bit mode we always run with CS == 8 in the
-  # kernel and CS == 35 in user space
-  if $cs == 8 || $cs == 35
-    if $lastcs != 8 && $lastcs != 35
-      set architecture i386
-    end
-    x/i $pc
-  else
-    if $lastcs == -1 || $lastcs == 8 || $lastcs == 35
-      set architecture i8086
-    end
-    # Translate the segment:offset into a physical address
-    printf "[%4x:%4x] ", $cs, $eip
-    x/i $cs*16+$eip
-  end
-  set $lastcs = $cs
-end
-
-echo + target remote localhost:1234\n
-target remote localhost:1234
-
-echo + symbol-file kernel\n
-symbol-file kernel
diff --git a/xv6-public/Operating-System-Project/.git/HEAD b/xv6-public/Operating-System-Project/.git/HEAD
deleted file mode 100644
index b870d82..0000000
--- a/xv6-public/Operating-System-Project/.git/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-ref: refs/heads/main
diff --git a/xv6-public/Operating-System-Project/.git/config b/xv6-public/Operating-System-Project/.git/config
deleted file mode 100644
index d713715..0000000
--- a/xv6-public/Operating-System-Project/.git/config
+++ /dev/null
@@ -1,11 +0,0 @@
-[core]
-	repositoryformatversion = 0
-	filemode = true
-	bare = false
-	logallrefupdates = true
-[remote "origin"]
-	url = https://github.com/Amirhossein-Rajabpour/Operating-System-Project.git
-	fetch = +refs/heads/*:refs/remotes/origin/*
-[branch "main"]
-	remote = origin
-	merge = refs/heads/main
diff --git a/xv6-public/Operating-System-Project/.git/description b/xv6-public/Operating-System-Project/.git/description
deleted file mode 100644
index 498b267..0000000
--- a/xv6-public/Operating-System-Project/.git/description
+++ /dev/null
@@ -1 +0,0 @@
-Unnamed repository; edit this file 'description' to name the repository.
diff --git a/xv6-public/Operating-System-Project/.git/hooks/applypatch-msg.sample b/xv6-public/Operating-System-Project/.git/hooks/applypatch-msg.sample
deleted file mode 100644
index a5d7b84..0000000
--- a/xv6-public/Operating-System-Project/.git/hooks/applypatch-msg.sample
+++ /dev/null
@@ -1,15 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message taken by
-# applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.  The hook is
-# allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "applypatch-msg".
-
-. git-sh-setup
-commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
-test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
-:
diff --git a/xv6-public/Operating-System-Project/.git/hooks/commit-msg.sample b/xv6-public/Operating-System-Project/.git/hooks/commit-msg.sample
deleted file mode 100644
index b58d118..0000000
--- a/xv6-public/Operating-System-Project/.git/hooks/commit-msg.sample
+++ /dev/null
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message.
-# Called by "git commit" with one argument, the name of the file
-# that has the commit message.  The hook should exit with non-zero
-# status after issuing an appropriate message if it wants to stop the
-# commit.  The hook is allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "commit-msg".
-
-# Uncomment the below to add a Signed-off-by line to the message.
-# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
-# hook is more suited to it.
-#
-# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
-
-# This example catches duplicate Signed-off-by lines.
-
-test "" = "$(grep '^Signed-off-by: ' "$1" |
-	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
-	echo >&2 Duplicate Signed-off-by lines.
-	exit 1
-}
diff --git a/xv6-public/Operating-System-Project/.git/hooks/fsmonitor-watchman.sample b/xv6-public/Operating-System-Project/.git/hooks/fsmonitor-watchman.sample
deleted file mode 100644
index ef94fa2..0000000
--- a/xv6-public/Operating-System-Project/.git/hooks/fsmonitor-watchman.sample
+++ /dev/null
@@ -1,109 +0,0 @@
-#!/usr/bin/perl
-
-use strict;
-use warnings;
-use IPC::Open2;
-
-# An example hook script to integrate Watchman
-# (https://facebook.github.io/watchman/) with git to speed up detecting
-# new and modified files.
-#
-# The hook is passed a version (currently 1) and a time in nanoseconds
-# formatted as a string and outputs to stdout all files that have been
-# modified since the given time. Paths must be relative to the root of
-# the working tree and separated by a single NUL.
-#
-# To enable this hook, rename this file to "query-watchman" and set
-# 'git config core.fsmonitor .git/hooks/query-watchman'
-#
-my ($version, $time) = @ARGV;
-
-# Check the hook interface version
-
-if ($version == 1) {
-	# convert nanoseconds to seconds
-	# subtract one second to make sure watchman will return all changes
-	$time = int ($time / 1000000000) - 1;
-} else {
-	die "Unsupported query-fsmonitor hook version '$version'.\n" .
-	    "Falling back to scanning...\n";
-}
-
-my $git_work_tree;
-if ($^O =~ 'msys' || $^O =~ 'cygwin') {
-	$git_work_tree = Win32::GetCwd();
-	$git_work_tree =~ tr/\\/\//;
-} else {
-	require Cwd;
-	$git_work_tree = Cwd::cwd();
-}
-
-my $retry = 1;
-
-launch_watchman();
-
-sub launch_watchman {
-
-	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
-	    or die "open2() failed: $!\n" .
-	    "Falling back to scanning...\n";
-
-	# In the query expression below we're asking for names of files that
-	# changed since $time but were not transient (ie created after
-	# $time but no longer exist).
-	#
-	# To accomplish this, we're using the "since" generator to use the
-	# recency index to select candidate nodes and "fields" to limit the
-	# output to file names only.
-
-	my $query = <<"	END";
-		["query", "$git_work_tree", {
-			"since": $time,
-			"fields": ["name"]
-		}]
-	END
-
-	print CHLD_IN $query;
-	close CHLD_IN;
-	my $response = do {local $/; <CHLD_OUT>};
-
-	die "Watchman: command returned no output.\n" .
-	    "Falling back to scanning...\n" if $response eq "";
-	die "Watchman: command returned invalid output: $response\n" .
-	    "Falling back to scanning...\n" unless $response =~ /^\{/;
-
-	my $json_pkg;
-	eval {
-		require JSON::XS;
-		$json_pkg = "JSON::XS";
-		1;
-	} or do {
-		require JSON::PP;
-		$json_pkg = "JSON::PP";
-	};
-
-	my $o = $json_pkg->new->utf8->decode($response);
-
-	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
-		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
-		$retry--;
-		qx/watchman watch "$git_work_tree"/;
-		die "Failed to make watchman watch '$git_work_tree'.\n" .
-		    "Falling back to scanning...\n" if $? != 0;
-
-		# Watchman will always return all files on the first query so
-		# return the fast "everything is dirty" flag to git and do the
-		# Watchman query just to get it over with now so we won't pay
-		# the cost in git to look up each individual file.
-		print "/\0";
-		eval { launch_watchman() };
-		exit 0;
-	}
-
-	die "Watchman: $o->{error}.\n" .
-	    "Falling back to scanning...\n" if $o->{error};
-
-	binmode STDOUT, ":utf8";
-	local $, = "\0";
-	print @{$o->{files}};
-}
diff --git a/xv6-public/Operating-System-Project/.git/hooks/post-update.sample b/xv6-public/Operating-System-Project/.git/hooks/post-update.sample
deleted file mode 100644
index ec17ec1..0000000
--- a/xv6-public/Operating-System-Project/.git/hooks/post-update.sample
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare a packed repository for use over
-# dumb transports.
-#
-# To enable this hook, rename this file to "post-update".
-
-exec git update-server-info
diff --git a/xv6-public/Operating-System-Project/.git/hooks/pre-applypatch.sample b/xv6-public/Operating-System-Project/.git/hooks/pre-applypatch.sample
deleted file mode 100644
index 4142082..0000000
--- a/xv6-public/Operating-System-Project/.git/hooks/pre-applypatch.sample
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed
-# by applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-applypatch".
-
-. git-sh-setup
-precommit="$(git rev-parse --git-path hooks/pre-commit)"
-test -x "$precommit" && exec "$precommit" ${1+"$@"}
-:
diff --git a/xv6-public/Operating-System-Project/.git/hooks/pre-commit.sample b/xv6-public/Operating-System-Project/.git/hooks/pre-commit.sample
deleted file mode 100644
index 6a75641..0000000
--- a/xv6-public/Operating-System-Project/.git/hooks/pre-commit.sample
+++ /dev/null
@@ -1,49 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git commit" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message if
-# it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-commit".
-
-if git rev-parse --verify HEAD >/dev/null 2>&1
-then
-	against=HEAD
-else
-	# Initial commit: diff against an empty tree object
-	against=$(git hash-object -t tree /dev/null)
-fi
-
-# If you want to allow non-ASCII filenames set this variable to true.
-allownonascii=$(git config --bool hooks.allownonascii)
-
-# Redirect output to stderr.
-exec 1>&2
-
-# Cross platform projects tend to avoid non-ASCII filenames; prevent
-# them from being added to the repository. We exploit the fact that the
-# printable range starts at the space character and ends with tilde.
-if [ "$allownonascii" != "true" ] &&
-	# Note that the use of brackets around a tr range is ok here, (it's
-	# even required, for portability to Solaris 10's /usr/bin/tr), since
-	# the square bracket bytes happen to fall in the designated range.
-	test $(git diff --cached --name-only --diff-filter=A -z $against |
-	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
-then
-	cat <<\EOF
-Error: Attempt to add a non-ASCII file name.
-
-This can cause problems if you want to work with people on other platforms.
-
-To be portable it is advisable to rename the file.
-
-If you know what you are doing you can disable this check using:
-
-  git config hooks.allownonascii true
-EOF
-	exit 1
-fi
-
-# If there are whitespace errors, print the offending file names and fail.
-exec git diff-index --check --cached $against --
diff --git a/xv6-public/Operating-System-Project/.git/hooks/pre-merge-commit.sample b/xv6-public/Operating-System-Project/.git/hooks/pre-merge-commit.sample
deleted file mode 100644
index 399eab1..0000000
--- a/xv6-public/Operating-System-Project/.git/hooks/pre-merge-commit.sample
+++ /dev/null
@@ -1,13 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git merge" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message to
-# stderr if it wants to stop the merge commit.
-#
-# To enable this hook, rename this file to "pre-merge-commit".
-
-. git-sh-setup
-test -x "$GIT_DIR/hooks/pre-commit" &&
-        exec "$GIT_DIR/hooks/pre-commit"
-:
diff --git a/xv6-public/Operating-System-Project/.git/hooks/pre-push.sample b/xv6-public/Operating-System-Project/.git/hooks/pre-push.sample
deleted file mode 100644
index 6187dbf..0000000
--- a/xv6-public/Operating-System-Project/.git/hooks/pre-push.sample
+++ /dev/null
@@ -1,53 +0,0 @@
-#!/bin/sh
-
-# An example hook script to verify what is about to be pushed.  Called by "git
-# push" after it has checked the remote status, but before anything has been
-# pushed.  If this script exits with a non-zero status nothing will be pushed.
-#
-# This hook is called with the following parameters:
-#
-# $1 -- Name of the remote to which the push is being done
-# $2 -- URL to which the push is being done
-#
-# If pushing without using a named remote those arguments will be equal.
-#
-# Information about the commits which are being pushed is supplied as lines to
-# the standard input in the form:
-#
-#   <local ref> <local sha1> <remote ref> <remote sha1>
-#
-# This sample shows how to prevent push of commits where the log message starts
-# with "WIP" (work in progress).
-
-remote="$1"
-url="$2"
-
-z40=0000000000000000000000000000000000000000
-
-while read local_ref local_sha remote_ref remote_sha
-do
-	if [ "$local_sha" = $z40 ]
-	then
-		# Handle delete
-		:
-	else
-		if [ "$remote_sha" = $z40 ]
-		then
-			# New branch, examine all commits
-			range="$local_sha"
-		else
-			# Update to existing branch, examine new commits
-			range="$remote_sha..$local_sha"
-		fi
-
-		# Check for WIP commit
-		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
-		if [ -n "$commit" ]
-		then
-			echo >&2 "Found WIP commit in $local_ref, not pushing"
-			exit 1
-		fi
-	fi
-done
-
-exit 0
diff --git a/xv6-public/Operating-System-Project/.git/hooks/pre-rebase.sample b/xv6-public/Operating-System-Project/.git/hooks/pre-rebase.sample
deleted file mode 100644
index 6cbef5c..0000000
--- a/xv6-public/Operating-System-Project/.git/hooks/pre-rebase.sample
+++ /dev/null
@@ -1,169 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2006, 2008 Junio C Hamano
-#
-# The "pre-rebase" hook is run just before "git rebase" starts doing
-# its job, and can prevent the command from running by exiting with
-# non-zero status.
-#
-# The hook is called with the following parameters:
-#
-# $1 -- the upstream the series was forked from.
-# $2 -- the branch being rebased (or empty when rebasing the current branch).
-#
-# This sample shows how to prevent topic branches that are already
-# merged to 'next' branch from getting rebased, because allowing it
-# would result in rebasing already published history.
-
-publish=next
-basebranch="$1"
-if test "$#" = 2
-then
-	topic="refs/heads/$2"
-else
-	topic=`git symbolic-ref HEAD` ||
-	exit 0 ;# we do not interrupt rebasing detached HEAD
-fi
-
-case "$topic" in
-refs/heads/??/*)
-	;;
-*)
-	exit 0 ;# we do not interrupt others.
-	;;
-esac
-
-# Now we are dealing with a topic branch being rebased
-# on top of master.  Is it OK to rebase it?
-
-# Does the topic really exist?
-git show-ref -q "$topic" || {
-	echo >&2 "No such branch $topic"
-	exit 1
-}
-
-# Is topic fully merged to master?
-not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
-if test -z "$not_in_master"
-then
-	echo >&2 "$topic is fully merged to master; better remove it."
-	exit 1 ;# we could allow it, but there is no point.
-fi
-
-# Is topic ever merged to next?  If so you should not be rebasing it.
-only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
-only_next_2=`git rev-list ^master           ${publish} | sort`
-if test "$only_next_1" = "$only_next_2"
-then
-	not_in_topic=`git rev-list "^$topic" master`
-	if test -z "$not_in_topic"
-	then
-		echo >&2 "$topic is already up to date with master"
-		exit 1 ;# we could allow it, but there is no point.
-	else
-		exit 0
-	fi
-else
-	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
-	/usr/bin/perl -e '
-		my $topic = $ARGV[0];
-		my $msg = "* $topic has commits already merged to public branch:\n";
-		my (%not_in_next) = map {
-			/^([0-9a-f]+) /;
-			($1 => 1);
-		} split(/\n/, $ARGV[1]);
-		for my $elem (map {
-				/^([0-9a-f]+) (.*)$/;
-				[$1 => $2];
-			} split(/\n/, $ARGV[2])) {
-			if (!exists $not_in_next{$elem->[0]}) {
-				if ($msg) {
-					print STDERR $msg;
-					undef $msg;
-				}
-				print STDERR " $elem->[1]\n";
-			}
-		}
-	' "$topic" "$not_in_next" "$not_in_master"
-	exit 1
-fi
-
-<<\DOC_END
-
-This sample hook safeguards topic branches that have been
-published from being rewound.
-
-The workflow assumed here is:
-
- * Once a topic branch forks from "master", "master" is never
-   merged into it again (either directly or indirectly).
-
- * Once a topic branch is fully cooked and merged into "master",
-   it is deleted.  If you need to build on top of it to correct
-   earlier mistakes, a new topic branch is created by forking at
-   the tip of the "master".  This is not strictly necessary, but
-   it makes it easier to keep your history simple.
-
- * Whenever you need to test or publish your changes to topic
-   branches, merge them into "next" branch.
-
-The script, being an example, hardcodes the publish branch name
-to be "next", but it is trivial to make it configurable via
-$GIT_DIR/config mechanism.
-
-With this workflow, you would want to know:
-
-(1) ... if a topic branch has ever been merged to "next".  Young
-    topic branches can have stupid mistakes you would rather
-    clean up before publishing, and things that have not been
-    merged into other branches can be easily rebased without
-    affecting other people.  But once it is published, you would
-    not want to rewind it.
-
-(2) ... if a topic branch has been fully merged to "master".
-    Then you can delete it.  More importantly, you should not
-    build on top of it -- other people may already want to
-    change things related to the topic as patches against your
-    "master", so if you need further changes, it is better to
-    fork the topic (perhaps with the same name) afresh from the
-    tip of "master".
-
-Let's look at this example:
-
-		   o---o---o---o---o---o---o---o---o---o "next"
-		  /       /           /           /
-		 /   a---a---b A     /           /
-		/   /               /           /
-	       /   /   c---c---c---c B         /
-	      /   /   /             \         /
-	     /   /   /   b---b C     \       /
-	    /   /   /   /             \     /
-    ---o---o---o---o---o---o---o---o---o---o---o "master"
-
-
-A, B and C are topic branches.
-
- * A has one fix since it was merged up to "next".
-
- * B has finished.  It has been fully merged up to "master" and "next",
-   and is ready to be deleted.
-
- * C has not merged to "next" at all.
-
-We would want to allow C to be rebased, refuse A, and encourage
-B to be deleted.
-
-To compute (1):
-
-	git rev-list ^master ^topic next
-	git rev-list ^master        next
-
-	if these match, topic has not merged in next at all.
-
-To compute (2):
-
-	git rev-list master..topic
-
-	if this is empty, it is fully merged to "master".
-
-DOC_END
diff --git a/xv6-public/Operating-System-Project/.git/hooks/pre-receive.sample b/xv6-public/Operating-System-Project/.git/hooks/pre-receive.sample
deleted file mode 100644
index a1fd29e..0000000
--- a/xv6-public/Operating-System-Project/.git/hooks/pre-receive.sample
+++ /dev/null
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to make use of push options.
-# The example simply echoes all push options that start with 'echoback='
-# and rejects all pushes when the "reject" push option is used.
-#
-# To enable this hook, rename this file to "pre-receive".
-
-if test -n "$GIT_PUSH_OPTION_COUNT"
-then
-	i=0
-	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
-	do
-		eval "value=\$GIT_PUSH_OPTION_$i"
-		case "$value" in
-		echoback=*)
-			echo "echo from the pre-receive-hook: ${value#*=}" >&2
-			;;
-		reject)
-			exit 1
-		esac
-		i=$((i + 1))
-	done
-fi
diff --git a/xv6-public/Operating-System-Project/.git/hooks/prepare-commit-msg.sample b/xv6-public/Operating-System-Project/.git/hooks/prepare-commit-msg.sample
deleted file mode 100644
index 10fa14c..0000000
--- a/xv6-public/Operating-System-Project/.git/hooks/prepare-commit-msg.sample
+++ /dev/null
@@ -1,42 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare the commit log message.
-# Called by "git commit" with the name of the file that has the
-# commit message, followed by the description of the commit
-# message's source.  The hook's purpose is to edit the commit
-# message file.  If the hook fails with a non-zero status,
-# the commit is aborted.
-#
-# To enable this hook, rename this file to "prepare-commit-msg".
-
-# This hook includes three examples. The first one removes the
-# "# Please enter the commit message..." help message.
-#
-# The second includes the output of "git diff --name-status -r"
-# into the message, just before the "git status" output.  It is
-# commented because it doesn't cope with --amend or with squashed
-# commits.
-#
-# The third example adds a Signed-off-by line to the message, that can
-# still be edited.  This is rarely a good idea.
-
-COMMIT_MSG_FILE=$1
-COMMIT_SOURCE=$2
-SHA1=$3
-
-/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
-
-# case "$COMMIT_SOURCE,$SHA1" in
-#  ,|template,)
-#    /usr/bin/perl -i.bak -pe '
-#       print "\n" . `git diff --cached --name-status -r`
-# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
-#  *) ;;
-# esac
-
-# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
-# if test -z "$COMMIT_SOURCE"
-# then
-#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
-# fi
diff --git a/xv6-public/Operating-System-Project/.git/hooks/update.sample b/xv6-public/Operating-System-Project/.git/hooks/update.sample
deleted file mode 100644
index 80ba941..0000000
--- a/xv6-public/Operating-System-Project/.git/hooks/update.sample
+++ /dev/null
@@ -1,128 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to block unannotated tags from entering.
-# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
-#
-# To enable this hook, rename this file to "update".
-#
-# Config
-# ------
-# hooks.allowunannotated
-#   This boolean sets whether unannotated tags will be allowed into the
-#   repository.  By default they won't be.
-# hooks.allowdeletetag
-#   This boolean sets whether deleting tags will be allowed in the
-#   repository.  By default they won't be.
-# hooks.allowmodifytag
-#   This boolean sets whether a tag may be modified after creation. By default
-#   it won't be.
-# hooks.allowdeletebranch
-#   This boolean sets whether deleting branches will be allowed in the
-#   repository.  By default they won't be.
-# hooks.denycreatebranch
-#   This boolean sets whether remotely creating branches will be denied
-#   in the repository.  By default this is allowed.
-#
-
-# --- Command line
-refname="$1"
-oldrev="$2"
-newrev="$3"
-
-# --- Safety check
-if [ -z "$GIT_DIR" ]; then
-	echo "Don't run this script from the command line." >&2
-	echo " (if you want, you could supply GIT_DIR then run" >&2
-	echo "  $0 <ref> <oldrev> <newrev>)" >&2
-	exit 1
-fi
-
-if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
-	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
-	exit 1
-fi
-
-# --- Config
-allowunannotated=$(git config --bool hooks.allowunannotated)
-allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
-denycreatebranch=$(git config --bool hooks.denycreatebranch)
-allowdeletetag=$(git config --bool hooks.allowdeletetag)
-allowmodifytag=$(git config --bool hooks.allowmodifytag)
-
-# check for no description
-projectdesc=$(sed -e '1q' "$GIT_DIR/description")
-case "$projectdesc" in
-"Unnamed repository"* | "")
-	echo "*** Project description file hasn't been set" >&2
-	exit 1
-	;;
-esac
-
-# --- Check types
-# if $newrev is 0000...0000, it's a commit to delete a ref.
-zero="0000000000000000000000000000000000000000"
-if [ "$newrev" = "$zero" ]; then
-	newrev_type=delete
-else
-	newrev_type=$(git cat-file -t $newrev)
-fi
-
-case "$refname","$newrev_type" in
-	refs/tags/*,commit)
-		# un-annotated tag
-		short_refname=${refname##refs/tags/}
-		if [ "$allowunannotated" != "true" ]; then
-			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
-			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,delete)
-		# delete tag
-		if [ "$allowdeletetag" != "true" ]; then
-			echo "*** Deleting a tag is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,tag)
-		# annotated tag
-		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
-		then
-			echo "*** Tag '$refname' already exists." >&2
-			echo "*** Modifying a tag is not allowed in this repository." >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,commit)
-		# branch
-		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
-			echo "*** Creating a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,delete)
-		# delete branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/remotes/*,commit)
-		# tracking branch
-		;;
-	refs/remotes/*,delete)
-		# delete tracking branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	*)
-		# Anything else (is there anything else?)
-		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
-		exit 1
-		;;
-esac
-
-# --- Finished
-exit 0
diff --git a/xv6-public/Operating-System-Project/.git/index b/xv6-public/Operating-System-Project/.git/index
deleted file mode 100644
index 3e32f52..0000000
Binary files a/xv6-public/Operating-System-Project/.git/index and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/.git/info/exclude b/xv6-public/Operating-System-Project/.git/info/exclude
deleted file mode 100644
index a5196d1..0000000
--- a/xv6-public/Operating-System-Project/.git/info/exclude
+++ /dev/null
@@ -1,6 +0,0 @@
-# git ls-files --others --exclude-from=.git/info/exclude
-# Lines that start with '#' are comments.
-# For a project mostly in C, the following would be a good set of
-# exclude patterns (uncomment them if you want to use them):
-# *.[oa]
-# *~
diff --git a/xv6-public/Operating-System-Project/.git/logs/HEAD b/xv6-public/Operating-System-Project/.git/logs/HEAD
deleted file mode 100644
index 0daa4c3..0000000
--- a/xv6-public/Operating-System-Project/.git/logs/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 76aa66ed504c2c666101df30defe5bc13c2cef84 double_m <double_m@MMProgrammer.localdomain> 1640896913 +0200	clone: from https://github.com/Amirhossein-Rajabpour/Operating-System-Project.git
diff --git a/xv6-public/Operating-System-Project/.git/logs/refs/heads/main b/xv6-public/Operating-System-Project/.git/logs/refs/heads/main
deleted file mode 100644
index 0daa4c3..0000000
--- a/xv6-public/Operating-System-Project/.git/logs/refs/heads/main
+++ /dev/null
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 76aa66ed504c2c666101df30defe5bc13c2cef84 double_m <double_m@MMProgrammer.localdomain> 1640896913 +0200	clone: from https://github.com/Amirhossein-Rajabpour/Operating-System-Project.git
diff --git a/xv6-public/Operating-System-Project/.git/logs/refs/remotes/origin/HEAD b/xv6-public/Operating-System-Project/.git/logs/refs/remotes/origin/HEAD
deleted file mode 100644
index 0daa4c3..0000000
--- a/xv6-public/Operating-System-Project/.git/logs/refs/remotes/origin/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 76aa66ed504c2c666101df30defe5bc13c2cef84 double_m <double_m@MMProgrammer.localdomain> 1640896913 +0200	clone: from https://github.com/Amirhossein-Rajabpour/Operating-System-Project.git
diff --git a/xv6-public/Operating-System-Project/.git/objects/pack/pack-231bde8f73fa0d3c87ba68ea249e408b9b2a0275.idx b/xv6-public/Operating-System-Project/.git/objects/pack/pack-231bde8f73fa0d3c87ba68ea249e408b9b2a0275.idx
deleted file mode 100644
index c58ce3f..0000000
Binary files a/xv6-public/Operating-System-Project/.git/objects/pack/pack-231bde8f73fa0d3c87ba68ea249e408b9b2a0275.idx and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/.git/objects/pack/pack-231bde8f73fa0d3c87ba68ea249e408b9b2a0275.pack b/xv6-public/Operating-System-Project/.git/objects/pack/pack-231bde8f73fa0d3c87ba68ea249e408b9b2a0275.pack
deleted file mode 100644
index acbf4f8..0000000
Binary files a/xv6-public/Operating-System-Project/.git/objects/pack/pack-231bde8f73fa0d3c87ba68ea249e408b9b2a0275.pack and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/.git/packed-refs b/xv6-public/Operating-System-Project/.git/packed-refs
deleted file mode 100644
index 8351dcd..0000000
--- a/xv6-public/Operating-System-Project/.git/packed-refs
+++ /dev/null
@@ -1,4 +0,0 @@
-# pack-refs with: peeled fully-peeled sorted 
-fe0beba4f957e977a6d690fe8ca38e7a4b094713 refs/remotes/origin/dev
-76aa66ed504c2c666101df30defe5bc13c2cef84 refs/remotes/origin/main
-925a89ad201fe4d209ac6ff186c2183a4dae20fb refs/remotes/origin/master
diff --git a/xv6-public/Operating-System-Project/.git/refs/heads/main b/xv6-public/Operating-System-Project/.git/refs/heads/main
deleted file mode 100644
index 62a0e58..0000000
--- a/xv6-public/Operating-System-Project/.git/refs/heads/main
+++ /dev/null
@@ -1 +0,0 @@
-76aa66ed504c2c666101df30defe5bc13c2cef84
diff --git a/xv6-public/Operating-System-Project/.git/refs/remotes/origin/HEAD b/xv6-public/Operating-System-Project/.git/refs/remotes/origin/HEAD
deleted file mode 100644
index 4b0a875..0000000
--- a/xv6-public/Operating-System-Project/.git/refs/remotes/origin/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-ref: refs/remotes/origin/main
diff --git a/xv6-public/Operating-System-Project/.gitignore b/xv6-public/Operating-System-Project/.gitignore
deleted file mode 100644
index 3e2c9de..0000000
--- a/xv6-public/Operating-System-Project/.gitignore
+++ /dev/null
@@ -1,16 +0,0 @@
-*~
-_*
-*.o
-*.d
-*.asm
-*.sym
-*.img
-vectors.S
-bootblock
-entryother
-initcode
-initcode.out
-kernel
-kernelmemfs
-mkfs
-.gdbinit
diff --git a/xv6-public/Operating-System-Project/.vscode/settings.json b/xv6-public/Operating-System-Project/.vscode/settings.json
deleted file mode 100644
index c0f8937..0000000
--- a/xv6-public/Operating-System-Project/.vscode/settings.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "files.associations": {
-        "spinlock.h": "c",
-        "defs.h": "c",
-        "cstdlib": "c",
-        "types.h": "c",
-        "user.h": "c",
-        "proc.h": "c",
-        "memlayout.h": "c",
-        "syscall.h": "c"
-    }
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/BUGS b/xv6-public/Operating-System-Project/BUGS
deleted file mode 100644
index 81d2220..0000000
--- a/xv6-public/Operating-System-Project/BUGS
+++ /dev/null
@@ -1,7 +0,0 @@
-formatting:
-	need to fix PAGEBREAK mechanism
-
-sh:
-	can't always runcmd in child -- breaks cd.
-	maybe should hard-code PATH=/ ?
-
diff --git a/xv6-public/Operating-System-Project/LICENSE b/xv6-public/Operating-System-Project/LICENSE
deleted file mode 100644
index 422c0cc..0000000
--- a/xv6-public/Operating-System-Project/LICENSE
+++ /dev/null
@@ -1,24 +0,0 @@
-The xv6 software is:
-
-Copyright (c) 2006-2018 Frans Kaashoek, Robert Morris, Russ Cox,
-                        Massachusetts Institute of Technology
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be
-included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
diff --git a/xv6-public/Operating-System-Project/Makefile b/xv6-public/Operating-System-Project/Makefile
deleted file mode 100644
index 4c9edbd..0000000
--- a/xv6-public/Operating-System-Project/Makefile
+++ /dev/null
@@ -1,300 +0,0 @@
-OBJS = \
-	bio.o\
-	console.o\
-	exec.o\
-	file.o\
-	fs.o\
-	ide.o\
-	ioapic.o\
-	kalloc.o\
-	kbd.o\
-	lapic.o\
-	log.o\
-	main.o\
-	mp.o\
-	picirq.o\
-	pipe.o\
-	proc.o\
-	sleeplock.o\
-	spinlock.o\
-	string.o\
-	swtch.o\
-	syscall.o\
-	sysfile.o\
-	sysproc.o\
-	trapasm.o\
-	trap.o\
-	uart.o\
-	vectors.o\
-	vm.o\
-
-# Cross-compiling (e.g., on Mac OS X)
-# TOOLPREFIX = i386-jos-elf
-
-# Using native tools (e.g., on X86 Linux)
-#TOOLPREFIX = 
-
-# Try to infer the correct TOOLPREFIX if not set
-ifndef TOOLPREFIX
-TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
-	then echo 'i386-jos-elf-'; \
-	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
-	then echo ''; \
-	else echo "***" 1>&2; \
-	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
-	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
-	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
-	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
-	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
-	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
-	echo "***" 1>&2; exit 1; fi)
-endif
-
-# If the makefile can't find QEMU, specify its path here
-# QEMU = qemu-system-i386
-
-# Try to infer the correct QEMU
-ifndef QEMU
-QEMU = $(shell if which qemu > /dev/null; \
-	then echo qemu; exit; \
-	elif which qemu-system-i386 > /dev/null; \
-	then echo qemu-system-i386; exit; \
-	elif which qemu-system-x86_64 > /dev/null; \
-	then echo qemu-system-x86_64; exit; \
-	else \
-	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
-	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
-	echo "***" 1>&2; \
-	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
-	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
-	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
-	echo "***" 1>&2; exit 1)
-endif
-
-CC = $(TOOLPREFIX)gcc
-AS = $(TOOLPREFIX)gas
-LD = $(TOOLPREFIX)ld
-OBJCOPY = $(TOOLPREFIX)objcopy
-OBJDUMP = $(TOOLPREFIX)objdump
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
-CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
-ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
-# FreeBSD ld wants ``elf_i386_fbsd''
-LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
-
-# Disable PIE when possible (for Ubuntu 16.10 toolchain)
-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
-CFLAGS += -fno-pie -no-pie
-endif
-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
-CFLAGS += -fno-pie -nopie
-endif
-
-xv6.img: bootblock kernel
-	dd if=/dev/zero of=xv6.img count=10000
-	dd if=bootblock of=xv6.img conv=notrunc
-	dd if=kernel of=xv6.img seek=1 conv=notrunc
-
-xv6memfs.img: bootblock kernelmemfs
-	dd if=/dev/zero of=xv6memfs.img count=10000
-	dd if=bootblock of=xv6memfs.img conv=notrunc
-	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
-
-bootblock: bootasm.S bootmain.c
-	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
-	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
-	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
-	$(OBJDUMP) -S bootblock.o > bootblock.asm
-	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
-	./sign.pl bootblock
-
-entryother: entryother.S
-	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
-	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
-	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
-	$(OBJDUMP) -S bootblockother.o > entryother.asm
-
-initcode: initcode.S
-	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
-	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
-	$(OBJCOPY) -S -O binary initcode.out initcode
-	$(OBJDUMP) -S initcode.o > initcode.asm
-
-kernel: $(OBJS) entry.o entryother initcode kernel.ld
-	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
-	$(OBJDUMP) -S kernel > kernel.asm
-	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
-
-# kernelmemfs is a copy of kernel that maintains the
-# disk image in memory instead of writing to a disk.
-# This is not so useful for testing persistent storage or
-# exploring disk buffering implementations, but it is
-# great for testing the kernel on real hardware without
-# needing a scratch disk.
-MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
-kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
-	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
-	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
-	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
-
-tags: $(OBJS) entryother.S _init
-	etags *.S *.c
-
-vectors.S: vectors.pl
-	./vectors.pl > vectors.S
-
-ULIB = ulib.o usys.o printf.o umalloc.o
-
-_%: %.o $(ULIB)
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
-	$(OBJDUMP) -S $@ > $*.asm
-	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
-
-_forktest: forktest.o $(ULIB)
-	# forktest has less library code linked in - needs to be small
-	# in order to be able to max out the proc table.
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
-	$(OBJDUMP) -S _forktest > forktest.asm
-
-mkfs: mkfs.c fs.h
-	gcc -Werror -Wall -o mkfs mkfs.c
-
-# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
-# that disk image changes after first build are persistent until clean.  More
-# details:
-# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
-.PRECIOUS: %.o
-
-UPROGS=\
-	_cat\
-	_echo\
-	_forktest\
-	_grep\
-	_init\
-	_kill\
-	_ln\
-	_ls\
-	_mkdir\
-	_rm\
-	_sh\
-	_stressfs\
-	_usertests\
-	_wc\
-	_zombie\
-	_getParentIDtest\
-	_getChildrenTest\
-	_getSyscallCounterTest\
-	_getCBTtest\
-	_getTurnAroundTimeTest\
-	_getWaitingTimeTest\
-	_roundRobinTest\
-	_multiLayeredQueuedTest\
-	_SJF\
-
-
-
-fs.img: mkfs README $(UPROGS)
-	./mkfs fs.img README $(UPROGS)
-
--include *.d
-
-clean: 
-	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
-	*.o *.d *.asm *.sym vectors.S bootblock entryother \
-	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
-	xv6memfs.img mkfs .gdbinit \
-	$(UPROGS)
-
-# make a printout
-FILES = $(shell grep -v '^\#' runoff.list)
-PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
-
-xv6.pdf: $(PRINT)
-	./runoff
-	ls -l xv6.pdf
-
-print: xv6.pdf
-
-# run in emulators
-
-bochs : fs.img xv6.img
-	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
-	bochs -q
-
-# try to generate a unique GDB port
-GDBPORT = $(shell expr `id -u` % 5000 + 25000)
-# QEMU's gdb stub command line changed in 0.11
-QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
-	then echo "-gdb tcp::$(GDBPORT)"; \
-	else echo "-s -p $(GDBPORT)"; fi)
-ifndef CPUS
-CPUS := 2
-endif
-QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
-
-qemu: fs.img xv6.img
-	$(QEMU) -serial mon:stdio $(QEMUOPTS)
-
-qemu-memfs: xv6memfs.img
-	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
-
-qemu-nox: fs.img xv6.img
-	$(QEMU) -nographic $(QEMUOPTS)
-
-.gdbinit: .gdbinit.tmpl
-	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
-
-qemu-gdb: fs.img xv6.img .gdbinit
-	@echo "*** Now run 'gdb'." 1>&2
-	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
-
-qemu-nox-gdb: fs.img xv6.img .gdbinit
-	@echo "*** Now run 'gdb'." 1>&2
-	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
-
-# CUT HERE
-# prepare dist for students
-# after running make dist, probably want to
-# rename it to rev0 or rev1 or so on and then
-# check in that version.
-
-EXTRA=\
-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	getParentIDtest.c getChildrenTest.c getSyscallCounterTest.c\
-	getCBTtest.c getTurnAroundTimeTest.c getWaitingTimeTest.c\
-	roundRobinTest.c multiLayeredQueuedTest.c SJF.c\
-	printf.c umalloc.c\
-	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
-	.gdbinit.tmpl gdbutil\
-
-dist:
-	rm -rf dist
-	mkdir dist
-	for i in $(FILES); \
-	do \
-		grep -v PAGEBREAK $$i >dist/$$i; \
-	done
-	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
-	echo >dist/runoff.spec
-	cp $(EXTRA) dist
-
-dist-test:
-	rm -rf dist
-	make dist
-	rm -rf dist-test
-	mkdir dist-test
-	cp dist/* dist-test
-	cd dist-test; $(MAKE) print
-	cd dist-test; $(MAKE) bochs || true
-	cd dist-test; $(MAKE) qemu
-
-# update this rule (change rev#) when it is time to
-# make a new revision.
-tar:
-	rm -rf /tmp/xv6
-	mkdir -p /tmp/xv6
-	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
-	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
-
-.PHONY: dist-test dist
diff --git a/xv6-public/Operating-System-Project/Notes b/xv6-public/Operating-System-Project/Notes
deleted file mode 100644
index 74c8aea..0000000
--- a/xv6-public/Operating-System-Project/Notes
+++ /dev/null
@@ -1,123 +0,0 @@
-bochs 2.2.6:
-./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae --disable-reset-on-triple-fault
-bochs CVS after 2.2.6:
-./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae 
-
-bootmain.c doesn't work right if the ELF sections aren't
-sector-aligned. so you can't use ld -N. and the sections may also need
-to be non-zero length, only really matters for tiny "kernels".
-
-kernel loaded at 1 megabyte. stack same place that bootasm.S left it.
-
-kinit() should find real mem size
-  and rescue useable memory below 1 meg
-
-no paging, no use of page table hardware, just segments
-
-no user area: no magic kernel stack mapping
-  so no copying of kernel stack during fork
-  though there is a kernel stack page for each process
-
-no kernel malloc(), just kalloc() for user core
-
-user pointers aren't valid in the kernel
-
-are interrupts turned on in the kernel? yes.
-
-pass curproc explicitly, or implicit from cpu #?
-  e.g. argument to newproc()?
-  hmm, you need a global curproc[cpu] for trap() &c
-
-no stack expansion
-
-test running out of memory, process slots
-
-we can't really use a separate stack segment, since stack addresses
-need to work correctly as ordinary pointers. the same may be true of
-data vs text. how can we have a gap between data and stack, so that
-both can grow, without committing 4GB of physical memory? does this
-mean we need paging?
-
-perhaps have fixed-size stack, put it in the data segment?
-
-oops, if kernel stack is in contiguous user phys mem, then moving
-users' memory (e.g. to expand it) will wreck any pointers into the
-kernel stack.
-
-do we need to set fs and gs? so user processes can't abuse them?
-
-setupsegs() may modify current segment table, is that legal?
-
-trap() ought to lgdt on return, since currently only done in swtch()
-
-protect hardware interrupt vectors from user INT instructions?
-
-test out-of-fd cases for creating pipe.
-test pipe reader closes then write
-test two readers, two writers.
-test children being inherited by grandparent &c
-
-some sleep()s should be interruptible by kill()
-
-locks
-  init_lock
-    sequences CPU startup
-  proc_table_lock
-    also protects next_pid
-  per-fd lock *just* protects count read-modify-write
-    also maybe freeness?
-  memory allocator
-  printf
-
-in general, the table locks protect both free-ness and
-  public variables of table elements
-  in many cases you can use table elements w/o a lock
-  e.g. if you are the process, or you are using an fd
-
-lock order
-  per-pipe lock
-  proc_table_lock fd_table_lock kalloc_lock
-  console_lock
-
-do you have to be holding the mutex in order to call wakeup()? yes
-
-device interrupts don't clear FL_IF
-  so a recursive timer interrupt is possible
-
-what does inode->busy mean?
-  might be held across disk reads
-  no-one is allowed to do anything to the inode
-  protected by inode_table_lock
-inode->count counts in-memory pointers to the struct
-  prevents inode[] element from being re-used
-  protected by inode_table_lock
-
-blocks and inodes have ad-hoc sleep-locks
-  provide a single mechanism?
-
-kalloc() can return 0; do callers handle this right?
-
-test: one process unlinks a file while another links to it
-test: one process opens a file while another deletes it
-test: deadlock d/.. vs ../d, two processes.
-test: dup() shared fd->off
-test: does echo foo > x truncate x?
-
-sh: ioredirection incorrect now we have pipes
-sh: chain of pipes won't work, also ugly that parent closes fdarray entries too
-sh: dynamic memory allocation?
-sh: should sh support ; () &
-sh: stop stdin on ctrl-d (for cat > y)
-
-really should have bdwrite() for file content
-  and make some inode updates async
-  so soft updates make sense
-
-disk scheduling
-echo foo > bar should truncate bar
-  so O_CREATE should not truncate
-  but O_TRUNC should
-
-make it work on a real machine
-release before acquire at end of sleep?
-check 2nd disk (i.e. if not in .bochsrc)
diff --git a/xv6-public/Operating-System-Project/README b/xv6-public/Operating-System-Project/README
deleted file mode 100644
index 923e0a4..0000000
--- a/xv6-public/Operating-System-Project/README
+++ /dev/null
@@ -1,51 +0,0 @@
-NOTE: we have stopped maintaining the x86 version of xv6, and switched
-our efforts to the RISC-V version
-(https://github.com/mit-pdos/xv6-riscv.git)
-
-xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
-Version 6 (v6).  xv6 loosely follows the structure and style of v6,
-but is implemented for a modern x86-based multiprocessor using ANSI C.
-
-ACKNOWLEDGMENTS
-
-xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
-to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
-2000)). See also https://pdos.csail.mit.edu/6.828/, which
-provides pointers to on-line resources for v6.
-
-xv6 borrows code from the following sources:
-    JOS (asm.h, elf.h, mmu.h, bootasm.S, ide.c, console.c, and others)
-    Plan 9 (entryother.S, mp.h, mp.c, lapic.c)
-    FreeBSD (ioapic.c)
-    NetBSD (console.c)
-
-The following people have made contributions: Russ Cox (context switching,
-locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
-Clements.
-
-We are also grateful for the bug reports and patches contributed by Silas
-Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
-Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter
-Froehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander
-Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin
-Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi
-Merimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,
-Eldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren
-Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
-Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.
-
-The code in the files that constitute xv6 is
-Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.
-
-ERROR REPORTS
-
-We don't process error reports (see note on top of this file).
-
-BUILDING AND RUNNING XV6
-
-To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
-"make". On non-x86 or non-ELF machines (like OS X, even on x86), you
-will need to install a cross-compiler gcc suite capable of producing
-x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
-Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
-simulator and run "make qemu".
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/README.md b/xv6-public/Operating-System-Project/README.md
deleted file mode 100644
index 413b2f8..0000000
--- a/xv6-public/Operating-System-Project/README.md
+++ /dev/null
@@ -1,6 +0,0 @@
-## About XV6
-xv6 is a modern reimplementation of Sixth Edition Unix in ANSI C for multiprocessor x86 and RISC-V systems. It was created for pedagogical purposes in MIT's Operating System Engineering course. [Wikipedia](https://en.wikipedia.org/wiki/Xv6)
-
-
-## About this project
-For the final project of the Operating Systems course (Fall 2020, instructed by [Dr. Seyed Ahmad Javadi](https://www3.cs.stonybrook.edu/~sjavadi/)), We ([danialzz](https://github.com/Danialzz) and [i](https://github.com/amirhoseinRj)) added some additional features to xv6. Our work mainly includes adding process scheduling algorithms (such as Priority, Reverse priority, Round Robin, and MultiLayered Queue scheduling), and also some useful system calls (i.e. getParentID, getChildren, getSyscallCounter, ...). The full documentation of the project can be found [here](https://github.com/amirhoseinRj/Operating-System-Project/blob/main/docs/Project%20Report.pdf) and [here](https://github.com/amirhoseinRj/Operating-System-Project/blob/main/docs/final_project_assignment_v1.pdf).
diff --git a/xv6-public/Operating-System-Project/SJF.asm b/xv6-public/Operating-System-Project/SJF.asm
deleted file mode 100644
index 391d02e..0000000
--- a/xv6-public/Operating-System-Project/SJF.asm
+++ /dev/null
@@ -1,1564 +0,0 @@
-
-_SJF:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-        }
-    }
-}
- 
-int main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	57                   	push   %edi
-  12:	56                   	push   %esi
-  13:	53                   	push   %ebx
-  14:	51                   	push   %ecx
-  15:	81 ec 94 01 00 00    	sub    $0x194,%esp
-    int result = changePolicy(2);
-  1b:	6a 02                	push   $0x2
-  1d:	e8 d1 05 00 00       	call   5f3 <changePolicy>
-    if (result == 0)
-  22:	83 c4 10             	add    $0x10,%esp
-  25:	85 c0                	test   %eax,%eax
-  27:	75 76                	jne    9f <main+0x9f>
-    {
-        printf(1, "Policy changed successfully!\n");
-  29:	50                   	push   %eax
-  2a:	50                   	push   %eax
-  2b:	68 58 0a 00 00       	push   $0xa58
-  30:	6a 01                	push   $0x1
-  32:	e8 b9 06 00 00       	call   6f0 <printf>
-  37:	83 c4 10             	add    $0x10,%esp
-    else
-    {
-        printf(1, "Policy change failed!\n");
-    }
-
-    int original_pid = getpid();
-  3a:	e8 74 05 00 00       	call   5b3 <getpid>
-    int child_num = -1;
-    int priority = -1;
-
-    for (int i = 0; i < NUM_CHILDREN; i++)
-  3f:	31 f6                	xor    %esi,%esi
-    int original_pid = getpid();
-  41:	89 c3                	mov    %eax,%ebx
-    for (int i = 0; i < NUM_CHILDREN; i++)
-  43:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  47:	90                   	nop
-    {
-        if (fork() == 0) // Child
-  48:	e8 de 04 00 00       	call   52b <fork>
-  4d:	89 f1                	mov    %esi,%ecx
-  4f:	83 c6 01             	add    $0x1,%esi
-  52:	85 c0                	test   %eax,%eax
-  54:	74 5c                	je     b2 <main+0xb2>
-    for (int i = 0; i < NUM_CHILDREN; i++)
-  56:	83 fe 0a             	cmp    $0xa,%esi
-  59:	75 ed                	jne    48 <main+0x48>
-    int child_num = -1;
-  5b:	83 ce ff             	or     $0xffffffff,%esi
-            setPriority(priority);
-            break;
-        }
-    }
-
-    if (getpid() != original_pid)
-  5e:	e8 50 05 00 00       	call   5b3 <getpid>
-  63:	39 d8                	cmp    %ebx,%eax
-  65:	74 73                	je     da <main+0xda>
-    {
-        for (int i = 1; i <= 50; i++)
-  67:	bb 01 00 00 00       	mov    $0x1,%ebx
-  6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-            printf(1, "/%d/: /%d/\n", child_num, i);
-  70:	53                   	push   %ebx
-        for (int i = 1; i <= 50; i++)
-  71:	83 c3 01             	add    $0x1,%ebx
-            printf(1, "/%d/: /%d/\n", child_num, i);
-  74:	56                   	push   %esi
-  75:	68 a2 0a 00 00       	push   $0xaa2
-  7a:	6a 01                	push   $0x1
-  7c:	e8 6f 06 00 00       	call   6f0 <printf>
-        for (int i = 1; i <= 50; i++)
-  81:	83 c4 10             	add    $0x10,%esp
-  84:	83 fb 33             	cmp    $0x33,%ebx
-  87:	75 e7                	jne    70 <main+0x70>
-  89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-               turnaroundsSum / NUM_CHILDREN,
-               waitingsSum / NUM_CHILDREN,
-               CBTsSum / NUM_CHILDREN);*/
-    }
-
-    while (wait() != -1)
-  90:	e8 a6 04 00 00       	call   53b <wait>
-  95:	83 f8 ff             	cmp    $0xffffffff,%eax
-  98:	75 f6                	jne    90 <main+0x90>
-        ;
-
-    exit();
-  9a:	e8 94 04 00 00       	call   533 <exit>
-        printf(1, "Policy change failed!\n");
-  9f:	57                   	push   %edi
-  a0:	57                   	push   %edi
-  a1:	68 76 0a 00 00       	push   $0xa76
-  a6:	6a 01                	push   $0x1
-  a8:	e8 43 06 00 00       	call   6f0 <printf>
-  ad:	83 c4 10             	add    $0x10,%esp
-  b0:	eb 88                	jmp    3a <main+0x3a>
-            priority = (i / 5) + 1;
-  b2:	89 c8                	mov    %ecx,%eax
-  b4:	bf 05 00 00 00       	mov    $0x5,%edi
-  b9:	99                   	cltd   
-  ba:	f7 ff                	idiv   %edi
-  bc:	8d 78 01             	lea    0x1(%eax),%edi
-            printf(1, "i: %d, priority: %d\n", i, priority);
-  bf:	57                   	push   %edi
-  c0:	51                   	push   %ecx
-  c1:	68 8d 0a 00 00       	push   $0xa8d
-  c6:	6a 01                	push   $0x1
-  c8:	e8 23 06 00 00       	call   6f0 <printf>
-            setPriority(priority);
-  cd:	89 3c 24             	mov    %edi,(%esp)
-  d0:	e8 16 05 00 00       	call   5eb <setPriority>
-            break;
-  d5:	83 c4 10             	add    $0x10,%esp
-  d8:	eb 84                	jmp    5e <main+0x5e>
-        int creation[NUM_CHILDREN] = {0}; // turnaround times for each child
-  da:	8d 95 80 fe ff ff    	lea    -0x180(%ebp),%edx
-  e0:	31 c0                	xor    %eax,%eax
-  e2:	b9 0a 00 00 00       	mov    $0xa,%ecx
-  e7:	89 d7                	mov    %edx,%edi
-        int CBTs[NUM_CHILDREN] = {0};        // CBTs for each child
-  e9:	8d 9d d0 fe ff ff    	lea    -0x130(%ebp),%ebx
-        int creation[NUM_CHILDREN] = {0}; // turnaround times for each child
-  ef:	f3 ab                	rep stos %eax,%es:(%edi)
-        int waitings[NUM_CHILDREN] = {0};    // waiting times for each child
-  f1:	b9 0a 00 00 00       	mov    $0xa,%ecx
-  f6:	8d bd a8 fe ff ff    	lea    -0x158(%ebp),%edi
-  fc:	f3 ab                	rep stos %eax,%es:(%edi)
-        int CBTs[NUM_CHILDREN] = {0};        // CBTs for each child
-  fe:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 103:	89 df                	mov    %ebx,%edi
- 105:	f3 ab                	rep stos %eax,%es:(%edi)
-        printf(1, "\n\n\n*****Times for each child*****\n");
- 107:	56                   	push   %esi
-        int i = 0;
- 108:	31 ff                	xor    %edi,%edi
-        printf(1, "\n\n\n*****Times for each child*****\n");
- 10a:	56                   	push   %esi
- 10b:	68 b0 0a 00 00       	push   $0xab0
- 110:	6a 01                	push   $0x1
- 112:	e8 d9 05 00 00       	call   6f0 <printf>
-        int *procTimes = malloc(5 * sizeof(int));
- 117:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
- 11e:	e8 2d 08 00 00       	call   950 <malloc>
-        while (customWait(procTimes) > 0)
- 123:	83 c4 10             	add    $0x10,%esp
-        int *procTimes = malloc(5 * sizeof(int));
- 126:	89 c6                	mov    %eax,%esi
-        while (customWait(procTimes) > 0)
- 128:	eb 1f                	jmp    149 <main+0x149>
- 12a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-            int waitingtime = procTimes[1];
- 130:	8b 46 04             	mov    0x4(%esi),%eax
-            creation[i] = creation_t;
- 133:	8b 4e 10             	mov    0x10(%esi),%ecx
-            waitings[i] = waitingtime;
- 136:	89 84 bd a8 fe ff ff 	mov    %eax,-0x158(%ebp,%edi,4)
-            CBTs[i] = bursttimes;
- 13d:	8b 46 08             	mov    0x8(%esi),%eax
-            creation[i] = creation_t;
- 140:	89 0c ba             	mov    %ecx,(%edx,%edi,4)
-            CBTs[i] = bursttimes;
- 143:	89 04 bb             	mov    %eax,(%ebx,%edi,4)
-            i++;
- 146:	83 c7 01             	add    $0x1,%edi
-        while (customWait(procTimes) > 0)
- 149:	83 ec 0c             	sub    $0xc,%esp
- 14c:	56                   	push   %esi
- 14d:	e8 c1 04 00 00       	call   613 <customWait>
- 152:	83 c4 10             	add    $0x10,%esp
- 155:	8d 95 80 fe ff ff    	lea    -0x180(%ebp),%edx
- 15b:	85 c0                	test   %eax,%eax
- 15d:	7f d1                	jg     130 <main+0x130>
-        int pda[NUM_CHILDREN][6] = {0} ;
- 15f:	8d bd f8 fe ff ff    	lea    -0x108(%ebp),%edi
- 165:	b9 3c 00 00 00       	mov    $0x3c,%ecx
- 16a:	31 c0                	xor    %eax,%eax
- 16c:	f3 ab                	rep stos %eax,%es:(%edi)
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 16e:	8d bd f8 fe ff ff    	lea    -0x108(%ebp),%edi
- 174:	89 bd 74 fe ff ff    	mov    %edi,-0x18c(%ebp)
-        int pda[NUM_CHILDREN][6] = {0} ;
- 17a:	89 f9                	mov    %edi,%ecx
- 17c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-         pda[j][1] = creation[j];
- 180:	8b 34 82             	mov    (%edx,%eax,4),%esi
-         pda[j][0] = j;
- 183:	89 01                	mov    %eax,(%ecx)
-         pda[j][1] = creation[j];
- 185:	83 c1 18             	add    $0x18,%ecx
- 188:	89 71 ec             	mov    %esi,-0x14(%ecx)
-         pda[j][2] = CBTs[j];
- 18b:	8b 34 83             	mov    (%ebx,%eax,4),%esi
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 18e:	83 c0 01             	add    $0x1,%eax
-         pda[j][2] = CBTs[j];
- 191:	89 71 f0             	mov    %esi,-0x10(%ecx)
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 194:	83 f8 0a             	cmp    $0xa,%eax
- 197:	75 e7                	jne    180 <main+0x180>
-    completionTime(NUM_CHILDREN, pda);
- 199:	50                   	push   %eax
- 19a:	8b b5 74 fe ff ff    	mov    -0x18c(%ebp),%esi
- 1a0:	50                   	push   %eax
- 1a1:	57                   	push   %edi
- 1a2:	81 c7 f0 00 00 00    	add    $0xf0,%edi
- 1a8:	6a 0a                	push   $0xa
- 1aa:	e8 61 00 00 00       	call   210 <completionTime>
-     printf(1, "\n\n\n*****Processes summary*****\n");
- 1af:	5a                   	pop    %edx
- 1b0:	59                   	pop    %ecx
- 1b1:	68 d4 0a 00 00       	push   $0xad4
- 1b6:	6a 01                	push   $0x1
- 1b8:	e8 33 05 00 00       	call   6f0 <printf>
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 1bd:	83 c4 10             	add    $0x10,%esp
-                   pda[j][0], pda[j][1],waitings[pda[j][0]],pda[j][2]);
- 1c0:	8b 06                	mov    (%esi),%eax
-            printf(1, "Process: %d -> Arrival: %d, Waiting: %d, Burst time: %d\n",
- 1c2:	83 ec 08             	sub    $0x8,%esp
- 1c5:	ff 76 08             	pushl  0x8(%esi)
- 1c8:	83 c6 18             	add    $0x18,%esi
- 1cb:	ff b4 85 a8 fe ff ff 	pushl  -0x158(%ebp,%eax,4)
- 1d2:	ff 76 ec             	pushl  -0x14(%esi)
- 1d5:	50                   	push   %eax
- 1d6:	68 f4 0a 00 00       	push   $0xaf4
- 1db:	6a 01                	push   $0x1
- 1dd:	e8 0e 05 00 00       	call   6f0 <printf>
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 1e2:	83 c4 20             	add    $0x20,%esp
- 1e5:	39 fe                	cmp    %edi,%esi
- 1e7:	75 d7                	jne    1c0 <main+0x1c0>
- 1e9:	e9 a2 fe ff ff       	jmp    90 <main+0x90>
- 1ee:	66 90                	xchg   %ax,%ax
-
-000001f0 <swap>:
-{
- 1f0:	f3 0f 1e fb          	endbr32 
-}
- 1f4:	c3                   	ret    
- 1f5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000200 <arrangeArrival>:
-{
- 200:	f3 0f 1e fb          	endbr32 
-}
- 204:	c3                   	ret    
- 205:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 20c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000210 <completionTime>:
-{
- 210:	f3 0f 1e fb          	endbr32 
- 214:	55                   	push   %ebp
- 215:	89 e5                	mov    %esp,%ebp
- 217:	57                   	push   %edi
- 218:	56                   	push   %esi
- 219:	53                   	push   %ebx
- 21a:	83 ec 0c             	sub    $0xc,%esp
-    mat[0][3] = mat[0][1] + mat[0][2];
- 21d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
- 220:	8b 45 0c             	mov    0xc(%ebp),%eax
-{
- 223:	8b 75 08             	mov    0x8(%ebp),%esi
-    mat[0][3] = mat[0][1] + mat[0][2];
- 226:	8b 40 08             	mov    0x8(%eax),%eax
- 229:	8b 4b 04             	mov    0x4(%ebx),%ecx
-    mat[0][4] = mat[0][5] - mat[0][2];
- 22c:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
-    mat[0][3] = mat[0][1] + mat[0][2];
- 233:	01 c1                	add    %eax,%ecx
-    mat[0][5] = mat[0][3] - mat[0][1];
- 235:	89 43 14             	mov    %eax,0x14(%ebx)
-    mat[0][3] = mat[0][1] + mat[0][2];
- 238:	89 4b 0c             	mov    %ecx,0xc(%ebx)
-    for (int i = 1; i < num; i++) {
- 23b:	83 fe 01             	cmp    $0x1,%esi
- 23e:	0f 8e 7c 00 00 00    	jle    2c0 <completionTime+0xb0>
- 244:	89 d8                	mov    %ebx,%eax
- 246:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
- 24d:	83 c0 1c             	add    $0x1c,%eax
-    int temp=0, val=0;
- 250:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
- 257:	89 45 ec             	mov    %eax,-0x14(%ebp)
- 25a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        int low = mat[i][2];
- 260:	8b 45 ec             	mov    -0x14(%ebp),%eax
- 263:	8b 55 f0             	mov    -0x10(%ebp),%edx
- 266:	8b 78 04             	mov    0x4(%eax),%edi
-        for (int j = i; j < num; j++) {
- 269:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-            if (temp >= mat[j][1] && low >= mat[j][2]) {
- 270:	39 08                	cmp    %ecx,(%eax)
- 272:	7f 0c                	jg     280 <completionTime+0x70>
- 274:	8b 58 04             	mov    0x4(%eax),%ebx
- 277:	39 fb                	cmp    %edi,%ebx
- 279:	7f 05                	jg     280 <completionTime+0x70>
- 27b:	89 55 e8             	mov    %edx,-0x18(%ebp)
- 27e:	89 df                	mov    %ebx,%edi
-        for (int j = i; j < num; j++) {
- 280:	83 c2 01             	add    $0x1,%edx
- 283:	83 c0 18             	add    $0x18,%eax
- 286:	39 d6                	cmp    %edx,%esi
- 288:	7f e6                	jg     270 <completionTime+0x60>
-        mat[val][3] = temp + mat[val][2];
- 28a:	8b 45 e8             	mov    -0x18(%ebp),%eax
- 28d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-    for (int i = 1; i < num; i++) {
- 290:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
-        mat[val][3] = temp + mat[val][2];
- 294:	8d 04 40             	lea    (%eax,%eax,2),%eax
- 297:	83 45 ec 18          	addl   $0x18,-0x14(%ebp)
- 29b:	8b 7d ec             	mov    -0x14(%ebp),%edi
- 29e:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
- 2a1:	8b 50 08             	mov    0x8(%eax),%edx
- 2a4:	01 d1                	add    %edx,%ecx
- 2a6:	89 48 0c             	mov    %ecx,0xc(%eax)
-        mat[val][5] = mat[val][3] - mat[val][1];
- 2a9:	2b 48 04             	sub    0x4(%eax),%ecx
- 2ac:	89 48 14             	mov    %ecx,0x14(%eax)
-        mat[val][4] = mat[val][5] - mat[val][2];
- 2af:	29 d1                	sub    %edx,%ecx
- 2b1:	89 48 10             	mov    %ecx,0x10(%eax)
-    for (int i = 1; i < num; i++) {
- 2b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
- 2b7:	39 c6                	cmp    %eax,%esi
- 2b9:	74 05                	je     2c0 <completionTime+0xb0>
- 2bb:	8b 4f f0             	mov    -0x10(%edi),%ecx
- 2be:	eb a0                	jmp    260 <completionTime+0x50>
-}
- 2c0:	83 c4 0c             	add    $0xc,%esp
- 2c3:	5b                   	pop    %ebx
- 2c4:	5e                   	pop    %esi
- 2c5:	5f                   	pop    %edi
- 2c6:	5d                   	pop    %ebp
- 2c7:	c3                   	ret    
- 2c8:	66 90                	xchg   %ax,%ax
- 2ca:	66 90                	xchg   %ax,%ax
- 2cc:	66 90                	xchg   %ax,%ax
- 2ce:	66 90                	xchg   %ax,%ax
-
-000002d0 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
- 2d0:	f3 0f 1e fb          	endbr32 
- 2d4:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
- 2d5:	31 c0                	xor    %eax,%eax
-{
- 2d7:	89 e5                	mov    %esp,%ebp
- 2d9:	53                   	push   %ebx
- 2da:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 2dd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
- 2e0:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
- 2e4:	88 14 01             	mov    %dl,(%ecx,%eax,1)
- 2e7:	83 c0 01             	add    $0x1,%eax
- 2ea:	84 d2                	test   %dl,%dl
- 2ec:	75 f2                	jne    2e0 <strcpy+0x10>
-    ;
-  return os;
-}
- 2ee:	89 c8                	mov    %ecx,%eax
- 2f0:	5b                   	pop    %ebx
- 2f1:	5d                   	pop    %ebp
- 2f2:	c3                   	ret    
- 2f3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 2fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000300 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
- 300:	f3 0f 1e fb          	endbr32 
- 304:	55                   	push   %ebp
- 305:	89 e5                	mov    %esp,%ebp
- 307:	53                   	push   %ebx
- 308:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 30b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
- 30e:	0f b6 01             	movzbl (%ecx),%eax
- 311:	0f b6 1a             	movzbl (%edx),%ebx
- 314:	84 c0                	test   %al,%al
- 316:	75 19                	jne    331 <strcmp+0x31>
- 318:	eb 26                	jmp    340 <strcmp+0x40>
- 31a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 320:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
- 324:	83 c1 01             	add    $0x1,%ecx
- 327:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
- 32a:	0f b6 1a             	movzbl (%edx),%ebx
- 32d:	84 c0                	test   %al,%al
- 32f:	74 0f                	je     340 <strcmp+0x40>
- 331:	38 d8                	cmp    %bl,%al
- 333:	74 eb                	je     320 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
- 335:	29 d8                	sub    %ebx,%eax
-}
- 337:	5b                   	pop    %ebx
- 338:	5d                   	pop    %ebp
- 339:	c3                   	ret    
- 33a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 340:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
- 342:	29 d8                	sub    %ebx,%eax
-}
- 344:	5b                   	pop    %ebx
- 345:	5d                   	pop    %ebp
- 346:	c3                   	ret    
- 347:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 34e:	66 90                	xchg   %ax,%ax
-
-00000350 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 350:	f3 0f 1e fb          	endbr32 
- 354:	55                   	push   %ebp
- 355:	89 e5                	mov    %esp,%ebp
- 357:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 35a:	80 3a 00             	cmpb   $0x0,(%edx)
- 35d:	74 21                	je     380 <strlen+0x30>
- 35f:	31 c0                	xor    %eax,%eax
- 361:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 368:	83 c0 01             	add    $0x1,%eax
- 36b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 36f:	89 c1                	mov    %eax,%ecx
- 371:	75 f5                	jne    368 <strlen+0x18>
-    ;
-  return n;
-}
- 373:	89 c8                	mov    %ecx,%eax
- 375:	5d                   	pop    %ebp
- 376:	c3                   	ret    
- 377:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 37e:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 380:	31 c9                	xor    %ecx,%ecx
-}
- 382:	5d                   	pop    %ebp
- 383:	89 c8                	mov    %ecx,%eax
- 385:	c3                   	ret    
- 386:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 38d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000390 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 390:	f3 0f 1e fb          	endbr32 
- 394:	55                   	push   %ebp
- 395:	89 e5                	mov    %esp,%ebp
- 397:	57                   	push   %edi
- 398:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 39b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 39e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 3a1:	89 d7                	mov    %edx,%edi
- 3a3:	fc                   	cld    
- 3a4:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 3a6:	89 d0                	mov    %edx,%eax
- 3a8:	5f                   	pop    %edi
- 3a9:	5d                   	pop    %ebp
- 3aa:	c3                   	ret    
- 3ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 3af:	90                   	nop
-
-000003b0 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 3b0:	f3 0f 1e fb          	endbr32 
- 3b4:	55                   	push   %ebp
- 3b5:	89 e5                	mov    %esp,%ebp
- 3b7:	8b 45 08             	mov    0x8(%ebp),%eax
- 3ba:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 3be:	0f b6 10             	movzbl (%eax),%edx
- 3c1:	84 d2                	test   %dl,%dl
- 3c3:	75 16                	jne    3db <strchr+0x2b>
- 3c5:	eb 21                	jmp    3e8 <strchr+0x38>
- 3c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3ce:	66 90                	xchg   %ax,%ax
- 3d0:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 3d4:	83 c0 01             	add    $0x1,%eax
- 3d7:	84 d2                	test   %dl,%dl
- 3d9:	74 0d                	je     3e8 <strchr+0x38>
-    if(*s == c)
- 3db:	38 d1                	cmp    %dl,%cl
- 3dd:	75 f1                	jne    3d0 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 3df:	5d                   	pop    %ebp
- 3e0:	c3                   	ret    
- 3e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 3e8:	31 c0                	xor    %eax,%eax
-}
- 3ea:	5d                   	pop    %ebp
- 3eb:	c3                   	ret    
- 3ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000003f0 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 3f0:	f3 0f 1e fb          	endbr32 
- 3f4:	55                   	push   %ebp
- 3f5:	89 e5                	mov    %esp,%ebp
- 3f7:	57                   	push   %edi
- 3f8:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 3f9:	31 f6                	xor    %esi,%esi
-{
- 3fb:	53                   	push   %ebx
- 3fc:	89 f3                	mov    %esi,%ebx
- 3fe:	83 ec 1c             	sub    $0x1c,%esp
- 401:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 404:	eb 33                	jmp    439 <gets+0x49>
- 406:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 40d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 410:	83 ec 04             	sub    $0x4,%esp
- 413:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 416:	6a 01                	push   $0x1
- 418:	50                   	push   %eax
- 419:	6a 00                	push   $0x0
- 41b:	e8 2b 01 00 00       	call   54b <read>
-    if(cc < 1)
- 420:	83 c4 10             	add    $0x10,%esp
- 423:	85 c0                	test   %eax,%eax
- 425:	7e 1c                	jle    443 <gets+0x53>
-      break;
-    buf[i++] = c;
- 427:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 42b:	83 c7 01             	add    $0x1,%edi
- 42e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 431:	3c 0a                	cmp    $0xa,%al
- 433:	74 23                	je     458 <gets+0x68>
- 435:	3c 0d                	cmp    $0xd,%al
- 437:	74 1f                	je     458 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 439:	83 c3 01             	add    $0x1,%ebx
- 43c:	89 fe                	mov    %edi,%esi
- 43e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 441:	7c cd                	jl     410 <gets+0x20>
- 443:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 445:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 448:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 44b:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 44e:	5b                   	pop    %ebx
- 44f:	5e                   	pop    %esi
- 450:	5f                   	pop    %edi
- 451:	5d                   	pop    %ebp
- 452:	c3                   	ret    
- 453:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 457:	90                   	nop
- 458:	8b 75 08             	mov    0x8(%ebp),%esi
- 45b:	8b 45 08             	mov    0x8(%ebp),%eax
- 45e:	01 de                	add    %ebx,%esi
- 460:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 462:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 465:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 468:	5b                   	pop    %ebx
- 469:	5e                   	pop    %esi
- 46a:	5f                   	pop    %edi
- 46b:	5d                   	pop    %ebp
- 46c:	c3                   	ret    
- 46d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000470 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 470:	f3 0f 1e fb          	endbr32 
- 474:	55                   	push   %ebp
- 475:	89 e5                	mov    %esp,%ebp
- 477:	56                   	push   %esi
- 478:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 479:	83 ec 08             	sub    $0x8,%esp
- 47c:	6a 00                	push   $0x0
- 47e:	ff 75 08             	pushl  0x8(%ebp)
- 481:	e8 ed 00 00 00       	call   573 <open>
-  if(fd < 0)
- 486:	83 c4 10             	add    $0x10,%esp
- 489:	85 c0                	test   %eax,%eax
- 48b:	78 2b                	js     4b8 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 48d:	83 ec 08             	sub    $0x8,%esp
- 490:	ff 75 0c             	pushl  0xc(%ebp)
- 493:	89 c3                	mov    %eax,%ebx
- 495:	50                   	push   %eax
- 496:	e8 f0 00 00 00       	call   58b <fstat>
-  close(fd);
- 49b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 49e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 4a0:	e8 b6 00 00 00       	call   55b <close>
-  return r;
- 4a5:	83 c4 10             	add    $0x10,%esp
-}
- 4a8:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 4ab:	89 f0                	mov    %esi,%eax
- 4ad:	5b                   	pop    %ebx
- 4ae:	5e                   	pop    %esi
- 4af:	5d                   	pop    %ebp
- 4b0:	c3                   	ret    
- 4b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 4b8:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 4bd:	eb e9                	jmp    4a8 <stat+0x38>
- 4bf:	90                   	nop
-
-000004c0 <atoi>:
-
-int
-atoi(const char *s)
-{
- 4c0:	f3 0f 1e fb          	endbr32 
- 4c4:	55                   	push   %ebp
- 4c5:	89 e5                	mov    %esp,%ebp
- 4c7:	53                   	push   %ebx
- 4c8:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 4cb:	0f be 02             	movsbl (%edx),%eax
- 4ce:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 4d1:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 4d4:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 4d9:	77 1a                	ja     4f5 <atoi+0x35>
- 4db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 4df:	90                   	nop
-    n = n*10 + *s++ - '0';
- 4e0:	83 c2 01             	add    $0x1,%edx
- 4e3:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 4e6:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 4ea:	0f be 02             	movsbl (%edx),%eax
- 4ed:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 4f0:	80 fb 09             	cmp    $0x9,%bl
- 4f3:	76 eb                	jbe    4e0 <atoi+0x20>
-  return n;
-}
- 4f5:	89 c8                	mov    %ecx,%eax
- 4f7:	5b                   	pop    %ebx
- 4f8:	5d                   	pop    %ebp
- 4f9:	c3                   	ret    
- 4fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000500 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 500:	f3 0f 1e fb          	endbr32 
- 504:	55                   	push   %ebp
- 505:	89 e5                	mov    %esp,%ebp
- 507:	57                   	push   %edi
- 508:	8b 45 10             	mov    0x10(%ebp),%eax
- 50b:	8b 55 08             	mov    0x8(%ebp),%edx
- 50e:	56                   	push   %esi
- 50f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 512:	85 c0                	test   %eax,%eax
- 514:	7e 0f                	jle    525 <memmove+0x25>
- 516:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 518:	89 d7                	mov    %edx,%edi
- 51a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 520:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 521:	39 f8                	cmp    %edi,%eax
- 523:	75 fb                	jne    520 <memmove+0x20>
-  return vdst;
-}
- 525:	5e                   	pop    %esi
- 526:	89 d0                	mov    %edx,%eax
- 528:	5f                   	pop    %edi
- 529:	5d                   	pop    %ebp
- 52a:	c3                   	ret    
-
-0000052b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 52b:	b8 01 00 00 00       	mov    $0x1,%eax
- 530:	cd 40                	int    $0x40
- 532:	c3                   	ret    
-
-00000533 <exit>:
-SYSCALL(exit)
- 533:	b8 02 00 00 00       	mov    $0x2,%eax
- 538:	cd 40                	int    $0x40
- 53a:	c3                   	ret    
-
-0000053b <wait>:
-SYSCALL(wait)
- 53b:	b8 03 00 00 00       	mov    $0x3,%eax
- 540:	cd 40                	int    $0x40
- 542:	c3                   	ret    
-
-00000543 <pipe>:
-SYSCALL(pipe)
- 543:	b8 04 00 00 00       	mov    $0x4,%eax
- 548:	cd 40                	int    $0x40
- 54a:	c3                   	ret    
-
-0000054b <read>:
-SYSCALL(read)
- 54b:	b8 05 00 00 00       	mov    $0x5,%eax
- 550:	cd 40                	int    $0x40
- 552:	c3                   	ret    
-
-00000553 <write>:
-SYSCALL(write)
- 553:	b8 10 00 00 00       	mov    $0x10,%eax
- 558:	cd 40                	int    $0x40
- 55a:	c3                   	ret    
-
-0000055b <close>:
-SYSCALL(close)
- 55b:	b8 15 00 00 00       	mov    $0x15,%eax
- 560:	cd 40                	int    $0x40
- 562:	c3                   	ret    
-
-00000563 <kill>:
-SYSCALL(kill)
- 563:	b8 06 00 00 00       	mov    $0x6,%eax
- 568:	cd 40                	int    $0x40
- 56a:	c3                   	ret    
-
-0000056b <exec>:
-SYSCALL(exec)
- 56b:	b8 07 00 00 00       	mov    $0x7,%eax
- 570:	cd 40                	int    $0x40
- 572:	c3                   	ret    
-
-00000573 <open>:
-SYSCALL(open)
- 573:	b8 0f 00 00 00       	mov    $0xf,%eax
- 578:	cd 40                	int    $0x40
- 57a:	c3                   	ret    
-
-0000057b <mknod>:
-SYSCALL(mknod)
- 57b:	b8 11 00 00 00       	mov    $0x11,%eax
- 580:	cd 40                	int    $0x40
- 582:	c3                   	ret    
-
-00000583 <unlink>:
-SYSCALL(unlink)
- 583:	b8 12 00 00 00       	mov    $0x12,%eax
- 588:	cd 40                	int    $0x40
- 58a:	c3                   	ret    
-
-0000058b <fstat>:
-SYSCALL(fstat)
- 58b:	b8 08 00 00 00       	mov    $0x8,%eax
- 590:	cd 40                	int    $0x40
- 592:	c3                   	ret    
-
-00000593 <link>:
-SYSCALL(link)
- 593:	b8 13 00 00 00       	mov    $0x13,%eax
- 598:	cd 40                	int    $0x40
- 59a:	c3                   	ret    
-
-0000059b <mkdir>:
-SYSCALL(mkdir)
- 59b:	b8 14 00 00 00       	mov    $0x14,%eax
- 5a0:	cd 40                	int    $0x40
- 5a2:	c3                   	ret    
-
-000005a3 <chdir>:
-SYSCALL(chdir)
- 5a3:	b8 09 00 00 00       	mov    $0x9,%eax
- 5a8:	cd 40                	int    $0x40
- 5aa:	c3                   	ret    
-
-000005ab <dup>:
-SYSCALL(dup)
- 5ab:	b8 0a 00 00 00       	mov    $0xa,%eax
- 5b0:	cd 40                	int    $0x40
- 5b2:	c3                   	ret    
-
-000005b3 <getpid>:
-SYSCALL(getpid)
- 5b3:	b8 0b 00 00 00       	mov    $0xb,%eax
- 5b8:	cd 40                	int    $0x40
- 5ba:	c3                   	ret    
-
-000005bb <sbrk>:
-SYSCALL(sbrk)
- 5bb:	b8 0c 00 00 00       	mov    $0xc,%eax
- 5c0:	cd 40                	int    $0x40
- 5c2:	c3                   	ret    
-
-000005c3 <sleep>:
-SYSCALL(sleep)
- 5c3:	b8 0d 00 00 00       	mov    $0xd,%eax
- 5c8:	cd 40                	int    $0x40
- 5ca:	c3                   	ret    
-
-000005cb <uptime>:
-SYSCALL(uptime)
- 5cb:	b8 0e 00 00 00       	mov    $0xe,%eax
- 5d0:	cd 40                	int    $0x40
- 5d2:	c3                   	ret    
-
-000005d3 <getParentID>:
-SYSCALL(getParentID)
- 5d3:	b8 16 00 00 00       	mov    $0x16,%eax
- 5d8:	cd 40                	int    $0x40
- 5da:	c3                   	ret    
-
-000005db <getChildren>:
-SYSCALL(getChildren)
- 5db:	b8 17 00 00 00       	mov    $0x17,%eax
- 5e0:	cd 40                	int    $0x40
- 5e2:	c3                   	ret    
-
-000005e3 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 5e3:	b8 18 00 00 00       	mov    $0x18,%eax
- 5e8:	cd 40                	int    $0x40
- 5ea:	c3                   	ret    
-
-000005eb <setPriority>:
-SYSCALL(setPriority)
- 5eb:	b8 19 00 00 00       	mov    $0x19,%eax
- 5f0:	cd 40                	int    $0x40
- 5f2:	c3                   	ret    
-
-000005f3 <changePolicy>:
-SYSCALL(changePolicy)
- 5f3:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 5f8:	cd 40                	int    $0x40
- 5fa:	c3                   	ret    
-
-000005fb <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 5fb:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 600:	cd 40                	int    $0x40
- 602:	c3                   	ret    
-
-00000603 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 603:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 608:	cd 40                	int    $0x40
- 60a:	c3                   	ret    
-
-0000060b <getCBT>:
-SYSCALL(getCBT)
- 60b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 610:	cd 40                	int    $0x40
- 612:	c3                   	ret    
-
-00000613 <customWait>:
-SYSCALL(customWait)
- 613:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 618:	cd 40                	int    $0x40
- 61a:	c3                   	ret    
-
-0000061b <setQueue>:
-SYSCALL(setQueue)
- 61b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 620:	cd 40                	int    $0x40
- 622:	c3                   	ret    
-
-00000623 <getBurstTime>:
-SYSCALL(getBurstTime)
- 623:	b8 20 00 00 00       	mov    $0x20,%eax
- 628:	cd 40                	int    $0x40
- 62a:	c3                   	ret    
-
-0000062b <getCreationTime>:
- 62b:	b8 21 00 00 00       	mov    $0x21,%eax
- 630:	cd 40                	int    $0x40
- 632:	c3                   	ret    
- 633:	66 90                	xchg   %ax,%ax
- 635:	66 90                	xchg   %ax,%ax
- 637:	66 90                	xchg   %ax,%ax
- 639:	66 90                	xchg   %ax,%ax
- 63b:	66 90                	xchg   %ax,%ax
- 63d:	66 90                	xchg   %ax,%ax
- 63f:	90                   	nop
-
-00000640 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 640:	55                   	push   %ebp
- 641:	89 e5                	mov    %esp,%ebp
- 643:	57                   	push   %edi
- 644:	56                   	push   %esi
- 645:	53                   	push   %ebx
- 646:	83 ec 3c             	sub    $0x3c,%esp
- 649:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 64c:	89 d1                	mov    %edx,%ecx
-{
- 64e:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 651:	85 d2                	test   %edx,%edx
- 653:	0f 89 7f 00 00 00    	jns    6d8 <printint+0x98>
- 659:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 65d:	74 79                	je     6d8 <printint+0x98>
-    neg = 1;
- 65f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 666:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 668:	31 db                	xor    %ebx,%ebx
- 66a:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 66d:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 670:	89 c8                	mov    %ecx,%eax
- 672:	31 d2                	xor    %edx,%edx
- 674:	89 cf                	mov    %ecx,%edi
- 676:	f7 75 c4             	divl   -0x3c(%ebp)
- 679:	0f b6 92 34 0b 00 00 	movzbl 0xb34(%edx),%edx
- 680:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 683:	89 d8                	mov    %ebx,%eax
- 685:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 688:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 68b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 68e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 691:	76 dd                	jbe    670 <printint+0x30>
-  if(neg)
- 693:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 696:	85 c9                	test   %ecx,%ecx
- 698:	74 0c                	je     6a6 <printint+0x66>
-    buf[i++] = '-';
- 69a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 69f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 6a1:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 6a6:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 6a9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 6ad:	eb 07                	jmp    6b6 <printint+0x76>
- 6af:	90                   	nop
- 6b0:	0f b6 13             	movzbl (%ebx),%edx
- 6b3:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 6b6:	83 ec 04             	sub    $0x4,%esp
- 6b9:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 6bc:	6a 01                	push   $0x1
- 6be:	56                   	push   %esi
- 6bf:	57                   	push   %edi
- 6c0:	e8 8e fe ff ff       	call   553 <write>
-  while(--i >= 0)
- 6c5:	83 c4 10             	add    $0x10,%esp
- 6c8:	39 de                	cmp    %ebx,%esi
- 6ca:	75 e4                	jne    6b0 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 6cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 6cf:	5b                   	pop    %ebx
- 6d0:	5e                   	pop    %esi
- 6d1:	5f                   	pop    %edi
- 6d2:	5d                   	pop    %ebp
- 6d3:	c3                   	ret    
- 6d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 6d8:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 6df:	eb 87                	jmp    668 <printint+0x28>
- 6e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 6e8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 6ef:	90                   	nop
-
-000006f0 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 6f0:	f3 0f 1e fb          	endbr32 
- 6f4:	55                   	push   %ebp
- 6f5:	89 e5                	mov    %esp,%ebp
- 6f7:	57                   	push   %edi
- 6f8:	56                   	push   %esi
- 6f9:	53                   	push   %ebx
- 6fa:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 6fd:	8b 75 0c             	mov    0xc(%ebp),%esi
- 700:	0f b6 1e             	movzbl (%esi),%ebx
- 703:	84 db                	test   %bl,%bl
- 705:	0f 84 b4 00 00 00    	je     7bf <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 70b:	8d 45 10             	lea    0x10(%ebp),%eax
- 70e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 711:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 714:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 716:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 719:	eb 33                	jmp    74e <printf+0x5e>
- 71b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 71f:	90                   	nop
- 720:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 723:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 728:	83 f8 25             	cmp    $0x25,%eax
- 72b:	74 17                	je     744 <printf+0x54>
-  write(fd, &c, 1);
- 72d:	83 ec 04             	sub    $0x4,%esp
- 730:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 733:	6a 01                	push   $0x1
- 735:	57                   	push   %edi
- 736:	ff 75 08             	pushl  0x8(%ebp)
- 739:	e8 15 fe ff ff       	call   553 <write>
- 73e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 741:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 744:	0f b6 1e             	movzbl (%esi),%ebx
- 747:	83 c6 01             	add    $0x1,%esi
- 74a:	84 db                	test   %bl,%bl
- 74c:	74 71                	je     7bf <printf+0xcf>
-    c = fmt[i] & 0xff;
- 74e:	0f be cb             	movsbl %bl,%ecx
- 751:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 754:	85 d2                	test   %edx,%edx
- 756:	74 c8                	je     720 <printf+0x30>
-      }
-    } else if(state == '%'){
- 758:	83 fa 25             	cmp    $0x25,%edx
- 75b:	75 e7                	jne    744 <printf+0x54>
-      if(c == 'd'){
- 75d:	83 f8 64             	cmp    $0x64,%eax
- 760:	0f 84 9a 00 00 00    	je     800 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 766:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 76c:	83 f9 70             	cmp    $0x70,%ecx
- 76f:	74 5f                	je     7d0 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 771:	83 f8 73             	cmp    $0x73,%eax
- 774:	0f 84 d6 00 00 00    	je     850 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 77a:	83 f8 63             	cmp    $0x63,%eax
- 77d:	0f 84 8d 00 00 00    	je     810 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 783:	83 f8 25             	cmp    $0x25,%eax
- 786:	0f 84 b4 00 00 00    	je     840 <printf+0x150>
-  write(fd, &c, 1);
- 78c:	83 ec 04             	sub    $0x4,%esp
- 78f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 793:	6a 01                	push   $0x1
- 795:	57                   	push   %edi
- 796:	ff 75 08             	pushl  0x8(%ebp)
- 799:	e8 b5 fd ff ff       	call   553 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 79e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 7a1:	83 c4 0c             	add    $0xc,%esp
- 7a4:	6a 01                	push   $0x1
- 7a6:	83 c6 01             	add    $0x1,%esi
- 7a9:	57                   	push   %edi
- 7aa:	ff 75 08             	pushl  0x8(%ebp)
- 7ad:	e8 a1 fd ff ff       	call   553 <write>
-  for(i = 0; fmt[i]; i++){
- 7b2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 7b6:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 7b9:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 7bb:	84 db                	test   %bl,%bl
- 7bd:	75 8f                	jne    74e <printf+0x5e>
-    }
-  }
-}
- 7bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 7c2:	5b                   	pop    %ebx
- 7c3:	5e                   	pop    %esi
- 7c4:	5f                   	pop    %edi
- 7c5:	5d                   	pop    %ebp
- 7c6:	c3                   	ret    
- 7c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 7ce:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 7d0:	83 ec 0c             	sub    $0xc,%esp
- 7d3:	b9 10 00 00 00       	mov    $0x10,%ecx
- 7d8:	6a 00                	push   $0x0
- 7da:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 7dd:	8b 45 08             	mov    0x8(%ebp),%eax
- 7e0:	8b 13                	mov    (%ebx),%edx
- 7e2:	e8 59 fe ff ff       	call   640 <printint>
-        ap++;
- 7e7:	89 d8                	mov    %ebx,%eax
- 7e9:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 7ec:	31 d2                	xor    %edx,%edx
-        ap++;
- 7ee:	83 c0 04             	add    $0x4,%eax
- 7f1:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 7f4:	e9 4b ff ff ff       	jmp    744 <printf+0x54>
- 7f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 800:	83 ec 0c             	sub    $0xc,%esp
- 803:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 808:	6a 01                	push   $0x1
- 80a:	eb ce                	jmp    7da <printf+0xea>
- 80c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 810:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 813:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 816:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 818:	6a 01                	push   $0x1
-        ap++;
- 81a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 81d:	57                   	push   %edi
- 81e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 821:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 824:	e8 2a fd ff ff       	call   553 <write>
-        ap++;
- 829:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 82c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 82f:	31 d2                	xor    %edx,%edx
- 831:	e9 0e ff ff ff       	jmp    744 <printf+0x54>
- 836:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 83d:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 840:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 843:	83 ec 04             	sub    $0x4,%esp
- 846:	e9 59 ff ff ff       	jmp    7a4 <printf+0xb4>
- 84b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 84f:	90                   	nop
-        s = (char*)*ap;
- 850:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 853:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 855:	83 c0 04             	add    $0x4,%eax
- 858:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 85b:	85 db                	test   %ebx,%ebx
- 85d:	74 17                	je     876 <printf+0x186>
-        while(*s != 0){
- 85f:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 862:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 864:	84 c0                	test   %al,%al
- 866:	0f 84 d8 fe ff ff    	je     744 <printf+0x54>
- 86c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 86f:	89 de                	mov    %ebx,%esi
- 871:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 874:	eb 1a                	jmp    890 <printf+0x1a0>
-          s = "(null)";
- 876:	bb 2d 0b 00 00       	mov    $0xb2d,%ebx
-        while(*s != 0){
- 87b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 87e:	b8 28 00 00 00       	mov    $0x28,%eax
- 883:	89 de                	mov    %ebx,%esi
- 885:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 888:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 88f:	90                   	nop
-  write(fd, &c, 1);
- 890:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 893:	83 c6 01             	add    $0x1,%esi
- 896:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 899:	6a 01                	push   $0x1
- 89b:	57                   	push   %edi
- 89c:	53                   	push   %ebx
- 89d:	e8 b1 fc ff ff       	call   553 <write>
-        while(*s != 0){
- 8a2:	0f b6 06             	movzbl (%esi),%eax
- 8a5:	83 c4 10             	add    $0x10,%esp
- 8a8:	84 c0                	test   %al,%al
- 8aa:	75 e4                	jne    890 <printf+0x1a0>
- 8ac:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 8af:	31 d2                	xor    %edx,%edx
- 8b1:	e9 8e fe ff ff       	jmp    744 <printf+0x54>
- 8b6:	66 90                	xchg   %ax,%ax
- 8b8:	66 90                	xchg   %ax,%ax
- 8ba:	66 90                	xchg   %ax,%ax
- 8bc:	66 90                	xchg   %ax,%ax
- 8be:	66 90                	xchg   %ax,%ax
-
-000008c0 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 8c0:	f3 0f 1e fb          	endbr32 
- 8c4:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 8c5:	a1 3c 0e 00 00       	mov    0xe3c,%eax
-{
- 8ca:	89 e5                	mov    %esp,%ebp
- 8cc:	57                   	push   %edi
- 8cd:	56                   	push   %esi
- 8ce:	53                   	push   %ebx
- 8cf:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 8d2:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 8d4:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 8d7:	39 c8                	cmp    %ecx,%eax
- 8d9:	73 15                	jae    8f0 <free+0x30>
- 8db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 8df:	90                   	nop
- 8e0:	39 d1                	cmp    %edx,%ecx
- 8e2:	72 14                	jb     8f8 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 8e4:	39 d0                	cmp    %edx,%eax
- 8e6:	73 10                	jae    8f8 <free+0x38>
-{
- 8e8:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 8ea:	8b 10                	mov    (%eax),%edx
- 8ec:	39 c8                	cmp    %ecx,%eax
- 8ee:	72 f0                	jb     8e0 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 8f0:	39 d0                	cmp    %edx,%eax
- 8f2:	72 f4                	jb     8e8 <free+0x28>
- 8f4:	39 d1                	cmp    %edx,%ecx
- 8f6:	73 f0                	jae    8e8 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 8f8:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 8fb:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 8fe:	39 fa                	cmp    %edi,%edx
- 900:	74 1e                	je     920 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 902:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 905:	8b 50 04             	mov    0x4(%eax),%edx
- 908:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 90b:	39 f1                	cmp    %esi,%ecx
- 90d:	74 28                	je     937 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 90f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 911:	5b                   	pop    %ebx
-  freep = p;
- 912:	a3 3c 0e 00 00       	mov    %eax,0xe3c
-}
- 917:	5e                   	pop    %esi
- 918:	5f                   	pop    %edi
- 919:	5d                   	pop    %ebp
- 91a:	c3                   	ret    
- 91b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 91f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 920:	03 72 04             	add    0x4(%edx),%esi
- 923:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 926:	8b 10                	mov    (%eax),%edx
- 928:	8b 12                	mov    (%edx),%edx
- 92a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 92d:	8b 50 04             	mov    0x4(%eax),%edx
- 930:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 933:	39 f1                	cmp    %esi,%ecx
- 935:	75 d8                	jne    90f <free+0x4f>
-    p->s.size += bp->s.size;
- 937:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 93a:	a3 3c 0e 00 00       	mov    %eax,0xe3c
-    p->s.size += bp->s.size;
- 93f:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 942:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 945:	89 10                	mov    %edx,(%eax)
-}
- 947:	5b                   	pop    %ebx
- 948:	5e                   	pop    %esi
- 949:	5f                   	pop    %edi
- 94a:	5d                   	pop    %ebp
- 94b:	c3                   	ret    
- 94c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000950 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 950:	f3 0f 1e fb          	endbr32 
- 954:	55                   	push   %ebp
- 955:	89 e5                	mov    %esp,%ebp
- 957:	57                   	push   %edi
- 958:	56                   	push   %esi
- 959:	53                   	push   %ebx
- 95a:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 95d:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 960:	8b 3d 3c 0e 00 00    	mov    0xe3c,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 966:	8d 70 07             	lea    0x7(%eax),%esi
- 969:	c1 ee 03             	shr    $0x3,%esi
- 96c:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 96f:	85 ff                	test   %edi,%edi
- 971:	0f 84 a9 00 00 00    	je     a20 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 977:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 979:	8b 48 04             	mov    0x4(%eax),%ecx
- 97c:	39 f1                	cmp    %esi,%ecx
- 97e:	73 6d                	jae    9ed <malloc+0x9d>
- 980:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 986:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 98b:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 98e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 995:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 998:	eb 17                	jmp    9b1 <malloc+0x61>
- 99a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 9a0:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 9a2:	8b 4a 04             	mov    0x4(%edx),%ecx
- 9a5:	39 f1                	cmp    %esi,%ecx
- 9a7:	73 4f                	jae    9f8 <malloc+0xa8>
- 9a9:	8b 3d 3c 0e 00 00    	mov    0xe3c,%edi
- 9af:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 9b1:	39 c7                	cmp    %eax,%edi
- 9b3:	75 eb                	jne    9a0 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 9b5:	83 ec 0c             	sub    $0xc,%esp
- 9b8:	ff 75 e4             	pushl  -0x1c(%ebp)
- 9bb:	e8 fb fb ff ff       	call   5bb <sbrk>
-  if(p == (char*)-1)
- 9c0:	83 c4 10             	add    $0x10,%esp
- 9c3:	83 f8 ff             	cmp    $0xffffffff,%eax
- 9c6:	74 1b                	je     9e3 <malloc+0x93>
-  hp->s.size = nu;
- 9c8:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 9cb:	83 ec 0c             	sub    $0xc,%esp
- 9ce:	83 c0 08             	add    $0x8,%eax
- 9d1:	50                   	push   %eax
- 9d2:	e8 e9 fe ff ff       	call   8c0 <free>
-  return freep;
- 9d7:	a1 3c 0e 00 00       	mov    0xe3c,%eax
-      if((p = morecore(nunits)) == 0)
- 9dc:	83 c4 10             	add    $0x10,%esp
- 9df:	85 c0                	test   %eax,%eax
- 9e1:	75 bd                	jne    9a0 <malloc+0x50>
-        return 0;
-  }
-}
- 9e3:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 9e6:	31 c0                	xor    %eax,%eax
-}
- 9e8:	5b                   	pop    %ebx
- 9e9:	5e                   	pop    %esi
- 9ea:	5f                   	pop    %edi
- 9eb:	5d                   	pop    %ebp
- 9ec:	c3                   	ret    
-    if(p->s.size >= nunits){
- 9ed:	89 c2                	mov    %eax,%edx
- 9ef:	89 f8                	mov    %edi,%eax
- 9f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 9f8:	39 ce                	cmp    %ecx,%esi
- 9fa:	74 54                	je     a50 <malloc+0x100>
-        p->s.size -= nunits;
- 9fc:	29 f1                	sub    %esi,%ecx
- 9fe:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- a01:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- a04:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- a07:	a3 3c 0e 00 00       	mov    %eax,0xe3c
-}
- a0c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- a0f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- a12:	5b                   	pop    %ebx
- a13:	5e                   	pop    %esi
- a14:	5f                   	pop    %edi
- a15:	5d                   	pop    %ebp
- a16:	c3                   	ret    
- a17:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- a1e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- a20:	c7 05 3c 0e 00 00 40 	movl   $0xe40,0xe3c
- a27:	0e 00 00 
-    base.s.size = 0;
- a2a:	bf 40 0e 00 00       	mov    $0xe40,%edi
-    base.s.ptr = freep = prevp = &base;
- a2f:	c7 05 40 0e 00 00 40 	movl   $0xe40,0xe40
- a36:	0e 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- a39:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- a3b:	c7 05 44 0e 00 00 00 	movl   $0x0,0xe44
- a42:	00 00 00 
-    if(p->s.size >= nunits){
- a45:	e9 36 ff ff ff       	jmp    980 <malloc+0x30>
- a4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- a50:	8b 0a                	mov    (%edx),%ecx
- a52:	89 08                	mov    %ecx,(%eax)
- a54:	eb b1                	jmp    a07 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/SJF.c b/xv6-public/Operating-System-Project/SJF.c
deleted file mode 100644
index 57f04ec..0000000
--- a/xv6-public/Operating-System-Project/SJF.c
+++ /dev/null
@@ -1,356 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-// number of children created
-#define NUM_CHILDREN 10
-void swap(int a, int b)
-{
-    int temp = a;
-    a =b;
-    b = temp;
-}
- 
-void arrangeArrival(int num, int mat[][6])
-{
-    for (int i = 0; i < num; i++) {
-        for (int j = 0; j < num - i - 1; j++) {
-            if (mat[j][1] > mat[j + 1][1]) {
-                for (int k = 0; k < 5; k++) {
-                    swap(mat[j][k], mat[j + 1][k]);
-                }
-            }
-        }
-    }
-}
- 
-void completionTime(int num, int mat[][6])
-{
-    int temp=0, val=0;
-    mat[0][3] = mat[0][1] + mat[0][2];
-    mat[0][5] = mat[0][3] - mat[0][1];
-    mat[0][4] = mat[0][5] - mat[0][2];
- 
-    for (int i = 1; i < num; i++) {
-        temp = mat[i - 1][3];
-        int low = mat[i][2];
-        for (int j = i; j < num; j++) {
-            if (temp >= mat[j][1] && low >= mat[j][2]) {
-                low = mat[j][2];
-                val = j;
-            }
-        }
-        mat[val][3] = temp + mat[val][2];
-        mat[val][5] = mat[val][3] - mat[val][1];
-        mat[val][4] = mat[val][5] - mat[val][2];
-        for (int k = 0; k < 6; k++) {
-            swap(mat[val][k], mat[i][k]);
-        }
-    }
-}
- 
-int main(int argc, char *argv[])
-{
-    int result = changePolicy(2);
-    if (result == 0)
-    {
-        printf(1, "Policy changed successfully!\n");
-    }
-    else
-    {
-        printf(1, "Policy change failed!\n");
-    }
-
-    int original_pid = getpid();
-    int child_num = -1;
-    int priority = -1;
-
-    for (int i = 0; i < NUM_CHILDREN; i++)
-    {
-        if (fork() == 0) // Child
-        {
-            child_num = i + 1;
-            // priority = 6 - (i / 5);
-            priority = (i / 5) + 1;
-            printf(1, "i: %d, priority: %d\n", i, priority);
-            setPriority(priority);
-            break;
-        }
-    }
-
-    if (getpid() != original_pid)
-    {
-        for (int i = 1; i <= 50; i++)
-            printf(1, "/%d/: /%d/\n", child_num, i);
-    }
-
-    else
-    {
-       // int pid[NUM_CHILDREN] = {0};  // priorites for each child
-        int creation[NUM_CHILDREN] = {0}; // turnaround times for each child
-        int waitings[NUM_CHILDREN] = {0};    // waiting times for each child
-        int CBTs[NUM_CHILDREN] = {0};        // CBTs for each child
-
-        printf(1, "\n\n\n*****Times for each child*****\n");
-        int *procTimes = malloc(5 * sizeof(int));
-        int i = 0;
-        while (customWait(procTimes) > 0)
-        {
-         //   int childPriority = procTimes[3];
-            int creation_t = procTimes[4];
-           // int childTurnaround = procTimes[3];
-            int waitingtime = procTimes[1];
-            int bursttimes = procTimes[2];
-
-            creation[i] = creation_t;
-            //turnarounds[i] = childTurnaround;
-            waitings[i] = waitingtime;
-            CBTs[i] = bursttimes;
-            i++;
-        }
-//int H_J = 0 ;
-// int c_j = 0;
- //int tmp = 0;
- //int btmp=0;
- //int cotmp=0;
-        int pda[NUM_CHILDREN][6] = {0} ;
-        //int so
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-         pda[j][0] = j;
-         pda[j][1] = creation[j];
-         pda[j][2] = CBTs[j];
-        }
-         /*for (int i = 0; i < NUM_CHILDREN; i++) {
-        printf(1, "Process: %d -> Arrival: %d, Burst time: %d\n", pda[i][0]  , pda[i][1] 
-            , pda[i][2], "\n");
-    }*/
-        //arrangeArrival(NUM_CHILDREN, pda);
-    completionTime(NUM_CHILDREN, pda);
-     printf(1, "\n\n\n*****Processes summary*****\n");
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            
-            printf(1, "Process: %d -> Arrival: %d, Waiting: %d, Burst time: %d\n",
-                   pda[j][0], pda[j][1],waitings[pda[j][0]],pda[j][2]);
-                    //CBTs[pda[j][0]], creation
-        }
-       /* for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            
-            if(j==0){
-                    H_J = j;
-               c_j = j;
-                pda[j] = j;
-                }
-                if (CBTs[j]<= CBTs[H_J])
-                {
-                   
-                   */
-                  /* for (int co = 0; co < j; co++)
-                    {
-                        if (creation[j] <= creation[co]&&CBTs[j]<=CBTs[co])
-                        {
-                            continue;
-                        }
-                        else {
-                            H_J = co;
-
-                        }
-                    } 
-                 //  H_J  = j;*/
-                    /*for (int co = 0; co < j; co++)
-                    {
-                        if (creation[j] <= creation[co])
-                        {
-                            H_J = j;;
-                        }
-                        else {
-                            H_J = co;
-
-                        }
-                    }
-*/
-// H_J = 1--->2
-//c_J =1-->2
-
-//H_J = 2-->1
-//c_J = 2-->1
-               // H_J = j;
-               //c_j = j;//2
-               //pda[j] = c_j;
-                // continue;
-               /* if (j!=0)
-                {
-              
-                for (int co =j-1; co >0; co--)
-                    {
-                     if (CBTs[c_j] < CBTs[co])
-                        {
-                            tmp = pda[co]; //
-                            c_j = pda[co];//
-                            pda[co] = j;//
-                            pda[co-1] = tmp;//
-                        }
-                        else {
-                           continue;
-                        }
-                    }
-                }*/
-                /*for (int co = 0; co < j; co++)
-                    {
-                        if (CBTs[c_j] < CBTs[co])
-                        {
-                            tmp = pda[co]; //0
-                            c_j = pda[co];//0
-                            pda[co] = j;//2
-                            pda[j] = tmp;//1
-                        }
-                        else {
-                             if (co==j-1)
-                              {
-                                  pda[j] = c_j;
-
-
-                                 
-                              }
-
-                        }
-                    }*/
-              //  }
-                //2,1,3,0
-                //2,0,1
-                 
-           //     else
-               // {
-                    
-                 //   c_j = j;
-                //jc = 5
-                //coc = 5
-                //jb = 2
-                //cob = 3
-                //co = 4
-                //j=5
-                    /* for (int co = 0; co < j; co++)
-                    {
-                     if (CBTs[c_j] < CBTs[co])
-                        {
-                            tmp = pda[co]; //
-                            c_j = pda[co];//
-                            pda[co] = j;//
-                            pda[co+1] = tmp;//
-                        }
-                        else {
-                           continue;
-                        }
-                    }
-*/
-/*for (int co = 0; co < j; co++)
-                    {
-                        if (creation[j] < creation[co])
-                        {
-                            tmp = pda[co]; //
-                            c_j = pda[co];//
-                            pda[co] = j;//
-                        }
-                        else {
-                            continue;
-
-                        }
-                    } 
-pda[j] = j;*/
-                    /* if (CBTs[c_j] == CBTs[co]){
-                          if (creation[c_j]< creation[co]){
-                             tmp = pda[co];
-                             btmp = pda[co];
-                             //c_j = pda[co];
-                             pda[co] = c_j;
-                             c_j = btmp;
-                            // pda[j] = tmp;
-                          }
-                          else if (creation[c_j]== creation[co])
-                          { 
-                              tmp = pda[co+1];
-                              pda[co+1] = c_j;
-                              c_j = tmp;
-                          
-                          }*/
-                          
-                         /* else{
-                             // cotmp = co;
-                              if (co==j-1)
-                              {
-                                  pda[j] = c_j;
-
-                                 
-                              }
-                              else{
-                                  tmp = pda[co];
-                             c_j = pda[co+1];
-                            // pda[co] = j;
-                             //pda[j] = tmp;
-                             }
-                            
-                          }
-                     }
-                     else{*/
-                        
-                       
-                     //}
-                    
-                     
-                     
-                    // c_J = j;
-                    
-                //}
-               // pda[j] = c_j;
-               
-       // }
-      /*  H_J = 0;
-        tmp = 0;
-        c_j = 0;*/
-       
-// printf(1,"Waiting: %d",waitings[2]);
-
-      /*  printf(1, "\n\n\n*****AVG Times for each priority class*****\n");
-        int turnaroundsPerClass[6] = {0};
-        int waitingsPerClass[6] = {0};
-        int CBTsPerClass[6] = {0};
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            int childPriority = priorities[j];
-            turnaroundsPerClass[childPriority - 1] += turnarounds[j];
-            waitingsPerClass[childPriority - 1] += waitings[j];
-            CBTsPerClass[childPriority - 1] += CBTs[j];
-        }
-        for (int j = 0; j < 6; j++)
-        {
-            printf(1, "Priority class: %d -> AVG Turnaround: %d, AVG Waiting: %d, AVG CBT: %d\n",
-                   j + 1,
-                   turnaroundsPerClass[j] / (NUM_CHILDREN / 6),
-                   waitingsPerClass[j] / (NUM_CHILDREN / 6),
-                   CBTsPerClass[j] / (NUM_CHILDREN / 6));
-        }
-
-        printf(1, "\n\n\n*****AVG Times in total*****\n");
-        int turnaroundsSum = 0;
-        int waitingsSum = 0;
-        int CBTsSum = 0;
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            turnaroundsSum += turnarounds[j];
-            waitingsSum += waitings[j];
-            CBTsSum += CBTs[j];
-        }
-        printf(1, "Total -> AVG Turnaround: %d, AVG Waiting: %d, AVG CBT: %d\n",
-               turnaroundsSum / NUM_CHILDREN,
-               waitingsSum / NUM_CHILDREN,
-               CBTsSum / NUM_CHILDREN);*/
-    }
-
-    while (wait() != -1)
-        ;
-
-    exit();
-   // }
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/SJF.d b/xv6-public/Operating-System-Project/SJF.d
deleted file mode 100644
index 27be7ff..0000000
--- a/xv6-public/Operating-System-Project/SJF.d
+++ /dev/null
@@ -1 +0,0 @@
-SJF.o: SJF.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/SJF.o b/xv6-public/Operating-System-Project/SJF.o
deleted file mode 100644
index 639fff9..0000000
Binary files a/xv6-public/Operating-System-Project/SJF.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/SJF.sym b/xv6-public/Operating-System-Project/SJF.sym
deleted file mode 100644
index 67fd298..0000000
--- a/xv6-public/Operating-System-Project/SJF.sym
+++ /dev/null
@@ -1,72 +0,0 @@
-00000000 .text
-00000a58 .rodata
-00000b48 .eh_frame
-00000e3c .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 SJF.c
-00000000 ulib.c
-00000000 printf.c
-00000640 printint
-00000b34 digits.1109
-00000000 umalloc.c
-00000e3c freep
-00000e40 base
-000002d0 strcpy
-000005db getChildren
-000006f0 printf
-00000500 memmove
-0000057b mknod
-000003f0 gets
-000005b3 getpid
-00000613 customWait
-000001f0 swap
-0000060b getCBT
-00000950 malloc
-000005c3 sleep
-00000210 completionTime
-00000543 pipe
-000005f3 changePolicy
-00000553 write
-0000058b fstat
-00000563 kill
-000005a3 chdir
-0000061b setQueue
-0000056b exec
-0000053b wait
-0000054b read
-00000623 getBurstTime
-00000583 unlink
-0000052b fork
-000005fb getTurnAroundTime
-000005bb sbrk
-000005cb uptime
-00000e3c __bss_start
-00000390 memset
-00000000 main
-00000300 strcmp
-000005ab dup
-000005e3 getSyscallCounter
-00000200 arrangeArrival
-000005d3 getParentID
-00000470 stat
-00000e3c _edata
-00000e48 _end
-00000593 link
-00000533 exit
-000005eb setPriority
-000004c0 atoi
-0000062b getCreationTime
-00000350 strlen
-00000573 open
-000003b0 strchr
-0000059b mkdir
-0000055b close
-00000603 getWaitingTime
-000008c0 free
diff --git a/xv6-public/Operating-System-Project/TRICKS b/xv6-public/Operating-System-Project/TRICKS
deleted file mode 100644
index 8d1439f..0000000
--- a/xv6-public/Operating-System-Project/TRICKS
+++ /dev/null
@@ -1,140 +0,0 @@
-This file lists subtle things that might not be commented 
-as well as they should be in the source code and that
-might be worth pointing out in a longer explanation or in class.
-
----
-
-[2009/07/12: No longer relevant; forkret1 changed
-and this is now cleaner.]
-
-forkret1 in trapasm.S is called with a tf argument.
-In order to use it, forkret1 copies the tf pointer into
-%esp and then jumps to trapret, which pops the 
-register state out of the trap frame.  If an interrupt
-came in between the mov tf, %esp and the iret that
-goes back out to user space, the interrupt stack frame
-would end up scribbling over the tf and whatever memory
-lay under it.
-
-Why is this safe?  Because forkret1 is only called
-the first time a process returns to user space, and
-at that point, cp->tf is set to point to a trap frame
-constructed at the top of cp's kernel stack.  So tf 
-*is* a valid %esp that can hold interrupt state.
-
-If other tf's were used in forkret1, we could add
-a cli before the mov tf, %esp.
-
----
-
-In pushcli, must cli() no matter what.  It is not safe to do
-
-  if(cpus[cpu()].ncli == 0)
-    cli();
-  cpus[cpu()].ncli++;
-
-because if interrupts are off then we might call cpu(), get
-rescheduled to a different cpu, look at cpus[oldcpu].ncli,
-and wrongly decide not to disable interrupts on the new cpu.
-
-Instead do 
-
-  cli();
-  cpus[cpu()].ncli++;
-
-always.
-
----
-
-There is a (harmless) race in pushcli, which does
-
-	eflags = readeflags();
-	cli();
-	if(c->ncli++ == 0)
-		c->intena = eflags & FL_IF;
-
-Consider a bottom-level pushcli.  
-If interrupts are disabled already, then the right thing
-happens: read_eflags finds that FL_IF is not set,
-and intena = 0.  If interrupts are enabled, then
-it is less clear that the right thing happens:
-the readeflags can execute, then the process
-can get preempted and rescheduled on another cpu,
-and then once it starts running, perhaps with 
-interrupts disabled (can happen since the scheduler
-only enables interrupts once per scheduling loop,
-not every time it schedules a process), it will 
-incorrectly record that interrupts *were* enabled.
-This doesn't matter, because if it was safe to be
-running with interrupts enabled before the context
-switch, it is still safe (and arguably more correct)
-to run with them enabled after the context switch too.
-
-In fact it would be safe if scheduler always set
-	c->intena = 1;
-before calling swtch, and perhaps it should.
-
----
-
-The x86's processor-ordering memory model 
-matches spin locks well, so no explicit memory
-synchronization instructions are required in
-acquire and release.  
-
-Consider two sequences of code on different CPUs:
-
-CPU0
-A;
-release(lk);
-
-and
-
-CPU1
-acquire(lk);
-B;
-
-We want to make sure that:
-  - all reads in B see the effects of writes in A.
-  - all reads in A do *not* see the effects of writes in B.
- 
-The x86 guarantees that writes in A will go out
-to memory before the write of lk->locked = 0 in 
-release(lk).  It further guarantees that CPU1 
-will observe CPU0's write of lk->locked = 0 only
-after observing the earlier writes by CPU0.
-So any reads in B are guaranteed to observe the
-effects of writes in A.
-
-According to the Intel manual behavior spec, the
-second condition requires a serialization instruction
-in release, to avoid reads in A happening after giving
-up lk.  No Intel SMP processor in existence actually
-moves reads down after writes, but the language in
-the spec allows it.  There is no telling whether future
-processors will need it.
-
----
-
-The code in fork needs to read np->pid before
-setting np->state to RUNNABLE.  The following
-is not a correct way to do this:
-
-	int
-	fork(void)
-	{
-	  ...
-	  np->state = RUNNABLE;
-	  return np->pid; // oops
-	}
-
-After setting np->state to RUNNABLE, some other CPU
-might run the process, it might exit, and then it might
-get reused for a different process (with a new pid), all
-before the return statement.  So it's not safe to just
-"return np->pid". Even saving a copy of np->pid before
-setting np->state isn't safe, since the compiler is
-allowed to re-order statements.
-
-The real code saves a copy of np->pid, then acquires a lock
-around the write to np->state. The acquire() prevents the
-compiler from re-ordering.
diff --git a/xv6-public/Operating-System-Project/_SJF b/xv6-public/Operating-System-Project/_SJF
deleted file mode 100644
index 72775eb..0000000
Binary files a/xv6-public/Operating-System-Project/_SJF and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_SJFTest b/xv6-public/Operating-System-Project/_SJFTest
deleted file mode 100644
index 9815d00..0000000
Binary files a/xv6-public/Operating-System-Project/_SJFTest and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_cat b/xv6-public/Operating-System-Project/_cat
deleted file mode 100644
index 3c8da95..0000000
Binary files a/xv6-public/Operating-System-Project/_cat and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_echo b/xv6-public/Operating-System-Project/_echo
deleted file mode 100644
index 7923ce8..0000000
Binary files a/xv6-public/Operating-System-Project/_echo and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_forktest b/xv6-public/Operating-System-Project/_forktest
deleted file mode 100644
index d05e4b9..0000000
Binary files a/xv6-public/Operating-System-Project/_forktest and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_getCBTtest b/xv6-public/Operating-System-Project/_getCBTtest
deleted file mode 100644
index 0794cfb..0000000
Binary files a/xv6-public/Operating-System-Project/_getCBTtest and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_getChildrenTest b/xv6-public/Operating-System-Project/_getChildrenTest
deleted file mode 100644
index c76602e..0000000
Binary files a/xv6-public/Operating-System-Project/_getChildrenTest and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_getParentIDtest b/xv6-public/Operating-System-Project/_getParentIDtest
deleted file mode 100644
index f9cbb8e..0000000
Binary files a/xv6-public/Operating-System-Project/_getParentIDtest and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_getSyscallCounterTest b/xv6-public/Operating-System-Project/_getSyscallCounterTest
deleted file mode 100644
index be8b125..0000000
Binary files a/xv6-public/Operating-System-Project/_getSyscallCounterTest and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_getTurnAroundTimeTest b/xv6-public/Operating-System-Project/_getTurnAroundTimeTest
deleted file mode 100644
index bd745f4..0000000
Binary files a/xv6-public/Operating-System-Project/_getTurnAroundTimeTest and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_getWaitingTimeTest b/xv6-public/Operating-System-Project/_getWaitingTimeTest
deleted file mode 100644
index d88d387..0000000
Binary files a/xv6-public/Operating-System-Project/_getWaitingTimeTest and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_grep b/xv6-public/Operating-System-Project/_grep
deleted file mode 100644
index 31ba030..0000000
Binary files a/xv6-public/Operating-System-Project/_grep and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_init b/xv6-public/Operating-System-Project/_init
deleted file mode 100644
index ba39e6d..0000000
Binary files a/xv6-public/Operating-System-Project/_init and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_kill b/xv6-public/Operating-System-Project/_kill
deleted file mode 100644
index 24c9cb8..0000000
Binary files a/xv6-public/Operating-System-Project/_kill and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_ln b/xv6-public/Operating-System-Project/_ln
deleted file mode 100644
index a23a855..0000000
Binary files a/xv6-public/Operating-System-Project/_ln and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_ls b/xv6-public/Operating-System-Project/_ls
deleted file mode 100644
index 46378e6..0000000
Binary files a/xv6-public/Operating-System-Project/_ls and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_mkdir b/xv6-public/Operating-System-Project/_mkdir
deleted file mode 100644
index 13d0f10..0000000
Binary files a/xv6-public/Operating-System-Project/_mkdir and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_multiLayeredQueuedTest b/xv6-public/Operating-System-Project/_multiLayeredQueuedTest
deleted file mode 100644
index d40dc8a..0000000
Binary files a/xv6-public/Operating-System-Project/_multiLayeredQueuedTest and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_prioritySchedTest b/xv6-public/Operating-System-Project/_prioritySchedTest
deleted file mode 100644
index a96a908..0000000
Binary files a/xv6-public/Operating-System-Project/_prioritySchedTest and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_rm b/xv6-public/Operating-System-Project/_rm
deleted file mode 100644
index 3175b7c..0000000
Binary files a/xv6-public/Operating-System-Project/_rm and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_roundRobinTest b/xv6-public/Operating-System-Project/_roundRobinTest
deleted file mode 100644
index 3fdab34..0000000
Binary files a/xv6-public/Operating-System-Project/_roundRobinTest and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_sh b/xv6-public/Operating-System-Project/_sh
deleted file mode 100644
index ee0d362..0000000
Binary files a/xv6-public/Operating-System-Project/_sh and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_stressfs b/xv6-public/Operating-System-Project/_stressfs
deleted file mode 100644
index d086611..0000000
Binary files a/xv6-public/Operating-System-Project/_stressfs and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_usertests b/xv6-public/Operating-System-Project/_usertests
deleted file mode 100644
index 2d62ff2..0000000
Binary files a/xv6-public/Operating-System-Project/_usertests and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_wc b/xv6-public/Operating-System-Project/_wc
deleted file mode 100644
index d6b1a51..0000000
Binary files a/xv6-public/Operating-System-Project/_wc and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/_zombie b/xv6-public/Operating-System-Project/_zombie
deleted file mode 100644
index 8d2cba0..0000000
Binary files a/xv6-public/Operating-System-Project/_zombie and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/asm.h b/xv6-public/Operating-System-Project/asm.h
deleted file mode 100644
index b8a7353..0000000
--- a/xv6-public/Operating-System-Project/asm.h
+++ /dev/null
@@ -1,18 +0,0 @@
-//
-// assembler macros to create x86 segments
-//
-
-#define SEG_NULLASM                                             \
-        .word 0, 0;                                             \
-        .byte 0, 0, 0, 0
-
-// The 0xC0 means the limit is in 4096-byte units
-// and (for executable segments) 32-bit mode.
-#define SEG_ASM(type,base,lim)                                  \
-        .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
-        .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
-                (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
-
-#define STA_X     0x8       // Executable segment
-#define STA_W     0x2       // Writeable (non-executable segments)
-#define STA_R     0x2       // Readable (executable segments)
diff --git a/xv6-public/Operating-System-Project/bio.c b/xv6-public/Operating-System-Project/bio.c
deleted file mode 100644
index a45ff3e..0000000
--- a/xv6-public/Operating-System-Project/bio.c
+++ /dev/null
@@ -1,144 +0,0 @@
-// Buffer cache.
-//
-// The buffer cache is a linked list of buf structures holding
-// cached copies of disk block contents.  Caching disk blocks
-// in memory reduces the number of disk reads and also provides
-// a synchronization point for disk blocks used by multiple processes.
-//
-// Interface:
-// * To get a buffer for a particular disk block, call bread.
-// * After changing buffer data, call bwrite to write it to disk.
-// * When done with the buffer, call brelse.
-// * Do not use the buffer after calling brelse.
-// * Only one process at a time can use a buffer,
-//     so do not keep them longer than necessary.
-//
-// The implementation uses two state flags internally:
-// * B_VALID: the buffer data has been read from the disk.
-// * B_DIRTY: the buffer data has been modified
-//     and needs to be written to disk.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "buf.h"
-
-struct {
-  struct spinlock lock;
-  struct buf buf[NBUF];
-
-  // Linked list of all buffers, through prev/next.
-  // head.next is most recently used.
-  struct buf head;
-} bcache;
-
-void
-binit(void)
-{
-  struct buf *b;
-
-  initlock(&bcache.lock, "bcache");
-
-//PAGEBREAK!
-  // Create linked list of buffers
-  bcache.head.prev = &bcache.head;
-  bcache.head.next = &bcache.head;
-  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
-    b->next = bcache.head.next;
-    b->prev = &bcache.head;
-    initsleeplock(&b->lock, "buffer");
-    bcache.head.next->prev = b;
-    bcache.head.next = b;
-  }
-}
-
-// Look through buffer cache for block on device dev.
-// If not found, allocate a buffer.
-// In either case, return locked buffer.
-static struct buf*
-bget(uint dev, uint blockno)
-{
-  struct buf *b;
-
-  acquire(&bcache.lock);
-
-  // Is the block already cached?
-  for(b = bcache.head.next; b != &bcache.head; b = b->next){
-    if(b->dev == dev && b->blockno == blockno){
-      b->refcnt++;
-      release(&bcache.lock);
-      acquiresleep(&b->lock);
-      return b;
-    }
-  }
-
-  // Not cached; recycle an unused buffer.
-  // Even if refcnt==0, B_DIRTY indicates a buffer is in use
-  // because log.c has modified it but not yet committed it.
-  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
-    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
-      b->dev = dev;
-      b->blockno = blockno;
-      b->flags = 0;
-      b->refcnt = 1;
-      release(&bcache.lock);
-      acquiresleep(&b->lock);
-      return b;
-    }
-  }
-  panic("bget: no buffers");
-}
-
-// Return a locked buf with the contents of the indicated block.
-struct buf*
-bread(uint dev, uint blockno)
-{
-  struct buf *b;
-
-  b = bget(dev, blockno);
-  if((b->flags & B_VALID) == 0) {
-    iderw(b);
-  }
-  return b;
-}
-
-// Write b's contents to disk.  Must be locked.
-void
-bwrite(struct buf *b)
-{
-  if(!holdingsleep(&b->lock))
-    panic("bwrite");
-  b->flags |= B_DIRTY;
-  iderw(b);
-}
-
-// Release a locked buffer.
-// Move to the head of the MRU list.
-void
-brelse(struct buf *b)
-{
-  if(!holdingsleep(&b->lock))
-    panic("brelse");
-
-  releasesleep(&b->lock);
-
-  acquire(&bcache.lock);
-  b->refcnt--;
-  if (b->refcnt == 0) {
-    // no one is waiting for it.
-    b->next->prev = b->prev;
-    b->prev->next = b->next;
-    b->next = bcache.head.next;
-    b->prev = &bcache.head;
-    bcache.head.next->prev = b;
-    bcache.head.next = b;
-  }
-  
-  release(&bcache.lock);
-}
-//PAGEBREAK!
-// Blank page.
-
diff --git a/xv6-public/Operating-System-Project/bio.d b/xv6-public/Operating-System-Project/bio.d
deleted file mode 100644
index b4bbd30..0000000
--- a/xv6-public/Operating-System-Project/bio.d
+++ /dev/null
@@ -1,2 +0,0 @@
-bio.o: bio.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h \
- sleeplock.h fs.h buf.h
diff --git a/xv6-public/Operating-System-Project/bio.o b/xv6-public/Operating-System-Project/bio.o
deleted file mode 100644
index 00bac9a..0000000
Binary files a/xv6-public/Operating-System-Project/bio.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/bootasm.S b/xv6-public/Operating-System-Project/bootasm.S
deleted file mode 100644
index 257867c..0000000
--- a/xv6-public/Operating-System-Project/bootasm.S
+++ /dev/null
@@ -1,88 +0,0 @@
-#include "asm.h"
-#include "memlayout.h"
-#include "mmu.h"
-
-# Start the first CPU: switch to 32-bit protected mode, jump into C.
-# The BIOS loads this code from the first sector of the hard disk into
-# memory at physical address 0x7c00 and starts executing in real mode
-# with %cs=0 %ip=7c00.
-
-.code16                       # Assemble for 16-bit mode
-.globl start
-start:
-  cli                         # BIOS enabled interrupts; disable
-
-  # Zero data segment registers DS, ES, and SS.
-  xorw    %ax,%ax             # Set %ax to zero
-  movw    %ax,%ds             # -> Data Segment
-  movw    %ax,%es             # -> Extra Segment
-  movw    %ax,%ss             # -> Stack Segment
-
-  # Physical address line A20 is tied to zero so that the first PCs 
-  # with 2 MB would run software that assumed 1 MB.  Undo that.
-seta20.1:
-  inb     $0x64,%al               # Wait for not busy
-  testb   $0x2,%al
-  jnz     seta20.1
-
-  movb    $0xd1,%al               # 0xd1 -> port 0x64
-  outb    %al,$0x64
-
-seta20.2:
-  inb     $0x64,%al               # Wait for not busy
-  testb   $0x2,%al
-  jnz     seta20.2
-
-  movb    $0xdf,%al               # 0xdf -> port 0x60
-  outb    %al,$0x60
-
-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
-  # virtual addresses map directly to physical addresses so that the
-  # effective memory map doesn't change during the transition.
-  lgdt    gdtdesc
-  movl    %cr0, %eax
-  orl     $CR0_PE, %eax
-  movl    %eax, %cr0
-
-//PAGEBREAK!
-  # Complete the transition to 32-bit protected mode by using a long jmp
-  # to reload %cs and %eip.  The segment descriptors are set up with no
-  # translation, so that the mapping is still the identity mapping.
-  ljmp    $(SEG_KCODE<<3), $start32
-
-.code32  # Tell assembler to generate 32-bit code now.
-start32:
-  # Set up the protected-mode data segment registers
-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
-  movw    %ax, %ds                # -> DS: Data Segment
-  movw    %ax, %es                # -> ES: Extra Segment
-  movw    %ax, %ss                # -> SS: Stack Segment
-  movw    $0, %ax                 # Zero segments not ready for use
-  movw    %ax, %fs                # -> FS
-  movw    %ax, %gs                # -> GS
-
-  # Set up the stack pointer and call into C.
-  movl    $start, %esp
-  call    bootmain
-
-  # If bootmain returns (it shouldn't), trigger a Bochs
-  # breakpoint if running under Bochs, then loop.
-  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
-  movw    %ax, %dx
-  outw    %ax, %dx
-  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
-  outw    %ax, %dx
-spin:
-  jmp     spin
-
-# Bootstrap GDT
-.p2align 2                                # force 4 byte alignment
-gdt:
-  SEG_NULLASM                             # null seg
-  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
-  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg
-
-gdtdesc:
-  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
-  .long   gdt                             # address gdt
-
diff --git a/xv6-public/Operating-System-Project/bootasm.d b/xv6-public/Operating-System-Project/bootasm.d
deleted file mode 100644
index 3b3dc19..0000000
--- a/xv6-public/Operating-System-Project/bootasm.d
+++ /dev/null
@@ -1 +0,0 @@
-bootasm.o: bootasm.S asm.h memlayout.h mmu.h
diff --git a/xv6-public/Operating-System-Project/bootasm.o b/xv6-public/Operating-System-Project/bootasm.o
deleted file mode 100644
index c7b8800..0000000
Binary files a/xv6-public/Operating-System-Project/bootasm.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/bootblock b/xv6-public/Operating-System-Project/bootblock
deleted file mode 100644
index ed06193..0000000
Binary files a/xv6-public/Operating-System-Project/bootblock and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/bootblock.asm b/xv6-public/Operating-System-Project/bootblock.asm
deleted file mode 100644
index 0062ca4..0000000
--- a/xv6-public/Operating-System-Project/bootblock.asm
+++ /dev/null
@@ -1,361 +0,0 @@
-
-bootblock.o:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00007c00 <start>:
-# with %cs=0 %ip=7c00.
-
-.code16                       # Assemble for 16-bit mode
-.globl start
-start:
-  cli                         # BIOS enabled interrupts; disable
-    7c00:	fa                   	cli    
-
-  # Zero data segment registers DS, ES, and SS.
-  xorw    %ax,%ax             # Set %ax to zero
-    7c01:	31 c0                	xor    %eax,%eax
-  movw    %ax,%ds             # -> Data Segment
-    7c03:	8e d8                	mov    %eax,%ds
-  movw    %ax,%es             # -> Extra Segment
-    7c05:	8e c0                	mov    %eax,%es
-  movw    %ax,%ss             # -> Stack Segment
-    7c07:	8e d0                	mov    %eax,%ss
-
-00007c09 <seta20.1>:
-
-  # Physical address line A20 is tied to zero so that the first PCs 
-  # with 2 MB would run software that assumed 1 MB.  Undo that.
-seta20.1:
-  inb     $0x64,%al               # Wait for not busy
-    7c09:	e4 64                	in     $0x64,%al
-  testb   $0x2,%al
-    7c0b:	a8 02                	test   $0x2,%al
-  jnz     seta20.1
-    7c0d:	75 fa                	jne    7c09 <seta20.1>
-
-  movb    $0xd1,%al               # 0xd1 -> port 0x64
-    7c0f:	b0 d1                	mov    $0xd1,%al
-  outb    %al,$0x64
-    7c11:	e6 64                	out    %al,$0x64
-
-00007c13 <seta20.2>:
-
-seta20.2:
-  inb     $0x64,%al               # Wait for not busy
-    7c13:	e4 64                	in     $0x64,%al
-  testb   $0x2,%al
-    7c15:	a8 02                	test   $0x2,%al
-  jnz     seta20.2
-    7c17:	75 fa                	jne    7c13 <seta20.2>
-
-  movb    $0xdf,%al               # 0xdf -> port 0x60
-    7c19:	b0 df                	mov    $0xdf,%al
-  outb    %al,$0x60
-    7c1b:	e6 60                	out    %al,$0x60
-
-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
-  # virtual addresses map directly to physical addresses so that the
-  # effective memory map doesn't change during the transition.
-  lgdt    gdtdesc
-    7c1d:	0f 01 16             	lgdtl  (%esi)
-    7c20:	78 7c                	js     7c9e <readsect+0xe>
-  movl    %cr0, %eax
-    7c22:	0f 20 c0             	mov    %cr0,%eax
-  orl     $CR0_PE, %eax
-    7c25:	66 83 c8 01          	or     $0x1,%ax
-  movl    %eax, %cr0
-    7c29:	0f 22 c0             	mov    %eax,%cr0
-
-//PAGEBREAK!
-  # Complete the transition to 32-bit protected mode by using a long jmp
-  # to reload %cs and %eip.  The segment descriptors are set up with no
-  # translation, so that the mapping is still the identity mapping.
-  ljmp    $(SEG_KCODE<<3), $start32
-    7c2c:	ea                   	.byte 0xea
-    7c2d:	31 7c 08 00          	xor    %edi,0x0(%eax,%ecx,1)
-
-00007c31 <start32>:
-
-.code32  # Tell assembler to generate 32-bit code now.
-start32:
-  # Set up the protected-mode data segment registers
-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
-    7c31:	66 b8 10 00          	mov    $0x10,%ax
-  movw    %ax, %ds                # -> DS: Data Segment
-    7c35:	8e d8                	mov    %eax,%ds
-  movw    %ax, %es                # -> ES: Extra Segment
-    7c37:	8e c0                	mov    %eax,%es
-  movw    %ax, %ss                # -> SS: Stack Segment
-    7c39:	8e d0                	mov    %eax,%ss
-  movw    $0, %ax                 # Zero segments not ready for use
-    7c3b:	66 b8 00 00          	mov    $0x0,%ax
-  movw    %ax, %fs                # -> FS
-    7c3f:	8e e0                	mov    %eax,%fs
-  movw    %ax, %gs                # -> GS
-    7c41:	8e e8                	mov    %eax,%gs
-
-  # Set up the stack pointer and call into C.
-  movl    $start, %esp
-    7c43:	bc 00 7c 00 00       	mov    $0x7c00,%esp
-  call    bootmain
-    7c48:	e8 fc 00 00 00       	call   7d49 <bootmain>
-
-  # If bootmain returns (it shouldn't), trigger a Bochs
-  # breakpoint if running under Bochs, then loop.
-  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
-    7c4d:	66 b8 00 8a          	mov    $0x8a00,%ax
-  movw    %ax, %dx
-    7c51:	66 89 c2             	mov    %ax,%dx
-  outw    %ax, %dx
-    7c54:	66 ef                	out    %ax,(%dx)
-  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
-    7c56:	66 b8 e0 8a          	mov    $0x8ae0,%ax
-  outw    %ax, %dx
-    7c5a:	66 ef                	out    %ax,(%dx)
-
-00007c5c <spin>:
-spin:
-  jmp     spin
-    7c5c:	eb fe                	jmp    7c5c <spin>
-    7c5e:	66 90                	xchg   %ax,%ax
-
-00007c60 <gdt>:
-	...
-    7c68:	ff                   	(bad)  
-    7c69:	ff 00                	incl   (%eax)
-    7c6b:	00 00                	add    %al,(%eax)
-    7c6d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
-    7c74:	00                   	.byte 0x0
-    7c75:	92                   	xchg   %eax,%edx
-    7c76:	cf                   	iret   
-	...
-
-00007c78 <gdtdesc>:
-    7c78:	17                   	pop    %ss
-    7c79:	00 60 7c             	add    %ah,0x7c(%eax)
-	...
-
-00007c7e <waitdisk>:
-  entry();
-}
-
-void
-waitdisk(void)
-{
-    7c7e:	f3 0f 1e fb          	endbr32 
-static inline uchar
-inb(ushort port)
-{
-  uchar data;
-
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-    7c82:	ba f7 01 00 00       	mov    $0x1f7,%edx
-    7c87:	ec                   	in     (%dx),%al
-  // Wait for disk ready.
-  while((inb(0x1F7) & 0xC0) != 0x40)
-    7c88:	83 e0 c0             	and    $0xffffffc0,%eax
-    7c8b:	3c 40                	cmp    $0x40,%al
-    7c8d:	75 f8                	jne    7c87 <waitdisk+0x9>
-    ;
-}
-    7c8f:	c3                   	ret    
-
-00007c90 <readsect>:
-
-// Read a single sector at offset into dst.
-void
-readsect(void *dst, uint offset)
-{
-    7c90:	f3 0f 1e fb          	endbr32 
-    7c94:	55                   	push   %ebp
-    7c95:	89 e5                	mov    %esp,%ebp
-    7c97:	57                   	push   %edi
-    7c98:	53                   	push   %ebx
-    7c99:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  // Issue command.
-  waitdisk();
-    7c9c:	e8 dd ff ff ff       	call   7c7e <waitdisk>
-}
-
-static inline void
-outb(ushort port, uchar data)
-{
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-    7ca1:	b8 01 00 00 00       	mov    $0x1,%eax
-    7ca6:	ba f2 01 00 00       	mov    $0x1f2,%edx
-    7cab:	ee                   	out    %al,(%dx)
-    7cac:	ba f3 01 00 00       	mov    $0x1f3,%edx
-    7cb1:	89 d8                	mov    %ebx,%eax
-    7cb3:	ee                   	out    %al,(%dx)
-  outb(0x1F2, 1);   // count = 1
-  outb(0x1F3, offset);
-  outb(0x1F4, offset >> 8);
-    7cb4:	89 d8                	mov    %ebx,%eax
-    7cb6:	c1 e8 08             	shr    $0x8,%eax
-    7cb9:	ba f4 01 00 00       	mov    $0x1f4,%edx
-    7cbe:	ee                   	out    %al,(%dx)
-  outb(0x1F5, offset >> 16);
-    7cbf:	89 d8                	mov    %ebx,%eax
-    7cc1:	c1 e8 10             	shr    $0x10,%eax
-    7cc4:	ba f5 01 00 00       	mov    $0x1f5,%edx
-    7cc9:	ee                   	out    %al,(%dx)
-  outb(0x1F6, (offset >> 24) | 0xE0);
-    7cca:	89 d8                	mov    %ebx,%eax
-    7ccc:	c1 e8 18             	shr    $0x18,%eax
-    7ccf:	83 c8 e0             	or     $0xffffffe0,%eax
-    7cd2:	ba f6 01 00 00       	mov    $0x1f6,%edx
-    7cd7:	ee                   	out    %al,(%dx)
-    7cd8:	b8 20 00 00 00       	mov    $0x20,%eax
-    7cdd:	ba f7 01 00 00       	mov    $0x1f7,%edx
-    7ce2:	ee                   	out    %al,(%dx)
-  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
-
-  // Read data.
-  waitdisk();
-    7ce3:	e8 96 ff ff ff       	call   7c7e <waitdisk>
-  asm volatile("cld; rep insl" :
-    7ce8:	8b 7d 08             	mov    0x8(%ebp),%edi
-    7ceb:	b9 80 00 00 00       	mov    $0x80,%ecx
-    7cf0:	ba f0 01 00 00       	mov    $0x1f0,%edx
-    7cf5:	fc                   	cld    
-    7cf6:	f3 6d                	rep insl (%dx),%es:(%edi)
-  insl(0x1F0, dst, SECTSIZE/4);
-}
-    7cf8:	5b                   	pop    %ebx
-    7cf9:	5f                   	pop    %edi
-    7cfa:	5d                   	pop    %ebp
-    7cfb:	c3                   	ret    
-
-00007cfc <readseg>:
-
-// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
-// Might copy more than asked.
-void
-readseg(uchar* pa, uint count, uint offset)
-{
-    7cfc:	f3 0f 1e fb          	endbr32 
-    7d00:	55                   	push   %ebp
-    7d01:	89 e5                	mov    %esp,%ebp
-    7d03:	57                   	push   %edi
-    7d04:	56                   	push   %esi
-    7d05:	53                   	push   %ebx
-    7d06:	83 ec 0c             	sub    $0xc,%esp
-    7d09:	8b 5d 08             	mov    0x8(%ebp),%ebx
-    7d0c:	8b 75 10             	mov    0x10(%ebp),%esi
-  uchar* epa;
-
-  epa = pa + count;
-    7d0f:	89 df                	mov    %ebx,%edi
-    7d11:	03 7d 0c             	add    0xc(%ebp),%edi
-
-  // Round down to sector boundary.
-  pa -= offset % SECTSIZE;
-    7d14:	89 f0                	mov    %esi,%eax
-    7d16:	25 ff 01 00 00       	and    $0x1ff,%eax
-    7d1b:	29 c3                	sub    %eax,%ebx
-
-  // Translate from bytes to sectors; kernel starts at sector 1.
-  offset = (offset / SECTSIZE) + 1;
-    7d1d:	c1 ee 09             	shr    $0x9,%esi
-    7d20:	83 c6 01             	add    $0x1,%esi
-
-  // If this is too slow, we could read lots of sectors at a time.
-  // We'd write more to memory than asked, but it doesn't matter --
-  // we load in increasing order.
-  for(; pa < epa; pa += SECTSIZE, offset++)
-    7d23:	39 df                	cmp    %ebx,%edi
-    7d25:	76 1a                	jbe    7d41 <readseg+0x45>
-    readsect(pa, offset);
-    7d27:	83 ec 08             	sub    $0x8,%esp
-    7d2a:	56                   	push   %esi
-    7d2b:	53                   	push   %ebx
-    7d2c:	e8 5f ff ff ff       	call   7c90 <readsect>
-  for(; pa < epa; pa += SECTSIZE, offset++)
-    7d31:	81 c3 00 02 00 00    	add    $0x200,%ebx
-    7d37:	83 c6 01             	add    $0x1,%esi
-    7d3a:	83 c4 10             	add    $0x10,%esp
-    7d3d:	39 df                	cmp    %ebx,%edi
-    7d3f:	77 e6                	ja     7d27 <readseg+0x2b>
-}
-    7d41:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    7d44:	5b                   	pop    %ebx
-    7d45:	5e                   	pop    %esi
-    7d46:	5f                   	pop    %edi
-    7d47:	5d                   	pop    %ebp
-    7d48:	c3                   	ret    
-
-00007d49 <bootmain>:
-{
-    7d49:	f3 0f 1e fb          	endbr32 
-    7d4d:	55                   	push   %ebp
-    7d4e:	89 e5                	mov    %esp,%ebp
-    7d50:	57                   	push   %edi
-    7d51:	56                   	push   %esi
-    7d52:	53                   	push   %ebx
-    7d53:	83 ec 10             	sub    $0x10,%esp
-  readseg((uchar*)elf, 4096, 0);
-    7d56:	6a 00                	push   $0x0
-    7d58:	68 00 10 00 00       	push   $0x1000
-    7d5d:	68 00 00 01 00       	push   $0x10000
-    7d62:	e8 95 ff ff ff       	call   7cfc <readseg>
-  if(elf->magic != ELF_MAGIC)
-    7d67:	83 c4 10             	add    $0x10,%esp
-    7d6a:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
-    7d71:	45 4c 46 
-    7d74:	75 21                	jne    7d97 <bootmain+0x4e>
-  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
-    7d76:	a1 1c 00 01 00       	mov    0x1001c,%eax
-    7d7b:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx
-  eph = ph + elf->phnum;
-    7d81:	0f b7 35 2c 00 01 00 	movzwl 0x1002c,%esi
-    7d88:	c1 e6 05             	shl    $0x5,%esi
-    7d8b:	01 de                	add    %ebx,%esi
-  for(; ph < eph; ph++){
-    7d8d:	39 f3                	cmp    %esi,%ebx
-    7d8f:	72 15                	jb     7da6 <bootmain+0x5d>
-  entry();
-    7d91:	ff 15 18 00 01 00    	call   *0x10018
-}
-    7d97:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    7d9a:	5b                   	pop    %ebx
-    7d9b:	5e                   	pop    %esi
-    7d9c:	5f                   	pop    %edi
-    7d9d:	5d                   	pop    %ebp
-    7d9e:	c3                   	ret    
-  for(; ph < eph; ph++){
-    7d9f:	83 c3 20             	add    $0x20,%ebx
-    7da2:	39 de                	cmp    %ebx,%esi
-    7da4:	76 eb                	jbe    7d91 <bootmain+0x48>
-    pa = (uchar*)ph->paddr;
-    7da6:	8b 7b 0c             	mov    0xc(%ebx),%edi
-    readseg(pa, ph->filesz, ph->off);
-    7da9:	83 ec 04             	sub    $0x4,%esp
-    7dac:	ff 73 04             	pushl  0x4(%ebx)
-    7daf:	ff 73 10             	pushl  0x10(%ebx)
-    7db2:	57                   	push   %edi
-    7db3:	e8 44 ff ff ff       	call   7cfc <readseg>
-    if(ph->memsz > ph->filesz)
-    7db8:	8b 4b 14             	mov    0x14(%ebx),%ecx
-    7dbb:	8b 43 10             	mov    0x10(%ebx),%eax
-    7dbe:	83 c4 10             	add    $0x10,%esp
-    7dc1:	39 c1                	cmp    %eax,%ecx
-    7dc3:	76 da                	jbe    7d9f <bootmain+0x56>
-      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
-    7dc5:	01 c7                	add    %eax,%edi
-    7dc7:	29 c1                	sub    %eax,%ecx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
-    7dc9:	b8 00 00 00 00       	mov    $0x0,%eax
-    7dce:	fc                   	cld    
-    7dcf:	f3 aa                	rep stos %al,%es:(%edi)
-               "=D" (addr), "=c" (cnt) :
-               "0" (addr), "1" (cnt), "a" (data) :
-               "memory", "cc");
-}
-    7dd1:	eb cc                	jmp    7d9f <bootmain+0x56>
diff --git a/xv6-public/Operating-System-Project/bootblock.o b/xv6-public/Operating-System-Project/bootblock.o
deleted file mode 100644
index bf5613e..0000000
Binary files a/xv6-public/Operating-System-Project/bootblock.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/bootblockother.o b/xv6-public/Operating-System-Project/bootblockother.o
deleted file mode 100644
index 494a8b4..0000000
Binary files a/xv6-public/Operating-System-Project/bootblockother.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/bootmain.c b/xv6-public/Operating-System-Project/bootmain.c
deleted file mode 100644
index 1f20e5b..0000000
--- a/xv6-public/Operating-System-Project/bootmain.c
+++ /dev/null
@@ -1,96 +0,0 @@
-// Boot loader.
-//
-// Part of the boot block, along with bootasm.S, which calls bootmain().
-// bootasm.S has put the processor into protected 32-bit mode.
-// bootmain() loads an ELF kernel image from the disk starting at
-// sector 1 and then jumps to the kernel entry routine.
-
-#include "types.h"
-#include "elf.h"
-#include "x86.h"
-#include "memlayout.h"
-
-#define SECTSIZE  512
-
-void readseg(uchar*, uint, uint);
-
-void
-bootmain(void)
-{
-  struct elfhdr *elf;
-  struct proghdr *ph, *eph;
-  void (*entry)(void);
-  uchar* pa;
-
-  elf = (struct elfhdr*)0x10000;  // scratch space
-
-  // Read 1st page off disk
-  readseg((uchar*)elf, 4096, 0);
-
-  // Is this an ELF executable?
-  if(elf->magic != ELF_MAGIC)
-    return;  // let bootasm.S handle error
-
-  // Load each program segment (ignores ph flags).
-  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
-  eph = ph + elf->phnum;
-  for(; ph < eph; ph++){
-    pa = (uchar*)ph->paddr;
-    readseg(pa, ph->filesz, ph->off);
-    if(ph->memsz > ph->filesz)
-      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
-  }
-
-  // Call the entry point from the ELF header.
-  // Does not return!
-  entry = (void(*)(void))(elf->entry);
-  entry();
-}
-
-void
-waitdisk(void)
-{
-  // Wait for disk ready.
-  while((inb(0x1F7) & 0xC0) != 0x40)
-    ;
-}
-
-// Read a single sector at offset into dst.
-void
-readsect(void *dst, uint offset)
-{
-  // Issue command.
-  waitdisk();
-  outb(0x1F2, 1);   // count = 1
-  outb(0x1F3, offset);
-  outb(0x1F4, offset >> 8);
-  outb(0x1F5, offset >> 16);
-  outb(0x1F6, (offset >> 24) | 0xE0);
-  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
-
-  // Read data.
-  waitdisk();
-  insl(0x1F0, dst, SECTSIZE/4);
-}
-
-// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
-// Might copy more than asked.
-void
-readseg(uchar* pa, uint count, uint offset)
-{
-  uchar* epa;
-
-  epa = pa + count;
-
-  // Round down to sector boundary.
-  pa -= offset % SECTSIZE;
-
-  // Translate from bytes to sectors; kernel starts at sector 1.
-  offset = (offset / SECTSIZE) + 1;
-
-  // If this is too slow, we could read lots of sectors at a time.
-  // We'd write more to memory than asked, but it doesn't matter --
-  // we load in increasing order.
-  for(; pa < epa; pa += SECTSIZE, offset++)
-    readsect(pa, offset);
-}
diff --git a/xv6-public/Operating-System-Project/bootmain.d b/xv6-public/Operating-System-Project/bootmain.d
deleted file mode 100644
index b32eaf5..0000000
--- a/xv6-public/Operating-System-Project/bootmain.d
+++ /dev/null
@@ -1 +0,0 @@
-bootmain.o: bootmain.c types.h elf.h x86.h memlayout.h
diff --git a/xv6-public/Operating-System-Project/bootmain.o b/xv6-public/Operating-System-Project/bootmain.o
deleted file mode 100644
index 325bd6a..0000000
Binary files a/xv6-public/Operating-System-Project/bootmain.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/buf.h b/xv6-public/Operating-System-Project/buf.h
deleted file mode 100644
index 3266495..0000000
--- a/xv6-public/Operating-System-Project/buf.h
+++ /dev/null
@@ -1,14 +0,0 @@
-struct buf {
-  int flags;
-  uint dev;
-  uint blockno;
-  struct sleeplock lock;
-  uint refcnt;
-  struct buf *prev; // LRU cache list
-  struct buf *next;
-  struct buf *qnext; // disk queue
-  uchar data[BSIZE];
-};
-#define B_VALID 0x2  // buffer has been read from disk
-#define B_DIRTY 0x4  // buffer needs to be written to disk
-
diff --git a/xv6-public/Operating-System-Project/cat.asm b/xv6-public/Operating-System-Project/cat.asm
deleted file mode 100644
index 4b14532..0000000
--- a/xv6-public/Operating-System-Project/cat.asm
+++ /dev/null
@@ -1,1351 +0,0 @@
-
-_cat:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-  }
-}
-
-int
-main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	57                   	push   %edi
-  12:	56                   	push   %esi
-  13:	be 01 00 00 00       	mov    $0x1,%esi
-  18:	53                   	push   %ebx
-  19:	51                   	push   %ecx
-  1a:	83 ec 18             	sub    $0x18,%esp
-  1d:	8b 01                	mov    (%ecx),%eax
-  1f:	8b 59 04             	mov    0x4(%ecx),%ebx
-  22:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-  25:	83 c3 04             	add    $0x4,%ebx
-  int fd, i;
-
-  if(argc <= 1){
-  28:	83 f8 01             	cmp    $0x1,%eax
-  2b:	7e 50                	jle    7d <main+0x7d>
-  2d:	8d 76 00             	lea    0x0(%esi),%esi
-    cat(0);
-    exit();
-  }
-
-  for(i = 1; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
-  30:	83 ec 08             	sub    $0x8,%esp
-  33:	6a 00                	push   $0x0
-  35:	ff 33                	pushl  (%ebx)
-  37:	e8 77 03 00 00       	call   3b3 <open>
-  3c:	83 c4 10             	add    $0x10,%esp
-  3f:	89 c7                	mov    %eax,%edi
-  41:	85 c0                	test   %eax,%eax
-  43:	78 24                	js     69 <main+0x69>
-      printf(1, "cat: cannot open %s\n", argv[i]);
-      exit();
-    }
-    cat(fd);
-  45:	83 ec 0c             	sub    $0xc,%esp
-  for(i = 1; i < argc; i++){
-  48:	83 c6 01             	add    $0x1,%esi
-  4b:	83 c3 04             	add    $0x4,%ebx
-    cat(fd);
-  4e:	50                   	push   %eax
-  4f:	e8 3c 00 00 00       	call   90 <cat>
-    close(fd);
-  54:	89 3c 24             	mov    %edi,(%esp)
-  57:	e8 3f 03 00 00       	call   39b <close>
-  for(i = 1; i < argc; i++){
-  5c:	83 c4 10             	add    $0x10,%esp
-  5f:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
-  62:	75 cc                	jne    30 <main+0x30>
-  }
-  exit();
-  64:	e8 0a 03 00 00       	call   373 <exit>
-      printf(1, "cat: cannot open %s\n", argv[i]);
-  69:	50                   	push   %eax
-  6a:	ff 33                	pushl  (%ebx)
-  6c:	68 bb 08 00 00       	push   $0x8bb
-  71:	6a 01                	push   $0x1
-  73:	e8 b8 04 00 00       	call   530 <printf>
-      exit();
-  78:	e8 f6 02 00 00       	call   373 <exit>
-    cat(0);
-  7d:	83 ec 0c             	sub    $0xc,%esp
-  80:	6a 00                	push   $0x0
-  82:	e8 09 00 00 00       	call   90 <cat>
-    exit();
-  87:	e8 e7 02 00 00       	call   373 <exit>
-  8c:	66 90                	xchg   %ax,%ax
-  8e:	66 90                	xchg   %ax,%ax
-
-00000090 <cat>:
-{
-  90:	f3 0f 1e fb          	endbr32 
-  94:	55                   	push   %ebp
-  95:	89 e5                	mov    %esp,%ebp
-  97:	56                   	push   %esi
-  98:	8b 75 08             	mov    0x8(%ebp),%esi
-  9b:	53                   	push   %ebx
-  while((n = read(fd, buf, sizeof(buf))) > 0) {
-  9c:	eb 19                	jmp    b7 <cat+0x27>
-  9e:	66 90                	xchg   %ax,%ax
-    if (write(1, buf, n) != n) {
-  a0:	83 ec 04             	sub    $0x4,%esp
-  a3:	53                   	push   %ebx
-  a4:	68 e0 0b 00 00       	push   $0xbe0
-  a9:	6a 01                	push   $0x1
-  ab:	e8 e3 02 00 00       	call   393 <write>
-  b0:	83 c4 10             	add    $0x10,%esp
-  b3:	39 d8                	cmp    %ebx,%eax
-  b5:	75 25                	jne    dc <cat+0x4c>
-  while((n = read(fd, buf, sizeof(buf))) > 0) {
-  b7:	83 ec 04             	sub    $0x4,%esp
-  ba:	68 00 02 00 00       	push   $0x200
-  bf:	68 e0 0b 00 00       	push   $0xbe0
-  c4:	56                   	push   %esi
-  c5:	e8 c1 02 00 00       	call   38b <read>
-  ca:	83 c4 10             	add    $0x10,%esp
-  cd:	89 c3                	mov    %eax,%ebx
-  cf:	85 c0                	test   %eax,%eax
-  d1:	7f cd                	jg     a0 <cat+0x10>
-  if(n < 0){
-  d3:	75 1b                	jne    f0 <cat+0x60>
-}
-  d5:	8d 65 f8             	lea    -0x8(%ebp),%esp
-  d8:	5b                   	pop    %ebx
-  d9:	5e                   	pop    %esi
-  da:	5d                   	pop    %ebp
-  db:	c3                   	ret    
-      printf(1, "cat: write error\n");
-  dc:	83 ec 08             	sub    $0x8,%esp
-  df:	68 98 08 00 00       	push   $0x898
-  e4:	6a 01                	push   $0x1
-  e6:	e8 45 04 00 00       	call   530 <printf>
-      exit();
-  eb:	e8 83 02 00 00       	call   373 <exit>
-    printf(1, "cat: read error\n");
-  f0:	50                   	push   %eax
-  f1:	50                   	push   %eax
-  f2:	68 aa 08 00 00       	push   $0x8aa
-  f7:	6a 01                	push   $0x1
-  f9:	e8 32 04 00 00       	call   530 <printf>
-    exit();
-  fe:	e8 70 02 00 00       	call   373 <exit>
- 103:	66 90                	xchg   %ax,%ax
- 105:	66 90                	xchg   %ax,%ax
- 107:	66 90                	xchg   %ax,%ax
- 109:	66 90                	xchg   %ax,%ax
- 10b:	66 90                	xchg   %ax,%ax
- 10d:	66 90                	xchg   %ax,%ax
- 10f:	90                   	nop
-
-00000110 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
- 110:	f3 0f 1e fb          	endbr32 
- 114:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
- 115:	31 c0                	xor    %eax,%eax
-{
- 117:	89 e5                	mov    %esp,%ebp
- 119:	53                   	push   %ebx
- 11a:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 11d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
- 120:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
- 124:	88 14 01             	mov    %dl,(%ecx,%eax,1)
- 127:	83 c0 01             	add    $0x1,%eax
- 12a:	84 d2                	test   %dl,%dl
- 12c:	75 f2                	jne    120 <strcpy+0x10>
-    ;
-  return os;
-}
- 12e:	89 c8                	mov    %ecx,%eax
- 130:	5b                   	pop    %ebx
- 131:	5d                   	pop    %ebp
- 132:	c3                   	ret    
- 133:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 13a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000140 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
- 140:	f3 0f 1e fb          	endbr32 
- 144:	55                   	push   %ebp
- 145:	89 e5                	mov    %esp,%ebp
- 147:	53                   	push   %ebx
- 148:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 14b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
- 14e:	0f b6 01             	movzbl (%ecx),%eax
- 151:	0f b6 1a             	movzbl (%edx),%ebx
- 154:	84 c0                	test   %al,%al
- 156:	75 19                	jne    171 <strcmp+0x31>
- 158:	eb 26                	jmp    180 <strcmp+0x40>
- 15a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 160:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
- 164:	83 c1 01             	add    $0x1,%ecx
- 167:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
- 16a:	0f b6 1a             	movzbl (%edx),%ebx
- 16d:	84 c0                	test   %al,%al
- 16f:	74 0f                	je     180 <strcmp+0x40>
- 171:	38 d8                	cmp    %bl,%al
- 173:	74 eb                	je     160 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
- 175:	29 d8                	sub    %ebx,%eax
-}
- 177:	5b                   	pop    %ebx
- 178:	5d                   	pop    %ebp
- 179:	c3                   	ret    
- 17a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 180:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
- 182:	29 d8                	sub    %ebx,%eax
-}
- 184:	5b                   	pop    %ebx
- 185:	5d                   	pop    %ebp
- 186:	c3                   	ret    
- 187:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 18e:	66 90                	xchg   %ax,%ax
-
-00000190 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 190:	f3 0f 1e fb          	endbr32 
- 194:	55                   	push   %ebp
- 195:	89 e5                	mov    %esp,%ebp
- 197:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 19a:	80 3a 00             	cmpb   $0x0,(%edx)
- 19d:	74 21                	je     1c0 <strlen+0x30>
- 19f:	31 c0                	xor    %eax,%eax
- 1a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1a8:	83 c0 01             	add    $0x1,%eax
- 1ab:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 1af:	89 c1                	mov    %eax,%ecx
- 1b1:	75 f5                	jne    1a8 <strlen+0x18>
-    ;
-  return n;
-}
- 1b3:	89 c8                	mov    %ecx,%eax
- 1b5:	5d                   	pop    %ebp
- 1b6:	c3                   	ret    
- 1b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1be:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 1c0:	31 c9                	xor    %ecx,%ecx
-}
- 1c2:	5d                   	pop    %ebp
- 1c3:	89 c8                	mov    %ecx,%eax
- 1c5:	c3                   	ret    
- 1c6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1cd:	8d 76 00             	lea    0x0(%esi),%esi
-
-000001d0 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 1d0:	f3 0f 1e fb          	endbr32 
- 1d4:	55                   	push   %ebp
- 1d5:	89 e5                	mov    %esp,%ebp
- 1d7:	57                   	push   %edi
- 1d8:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 1db:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 1de:	8b 45 0c             	mov    0xc(%ebp),%eax
- 1e1:	89 d7                	mov    %edx,%edi
- 1e3:	fc                   	cld    
- 1e4:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 1e6:	89 d0                	mov    %edx,%eax
- 1e8:	5f                   	pop    %edi
- 1e9:	5d                   	pop    %ebp
- 1ea:	c3                   	ret    
- 1eb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 1ef:	90                   	nop
-
-000001f0 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 1f0:	f3 0f 1e fb          	endbr32 
- 1f4:	55                   	push   %ebp
- 1f5:	89 e5                	mov    %esp,%ebp
- 1f7:	8b 45 08             	mov    0x8(%ebp),%eax
- 1fa:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 1fe:	0f b6 10             	movzbl (%eax),%edx
- 201:	84 d2                	test   %dl,%dl
- 203:	75 16                	jne    21b <strchr+0x2b>
- 205:	eb 21                	jmp    228 <strchr+0x38>
- 207:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 20e:	66 90                	xchg   %ax,%ax
- 210:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 214:	83 c0 01             	add    $0x1,%eax
- 217:	84 d2                	test   %dl,%dl
- 219:	74 0d                	je     228 <strchr+0x38>
-    if(*s == c)
- 21b:	38 d1                	cmp    %dl,%cl
- 21d:	75 f1                	jne    210 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 21f:	5d                   	pop    %ebp
- 220:	c3                   	ret    
- 221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 228:	31 c0                	xor    %eax,%eax
-}
- 22a:	5d                   	pop    %ebp
- 22b:	c3                   	ret    
- 22c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000230 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 230:	f3 0f 1e fb          	endbr32 
- 234:	55                   	push   %ebp
- 235:	89 e5                	mov    %esp,%ebp
- 237:	57                   	push   %edi
- 238:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 239:	31 f6                	xor    %esi,%esi
-{
- 23b:	53                   	push   %ebx
- 23c:	89 f3                	mov    %esi,%ebx
- 23e:	83 ec 1c             	sub    $0x1c,%esp
- 241:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 244:	eb 33                	jmp    279 <gets+0x49>
- 246:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 24d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 250:	83 ec 04             	sub    $0x4,%esp
- 253:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 256:	6a 01                	push   $0x1
- 258:	50                   	push   %eax
- 259:	6a 00                	push   $0x0
- 25b:	e8 2b 01 00 00       	call   38b <read>
-    if(cc < 1)
- 260:	83 c4 10             	add    $0x10,%esp
- 263:	85 c0                	test   %eax,%eax
- 265:	7e 1c                	jle    283 <gets+0x53>
-      break;
-    buf[i++] = c;
- 267:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 26b:	83 c7 01             	add    $0x1,%edi
- 26e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 271:	3c 0a                	cmp    $0xa,%al
- 273:	74 23                	je     298 <gets+0x68>
- 275:	3c 0d                	cmp    $0xd,%al
- 277:	74 1f                	je     298 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 279:	83 c3 01             	add    $0x1,%ebx
- 27c:	89 fe                	mov    %edi,%esi
- 27e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 281:	7c cd                	jl     250 <gets+0x20>
- 283:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 285:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 288:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 28b:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 28e:	5b                   	pop    %ebx
- 28f:	5e                   	pop    %esi
- 290:	5f                   	pop    %edi
- 291:	5d                   	pop    %ebp
- 292:	c3                   	ret    
- 293:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 297:	90                   	nop
- 298:	8b 75 08             	mov    0x8(%ebp),%esi
- 29b:	8b 45 08             	mov    0x8(%ebp),%eax
- 29e:	01 de                	add    %ebx,%esi
- 2a0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 2a2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 2a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 2a8:	5b                   	pop    %ebx
- 2a9:	5e                   	pop    %esi
- 2aa:	5f                   	pop    %edi
- 2ab:	5d                   	pop    %ebp
- 2ac:	c3                   	ret    
- 2ad:	8d 76 00             	lea    0x0(%esi),%esi
-
-000002b0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 2b0:	f3 0f 1e fb          	endbr32 
- 2b4:	55                   	push   %ebp
- 2b5:	89 e5                	mov    %esp,%ebp
- 2b7:	56                   	push   %esi
- 2b8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 2b9:	83 ec 08             	sub    $0x8,%esp
- 2bc:	6a 00                	push   $0x0
- 2be:	ff 75 08             	pushl  0x8(%ebp)
- 2c1:	e8 ed 00 00 00       	call   3b3 <open>
-  if(fd < 0)
- 2c6:	83 c4 10             	add    $0x10,%esp
- 2c9:	85 c0                	test   %eax,%eax
- 2cb:	78 2b                	js     2f8 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 2cd:	83 ec 08             	sub    $0x8,%esp
- 2d0:	ff 75 0c             	pushl  0xc(%ebp)
- 2d3:	89 c3                	mov    %eax,%ebx
- 2d5:	50                   	push   %eax
- 2d6:	e8 f0 00 00 00       	call   3cb <fstat>
-  close(fd);
- 2db:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 2de:	89 c6                	mov    %eax,%esi
-  close(fd);
- 2e0:	e8 b6 00 00 00       	call   39b <close>
-  return r;
- 2e5:	83 c4 10             	add    $0x10,%esp
-}
- 2e8:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 2eb:	89 f0                	mov    %esi,%eax
- 2ed:	5b                   	pop    %ebx
- 2ee:	5e                   	pop    %esi
- 2ef:	5d                   	pop    %ebp
- 2f0:	c3                   	ret    
- 2f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 2f8:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 2fd:	eb e9                	jmp    2e8 <stat+0x38>
- 2ff:	90                   	nop
-
-00000300 <atoi>:
-
-int
-atoi(const char *s)
-{
- 300:	f3 0f 1e fb          	endbr32 
- 304:	55                   	push   %ebp
- 305:	89 e5                	mov    %esp,%ebp
- 307:	53                   	push   %ebx
- 308:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 30b:	0f be 02             	movsbl (%edx),%eax
- 30e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 311:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 314:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 319:	77 1a                	ja     335 <atoi+0x35>
- 31b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 31f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 320:	83 c2 01             	add    $0x1,%edx
- 323:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 326:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 32a:	0f be 02             	movsbl (%edx),%eax
- 32d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 330:	80 fb 09             	cmp    $0x9,%bl
- 333:	76 eb                	jbe    320 <atoi+0x20>
-  return n;
-}
- 335:	89 c8                	mov    %ecx,%eax
- 337:	5b                   	pop    %ebx
- 338:	5d                   	pop    %ebp
- 339:	c3                   	ret    
- 33a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000340 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 340:	f3 0f 1e fb          	endbr32 
- 344:	55                   	push   %ebp
- 345:	89 e5                	mov    %esp,%ebp
- 347:	57                   	push   %edi
- 348:	8b 45 10             	mov    0x10(%ebp),%eax
- 34b:	8b 55 08             	mov    0x8(%ebp),%edx
- 34e:	56                   	push   %esi
- 34f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 352:	85 c0                	test   %eax,%eax
- 354:	7e 0f                	jle    365 <memmove+0x25>
- 356:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 358:	89 d7                	mov    %edx,%edi
- 35a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 360:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 361:	39 f8                	cmp    %edi,%eax
- 363:	75 fb                	jne    360 <memmove+0x20>
-  return vdst;
-}
- 365:	5e                   	pop    %esi
- 366:	89 d0                	mov    %edx,%eax
- 368:	5f                   	pop    %edi
- 369:	5d                   	pop    %ebp
- 36a:	c3                   	ret    
-
-0000036b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 36b:	b8 01 00 00 00       	mov    $0x1,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <exit>:
-SYSCALL(exit)
- 373:	b8 02 00 00 00       	mov    $0x2,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <wait>:
-SYSCALL(wait)
- 37b:	b8 03 00 00 00       	mov    $0x3,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <pipe>:
-SYSCALL(pipe)
- 383:	b8 04 00 00 00       	mov    $0x4,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <read>:
-SYSCALL(read)
- 38b:	b8 05 00 00 00       	mov    $0x5,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <write>:
-SYSCALL(write)
- 393:	b8 10 00 00 00       	mov    $0x10,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <close>:
-SYSCALL(close)
- 39b:	b8 15 00 00 00       	mov    $0x15,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
-
-000003a3 <kill>:
-SYSCALL(kill)
- 3a3:	b8 06 00 00 00       	mov    $0x6,%eax
- 3a8:	cd 40                	int    $0x40
- 3aa:	c3                   	ret    
-
-000003ab <exec>:
-SYSCALL(exec)
- 3ab:	b8 07 00 00 00       	mov    $0x7,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
-
-000003b3 <open>:
-SYSCALL(open)
- 3b3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 3b8:	cd 40                	int    $0x40
- 3ba:	c3                   	ret    
-
-000003bb <mknod>:
-SYSCALL(mknod)
- 3bb:	b8 11 00 00 00       	mov    $0x11,%eax
- 3c0:	cd 40                	int    $0x40
- 3c2:	c3                   	ret    
-
-000003c3 <unlink>:
-SYSCALL(unlink)
- 3c3:	b8 12 00 00 00       	mov    $0x12,%eax
- 3c8:	cd 40                	int    $0x40
- 3ca:	c3                   	ret    
-
-000003cb <fstat>:
-SYSCALL(fstat)
- 3cb:	b8 08 00 00 00       	mov    $0x8,%eax
- 3d0:	cd 40                	int    $0x40
- 3d2:	c3                   	ret    
-
-000003d3 <link>:
-SYSCALL(link)
- 3d3:	b8 13 00 00 00       	mov    $0x13,%eax
- 3d8:	cd 40                	int    $0x40
- 3da:	c3                   	ret    
-
-000003db <mkdir>:
-SYSCALL(mkdir)
- 3db:	b8 14 00 00 00       	mov    $0x14,%eax
- 3e0:	cd 40                	int    $0x40
- 3e2:	c3                   	ret    
-
-000003e3 <chdir>:
-SYSCALL(chdir)
- 3e3:	b8 09 00 00 00       	mov    $0x9,%eax
- 3e8:	cd 40                	int    $0x40
- 3ea:	c3                   	ret    
-
-000003eb <dup>:
-SYSCALL(dup)
- 3eb:	b8 0a 00 00 00       	mov    $0xa,%eax
- 3f0:	cd 40                	int    $0x40
- 3f2:	c3                   	ret    
-
-000003f3 <getpid>:
-SYSCALL(getpid)
- 3f3:	b8 0b 00 00 00       	mov    $0xb,%eax
- 3f8:	cd 40                	int    $0x40
- 3fa:	c3                   	ret    
-
-000003fb <sbrk>:
-SYSCALL(sbrk)
- 3fb:	b8 0c 00 00 00       	mov    $0xc,%eax
- 400:	cd 40                	int    $0x40
- 402:	c3                   	ret    
-
-00000403 <sleep>:
-SYSCALL(sleep)
- 403:	b8 0d 00 00 00       	mov    $0xd,%eax
- 408:	cd 40                	int    $0x40
- 40a:	c3                   	ret    
-
-0000040b <uptime>:
-SYSCALL(uptime)
- 40b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 410:	cd 40                	int    $0x40
- 412:	c3                   	ret    
-
-00000413 <getParentID>:
-SYSCALL(getParentID)
- 413:	b8 16 00 00 00       	mov    $0x16,%eax
- 418:	cd 40                	int    $0x40
- 41a:	c3                   	ret    
-
-0000041b <getChildren>:
-SYSCALL(getChildren)
- 41b:	b8 17 00 00 00       	mov    $0x17,%eax
- 420:	cd 40                	int    $0x40
- 422:	c3                   	ret    
-
-00000423 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 423:	b8 18 00 00 00       	mov    $0x18,%eax
- 428:	cd 40                	int    $0x40
- 42a:	c3                   	ret    
-
-0000042b <setPriority>:
-SYSCALL(setPriority)
- 42b:	b8 19 00 00 00       	mov    $0x19,%eax
- 430:	cd 40                	int    $0x40
- 432:	c3                   	ret    
-
-00000433 <changePolicy>:
-SYSCALL(changePolicy)
- 433:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 438:	cd 40                	int    $0x40
- 43a:	c3                   	ret    
-
-0000043b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 43b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 440:	cd 40                	int    $0x40
- 442:	c3                   	ret    
-
-00000443 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 443:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 448:	cd 40                	int    $0x40
- 44a:	c3                   	ret    
-
-0000044b <getCBT>:
-SYSCALL(getCBT)
- 44b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 450:	cd 40                	int    $0x40
- 452:	c3                   	ret    
-
-00000453 <customWait>:
-SYSCALL(customWait)
- 453:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 458:	cd 40                	int    $0x40
- 45a:	c3                   	ret    
-
-0000045b <setQueue>:
-SYSCALL(setQueue)
- 45b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 460:	cd 40                	int    $0x40
- 462:	c3                   	ret    
-
-00000463 <getBurstTime>:
-SYSCALL(getBurstTime)
- 463:	b8 20 00 00 00       	mov    $0x20,%eax
- 468:	cd 40                	int    $0x40
- 46a:	c3                   	ret    
-
-0000046b <getCreationTime>:
- 46b:	b8 21 00 00 00       	mov    $0x21,%eax
- 470:	cd 40                	int    $0x40
- 472:	c3                   	ret    
- 473:	66 90                	xchg   %ax,%ax
- 475:	66 90                	xchg   %ax,%ax
- 477:	66 90                	xchg   %ax,%ax
- 479:	66 90                	xchg   %ax,%ax
- 47b:	66 90                	xchg   %ax,%ax
- 47d:	66 90                	xchg   %ax,%ax
- 47f:	90                   	nop
-
-00000480 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 480:	55                   	push   %ebp
- 481:	89 e5                	mov    %esp,%ebp
- 483:	57                   	push   %edi
- 484:	56                   	push   %esi
- 485:	53                   	push   %ebx
- 486:	83 ec 3c             	sub    $0x3c,%esp
- 489:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 48c:	89 d1                	mov    %edx,%ecx
-{
- 48e:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 491:	85 d2                	test   %edx,%edx
- 493:	0f 89 7f 00 00 00    	jns    518 <printint+0x98>
- 499:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 49d:	74 79                	je     518 <printint+0x98>
-    neg = 1;
- 49f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 4a6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 4a8:	31 db                	xor    %ebx,%ebx
- 4aa:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 4ad:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 4b0:	89 c8                	mov    %ecx,%eax
- 4b2:	31 d2                	xor    %edx,%edx
- 4b4:	89 cf                	mov    %ecx,%edi
- 4b6:	f7 75 c4             	divl   -0x3c(%ebp)
- 4b9:	0f b6 92 d8 08 00 00 	movzbl 0x8d8(%edx),%edx
- 4c0:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 4c3:	89 d8                	mov    %ebx,%eax
- 4c5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 4c8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 4cb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 4ce:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 4d1:	76 dd                	jbe    4b0 <printint+0x30>
-  if(neg)
- 4d3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 4d6:	85 c9                	test   %ecx,%ecx
- 4d8:	74 0c                	je     4e6 <printint+0x66>
-    buf[i++] = '-';
- 4da:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 4df:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 4e1:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 4e6:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 4e9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 4ed:	eb 07                	jmp    4f6 <printint+0x76>
- 4ef:	90                   	nop
- 4f0:	0f b6 13             	movzbl (%ebx),%edx
- 4f3:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 4f6:	83 ec 04             	sub    $0x4,%esp
- 4f9:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 4fc:	6a 01                	push   $0x1
- 4fe:	56                   	push   %esi
- 4ff:	57                   	push   %edi
- 500:	e8 8e fe ff ff       	call   393 <write>
-  while(--i >= 0)
- 505:	83 c4 10             	add    $0x10,%esp
- 508:	39 de                	cmp    %ebx,%esi
- 50a:	75 e4                	jne    4f0 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 50c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 50f:	5b                   	pop    %ebx
- 510:	5e                   	pop    %esi
- 511:	5f                   	pop    %edi
- 512:	5d                   	pop    %ebp
- 513:	c3                   	ret    
- 514:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 518:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 51f:	eb 87                	jmp    4a8 <printint+0x28>
- 521:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 528:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 52f:	90                   	nop
-
-00000530 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 530:	f3 0f 1e fb          	endbr32 
- 534:	55                   	push   %ebp
- 535:	89 e5                	mov    %esp,%ebp
- 537:	57                   	push   %edi
- 538:	56                   	push   %esi
- 539:	53                   	push   %ebx
- 53a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 53d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 540:	0f b6 1e             	movzbl (%esi),%ebx
- 543:	84 db                	test   %bl,%bl
- 545:	0f 84 b4 00 00 00    	je     5ff <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 54b:	8d 45 10             	lea    0x10(%ebp),%eax
- 54e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 551:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 554:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 556:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 559:	eb 33                	jmp    58e <printf+0x5e>
- 55b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 55f:	90                   	nop
- 560:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 563:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 568:	83 f8 25             	cmp    $0x25,%eax
- 56b:	74 17                	je     584 <printf+0x54>
-  write(fd, &c, 1);
- 56d:	83 ec 04             	sub    $0x4,%esp
- 570:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 573:	6a 01                	push   $0x1
- 575:	57                   	push   %edi
- 576:	ff 75 08             	pushl  0x8(%ebp)
- 579:	e8 15 fe ff ff       	call   393 <write>
- 57e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 581:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 584:	0f b6 1e             	movzbl (%esi),%ebx
- 587:	83 c6 01             	add    $0x1,%esi
- 58a:	84 db                	test   %bl,%bl
- 58c:	74 71                	je     5ff <printf+0xcf>
-    c = fmt[i] & 0xff;
- 58e:	0f be cb             	movsbl %bl,%ecx
- 591:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 594:	85 d2                	test   %edx,%edx
- 596:	74 c8                	je     560 <printf+0x30>
-      }
-    } else if(state == '%'){
- 598:	83 fa 25             	cmp    $0x25,%edx
- 59b:	75 e7                	jne    584 <printf+0x54>
-      if(c == 'd'){
- 59d:	83 f8 64             	cmp    $0x64,%eax
- 5a0:	0f 84 9a 00 00 00    	je     640 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 5a6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 5ac:	83 f9 70             	cmp    $0x70,%ecx
- 5af:	74 5f                	je     610 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 5b1:	83 f8 73             	cmp    $0x73,%eax
- 5b4:	0f 84 d6 00 00 00    	je     690 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 5ba:	83 f8 63             	cmp    $0x63,%eax
- 5bd:	0f 84 8d 00 00 00    	je     650 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 5c3:	83 f8 25             	cmp    $0x25,%eax
- 5c6:	0f 84 b4 00 00 00    	je     680 <printf+0x150>
-  write(fd, &c, 1);
- 5cc:	83 ec 04             	sub    $0x4,%esp
- 5cf:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 5d3:	6a 01                	push   $0x1
- 5d5:	57                   	push   %edi
- 5d6:	ff 75 08             	pushl  0x8(%ebp)
- 5d9:	e8 b5 fd ff ff       	call   393 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 5de:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5e1:	83 c4 0c             	add    $0xc,%esp
- 5e4:	6a 01                	push   $0x1
- 5e6:	83 c6 01             	add    $0x1,%esi
- 5e9:	57                   	push   %edi
- 5ea:	ff 75 08             	pushl  0x8(%ebp)
- 5ed:	e8 a1 fd ff ff       	call   393 <write>
-  for(i = 0; fmt[i]; i++){
- 5f2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 5f6:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 5f9:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 5fb:	84 db                	test   %bl,%bl
- 5fd:	75 8f                	jne    58e <printf+0x5e>
-    }
-  }
-}
- 5ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 602:	5b                   	pop    %ebx
- 603:	5e                   	pop    %esi
- 604:	5f                   	pop    %edi
- 605:	5d                   	pop    %ebp
- 606:	c3                   	ret    
- 607:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 60e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 610:	83 ec 0c             	sub    $0xc,%esp
- 613:	b9 10 00 00 00       	mov    $0x10,%ecx
- 618:	6a 00                	push   $0x0
- 61a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 61d:	8b 45 08             	mov    0x8(%ebp),%eax
- 620:	8b 13                	mov    (%ebx),%edx
- 622:	e8 59 fe ff ff       	call   480 <printint>
-        ap++;
- 627:	89 d8                	mov    %ebx,%eax
- 629:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 62c:	31 d2                	xor    %edx,%edx
-        ap++;
- 62e:	83 c0 04             	add    $0x4,%eax
- 631:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 634:	e9 4b ff ff ff       	jmp    584 <printf+0x54>
- 639:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 640:	83 ec 0c             	sub    $0xc,%esp
- 643:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 648:	6a 01                	push   $0x1
- 64a:	eb ce                	jmp    61a <printf+0xea>
- 64c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 650:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 653:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 656:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 658:	6a 01                	push   $0x1
-        ap++;
- 65a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 65d:	57                   	push   %edi
- 65e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 661:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 664:	e8 2a fd ff ff       	call   393 <write>
-        ap++;
- 669:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 66c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 66f:	31 d2                	xor    %edx,%edx
- 671:	e9 0e ff ff ff       	jmp    584 <printf+0x54>
- 676:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 67d:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 680:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 683:	83 ec 04             	sub    $0x4,%esp
- 686:	e9 59 ff ff ff       	jmp    5e4 <printf+0xb4>
- 68b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 68f:	90                   	nop
-        s = (char*)*ap;
- 690:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 693:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 695:	83 c0 04             	add    $0x4,%eax
- 698:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 69b:	85 db                	test   %ebx,%ebx
- 69d:	74 17                	je     6b6 <printf+0x186>
-        while(*s != 0){
- 69f:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 6a2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 6a4:	84 c0                	test   %al,%al
- 6a6:	0f 84 d8 fe ff ff    	je     584 <printf+0x54>
- 6ac:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 6af:	89 de                	mov    %ebx,%esi
- 6b1:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 6b4:	eb 1a                	jmp    6d0 <printf+0x1a0>
-          s = "(null)";
- 6b6:	bb d0 08 00 00       	mov    $0x8d0,%ebx
-        while(*s != 0){
- 6bb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 6be:	b8 28 00 00 00       	mov    $0x28,%eax
- 6c3:	89 de                	mov    %ebx,%esi
- 6c5:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 6c8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 6cf:	90                   	nop
-  write(fd, &c, 1);
- 6d0:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 6d3:	83 c6 01             	add    $0x1,%esi
- 6d6:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 6d9:	6a 01                	push   $0x1
- 6db:	57                   	push   %edi
- 6dc:	53                   	push   %ebx
- 6dd:	e8 b1 fc ff ff       	call   393 <write>
-        while(*s != 0){
- 6e2:	0f b6 06             	movzbl (%esi),%eax
- 6e5:	83 c4 10             	add    $0x10,%esp
- 6e8:	84 c0                	test   %al,%al
- 6ea:	75 e4                	jne    6d0 <printf+0x1a0>
- 6ec:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 6ef:	31 d2                	xor    %edx,%edx
- 6f1:	e9 8e fe ff ff       	jmp    584 <printf+0x54>
- 6f6:	66 90                	xchg   %ax,%ax
- 6f8:	66 90                	xchg   %ax,%ax
- 6fa:	66 90                	xchg   %ax,%ax
- 6fc:	66 90                	xchg   %ax,%ax
- 6fe:	66 90                	xchg   %ax,%ax
-
-00000700 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 700:	f3 0f 1e fb          	endbr32 
- 704:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 705:	a1 c0 0b 00 00       	mov    0xbc0,%eax
-{
- 70a:	89 e5                	mov    %esp,%ebp
- 70c:	57                   	push   %edi
- 70d:	56                   	push   %esi
- 70e:	53                   	push   %ebx
- 70f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 712:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 714:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 717:	39 c8                	cmp    %ecx,%eax
- 719:	73 15                	jae    730 <free+0x30>
- 71b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 71f:	90                   	nop
- 720:	39 d1                	cmp    %edx,%ecx
- 722:	72 14                	jb     738 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 724:	39 d0                	cmp    %edx,%eax
- 726:	73 10                	jae    738 <free+0x38>
-{
- 728:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 72a:	8b 10                	mov    (%eax),%edx
- 72c:	39 c8                	cmp    %ecx,%eax
- 72e:	72 f0                	jb     720 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 730:	39 d0                	cmp    %edx,%eax
- 732:	72 f4                	jb     728 <free+0x28>
- 734:	39 d1                	cmp    %edx,%ecx
- 736:	73 f0                	jae    728 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 738:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 73b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 73e:	39 fa                	cmp    %edi,%edx
- 740:	74 1e                	je     760 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 742:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 745:	8b 50 04             	mov    0x4(%eax),%edx
- 748:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 74b:	39 f1                	cmp    %esi,%ecx
- 74d:	74 28                	je     777 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 74f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 751:	5b                   	pop    %ebx
-  freep = p;
- 752:	a3 c0 0b 00 00       	mov    %eax,0xbc0
-}
- 757:	5e                   	pop    %esi
- 758:	5f                   	pop    %edi
- 759:	5d                   	pop    %ebp
- 75a:	c3                   	ret    
- 75b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 75f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 760:	03 72 04             	add    0x4(%edx),%esi
- 763:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 766:	8b 10                	mov    (%eax),%edx
- 768:	8b 12                	mov    (%edx),%edx
- 76a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 76d:	8b 50 04             	mov    0x4(%eax),%edx
- 770:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 773:	39 f1                	cmp    %esi,%ecx
- 775:	75 d8                	jne    74f <free+0x4f>
-    p->s.size += bp->s.size;
- 777:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 77a:	a3 c0 0b 00 00       	mov    %eax,0xbc0
-    p->s.size += bp->s.size;
- 77f:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 782:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 785:	89 10                	mov    %edx,(%eax)
-}
- 787:	5b                   	pop    %ebx
- 788:	5e                   	pop    %esi
- 789:	5f                   	pop    %edi
- 78a:	5d                   	pop    %ebp
- 78b:	c3                   	ret    
- 78c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000790 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 790:	f3 0f 1e fb          	endbr32 
- 794:	55                   	push   %ebp
- 795:	89 e5                	mov    %esp,%ebp
- 797:	57                   	push   %edi
- 798:	56                   	push   %esi
- 799:	53                   	push   %ebx
- 79a:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 79d:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 7a0:	8b 3d c0 0b 00 00    	mov    0xbc0,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 7a6:	8d 70 07             	lea    0x7(%eax),%esi
- 7a9:	c1 ee 03             	shr    $0x3,%esi
- 7ac:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 7af:	85 ff                	test   %edi,%edi
- 7b1:	0f 84 a9 00 00 00    	je     860 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7b7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 7b9:	8b 48 04             	mov    0x4(%eax),%ecx
- 7bc:	39 f1                	cmp    %esi,%ecx
- 7be:	73 6d                	jae    82d <malloc+0x9d>
- 7c0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 7c6:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 7cb:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 7ce:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 7d5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 7d8:	eb 17                	jmp    7f1 <malloc+0x61>
- 7da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7e0:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 7e2:	8b 4a 04             	mov    0x4(%edx),%ecx
- 7e5:	39 f1                	cmp    %esi,%ecx
- 7e7:	73 4f                	jae    838 <malloc+0xa8>
- 7e9:	8b 3d c0 0b 00 00    	mov    0xbc0,%edi
- 7ef:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 7f1:	39 c7                	cmp    %eax,%edi
- 7f3:	75 eb                	jne    7e0 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 7f5:	83 ec 0c             	sub    $0xc,%esp
- 7f8:	ff 75 e4             	pushl  -0x1c(%ebp)
- 7fb:	e8 fb fb ff ff       	call   3fb <sbrk>
-  if(p == (char*)-1)
- 800:	83 c4 10             	add    $0x10,%esp
- 803:	83 f8 ff             	cmp    $0xffffffff,%eax
- 806:	74 1b                	je     823 <malloc+0x93>
-  hp->s.size = nu;
- 808:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 80b:	83 ec 0c             	sub    $0xc,%esp
- 80e:	83 c0 08             	add    $0x8,%eax
- 811:	50                   	push   %eax
- 812:	e8 e9 fe ff ff       	call   700 <free>
-  return freep;
- 817:	a1 c0 0b 00 00       	mov    0xbc0,%eax
-      if((p = morecore(nunits)) == 0)
- 81c:	83 c4 10             	add    $0x10,%esp
- 81f:	85 c0                	test   %eax,%eax
- 821:	75 bd                	jne    7e0 <malloc+0x50>
-        return 0;
-  }
-}
- 823:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 826:	31 c0                	xor    %eax,%eax
-}
- 828:	5b                   	pop    %ebx
- 829:	5e                   	pop    %esi
- 82a:	5f                   	pop    %edi
- 82b:	5d                   	pop    %ebp
- 82c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 82d:	89 c2                	mov    %eax,%edx
- 82f:	89 f8                	mov    %edi,%eax
- 831:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 838:	39 ce                	cmp    %ecx,%esi
- 83a:	74 54                	je     890 <malloc+0x100>
-        p->s.size -= nunits;
- 83c:	29 f1                	sub    %esi,%ecx
- 83e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 841:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 844:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 847:	a3 c0 0b 00 00       	mov    %eax,0xbc0
-}
- 84c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 84f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 852:	5b                   	pop    %ebx
- 853:	5e                   	pop    %esi
- 854:	5f                   	pop    %edi
- 855:	5d                   	pop    %ebp
- 856:	c3                   	ret    
- 857:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 85e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 860:	c7 05 c0 0b 00 00 c4 	movl   $0xbc4,0xbc0
- 867:	0b 00 00 
-    base.s.size = 0;
- 86a:	bf c4 0b 00 00       	mov    $0xbc4,%edi
-    base.s.ptr = freep = prevp = &base;
- 86f:	c7 05 c4 0b 00 00 c4 	movl   $0xbc4,0xbc4
- 876:	0b 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 879:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 87b:	c7 05 c8 0b 00 00 00 	movl   $0x0,0xbc8
- 882:	00 00 00 
-    if(p->s.size >= nunits){
- 885:	e9 36 ff ff ff       	jmp    7c0 <malloc+0x30>
- 88a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 890:	8b 0a                	mov    (%edx),%ecx
- 892:	89 08                	mov    %ecx,(%eax)
- 894:	eb b1                	jmp    847 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/cat.c b/xv6-public/Operating-System-Project/cat.c
deleted file mode 100644
index 5ddc820..0000000
--- a/xv6-public/Operating-System-Project/cat.c
+++ /dev/null
@@ -1,43 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-char buf[512];
-
-void
-cat(int fd)
-{
-  int n;
-
-  while((n = read(fd, buf, sizeof(buf))) > 0) {
-    if (write(1, buf, n) != n) {
-      printf(1, "cat: write error\n");
-      exit();
-    }
-  }
-  if(n < 0){
-    printf(1, "cat: read error\n");
-    exit();
-  }
-}
-
-int
-main(int argc, char *argv[])
-{
-  int fd, i;
-
-  if(argc <= 1){
-    cat(0);
-    exit();
-  }
-
-  for(i = 1; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
-      printf(1, "cat: cannot open %s\n", argv[i]);
-      exit();
-    }
-    cat(fd);
-    close(fd);
-  }
-  exit();
-}
diff --git a/xv6-public/Operating-System-Project/cat.d b/xv6-public/Operating-System-Project/cat.d
deleted file mode 100644
index 8f55acc..0000000
--- a/xv6-public/Operating-System-Project/cat.d
+++ /dev/null
@@ -1 +0,0 @@
-cat.o: cat.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/cat.o b/xv6-public/Operating-System-Project/cat.o
deleted file mode 100644
index 2fcf5c1..0000000
Binary files a/xv6-public/Operating-System-Project/cat.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/cat.sym b/xv6-public/Operating-System-Project/cat.sym
deleted file mode 100644
index c5ebc47..0000000
--- a/xv6-public/Operating-System-Project/cat.sym
+++ /dev/null
@@ -1,71 +0,0 @@
-00000000 .text
-00000898 .rodata
-000008ec .eh_frame
-00000bc0 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 cat.c
-00000000 ulib.c
-00000000 printf.c
-00000480 printint
-000008d8 digits.1109
-00000000 umalloc.c
-00000bc0 freep
-00000bc4 base
-00000110 strcpy
-0000041b getChildren
-00000530 printf
-00000340 memmove
-000003bb mknod
-00000230 gets
-000003f3 getpid
-00000453 customWait
-00000090 cat
-0000044b getCBT
-00000790 malloc
-00000403 sleep
-00000383 pipe
-00000433 changePolicy
-00000393 write
-000003cb fstat
-000003a3 kill
-000003e3 chdir
-0000045b setQueue
-000003ab exec
-0000037b wait
-0000038b read
-00000463 getBurstTime
-000003c3 unlink
-0000036b fork
-0000043b getTurnAroundTime
-000003fb sbrk
-0000040b uptime
-00000bbc __bss_start
-000001d0 memset
-00000000 main
-00000140 strcmp
-000003eb dup
-00000423 getSyscallCounter
-00000be0 buf
-00000413 getParentID
-000002b0 stat
-00000bbc _edata
-00000de0 _end
-000003d3 link
-00000373 exit
-0000042b setPriority
-00000300 atoi
-0000046b getCreationTime
-00000190 strlen
-000003b3 open
-000001f0 strchr
-000003db mkdir
-0000039b close
-00000443 getWaitingTime
-00000700 free
diff --git a/xv6-public/Operating-System-Project/console.c b/xv6-public/Operating-System-Project/console.c
deleted file mode 100644
index a280d2b..0000000
--- a/xv6-public/Operating-System-Project/console.c
+++ /dev/null
@@ -1,299 +0,0 @@
-// Console input and output.
-// Input is from the keyboard or serial port.
-// Output is written to the screen and serial port.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "traps.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "file.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-
-static void consputc(int);
-
-static int panicked = 0;
-
-static struct {
-  struct spinlock lock;
-  int locking;
-} cons;
-
-static void
-printint(int xx, int base, int sign)
-{
-  static char digits[] = "0123456789abcdef";
-  char buf[16];
-  int i;
-  uint x;
-
-  if(sign && (sign = xx < 0))
-    x = -xx;
-  else
-    x = xx;
-
-  i = 0;
-  do{
-    buf[i++] = digits[x % base];
-  }while((x /= base) != 0);
-
-  if(sign)
-    buf[i++] = '-';
-
-  while(--i >= 0)
-    consputc(buf[i]);
-}
-//PAGEBREAK: 50
-
-// Print to the console. only understands %d, %x, %p, %s.
-void
-cprintf(char *fmt, ...)
-{
-  int i, c, locking;
-  uint *argp;
-  char *s;
-
-  locking = cons.locking;
-  if(locking)
-    acquire(&cons.lock);
-
-  if (fmt == 0)
-    panic("null fmt");
-
-  argp = (uint*)(void*)(&fmt + 1);
-  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
-    if(c != '%'){
-      consputc(c);
-      continue;
-    }
-    c = fmt[++i] & 0xff;
-    if(c == 0)
-      break;
-    switch(c){
-    case 'd':
-      printint(*argp++, 10, 1);
-      break;
-    case 'x':
-    case 'p':
-      printint(*argp++, 16, 0);
-      break;
-    case 's':
-      if((s = (char*)*argp++) == 0)
-        s = "(null)";
-      for(; *s; s++)
-        consputc(*s);
-      break;
-    case '%':
-      consputc('%');
-      break;
-    default:
-      // Print unknown % sequence to draw attention.
-      consputc('%');
-      consputc(c);
-      break;
-    }
-  }
-
-  if(locking)
-    release(&cons.lock);
-}
-
-void
-panic(char *s)
-{
-  int i;
-  uint pcs[10];
-
-  cli();
-  cons.locking = 0;
-  // use lapiccpunum so that we can call panic from mycpu()
-  cprintf("lapicid %d: panic: ", lapicid());
-  cprintf(s);
-  cprintf("\n");
-  getcallerpcs(&s, pcs);
-  for(i=0; i<10; i++)
-    cprintf(" %p", pcs[i]);
-  panicked = 1; // freeze other CPU
-  for(;;)
-    ;
-}
-
-//PAGEBREAK: 50
-#define BACKSPACE 0x100
-#define CRTPORT 0x3d4
-static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
-
-static void
-cgaputc(int c)
-{
-  int pos;
-
-  // Cursor position: col + 80*row.
-  outb(CRTPORT, 14);
-  pos = inb(CRTPORT+1) << 8;
-  outb(CRTPORT, 15);
-  pos |= inb(CRTPORT+1);
-
-  if(c == '\n')
-    pos += 80 - pos%80;
-  else if(c == BACKSPACE){
-    if(pos > 0) --pos;
-  } else
-    crt[pos++] = (c&0xff) | 0x0700;  // black on white
-
-  if(pos < 0 || pos > 25*80)
-    panic("pos under/overflow");
-
-  if((pos/80) >= 24){  // Scroll up.
-    memmove(crt, crt+80, sizeof(crt[0])*23*80);
-    pos -= 80;
-    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
-  }
-
-  outb(CRTPORT, 14);
-  outb(CRTPORT+1, pos>>8);
-  outb(CRTPORT, 15);
-  outb(CRTPORT+1, pos);
-  crt[pos] = ' ' | 0x0700;
-}
-
-void
-consputc(int c)
-{
-  if(panicked){
-    cli();
-    for(;;)
-      ;
-  }
-
-  if(c == BACKSPACE){
-    uartputc('\b'); uartputc(' '); uartputc('\b');
-  } else
-    uartputc(c);
-  cgaputc(c);
-}
-
-#define INPUT_BUF 128
-struct {
-  char buf[INPUT_BUF];
-  uint r;  // Read index
-  uint w;  // Write index
-  uint e;  // Edit index
-} input;
-
-#define C(x)  ((x)-'@')  // Control-x
-
-void
-consoleintr(int (*getc)(void))
-{
-  int c, doprocdump = 0;
-
-  acquire(&cons.lock);
-  while((c = getc()) >= 0){
-    switch(c){
-    case C('P'):  // Process listing.
-      // procdump() locks cons.lock indirectly; invoke later
-      doprocdump = 1;
-      break;
-    case C('U'):  // Kill line.
-      while(input.e != input.w &&
-            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
-        input.e--;
-        consputc(BACKSPACE);
-      }
-      break;
-    case C('H'): case '\x7f':  // Backspace
-      if(input.e != input.w){
-        input.e--;
-        consputc(BACKSPACE);
-      }
-      break;
-    default:
-      if(c != 0 && input.e-input.r < INPUT_BUF){
-        c = (c == '\r') ? '\n' : c;
-        input.buf[input.e++ % INPUT_BUF] = c;
-        consputc(c);
-        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
-          input.w = input.e;
-          wakeup(&input.r);
-        }
-      }
-      break;
-    }
-  }
-  release(&cons.lock);
-  if(doprocdump) {
-    procdump();  // now call procdump() wo. cons.lock held
-  }
-}
-
-int
-consoleread(struct inode *ip, char *dst, int n)
-{
-  uint target;
-  int c;
-
-  iunlock(ip);
-  target = n;
-  acquire(&cons.lock);
-  while(n > 0){
-    while(input.r == input.w){
-      if(myproc()->killed){
-        release(&cons.lock);
-        ilock(ip);
-        return -1;
-      }
-      sleep(&input.r, &cons.lock);
-    }
-    c = input.buf[input.r++ % INPUT_BUF];
-    if(c == C('D')){  // EOF
-      if(n < target){
-        // Save ^D for next time, to make sure
-        // caller gets a 0-byte result.
-        input.r--;
-      }
-      break;
-    }
-    *dst++ = c;
-    --n;
-    if(c == '\n')
-      break;
-  }
-  release(&cons.lock);
-  ilock(ip);
-
-  return target - n;
-}
-
-int
-consolewrite(struct inode *ip, char *buf, int n)
-{
-  int i;
-
-  iunlock(ip);
-  acquire(&cons.lock);
-  for(i = 0; i < n; i++)
-    consputc(buf[i] & 0xff);
-  release(&cons.lock);
-  ilock(ip);
-
-  return n;
-}
-
-void
-consoleinit(void)
-{
-  initlock(&cons.lock, "console");
-
-  devsw[CONSOLE].write = consolewrite;
-  devsw[CONSOLE].read = consoleread;
-  cons.locking = 1;
-
-  ioapicenable(IRQ_KBD, 0);
-}
-
diff --git a/xv6-public/Operating-System-Project/console.d b/xv6-public/Operating-System-Project/console.d
deleted file mode 100644
index 7b5564c..0000000
--- a/xv6-public/Operating-System-Project/console.d
+++ /dev/null
@@ -1,3 +0,0 @@
-console.o: console.c /usr/include/stdc-predef.h types.h defs.h param.h \
- traps.h spinlock.h sleeplock.h fs.h file.h memlayout.h mmu.h proc.h \
- x86.h
diff --git a/xv6-public/Operating-System-Project/console.o b/xv6-public/Operating-System-Project/console.o
deleted file mode 100644
index 8d84455..0000000
Binary files a/xv6-public/Operating-System-Project/console.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/cuth b/xv6-public/Operating-System-Project/cuth
deleted file mode 100644
index cce8c0c..0000000
--- a/xv6-public/Operating-System-Project/cuth
+++ /dev/null
@@ -1,48 +0,0 @@
-#!/usr/bin/perl
-
-$| = 1;
-
-sub writefile($@){
-	my ($file, @lines) = @_;
-	
-	sleep(1);
-	open(F, ">$file") || die "open >$file: $!";
-	print F @lines;
-	close(F);
-}
-
-# Cut out #include lines that don't contribute anything.
-for($i=0; $i<@ARGV; $i++){
-	$file = $ARGV[$i];
-	if(!open(F, $file)){
-		print STDERR "open $file: $!\n";
-		next;
-	}
-	@lines = <F>;
-	close(F);
-	
-	$obj = "$file.o";
-	$obj =~ s/\.c\.o$/.o/;
-	system("touch $file");
-
-	if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
-		print STDERR "make $obj failed: $rv\n";
-		next;
-	}
-
-	system("cp $file =$file");
-	for($j=@lines-1; $j>=0; $j--){
-		if($lines[$j] =~ /^#include/){
-			$old = $lines[$j];
-			$lines[$j] = "/* CUT-H */\n";
-			writefile($file, @lines);
-			if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
-				$lines[$j] = $old;
-			}else{
-				print STDERR "$file $old";
-			}
-		}
-	}
-	writefile($file, grep {!/CUT-H/} @lines);
-	system("rm =$file");
-}
diff --git a/xv6-public/Operating-System-Project/date.h b/xv6-public/Operating-System-Project/date.h
deleted file mode 100644
index 94aec4b..0000000
--- a/xv6-public/Operating-System-Project/date.h
+++ /dev/null
@@ -1,8 +0,0 @@
-struct rtcdate {
-  uint second;
-  uint minute;
-  uint hour;
-  uint day;
-  uint month;
-  uint year;
-};
diff --git a/xv6-public/Operating-System-Project/defs.h b/xv6-public/Operating-System-Project/defs.h
deleted file mode 100644
index 8358ab8..0000000
--- a/xv6-public/Operating-System-Project/defs.h
+++ /dev/null
@@ -1,206 +0,0 @@
-#include "param.h"
-
-struct buf;
-struct context;
-struct file;
-struct inode;
-struct pipe;
-struct proc;
-struct rtcdate;
-struct spinlock;
-struct sleeplock;
-struct stat;
-struct superblock;
-
-// bio.c
-void binit(void);
-struct buf *bread(uint, uint);
-void brelse(struct buf *);
-void bwrite(struct buf *);
-
-// console.c
-void consoleinit(void);
-void cprintf(char *, ...);
-void consoleintr(int (*)(void));
-void panic(char *) __attribute__((noreturn));
-
-// exec.c
-int exec(char *, char **);
-
-// file.c
-struct file *filealloc(void);
-void fileclose(struct file *);
-struct file *filedup(struct file *);
-void fileinit(void);
-int fileread(struct file *, char *, int n);
-int filestat(struct file *, struct stat *);
-int filewrite(struct file *, char *, int n);
-
-// fs.c
-void readsb(int dev, struct superblock *sb);
-int dirlink(struct inode *, char *, uint);
-struct inode *dirlookup(struct inode *, char *, uint *);
-struct inode *ialloc(uint, short);
-struct inode *idup(struct inode *);
-void iinit(int dev);
-void ilock(struct inode *);
-void iput(struct inode *);
-void iunlock(struct inode *);
-void iunlockput(struct inode *);
-void iupdate(struct inode *);
-int namecmp(const char *, const char *);
-struct inode *namei(char *);
-struct inode *nameiparent(char *, char *);
-int readi(struct inode *, char *, uint, uint);
-void stati(struct inode *, struct stat *);
-int writei(struct inode *, char *, uint, uint);
-
-// ide.c
-void ideinit(void);
-void ideintr(void);
-void iderw(struct buf *);
-
-// ioapic.c
-void ioapicenable(int irq, int cpu);
-extern uchar ioapicid;
-void ioapicinit(void);
-
-// kalloc.c
-char *kalloc(void);
-void kfree(char *);
-void kinit1(void *, void *);
-void kinit2(void *, void *);
-
-// kbd.c
-void kbdintr(void);
-
-// lapic.c
-void cmostime(struct rtcdate *r);
-int lapicid(void);
-extern volatile uint *lapic;
-void lapiceoi(void);
-void lapicinit(void);
-void lapicstartap(uchar, uint);
-void microdelay(int);
-
-// log.c
-void initlog(int dev);
-void log_write(struct buf *);
-void begin_op();
-void end_op();
-
-// mp.c
-extern int ismp;
-void mpinit(void);
-
-// picirq.c
-void picenable(int);
-void picinit(void);
-
-// pipe.c
-int pipealloc(struct file **, struct file **);
-void pipeclose(struct pipe *, int);
-int piperead(struct pipe *, char *, int);
-int pipewrite(struct pipe *, char *, int);
-
-//PAGEBREAK: 16
-// proc.c
-int cpuid(void);
-void exit(void);
-int fork(void);
-int growproc(int);
-int kill(int);
-struct cpu *mycpu(void);
-struct proc *myproc();
-void pinit(void);
-void procdump(void);
-void scheduler(void) __attribute__((noreturn));
-void sched(void);
-void setproc(struct proc *);
-void sleep(void *, struct spinlock *);
-void userinit(void);
-int wait(void);
-void wakeup(void *);
-void yield(void);
-void updateStateDurations();
-int getParentID(void);
-int getChildren(int *children_pid);
-int getSyscallCounter(int syscall_num);
-int setPriority(int newPriority);
-int changePolicy(int newPolicy);
-int getTurnAroundTime(int pid);
-int getBurstTime(int pid);
-int getCreationTime(int pid);
-int getWaitingTime(int pid);
-int getCBT(int pid);
-int customWait(int *procTimes);
-int setQueue(int queueNumber);
-
-// swtch.S
-void swtch(struct context **, struct context *);
-
-// spinlock.c
-void acquire(struct spinlock *);
-void getcallerpcs(void *, uint *);
-int holding(struct spinlock *);
-void initlock(struct spinlock *, char *);
-void release(struct spinlock *);
-void pushcli(void);
-void popcli(void);
-
-// sleeplock.c
-void acquiresleep(struct sleeplock *);
-void releasesleep(struct sleeplock *);
-int holdingsleep(struct sleeplock *);
-void initsleeplock(struct sleeplock *, char *);
-
-// string.c
-int memcmp(const void *, const void *, uint);
-void *memmove(void *, const void *, uint);
-void *memset(void *, int, uint);
-char *safestrcpy(char *, const char *, int);
-int strlen(const char *);
-int strncmp(const char *, const char *, uint);
-char *strncpy(char *, const char *, int);
-
-// syscall.c
-extern int syscallsCount[NSYSCALLS];
-int argint(int, int *);
-int argptr(int, char **, int);
-int argstr(int, char **);
-int fetchint(uint, int *);
-int fetchstr(uint, char **);
-void syscall(void);
-
-// timer.c
-void timerinit(void);
-
-// trap.c
-void idtinit(void);
-extern uint ticks;
-void tvinit(void);
-extern struct spinlock tickslock;
-
-// uart.c
-void uartinit(void);
-void uartintr(void);
-void uartputc(int);
-
-// vm.c
-void seginit(void);
-void kvmalloc(void);
-pde_t *setupkvm(void);
-char *uva2ka(pde_t *, char *);
-int allocuvm(pde_t *, uint, uint);
-int deallocuvm(pde_t *, uint, uint);
-void freevm(pde_t *);
-void inituvm(pde_t *, char *, uint);
-int loaduvm(pde_t *, char *, struct inode *, uint, uint);
-pde_t *copyuvm(pde_t *, uint);
-void switchuvm(struct proc *);
-void switchkvm(void);
-int copyout(pde_t *, uint, void *, uint);
-void clearpteu(pde_t *pgdir, char *uva);
-
-// number of elements in fixed-size array
-#define NELEM(x) (sizeof(x) / sizeof((x)[0]))
diff --git a/xv6-public/Operating-System-Project/docs/Project Report.pdf b/xv6-public/Operating-System-Project/docs/Project Report.pdf
deleted file mode 100644
index 02bd35c..0000000
Binary files a/xv6-public/Operating-System-Project/docs/Project Report.pdf and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/docs/final_project_assignment_v1.pdf b/xv6-public/Operating-System-Project/docs/final_project_assignment_v1.pdf
deleted file mode 100644
index 1a7ee55..0000000
Binary files a/xv6-public/Operating-System-Project/docs/final_project_assignment_v1.pdf and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/dot-bochsrc b/xv6-public/Operating-System-Project/dot-bochsrc
deleted file mode 100644
index ba13db7..0000000
--- a/xv6-public/Operating-System-Project/dot-bochsrc
+++ /dev/null
@@ -1,738 +0,0 @@
-# You may now use double quotes around pathnames, in case
-# your pathname includes spaces.
-
-#=======================================================================
-# CONFIG_INTERFACE
-#
-# The configuration interface is a series of menus or dialog boxes that
-# allows you to change all the settings that control Bochs's behavior.
-# There are two choices of configuration interface: a text mode version
-# called "textconfig" and a graphical version called "wx".  The text
-# mode version uses stdin/stdout and is always compiled in.  The graphical
-# version is only available when you use "--with-wx" on the configure 
-# command.  If you do not write a config_interface line, Bochs will 
-# choose a default for you.
-#
-# NOTE: if you use the "wx" configuration interface, you must also use
-# the "wx" display library.
-#=======================================================================
-#config_interface: textconfig
-#config_interface: wx
-
-#=======================================================================
-# DISPLAY_LIBRARY
-#
-# The display library is the code that displays the Bochs VGA screen.  Bochs 
-# has a selection of about 10 different display library implementations for 
-# different platforms.  If you run configure with multiple --with-* options, 
-# the display_library command lets you choose which one you want to run with.
-# If you do not write a display_library line, Bochs will choose a default for
-# you.
-#
-# The choices are: 
-#   x              use X windows interface, cross platform
-#   win32          use native win32 libraries
-#   carbon         use Carbon library (for MacOS X)
-#   beos           use native BeOS libraries
-#   macintosh      use MacOS pre-10
-#   amigaos        use native AmigaOS libraries
-#   sdl            use SDL library, cross platform
-#   svga           use SVGALIB library for Linux, allows graphics without X11
-#   term           text only, uses curses/ncurses library, cross platform
-#   rfb            provides an interface to AT&T's VNC viewer, cross platform
-#   wx             use wxWidgets library, cross platform
-#   nogui          no display at all
-#
-# NOTE: if you use the "wx" configuration interface, you must also use
-# the "wx" display library.
-#
-# Specific options:
-# Some display libraries now support specific option to control their
-# behaviour. See the examples below for currently supported options.
-#=======================================================================
-#display_library: amigaos
-#display_library: beos
-#display_library: carbon
-#display_library: macintosh
-#display_library: nogui
-#display_library: rfb, options="timeout=60" # time to wait for client
-#display_library: sdl, options="fullscreen" # startup in fullscreen mode
-#display_library: term
-#display_library: win32, options="legacyF12" # use F12 to toggle mouse
-#display_library: wx
-#display_library: x
-
-#=======================================================================
-# ROMIMAGE:
-# The ROM BIOS controls what the PC does when it first powers on.
-# Normally, you can use a precompiled BIOS in the source or binary
-# distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded
-# starting at address 0xf0000, and it is exactly 64k long.
-# You can also use the environment variable $BXSHARE to specify the
-# location of the BIOS.
-# The usage of external large BIOS images (up to 512k) at memory top is
-# now supported, but we still recommend to use the BIOS distributed with
-# Bochs. Now the start address can be calculated from image size.
-#=======================================================================
-romimage: file=$BXSHARE/BIOS-bochs-latest
-#romimage: file=mybios.bin, address=0xfff80000 # 512k at memory top
-#romimage: file=mybios.bin # calculate start address from image size
-
-#=======================================================================
-# CPU:
-# This defines cpu-related parameters inside Bochs:
-#
-#  COUNT:
-#  Set the number of processors when Bochs is compiled for SMP emulation.
-#  Bochs currently supports up to 8 processors. If Bochs is compiled
-#  without SMP support, it won't accept values different from 1.
-#
-#  IPS:
-#  Emulated Instructions Per Second.  This is the number of IPS that bochs
-#  is capable of running on your machine. You can recompile Bochs with
-#  --enable-show-ips option enabled, to find your workstation's capability.
-#  Measured IPS value will then be logged into your log file or status bar
-#  (if supported by the gui).
-#
-#  IPS is used to calibrate many time-dependent events within the bochs 
-#  simulation.  For example, changing IPS affects the frequency of VGA
-#  updates, the duration of time before a key starts to autorepeat, and
-#  the measurement of BogoMips and other benchmarks.
-#
-#  Examples:
-#  Machine                                         Mips
-# ________________________________________________________________
-#  2.1Ghz Athlon XP with Linux 2.6/g++ 3.4         12 to 15 Mips
-#  1.6Ghz Intel P4 with Win2000/g++ 3.3             5 to  7 Mips
-#  650Mhz Athlon K-7 with Linux 2.4.4/egcs-2.91.66  2 to  2.5 Mips
-#  400Mhz Pentium II with Linux 2.0.36/egcs-1.0.3   1 to  1.8 Mips
-#=======================================================================
-cpu: count=2, ips=10000000
-
-#=======================================================================
-# MEGS
-# Set the number of Megabytes of physical memory you want to emulate. 
-# The default is 32MB, most OS's won't need more than that.
-# The maximum amount of memory supported is 2048Mb.
-#=======================================================================
-#megs: 256
-#megs: 128
-#megs: 64
-megs: 32
-#megs: 16
-#megs: 8
-
-#=======================================================================
-# OPTROMIMAGE[1-4]:
-# You may now load up to 4 optional ROM images. Be sure to use a 
-# read-only area, typically between C8000 and EFFFF. These optional
-# ROM images should not overwrite the rombios (located at
-# F0000-FFFFF) and the videobios (located at C0000-C7FFF).
-# Those ROM images will be initialized by the bios if they contain 
-# the right signature (0x55AA) and a valid checksum.
-# It can also be a convenient way to upload some arbitrary code/data
-# in the simulation, that can be retrieved by the boot loader
-#=======================================================================
-#optromimage1: file=optionalrom.bin, address=0xd0000
-#optromimage2: file=optionalrom.bin, address=0xd1000
-#optromimage3: file=optionalrom.bin, address=0xd2000
-#optromimage4: file=optionalrom.bin, address=0xd3000
-
-#optramimage1: file=/path/file1.img, address=0x0010000
-#optramimage2: file=/path/file2.img, address=0x0020000
-#optramimage3: file=/path/file3.img, address=0x0030000
-#optramimage4: file=/path/file4.img, address=0x0040000
-
-#=======================================================================
-# VGAROMIMAGE
-# You now need to load a VGA ROM BIOS into C0000.
-#=======================================================================
-#vgaromimage: file=bios/VGABIOS-elpin-2.40
-vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
-#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus
-
-#=======================================================================
-# VGA:
-# Here you can specify the display extension to be used. With the value
-# 'none' you can use standard VGA with no extension. Other supported
-# values are 'vbe' for Bochs VBE and 'cirrus' for Cirrus SVGA support.
-#=======================================================================
-#vga: extension=cirrus
-#vga: extension=vbe
-vga: extension=none
-
-#=======================================================================
-# FLOPPYA:
-# Point this to pathname of floppy image file or device
-# This should be of a bootable floppy(image/device) if you're
-# booting from 'a' (or 'floppy').
-#
-# You can set the initial status of the media to 'ejected' or 'inserted'.
-#   floppya: 2_88=path, status=ejected             (2.88M 3.5" floppy)
-#   floppya: 1_44=path, status=inserted            (1.44M 3.5" floppy)
-#   floppya: 1_2=path, status=ejected              (1.2M  5.25" floppy)
-#   floppya: 720k=path, status=inserted            (720K  3.5" floppy)
-#   floppya: 360k=path, status=inserted            (360K  5.25" floppy)
-#   floppya: 320k=path, status=inserted            (320K  5.25" floppy)
-#   floppya: 180k=path, status=inserted            (180K  5.25" floppy)
-#   floppya: 160k=path, status=inserted            (160K  5.25" floppy)
-#   floppya: image=path, status=inserted           (guess type from image size)
-#
-# The path should be the name of a disk image file.  On Unix, you can use a raw
-# device name such as /dev/fd0 on Linux.  On win32 platforms, use drive letters
-# such as a: or b: as the path.  The parameter 'image' works with image files
-# only. In that case the size must match one of the supported types.
-#=======================================================================
-floppya: 1_44=/dev/fd0, status=inserted
-#floppya: image=../1.44, status=inserted
-#floppya: 1_44=/dev/fd0H1440, status=inserted
-#floppya: 1_2=../1_2, status=inserted
-#floppya: 1_44=a:, status=inserted
-#floppya: 1_44=a.img, status=inserted
-#floppya: 1_44=/dev/rfd0a, status=inserted
-
-#=======================================================================
-# FLOPPYB:
-# See FLOPPYA above for syntax
-#=======================================================================
-#floppyb: 1_44=b:, status=inserted
-floppyb: 1_44=b.img, status=inserted
-
-#=======================================================================
-# ATA0, ATA1, ATA2, ATA3
-# ATA controller for hard disks and cdroms
-#
-# ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
-# 
-# These options enables up to 4 ata channels. For each channel
-# the two base io addresses and the irq must be specified.
-# 
-# ata0 and ata1 are enabled by default with the values shown below
-#
-# Examples:
-#   ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
-#   ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
-#   ata2: enabled=1, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
-#   ata3: enabled=1, ioaddr1=0x168, ioaddr2=0x360, irq=9
-#=======================================================================
-ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
-ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
-ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
-ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9
-
-#=======================================================================
-# ATA[0-3]-MASTER, ATA[0-3]-SLAVE
-#
-# This defines the type and characteristics of all attached ata devices:
-#   type=       type of attached device [disk|cdrom] 
-#   mode=       only valid for disks [flat|concat|external|dll|sparse|vmware3]
-#   mode=       only valid for disks [undoable|growing|volatile]
-#   path=       path of the image
-#   cylinders=  only valid for disks
-#   heads=      only valid for disks
-#   spt=        only valid for disks
-#   status=     only valid for cdroms [inserted|ejected]
-#   biosdetect= type of biosdetection [none|auto], only for disks on ata0 [cmos]
-#   translation=type of translation of the bios, only for disks [none|lba|large|rechs|auto]
-#   model=      string returned by identify device command
-#   journal=    optional filename of the redolog for undoable and volatile disks
-#   
-# Point this at a hard disk image file, cdrom iso file, or physical cdrom
-# device.  To create a hard disk image, try running bximage.  It will help you
-# choose the size and then suggest a line that works with it.
-#
-# In UNIX it may be possible to use a raw device as a Bochs hard disk, 
-# but WE DON'T RECOMMEND IT.  In Windows there is no easy way.
-#
-# In windows, the drive letter + colon notation should be used for cdroms.
-# Depending on versions of windows and drivers, you may only be able to 
-# access the "first" cdrom in the system.  On MacOSX, use path="drive"
-# to access the physical drive.
-#
-# The path is always mandatory. For flat hard disk images created with
-# bximage geometry autodetection can be used (cylinders=0 -> cylinders are
-# calculated using heads=16 and spt=63). For other hard disk images and modes
-# the cylinders, heads, and spt are mandatory.
-#
-# Default values are:
-#   mode=flat, biosdetect=auto, translation=auto, model="Generic 1234"
-#
-# The biosdetect option has currently no effect on the bios
-#
-# Examples:
-#   ata0-master: type=disk, mode=flat, path=10M.sample, cylinders=306, heads=4, spt=17
-#   ata0-slave:  type=disk, mode=flat, path=20M.sample, cylinders=615, heads=4, spt=17
-#   ata1-master: type=disk, mode=flat, path=30M.sample, cylinders=615, heads=6, spt=17
-#   ata1-slave:  type=disk, mode=flat, path=46M.sample, cylinders=940, heads=6, spt=17
-#   ata2-master: type=disk, mode=flat, path=62M.sample, cylinders=940, heads=8, spt=17
-#   ata2-slave:  type=disk, mode=flat, path=112M.sample, cylinders=900, heads=15, spt=17
-#   ata3-master: type=disk, mode=flat, path=483M.sample, cylinders=1024, heads=15, spt=63
-#   ata3-slave:  type=cdrom, path=iso.sample, status=inserted
-#=======================================================================
-ata0-master: type=disk, mode=flat, path="xv6.img", cylinders=100, heads=10, spt=10
-ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
-#ata0-slave: type=cdrom, path=D:, status=inserted
-#ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
-#ata0-slave: type=cdrom, path="drive", status=inserted
-#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
-
-#=======================================================================
-# BOOT:
-# This defines the boot sequence. Now you can specify up to 3 boot drives.
-# You can either boot from 'floppy', 'disk' or 'cdrom'
-# legacy 'a' and 'c' are also supported
-# Examples:
-#   boot: floppy
-#   boot: disk
-#   boot: cdrom
-#   boot: c
-#   boot: a
-#   boot: cdrom, floppy, disk
-#=======================================================================
-#boot: floppy
-boot: disk
-
-#=======================================================================
-# CLOCK:
-# This defines the parameters of the clock inside Bochs:
-#
-#  SYNC:
-#  TO BE COMPLETED (see Greg explanation in feature request #536329)
-#
-#  TIME0:
-#  Specifies the start (boot) time of the virtual machine. Use a time 
-#  value as returned by the time(2) system call. If no time0 value is 
-#  set or if time0 equal to 1 (special case) or if time0 equal 'local', 
-#  the simulation will be started at the current local host time.
-#  If time0 equal to 2 (special case) or if time0 equal 'utc',
-#  the simulation will be started at the current utc time.
-#
-# Syntax:
-#  clock: sync=[none|slowdown|realtime|both], time0=[timeValue|local|utc]
-#
-# Example:
-#   clock: sync=none,     time0=local       # Now (localtime)
-#   clock: sync=slowdown, time0=315529200   # Tue Jan  1 00:00:00 1980
-#   clock: sync=none,     time0=631148400   # Mon Jan  1 00:00:00 1990
-#   clock: sync=realtime, time0=938581955   # Wed Sep 29 07:12:35 1999
-#   clock: sync=realtime, time0=946681200   # Sat Jan  1 00:00:00 2000
-#   clock: sync=none,     time0=1           # Now (localtime)
-#   clock: sync=none,     time0=utc         # Now (utc/gmt)
-# 
-# Default value are sync=none, time0=local
-#=======================================================================
-#clock: sync=none, time0=local
-
-
-#=======================================================================
-# FLOPPY_BOOTSIG_CHECK: disabled=[0|1]
-# Enables or disables the 0xaa55 signature check on boot floppies
-# Defaults to disabled=0
-# Examples:
-#   floppy_bootsig_check: disabled=0
-#   floppy_bootsig_check: disabled=1
-#=======================================================================
-#floppy_bootsig_check: disabled=1
-floppy_bootsig_check: disabled=0
-
-#=======================================================================
-# LOG:
-# Give the path of the log file you'd like Bochs debug and misc. verbiage
-# to be written to. If you don't use this option or set the filename to
-# '-' the output is written to the console. If you really don't want it,
-# make it "/dev/null" (Unix) or "nul" (win32). :^(
-#
-# Examples:
-#   log: ./bochs.out
-#   log: /dev/tty
-#=======================================================================
-#log: /dev/null
-log: bochsout.txt
-
-#=======================================================================
-# LOGPREFIX:
-# This handles the format of the string prepended to each log line.
-# You may use those special tokens :
-#   %t : 11 decimal digits timer tick
-#   %i : 8 hexadecimal digits of cpu current eip (ignored in SMP configuration)
-#   %e : 1 character event type ('i'nfo, 'd'ebug, 'p'anic, 'e'rror)
-#   %d : 5 characters string of the device, between brackets
-# 
-# Default : %t%e%d
-# Examples:
-#   logprefix: %t-%e-@%i-%d
-#   logprefix: %i%e%d
-#=======================================================================
-#logprefix: %t%e%d
-
-#=======================================================================
-# LOG CONTROLS
-#
-# Bochs now has four severity levels for event logging.
-#   panic: cannot proceed.  If you choose to continue after a panic, 
-#          don't be surprised if you get strange behavior or crashes.
-#   error: something went wrong, but it is probably safe to continue the
-#          simulation.
-#   info: interesting or useful messages.
-#   debug: messages useful only when debugging the code.  This may
-#          spit out thousands per second.
-#
-# For events of each level, you can choose to crash, report, or ignore.
-# TODO: allow choice based on the facility: e.g. crash on panics from
-#       everything except the cdrom, and only report those.
-#
-# If you are experiencing many panics, it can be helpful to change
-# the panic action to report instead of fatal.  However, be aware
-# that anything executed after a panic is uncharted territory and can 
-# cause bochs to become unstable.  The panic is a "graceful exit," so
-# if you disable it you may get a spectacular disaster instead.
-#=======================================================================
-panic: action=ask
-error: action=report
-info: action=report
-debug: action=ignore
-#pass: action=fatal
-
-#=======================================================================
-# DEBUGGER_LOG:
-# Give the path of the log file you'd like Bochs to log debugger output.
-# If you really don't want it, make it /dev/null or '-'. :^(
-#
-# Examples:
-#   debugger_log: ./debugger.out
-#=======================================================================
-#debugger_log: /dev/null
-#debugger_log: debugger.out
-debugger_log: -
-
-#=======================================================================
-# COM1, COM2, COM3, COM4:
-# This defines a serial port (UART type 16550A). In the 'term' you can specify
-# a device to use as com1. This can be a real serial line, or a pty.  To use
-# a pty (under X/Unix), create two windows (xterms, usually).  One of them will
-# run bochs, and the other will act as com1. Find out the tty the com1
-# window using the `tty' command, and use that as the `dev' parameter.
-# Then do `sleep 1000000' in the com1 window to keep the shell from
-# messing with things, and run bochs in the other window.  Serial I/O to
-# com1 (port 0x3f8) will all go to the other window.
-# Other serial modes are 'null' (no input/output), 'file' (output to a file
-# specified as the 'dev' parameter), 'raw' (use the real serial port - under
-# construction for win32), 'mouse' (standard serial mouse - requires
-# mouse option setting 'type=serial' or 'type=serial_wheel') and 'socket'
-# (connect a networking socket).
-#
-# Examples:
-#   com1: enabled=1, mode=null
-#   com1: enabled=1, mode=mouse
-#   com2: enabled=1, mode=file, dev=serial.out
-#   com3: enabled=1, mode=raw, dev=com1
-#   com3: enabled=1, mode=socket, dev=localhost:8888
-#=======================================================================
-#com1: enabled=1, mode=term, dev=/dev/ttyp9
-
-
-#=======================================================================
-# PARPORT1, PARPORT2:
-# This defines a parallel (printer) port. When turned on and an output file is
-# defined the emulated printer port sends characters printed by the guest OS
-# into the output file. On some platforms a device filename can be used to
-# send the data to the real parallel port (e.g. "/dev/lp0" on Linux, "lpt1" on
-# win32 platforms).
-#
-# Examples:
-#   parport1: enabled=1, file="parport.out"
-#   parport2: enabled=1, file="/dev/lp0"
-#   parport1: enabled=0
-#=======================================================================
-parport1: enabled=1, file="/dev/stdout"
-
-#=======================================================================
-# SB16:
-# This defines the SB16 sound emulation. It can have several of the
-# following properties.
-# All properties are in the format sb16: property=value
-# midi: The filename is where the midi data is sent. This can be a
-#       device or just a file if you want to record the midi data.
-# midimode:
-#      0=no data
-#      1=output to device (system dependent. midi denotes the device driver)
-#      2=SMF file output, including headers
-#      3=output the midi data stream to the file (no midi headers and no
-#        delta times, just command and data bytes)
-# wave: This is the device/file where wave output is stored
-# wavemode:
-#      0=no data
-#      1=output to device (system dependent. wave denotes the device driver)
-#      2=VOC file output, incl. headers
-#      3=output the raw wave stream to the file
-# log:  The file to write the sb16 emulator messages to.
-# loglevel:
-#      0=no log
-#      1=resource changes, midi program and bank changes
-#      2=severe errors
-#      3=all errors
-#      4=all errors plus all port accesses
-#      5=all errors and port accesses plus a lot of extra info
-# dmatimer:
-#      microseconds per second for a DMA cycle.  Make it smaller to fix
-#      non-continuous sound.  750000 is usually a good value.  This needs a
-#      reasonably correct setting for the IPS parameter of the CPU option.
-#
-# For an example look at the next line:
-#=======================================================================
-
-#sb16: midimode=1, midi=/dev/midi00, wavemode=1, wave=/dev/dsp, loglevel=2, log=sb16.log, dmatimer=600000
-
-#=======================================================================
-# VGA_UPDATE_INTERVAL:
-# Video memory is scanned for updates and screen updated every so many
-# virtual seconds.  The default is 40000, about 25Hz. Keep in mind that
-# you must tweak the 'cpu: ips=N' directive to be as close to the number
-# of emulated instructions-per-second your workstation can do, for this
-# to be accurate.
-#
-# Examples:
-#   vga_update_interval: 250000
-#=======================================================================
-vga_update_interval: 300000
-
-# using for Winstone '98 tests
-#vga_update_interval:  100000
-
-#=======================================================================
-# KEYBOARD_SERIAL_DELAY:
-# Approximate time in microseconds that it takes one character to
-# be transfered from the keyboard to controller over the serial path.
-# Examples:
-#   keyboard_serial_delay: 200
-#=======================================================================
-keyboard_serial_delay: 250
-
-#=======================================================================
-# KEYBOARD_PASTE_DELAY:
-# Approximate time in microseconds between attempts to paste
-# characters to the keyboard controller. This leaves time for the
-# guest os to deal with the flow of characters.  The ideal setting
-# depends on how your operating system processes characters.  The
-# default of 100000 usec (.1 seconds) was chosen because it works 
-# consistently in Windows.
-#
-# If your OS is losing characters during a paste, increase the paste
-# delay until it stops losing characters.
-#
-# Examples:
-#   keyboard_paste_delay: 100000
-#=======================================================================
-keyboard_paste_delay: 100000
-
-#=======================================================================
-# MOUSE: 
-# This option prevents Bochs from creating mouse "events" unless a mouse
-# is  enabled. The hardware emulation itself is not disabled by this.
-# You can turn the mouse on by setting enabled to 1, or turn it off by
-# setting enabled to 0. Unless you have a particular reason for enabling
-# the mouse by default, it is recommended that you leave it off.
-# You can also toggle the mouse usage at runtime (control key + middle
-# mouse button on X11, SDL, wxWidgets and Win32).
-# With the mouse type option you can select the type of mouse to emulate.
-# The default value is 'ps2'. The other choices are 'imps2' (wheel mouse
-# on PS/2), 'serial', 'serial_wheel' (one com port requires setting
-# 'mode=mouse') and 'usb' (3-button mouse - one of the USB ports must be
-# connected with the 'mouse' device - requires PCI and USB support).
-#
-# Examples:
-#   mouse: enabled=1
-#   mouse: enabled=1, type=imps2
-#   mouse: enabled=1, type=serial
-#   mouse: enabled=0
-#=======================================================================
-mouse: enabled=0
-
-#=======================================================================
-# private_colormap: Request that the GUI create and use it's own
-#                   non-shared colormap.  This colormap will be used
-#                   when in the bochs window.  If not enabled, a
-#                   shared colormap scheme may be used.  Not implemented
-#                   on all GUI's.
-#
-# Examples:
-#   private_colormap: enabled=1
-#   private_colormap: enabled=0
-#=======================================================================
-private_colormap: enabled=0
-
-#=======================================================================
-# fullscreen: ONLY IMPLEMENTED ON AMIGA
-#             Request that Bochs occupy the entire screen instead of a 
-#             window.
-#
-# Examples:
-#   fullscreen: enabled=0
-#   fullscreen: enabled=1
-#=======================================================================
-#fullscreen: enabled=0
-#screenmode: name="sample"
-
-#=======================================================================
-# ne2k: NE2000 compatible ethernet adapter
-#
-# Examples:
-# ne2k: ioaddr=IOADDR, irq=IRQ, mac=MACADDR, ethmod=MODULE, ethdev=DEVICE, script=SCRIPT
-#
-# ioaddr, irq: You probably won't need to change ioaddr and irq, unless there
-# are IRQ conflicts.
-#
-# mac: The MAC address MUST NOT match the address of any machine on the net.
-# Also, the first byte must be an even number (bit 0 set means a multicast
-# address), and you cannot use ff:ff:ff:ff:ff:ff because that's the broadcast
-# address.  For the ethertap module, you must use fe:fd:00:00:00:01.  There may
-# be other restrictions too.  To be safe, just use the b0:c4... address.
-#
-# ethdev: The ethdev value is the name of the network interface on your host
-# platform.  On UNIX machines, you can get the name by running ifconfig.  On
-# Windows machines, you must run niclist to get the name of the ethdev.
-# Niclist source code is in misc/niclist.c and it is included in Windows 
-# binary releases.
-#
-# script: The script value is optional, and is the name of a script that 
-# is executed after bochs initialize the network interface. You can use 
-# this script to configure this network interface, or enable masquerading.
-# This is mainly useful for the tun/tap devices that only exist during
-# Bochs execution. The network interface name is supplied to the script
-# as first parameter
-#
-# If you don't want to make connections to any physical networks,
-# you can use the following 'ethmod's to simulate a virtual network.
-#   null: All packets are discarded, but logged to a few files.
-#   arpback: ARP is simulated. Disabled by default.
-#   vde:  Virtual Distributed Ethernet
-#   vnet: ARP, ICMP-echo(ping), DHCP and read/write TFTP are simulated.
-#         The virtual host uses 192.168.10.1.
-#         DHCP assigns 192.168.10.2 to the guest.
-#         TFTP uses the ethdev value for the root directory and doesn't
-#         overwrite files.
-#
-#=======================================================================
-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=fbsd, ethdev=en0 #macosx
-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=fbsd, ethdev=xl0
-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=linux, ethdev=eth0
-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=win32, ethdev=MYCARD
-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tap, ethdev=tap0
-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tuntap, ethdev=/dev/net/tun0, script=./tunconfig
-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=null, ethdev=eth0
-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vde, ethdev="/tmp/vde.ctl"
-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vnet, ethdev="c:/temp"
-
-#=======================================================================
-# KEYBOARD_MAPPING:
-# This enables a remap of a physical localized keyboard to a 
-# virtualized us keyboard, as the PC architecture expects.
-# If enabled, the keymap file must be specified.
-# 
-# Examples:
-#   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
-#=======================================================================
-keyboard_mapping: enabled=0, map=
-
-#=======================================================================
-# KEYBOARD_TYPE:
-# Type of keyboard return by a "identify keyboard" command to the
-# keyboard controler. It must be one of "xt", "at" or "mf".
-# Defaults to "mf". It should be ok for almost everybody. A known
-# exception is french macs, that do have a "at"-like keyboard.
-#
-# Examples:
-#   keyboard_type: mf
-#=======================================================================
-#keyboard_type: mf
-
-#=======================================================================
-# USER_SHORTCUT:
-# This defines the keyboard shortcut to be sent when you press the "user"
-# button in the headerbar. The shortcut string is a combination of maximum
-# 3 key names (listed below) separated with a '-' character. The old-style
-# syntax (without the '-') still works for the key combinations supported
-# in Bochs 2.2.1.
-# Valid key names:
-# "alt", "bksl", "bksp", "ctrl", "del", "down", "end", "enter", "esc",
-# "f1", ... "f12", "home", "ins", "left", "menu", "minus", "pgdwn", "pgup",
-# "plus", "right", "shift", "space", "tab", "up", and "win".
-#
-# Example:
-#   user_shortcut: keys=ctrl-alt-del
-#=======================================================================
-#user_shortcut: keys=ctrl-alt-del
-
-#=======================================================================
-# I440FXSUPPORT:
-# This option controls the presence of the i440FX PCI chipset. You can
-# also specify the devices connected to PCI slots. Up to 5 slots are
-# available now. These devices are currently supported: ne2k, pcivga,
-# pcidev and pcipnic. If Bochs is compiled with Cirrus SVGA support
-# you'll have the additional choice 'cirrus'.
-#
-# Example:
-#   i440fxsupport: enabled=1, slot1=pcivga, slot2=ne2k
-#=======================================================================
-#i440fxsupport: enabled=1
-
-#=======================================================================
-# USB1:
-# This option controls the presence of the USB root hub which is a part
-# of the i440FX PCI chipset. With the portX option you can connect devices
-# to the hub (currently supported: 'mouse' and 'keypad'). If you connect
-# the mouse to one of the ports and use the mouse option 'type=usb' you'll
-# have a 3-button USB mouse.
-#
-# Example:
-#   usb1: enabled=1, port1=mouse, port2=keypad
-#=======================================================================
-#usb1: enabled=1
-
-#=======================================================================
-# CMOSIMAGE:
-# This defines image file that can be loaded into the CMOS RAM at startup.
-# The rtc_init parameter controls whether initialize the RTC with values stored
-# in the image. By default the time0 argument given to the clock option is used.
-# With 'rtc_init=image' the image is the source for the initial time.
-#
-# Example:
-#   cmosimage: file=cmos.img, rtc_init=image
-#=======================================================================
-#cmosimage: file=cmos.img, rtc_init=time0
-
-#=======================================================================
-# other stuff
-#=======================================================================
-#magic_break: enabled=1
-#load32bitOSImage: os=nullkernel, path=../kernel.img, iolog=../vga_io.log
-#load32bitOSImage: os=linux, path=../linux.img, iolog=../vga_io.log, initrd=../initrd.img
-#text_snapshot_check: enable
-
-#-------------------------
-# PCI host device mapping
-#-------------------------
-#pcidev: vendor=0x1234, device=0x5678
-
-#=======================================================================
-# GDBSTUB:
-# Enable GDB stub. See user documentation for details.
-# Default value is enabled=0.
-#=======================================================================
-#gdbstub: enabled=0, port=1234, text_base=0, data_base=0, bss_base=0
-
-#=======================================================================
-# IPS:
-# The IPS directive is DEPRECATED. Use the parameter IPS of the CPU
-# directive instead.
-#=======================================================================
-#ips: 10000000
-
-#=======================================================================
-# for Macintosh, use the style of pathnames in the following
-# examples.
-#
-# vgaromimage: :bios:VGABIOS-elpin-2.40
-# romimage: file=:bios:BIOS-bochs-latest, address=0xf0000
-# floppya: 1_44=[fd:], status=inserted
-#=======================================================================
diff --git a/xv6-public/Operating-System-Project/echo.asm b/xv6-public/Operating-System-Project/echo.asm
deleted file mode 100644
index 4b292b9..0000000
--- a/xv6-public/Operating-System-Project/echo.asm
+++ /dev/null
@@ -1,1270 +0,0 @@
-
-_echo:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	56                   	push   %esi
-  12:	53                   	push   %ebx
-  13:	51                   	push   %ecx
-  14:	83 ec 0c             	sub    $0xc,%esp
-  17:	8b 01                	mov    (%ecx),%eax
-  19:	8b 51 04             	mov    0x4(%ecx),%edx
-  int i;
-
-  for(i = 1; i < argc; i++)
-  1c:	83 f8 01             	cmp    $0x1,%eax
-  1f:	7e 4b                	jle    6c <main+0x6c>
-  21:	8d 5a 04             	lea    0x4(%edx),%ebx
-  24:	8d 34 82             	lea    (%edx,%eax,4),%esi
-    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
-  27:	83 c3 04             	add    $0x4,%ebx
-  2a:	8b 43 fc             	mov    -0x4(%ebx),%eax
-  2d:	39 f3                	cmp    %esi,%ebx
-  2f:	74 26                	je     57 <main+0x57>
-  31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  38:	68 08 08 00 00       	push   $0x808
-  3d:	83 c3 04             	add    $0x4,%ebx
-  40:	50                   	push   %eax
-  41:	68 0a 08 00 00       	push   $0x80a
-  46:	6a 01                	push   $0x1
-  48:	e8 53 04 00 00       	call   4a0 <printf>
-  for(i = 1; i < argc; i++)
-  4d:	8b 43 fc             	mov    -0x4(%ebx),%eax
-    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
-  50:	83 c4 10             	add    $0x10,%esp
-  53:	39 f3                	cmp    %esi,%ebx
-  55:	75 e1                	jne    38 <main+0x38>
-  57:	68 0f 08 00 00       	push   $0x80f
-  5c:	50                   	push   %eax
-  5d:	68 0a 08 00 00       	push   $0x80a
-  62:	6a 01                	push   $0x1
-  64:	e8 37 04 00 00       	call   4a0 <printf>
-  69:	83 c4 10             	add    $0x10,%esp
-  exit();
-  6c:	e8 72 02 00 00       	call   2e3 <exit>
-  71:	66 90                	xchg   %ax,%ax
-  73:	66 90                	xchg   %ax,%ax
-  75:	66 90                	xchg   %ax,%ax
-  77:	66 90                	xchg   %ax,%ax
-  79:	66 90                	xchg   %ax,%ax
-  7b:	66 90                	xchg   %ax,%ax
-  7d:	66 90                	xchg   %ax,%ax
-  7f:	90                   	nop
-
-00000080 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  80:	f3 0f 1e fb          	endbr32 
-  84:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  85:	31 c0                	xor    %eax,%eax
-{
-  87:	89 e5                	mov    %esp,%ebp
-  89:	53                   	push   %ebx
-  8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  8d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-  90:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-  94:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-  97:	83 c0 01             	add    $0x1,%eax
-  9a:	84 d2                	test   %dl,%dl
-  9c:	75 f2                	jne    90 <strcpy+0x10>
-    ;
-  return os;
-}
-  9e:	89 c8                	mov    %ecx,%eax
-  a0:	5b                   	pop    %ebx
-  a1:	5d                   	pop    %ebp
-  a2:	c3                   	ret    
-  a3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-000000b0 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-  b0:	f3 0f 1e fb          	endbr32 
-  b4:	55                   	push   %ebp
-  b5:	89 e5                	mov    %esp,%ebp
-  b7:	53                   	push   %ebx
-  b8:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  bb:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-  be:	0f b6 01             	movzbl (%ecx),%eax
-  c1:	0f b6 1a             	movzbl (%edx),%ebx
-  c4:	84 c0                	test   %al,%al
-  c6:	75 19                	jne    e1 <strcmp+0x31>
-  c8:	eb 26                	jmp    f0 <strcmp+0x40>
-  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  d0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-  d4:	83 c1 01             	add    $0x1,%ecx
-  d7:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-  da:	0f b6 1a             	movzbl (%edx),%ebx
-  dd:	84 c0                	test   %al,%al
-  df:	74 0f                	je     f0 <strcmp+0x40>
-  e1:	38 d8                	cmp    %bl,%al
-  e3:	74 eb                	je     d0 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-  e5:	29 d8                	sub    %ebx,%eax
-}
-  e7:	5b                   	pop    %ebx
-  e8:	5d                   	pop    %ebp
-  e9:	c3                   	ret    
-  ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  f0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-  f2:	29 d8                	sub    %ebx,%eax
-}
-  f4:	5b                   	pop    %ebx
-  f5:	5d                   	pop    %ebp
-  f6:	c3                   	ret    
-  f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  fe:	66 90                	xchg   %ax,%ax
-
-00000100 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 100:	f3 0f 1e fb          	endbr32 
- 104:	55                   	push   %ebp
- 105:	89 e5                	mov    %esp,%ebp
- 107:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 10a:	80 3a 00             	cmpb   $0x0,(%edx)
- 10d:	74 21                	je     130 <strlen+0x30>
- 10f:	31 c0                	xor    %eax,%eax
- 111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 118:	83 c0 01             	add    $0x1,%eax
- 11b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 11f:	89 c1                	mov    %eax,%ecx
- 121:	75 f5                	jne    118 <strlen+0x18>
-    ;
-  return n;
-}
- 123:	89 c8                	mov    %ecx,%eax
- 125:	5d                   	pop    %ebp
- 126:	c3                   	ret    
- 127:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 12e:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 130:	31 c9                	xor    %ecx,%ecx
-}
- 132:	5d                   	pop    %ebp
- 133:	89 c8                	mov    %ecx,%eax
- 135:	c3                   	ret    
- 136:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 13d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000140 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 140:	f3 0f 1e fb          	endbr32 
- 144:	55                   	push   %ebp
- 145:	89 e5                	mov    %esp,%ebp
- 147:	57                   	push   %edi
- 148:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 14b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 14e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 151:	89 d7                	mov    %edx,%edi
- 153:	fc                   	cld    
- 154:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 156:	89 d0                	mov    %edx,%eax
- 158:	5f                   	pop    %edi
- 159:	5d                   	pop    %ebp
- 15a:	c3                   	ret    
- 15b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 15f:	90                   	nop
-
-00000160 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 160:	f3 0f 1e fb          	endbr32 
- 164:	55                   	push   %ebp
- 165:	89 e5                	mov    %esp,%ebp
- 167:	8b 45 08             	mov    0x8(%ebp),%eax
- 16a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 16e:	0f b6 10             	movzbl (%eax),%edx
- 171:	84 d2                	test   %dl,%dl
- 173:	75 16                	jne    18b <strchr+0x2b>
- 175:	eb 21                	jmp    198 <strchr+0x38>
- 177:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 17e:	66 90                	xchg   %ax,%ax
- 180:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 184:	83 c0 01             	add    $0x1,%eax
- 187:	84 d2                	test   %dl,%dl
- 189:	74 0d                	je     198 <strchr+0x38>
-    if(*s == c)
- 18b:	38 d1                	cmp    %dl,%cl
- 18d:	75 f1                	jne    180 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 18f:	5d                   	pop    %ebp
- 190:	c3                   	ret    
- 191:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 198:	31 c0                	xor    %eax,%eax
-}
- 19a:	5d                   	pop    %ebp
- 19b:	c3                   	ret    
- 19c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000001a0 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 1a0:	f3 0f 1e fb          	endbr32 
- 1a4:	55                   	push   %ebp
- 1a5:	89 e5                	mov    %esp,%ebp
- 1a7:	57                   	push   %edi
- 1a8:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 1a9:	31 f6                	xor    %esi,%esi
-{
- 1ab:	53                   	push   %ebx
- 1ac:	89 f3                	mov    %esi,%ebx
- 1ae:	83 ec 1c             	sub    $0x1c,%esp
- 1b1:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 1b4:	eb 33                	jmp    1e9 <gets+0x49>
- 1b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1bd:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 1c0:	83 ec 04             	sub    $0x4,%esp
- 1c3:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 1c6:	6a 01                	push   $0x1
- 1c8:	50                   	push   %eax
- 1c9:	6a 00                	push   $0x0
- 1cb:	e8 2b 01 00 00       	call   2fb <read>
-    if(cc < 1)
- 1d0:	83 c4 10             	add    $0x10,%esp
- 1d3:	85 c0                	test   %eax,%eax
- 1d5:	7e 1c                	jle    1f3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 1d7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 1db:	83 c7 01             	add    $0x1,%edi
- 1de:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 1e1:	3c 0a                	cmp    $0xa,%al
- 1e3:	74 23                	je     208 <gets+0x68>
- 1e5:	3c 0d                	cmp    $0xd,%al
- 1e7:	74 1f                	je     208 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 1e9:	83 c3 01             	add    $0x1,%ebx
- 1ec:	89 fe                	mov    %edi,%esi
- 1ee:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 1f1:	7c cd                	jl     1c0 <gets+0x20>
- 1f3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 1f5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 1f8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1fe:	5b                   	pop    %ebx
- 1ff:	5e                   	pop    %esi
- 200:	5f                   	pop    %edi
- 201:	5d                   	pop    %ebp
- 202:	c3                   	ret    
- 203:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 207:	90                   	nop
- 208:	8b 75 08             	mov    0x8(%ebp),%esi
- 20b:	8b 45 08             	mov    0x8(%ebp),%eax
- 20e:	01 de                	add    %ebx,%esi
- 210:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 212:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 215:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 218:	5b                   	pop    %ebx
- 219:	5e                   	pop    %esi
- 21a:	5f                   	pop    %edi
- 21b:	5d                   	pop    %ebp
- 21c:	c3                   	ret    
- 21d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000220 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 220:	f3 0f 1e fb          	endbr32 
- 224:	55                   	push   %ebp
- 225:	89 e5                	mov    %esp,%ebp
- 227:	56                   	push   %esi
- 228:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 229:	83 ec 08             	sub    $0x8,%esp
- 22c:	6a 00                	push   $0x0
- 22e:	ff 75 08             	pushl  0x8(%ebp)
- 231:	e8 ed 00 00 00       	call   323 <open>
-  if(fd < 0)
- 236:	83 c4 10             	add    $0x10,%esp
- 239:	85 c0                	test   %eax,%eax
- 23b:	78 2b                	js     268 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 23d:	83 ec 08             	sub    $0x8,%esp
- 240:	ff 75 0c             	pushl  0xc(%ebp)
- 243:	89 c3                	mov    %eax,%ebx
- 245:	50                   	push   %eax
- 246:	e8 f0 00 00 00       	call   33b <fstat>
-  close(fd);
- 24b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 24e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 250:	e8 b6 00 00 00       	call   30b <close>
-  return r;
- 255:	83 c4 10             	add    $0x10,%esp
-}
- 258:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 25b:	89 f0                	mov    %esi,%eax
- 25d:	5b                   	pop    %ebx
- 25e:	5e                   	pop    %esi
- 25f:	5d                   	pop    %ebp
- 260:	c3                   	ret    
- 261:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 268:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 26d:	eb e9                	jmp    258 <stat+0x38>
- 26f:	90                   	nop
-
-00000270 <atoi>:
-
-int
-atoi(const char *s)
-{
- 270:	f3 0f 1e fb          	endbr32 
- 274:	55                   	push   %ebp
- 275:	89 e5                	mov    %esp,%ebp
- 277:	53                   	push   %ebx
- 278:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 27b:	0f be 02             	movsbl (%edx),%eax
- 27e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 281:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 284:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 289:	77 1a                	ja     2a5 <atoi+0x35>
- 28b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 28f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 290:	83 c2 01             	add    $0x1,%edx
- 293:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 296:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 29a:	0f be 02             	movsbl (%edx),%eax
- 29d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 2a0:	80 fb 09             	cmp    $0x9,%bl
- 2a3:	76 eb                	jbe    290 <atoi+0x20>
-  return n;
-}
- 2a5:	89 c8                	mov    %ecx,%eax
- 2a7:	5b                   	pop    %ebx
- 2a8:	5d                   	pop    %ebp
- 2a9:	c3                   	ret    
- 2aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-000002b0 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 2b0:	f3 0f 1e fb          	endbr32 
- 2b4:	55                   	push   %ebp
- 2b5:	89 e5                	mov    %esp,%ebp
- 2b7:	57                   	push   %edi
- 2b8:	8b 45 10             	mov    0x10(%ebp),%eax
- 2bb:	8b 55 08             	mov    0x8(%ebp),%edx
- 2be:	56                   	push   %esi
- 2bf:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 2c2:	85 c0                	test   %eax,%eax
- 2c4:	7e 0f                	jle    2d5 <memmove+0x25>
- 2c6:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 2c8:	89 d7                	mov    %edx,%edi
- 2ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 2d0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 2d1:	39 f8                	cmp    %edi,%eax
- 2d3:	75 fb                	jne    2d0 <memmove+0x20>
-  return vdst;
-}
- 2d5:	5e                   	pop    %esi
- 2d6:	89 d0                	mov    %edx,%eax
- 2d8:	5f                   	pop    %edi
- 2d9:	5d                   	pop    %ebp
- 2da:	c3                   	ret    
-
-000002db <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 2db:	b8 01 00 00 00       	mov    $0x1,%eax
- 2e0:	cd 40                	int    $0x40
- 2e2:	c3                   	ret    
-
-000002e3 <exit>:
-SYSCALL(exit)
- 2e3:	b8 02 00 00 00       	mov    $0x2,%eax
- 2e8:	cd 40                	int    $0x40
- 2ea:	c3                   	ret    
-
-000002eb <wait>:
-SYSCALL(wait)
- 2eb:	b8 03 00 00 00       	mov    $0x3,%eax
- 2f0:	cd 40                	int    $0x40
- 2f2:	c3                   	ret    
-
-000002f3 <pipe>:
-SYSCALL(pipe)
- 2f3:	b8 04 00 00 00       	mov    $0x4,%eax
- 2f8:	cd 40                	int    $0x40
- 2fa:	c3                   	ret    
-
-000002fb <read>:
-SYSCALL(read)
- 2fb:	b8 05 00 00 00       	mov    $0x5,%eax
- 300:	cd 40                	int    $0x40
- 302:	c3                   	ret    
-
-00000303 <write>:
-SYSCALL(write)
- 303:	b8 10 00 00 00       	mov    $0x10,%eax
- 308:	cd 40                	int    $0x40
- 30a:	c3                   	ret    
-
-0000030b <close>:
-SYSCALL(close)
- 30b:	b8 15 00 00 00       	mov    $0x15,%eax
- 310:	cd 40                	int    $0x40
- 312:	c3                   	ret    
-
-00000313 <kill>:
-SYSCALL(kill)
- 313:	b8 06 00 00 00       	mov    $0x6,%eax
- 318:	cd 40                	int    $0x40
- 31a:	c3                   	ret    
-
-0000031b <exec>:
-SYSCALL(exec)
- 31b:	b8 07 00 00 00       	mov    $0x7,%eax
- 320:	cd 40                	int    $0x40
- 322:	c3                   	ret    
-
-00000323 <open>:
-SYSCALL(open)
- 323:	b8 0f 00 00 00       	mov    $0xf,%eax
- 328:	cd 40                	int    $0x40
- 32a:	c3                   	ret    
-
-0000032b <mknod>:
-SYSCALL(mknod)
- 32b:	b8 11 00 00 00       	mov    $0x11,%eax
- 330:	cd 40                	int    $0x40
- 332:	c3                   	ret    
-
-00000333 <unlink>:
-SYSCALL(unlink)
- 333:	b8 12 00 00 00       	mov    $0x12,%eax
- 338:	cd 40                	int    $0x40
- 33a:	c3                   	ret    
-
-0000033b <fstat>:
-SYSCALL(fstat)
- 33b:	b8 08 00 00 00       	mov    $0x8,%eax
- 340:	cd 40                	int    $0x40
- 342:	c3                   	ret    
-
-00000343 <link>:
-SYSCALL(link)
- 343:	b8 13 00 00 00       	mov    $0x13,%eax
- 348:	cd 40                	int    $0x40
- 34a:	c3                   	ret    
-
-0000034b <mkdir>:
-SYSCALL(mkdir)
- 34b:	b8 14 00 00 00       	mov    $0x14,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <chdir>:
-SYSCALL(chdir)
- 353:	b8 09 00 00 00       	mov    $0x9,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <dup>:
-SYSCALL(dup)
- 35b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <getpid>:
-SYSCALL(getpid)
- 363:	b8 0b 00 00 00       	mov    $0xb,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <sbrk>:
-SYSCALL(sbrk)
- 36b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <sleep>:
-SYSCALL(sleep)
- 373:	b8 0d 00 00 00       	mov    $0xd,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <uptime>:
-SYSCALL(uptime)
- 37b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <getParentID>:
-SYSCALL(getParentID)
- 383:	b8 16 00 00 00       	mov    $0x16,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <getChildren>:
-SYSCALL(getChildren)
- 38b:	b8 17 00 00 00       	mov    $0x17,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 393:	b8 18 00 00 00       	mov    $0x18,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <setPriority>:
-SYSCALL(setPriority)
- 39b:	b8 19 00 00 00       	mov    $0x19,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
-
-000003a3 <changePolicy>:
-SYSCALL(changePolicy)
- 3a3:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 3a8:	cd 40                	int    $0x40
- 3aa:	c3                   	ret    
-
-000003ab <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 3ab:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
-
-000003b3 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 3b3:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 3b8:	cd 40                	int    $0x40
- 3ba:	c3                   	ret    
-
-000003bb <getCBT>:
-SYSCALL(getCBT)
- 3bb:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 3c0:	cd 40                	int    $0x40
- 3c2:	c3                   	ret    
-
-000003c3 <customWait>:
-SYSCALL(customWait)
- 3c3:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 3c8:	cd 40                	int    $0x40
- 3ca:	c3                   	ret    
-
-000003cb <setQueue>:
-SYSCALL(setQueue)
- 3cb:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 3d0:	cd 40                	int    $0x40
- 3d2:	c3                   	ret    
-
-000003d3 <getBurstTime>:
-SYSCALL(getBurstTime)
- 3d3:	b8 20 00 00 00       	mov    $0x20,%eax
- 3d8:	cd 40                	int    $0x40
- 3da:	c3                   	ret    
-
-000003db <getCreationTime>:
- 3db:	b8 21 00 00 00       	mov    $0x21,%eax
- 3e0:	cd 40                	int    $0x40
- 3e2:	c3                   	ret    
- 3e3:	66 90                	xchg   %ax,%ax
- 3e5:	66 90                	xchg   %ax,%ax
- 3e7:	66 90                	xchg   %ax,%ax
- 3e9:	66 90                	xchg   %ax,%ax
- 3eb:	66 90                	xchg   %ax,%ax
- 3ed:	66 90                	xchg   %ax,%ax
- 3ef:	90                   	nop
-
-000003f0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 3f0:	55                   	push   %ebp
- 3f1:	89 e5                	mov    %esp,%ebp
- 3f3:	57                   	push   %edi
- 3f4:	56                   	push   %esi
- 3f5:	53                   	push   %ebx
- 3f6:	83 ec 3c             	sub    $0x3c,%esp
- 3f9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 3fc:	89 d1                	mov    %edx,%ecx
-{
- 3fe:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 401:	85 d2                	test   %edx,%edx
- 403:	0f 89 7f 00 00 00    	jns    488 <printint+0x98>
- 409:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 40d:	74 79                	je     488 <printint+0x98>
-    neg = 1;
- 40f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 416:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 418:	31 db                	xor    %ebx,%ebx
- 41a:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 41d:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 420:	89 c8                	mov    %ecx,%eax
- 422:	31 d2                	xor    %edx,%edx
- 424:	89 cf                	mov    %ecx,%edi
- 426:	f7 75 c4             	divl   -0x3c(%ebp)
- 429:	0f b6 92 18 08 00 00 	movzbl 0x818(%edx),%edx
- 430:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 433:	89 d8                	mov    %ebx,%eax
- 435:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 438:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 43b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 43e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 441:	76 dd                	jbe    420 <printint+0x30>
-  if(neg)
- 443:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 446:	85 c9                	test   %ecx,%ecx
- 448:	74 0c                	je     456 <printint+0x66>
-    buf[i++] = '-';
- 44a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 44f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 451:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 456:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 459:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 45d:	eb 07                	jmp    466 <printint+0x76>
- 45f:	90                   	nop
- 460:	0f b6 13             	movzbl (%ebx),%edx
- 463:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 466:	83 ec 04             	sub    $0x4,%esp
- 469:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 46c:	6a 01                	push   $0x1
- 46e:	56                   	push   %esi
- 46f:	57                   	push   %edi
- 470:	e8 8e fe ff ff       	call   303 <write>
-  while(--i >= 0)
- 475:	83 c4 10             	add    $0x10,%esp
- 478:	39 de                	cmp    %ebx,%esi
- 47a:	75 e4                	jne    460 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 47c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 47f:	5b                   	pop    %ebx
- 480:	5e                   	pop    %esi
- 481:	5f                   	pop    %edi
- 482:	5d                   	pop    %ebp
- 483:	c3                   	ret    
- 484:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 488:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 48f:	eb 87                	jmp    418 <printint+0x28>
- 491:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 498:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 49f:	90                   	nop
-
-000004a0 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 4a0:	f3 0f 1e fb          	endbr32 
- 4a4:	55                   	push   %ebp
- 4a5:	89 e5                	mov    %esp,%ebp
- 4a7:	57                   	push   %edi
- 4a8:	56                   	push   %esi
- 4a9:	53                   	push   %ebx
- 4aa:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 4ad:	8b 75 0c             	mov    0xc(%ebp),%esi
- 4b0:	0f b6 1e             	movzbl (%esi),%ebx
- 4b3:	84 db                	test   %bl,%bl
- 4b5:	0f 84 b4 00 00 00    	je     56f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 4bb:	8d 45 10             	lea    0x10(%ebp),%eax
- 4be:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 4c1:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 4c4:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 4c6:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 4c9:	eb 33                	jmp    4fe <printf+0x5e>
- 4cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 4cf:	90                   	nop
- 4d0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 4d3:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 4d8:	83 f8 25             	cmp    $0x25,%eax
- 4db:	74 17                	je     4f4 <printf+0x54>
-  write(fd, &c, 1);
- 4dd:	83 ec 04             	sub    $0x4,%esp
- 4e0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 4e3:	6a 01                	push   $0x1
- 4e5:	57                   	push   %edi
- 4e6:	ff 75 08             	pushl  0x8(%ebp)
- 4e9:	e8 15 fe ff ff       	call   303 <write>
- 4ee:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 4f1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 4f4:	0f b6 1e             	movzbl (%esi),%ebx
- 4f7:	83 c6 01             	add    $0x1,%esi
- 4fa:	84 db                	test   %bl,%bl
- 4fc:	74 71                	je     56f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 4fe:	0f be cb             	movsbl %bl,%ecx
- 501:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 504:	85 d2                	test   %edx,%edx
- 506:	74 c8                	je     4d0 <printf+0x30>
-      }
-    } else if(state == '%'){
- 508:	83 fa 25             	cmp    $0x25,%edx
- 50b:	75 e7                	jne    4f4 <printf+0x54>
-      if(c == 'd'){
- 50d:	83 f8 64             	cmp    $0x64,%eax
- 510:	0f 84 9a 00 00 00    	je     5b0 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 516:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 51c:	83 f9 70             	cmp    $0x70,%ecx
- 51f:	74 5f                	je     580 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 521:	83 f8 73             	cmp    $0x73,%eax
- 524:	0f 84 d6 00 00 00    	je     600 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 52a:	83 f8 63             	cmp    $0x63,%eax
- 52d:	0f 84 8d 00 00 00    	je     5c0 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 533:	83 f8 25             	cmp    $0x25,%eax
- 536:	0f 84 b4 00 00 00    	je     5f0 <printf+0x150>
-  write(fd, &c, 1);
- 53c:	83 ec 04             	sub    $0x4,%esp
- 53f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 543:	6a 01                	push   $0x1
- 545:	57                   	push   %edi
- 546:	ff 75 08             	pushl  0x8(%ebp)
- 549:	e8 b5 fd ff ff       	call   303 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 54e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 551:	83 c4 0c             	add    $0xc,%esp
- 554:	6a 01                	push   $0x1
- 556:	83 c6 01             	add    $0x1,%esi
- 559:	57                   	push   %edi
- 55a:	ff 75 08             	pushl  0x8(%ebp)
- 55d:	e8 a1 fd ff ff       	call   303 <write>
-  for(i = 0; fmt[i]; i++){
- 562:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 566:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 569:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 56b:	84 db                	test   %bl,%bl
- 56d:	75 8f                	jne    4fe <printf+0x5e>
-    }
-  }
-}
- 56f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 572:	5b                   	pop    %ebx
- 573:	5e                   	pop    %esi
- 574:	5f                   	pop    %edi
- 575:	5d                   	pop    %ebp
- 576:	c3                   	ret    
- 577:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 57e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 580:	83 ec 0c             	sub    $0xc,%esp
- 583:	b9 10 00 00 00       	mov    $0x10,%ecx
- 588:	6a 00                	push   $0x0
- 58a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 58d:	8b 45 08             	mov    0x8(%ebp),%eax
- 590:	8b 13                	mov    (%ebx),%edx
- 592:	e8 59 fe ff ff       	call   3f0 <printint>
-        ap++;
- 597:	89 d8                	mov    %ebx,%eax
- 599:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 59c:	31 d2                	xor    %edx,%edx
-        ap++;
- 59e:	83 c0 04             	add    $0x4,%eax
- 5a1:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 5a4:	e9 4b ff ff ff       	jmp    4f4 <printf+0x54>
- 5a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 5b0:	83 ec 0c             	sub    $0xc,%esp
- 5b3:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 5b8:	6a 01                	push   $0x1
- 5ba:	eb ce                	jmp    58a <printf+0xea>
- 5bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 5c0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 5c3:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 5c6:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 5c8:	6a 01                	push   $0x1
-        ap++;
- 5ca:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 5cd:	57                   	push   %edi
- 5ce:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 5d1:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 5d4:	e8 2a fd ff ff       	call   303 <write>
-        ap++;
- 5d9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 5dc:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 5df:	31 d2                	xor    %edx,%edx
- 5e1:	e9 0e ff ff ff       	jmp    4f4 <printf+0x54>
- 5e6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5ed:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 5f0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5f3:	83 ec 04             	sub    $0x4,%esp
- 5f6:	e9 59 ff ff ff       	jmp    554 <printf+0xb4>
- 5fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 5ff:	90                   	nop
-        s = (char*)*ap;
- 600:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 603:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 605:	83 c0 04             	add    $0x4,%eax
- 608:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 60b:	85 db                	test   %ebx,%ebx
- 60d:	74 17                	je     626 <printf+0x186>
-        while(*s != 0){
- 60f:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 612:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 614:	84 c0                	test   %al,%al
- 616:	0f 84 d8 fe ff ff    	je     4f4 <printf+0x54>
- 61c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 61f:	89 de                	mov    %ebx,%esi
- 621:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 624:	eb 1a                	jmp    640 <printf+0x1a0>
-          s = "(null)";
- 626:	bb 11 08 00 00       	mov    $0x811,%ebx
-        while(*s != 0){
- 62b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 62e:	b8 28 00 00 00       	mov    $0x28,%eax
- 633:	89 de                	mov    %ebx,%esi
- 635:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 638:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 63f:	90                   	nop
-  write(fd, &c, 1);
- 640:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 643:	83 c6 01             	add    $0x1,%esi
- 646:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 649:	6a 01                	push   $0x1
- 64b:	57                   	push   %edi
- 64c:	53                   	push   %ebx
- 64d:	e8 b1 fc ff ff       	call   303 <write>
-        while(*s != 0){
- 652:	0f b6 06             	movzbl (%esi),%eax
- 655:	83 c4 10             	add    $0x10,%esp
- 658:	84 c0                	test   %al,%al
- 65a:	75 e4                	jne    640 <printf+0x1a0>
- 65c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 65f:	31 d2                	xor    %edx,%edx
- 661:	e9 8e fe ff ff       	jmp    4f4 <printf+0x54>
- 666:	66 90                	xchg   %ax,%ax
- 668:	66 90                	xchg   %ax,%ax
- 66a:	66 90                	xchg   %ax,%ax
- 66c:	66 90                	xchg   %ax,%ax
- 66e:	66 90                	xchg   %ax,%ax
-
-00000670 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 670:	f3 0f 1e fb          	endbr32 
- 674:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 675:	a1 c8 0a 00 00       	mov    0xac8,%eax
-{
- 67a:	89 e5                	mov    %esp,%ebp
- 67c:	57                   	push   %edi
- 67d:	56                   	push   %esi
- 67e:	53                   	push   %ebx
- 67f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 682:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 684:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 687:	39 c8                	cmp    %ecx,%eax
- 689:	73 15                	jae    6a0 <free+0x30>
- 68b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 68f:	90                   	nop
- 690:	39 d1                	cmp    %edx,%ecx
- 692:	72 14                	jb     6a8 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 694:	39 d0                	cmp    %edx,%eax
- 696:	73 10                	jae    6a8 <free+0x38>
-{
- 698:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 69a:	8b 10                	mov    (%eax),%edx
- 69c:	39 c8                	cmp    %ecx,%eax
- 69e:	72 f0                	jb     690 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 6a0:	39 d0                	cmp    %edx,%eax
- 6a2:	72 f4                	jb     698 <free+0x28>
- 6a4:	39 d1                	cmp    %edx,%ecx
- 6a6:	73 f0                	jae    698 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 6a8:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 6ab:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 6ae:	39 fa                	cmp    %edi,%edx
- 6b0:	74 1e                	je     6d0 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 6b2:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 6b5:	8b 50 04             	mov    0x4(%eax),%edx
- 6b8:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6bb:	39 f1                	cmp    %esi,%ecx
- 6bd:	74 28                	je     6e7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 6bf:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 6c1:	5b                   	pop    %ebx
-  freep = p;
- 6c2:	a3 c8 0a 00 00       	mov    %eax,0xac8
-}
- 6c7:	5e                   	pop    %esi
- 6c8:	5f                   	pop    %edi
- 6c9:	5d                   	pop    %ebp
- 6ca:	c3                   	ret    
- 6cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 6cf:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 6d0:	03 72 04             	add    0x4(%edx),%esi
- 6d3:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 6d6:	8b 10                	mov    (%eax),%edx
- 6d8:	8b 12                	mov    (%edx),%edx
- 6da:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 6dd:	8b 50 04             	mov    0x4(%eax),%edx
- 6e0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6e3:	39 f1                	cmp    %esi,%ecx
- 6e5:	75 d8                	jne    6bf <free+0x4f>
-    p->s.size += bp->s.size;
- 6e7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 6ea:	a3 c8 0a 00 00       	mov    %eax,0xac8
-    p->s.size += bp->s.size;
- 6ef:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 6f2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 6f5:	89 10                	mov    %edx,(%eax)
-}
- 6f7:	5b                   	pop    %ebx
- 6f8:	5e                   	pop    %esi
- 6f9:	5f                   	pop    %edi
- 6fa:	5d                   	pop    %ebp
- 6fb:	c3                   	ret    
- 6fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000700 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 700:	f3 0f 1e fb          	endbr32 
- 704:	55                   	push   %ebp
- 705:	89 e5                	mov    %esp,%ebp
- 707:	57                   	push   %edi
- 708:	56                   	push   %esi
- 709:	53                   	push   %ebx
- 70a:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 70d:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 710:	8b 3d c8 0a 00 00    	mov    0xac8,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 716:	8d 70 07             	lea    0x7(%eax),%esi
- 719:	c1 ee 03             	shr    $0x3,%esi
- 71c:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 71f:	85 ff                	test   %edi,%edi
- 721:	0f 84 a9 00 00 00    	je     7d0 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 727:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 729:	8b 48 04             	mov    0x4(%eax),%ecx
- 72c:	39 f1                	cmp    %esi,%ecx
- 72e:	73 6d                	jae    79d <malloc+0x9d>
- 730:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 736:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 73b:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 73e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 745:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 748:	eb 17                	jmp    761 <malloc+0x61>
- 74a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 750:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 752:	8b 4a 04             	mov    0x4(%edx),%ecx
- 755:	39 f1                	cmp    %esi,%ecx
- 757:	73 4f                	jae    7a8 <malloc+0xa8>
- 759:	8b 3d c8 0a 00 00    	mov    0xac8,%edi
- 75f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 761:	39 c7                	cmp    %eax,%edi
- 763:	75 eb                	jne    750 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 765:	83 ec 0c             	sub    $0xc,%esp
- 768:	ff 75 e4             	pushl  -0x1c(%ebp)
- 76b:	e8 fb fb ff ff       	call   36b <sbrk>
-  if(p == (char*)-1)
- 770:	83 c4 10             	add    $0x10,%esp
- 773:	83 f8 ff             	cmp    $0xffffffff,%eax
- 776:	74 1b                	je     793 <malloc+0x93>
-  hp->s.size = nu;
- 778:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 77b:	83 ec 0c             	sub    $0xc,%esp
- 77e:	83 c0 08             	add    $0x8,%eax
- 781:	50                   	push   %eax
- 782:	e8 e9 fe ff ff       	call   670 <free>
-  return freep;
- 787:	a1 c8 0a 00 00       	mov    0xac8,%eax
-      if((p = morecore(nunits)) == 0)
- 78c:	83 c4 10             	add    $0x10,%esp
- 78f:	85 c0                	test   %eax,%eax
- 791:	75 bd                	jne    750 <malloc+0x50>
-        return 0;
-  }
-}
- 793:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 796:	31 c0                	xor    %eax,%eax
-}
- 798:	5b                   	pop    %ebx
- 799:	5e                   	pop    %esi
- 79a:	5f                   	pop    %edi
- 79b:	5d                   	pop    %ebp
- 79c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 79d:	89 c2                	mov    %eax,%edx
- 79f:	89 f8                	mov    %edi,%eax
- 7a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 7a8:	39 ce                	cmp    %ecx,%esi
- 7aa:	74 54                	je     800 <malloc+0x100>
-        p->s.size -= nunits;
- 7ac:	29 f1                	sub    %esi,%ecx
- 7ae:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 7b1:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 7b4:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 7b7:	a3 c8 0a 00 00       	mov    %eax,0xac8
-}
- 7bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 7bf:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 7c2:	5b                   	pop    %ebx
- 7c3:	5e                   	pop    %esi
- 7c4:	5f                   	pop    %edi
- 7c5:	5d                   	pop    %ebp
- 7c6:	c3                   	ret    
- 7c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 7ce:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 7d0:	c7 05 c8 0a 00 00 cc 	movl   $0xacc,0xac8
- 7d7:	0a 00 00 
-    base.s.size = 0;
- 7da:	bf cc 0a 00 00       	mov    $0xacc,%edi
-    base.s.ptr = freep = prevp = &base;
- 7df:	c7 05 cc 0a 00 00 cc 	movl   $0xacc,0xacc
- 7e6:	0a 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7e9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 7eb:	c7 05 d0 0a 00 00 00 	movl   $0x0,0xad0
- 7f2:	00 00 00 
-    if(p->s.size >= nunits){
- 7f5:	e9 36 ff ff ff       	jmp    730 <malloc+0x30>
- 7fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 800:	8b 0a                	mov    (%edx),%ecx
- 802:	89 08                	mov    %ecx,(%eax)
- 804:	eb b1                	jmp    7b7 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/echo.c b/xv6-public/Operating-System-Project/echo.c
deleted file mode 100644
index 806dee0..0000000
--- a/xv6-public/Operating-System-Project/echo.c
+++ /dev/null
@@ -1,13 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char *argv[])
-{
-  int i;
-
-  for(i = 1; i < argc; i++)
-    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
-  exit();
-}
diff --git a/xv6-public/Operating-System-Project/echo.d b/xv6-public/Operating-System-Project/echo.d
deleted file mode 100644
index 16a6098..0000000
--- a/xv6-public/Operating-System-Project/echo.d
+++ /dev/null
@@ -1 +0,0 @@
-echo.o: echo.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/echo.o b/xv6-public/Operating-System-Project/echo.o
deleted file mode 100644
index 1083e68..0000000
Binary files a/xv6-public/Operating-System-Project/echo.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/echo.sym b/xv6-public/Operating-System-Project/echo.sym
deleted file mode 100644
index a4b5327..0000000
--- a/xv6-public/Operating-System-Project/echo.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-00000808 .rodata
-0000082c .eh_frame
-00000ac8 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 echo.c
-00000000 ulib.c
-00000000 printf.c
-000003f0 printint
-00000818 digits.1109
-00000000 umalloc.c
-00000ac8 freep
-00000acc base
-00000080 strcpy
-0000038b getChildren
-000004a0 printf
-000002b0 memmove
-0000032b mknod
-000001a0 gets
-00000363 getpid
-000003c3 customWait
-000003bb getCBT
-00000700 malloc
-00000373 sleep
-000002f3 pipe
-000003a3 changePolicy
-00000303 write
-0000033b fstat
-00000313 kill
-00000353 chdir
-000003cb setQueue
-0000031b exec
-000002eb wait
-000002fb read
-000003d3 getBurstTime
-00000333 unlink
-000002db fork
-000003ab getTurnAroundTime
-0000036b sbrk
-0000037b uptime
-00000ac8 __bss_start
-00000140 memset
-00000000 main
-000000b0 strcmp
-0000035b dup
-00000393 getSyscallCounter
-00000383 getParentID
-00000220 stat
-00000ac8 _edata
-00000ad4 _end
-00000343 link
-000002e3 exit
-0000039b setPriority
-00000270 atoi
-000003db getCreationTime
-00000100 strlen
-00000323 open
-00000160 strchr
-0000034b mkdir
-0000030b close
-000003b3 getWaitingTime
-00000670 free
diff --git a/xv6-public/Operating-System-Project/elf.h b/xv6-public/Operating-System-Project/elf.h
deleted file mode 100644
index d16c967..0000000
--- a/xv6-public/Operating-System-Project/elf.h
+++ /dev/null
@@ -1,42 +0,0 @@
-// Format of an ELF executable file
-
-#define ELF_MAGIC 0x464C457FU  // "\x7FELF" in little endian
-
-// File header
-struct elfhdr {
-  uint magic;  // must equal ELF_MAGIC
-  uchar elf[12];
-  ushort type;
-  ushort machine;
-  uint version;
-  uint entry;
-  uint phoff;
-  uint shoff;
-  uint flags;
-  ushort ehsize;
-  ushort phentsize;
-  ushort phnum;
-  ushort shentsize;
-  ushort shnum;
-  ushort shstrndx;
-};
-
-// Program section header
-struct proghdr {
-  uint type;
-  uint off;
-  uint vaddr;
-  uint paddr;
-  uint filesz;
-  uint memsz;
-  uint flags;
-  uint align;
-};
-
-// Values for Proghdr type
-#define ELF_PROG_LOAD           1
-
-// Flag bits for Proghdr flags
-#define ELF_PROG_FLAG_EXEC      1
-#define ELF_PROG_FLAG_WRITE     2
-#define ELF_PROG_FLAG_READ      4
diff --git a/xv6-public/Operating-System-Project/entry.S b/xv6-public/Operating-System-Project/entry.S
deleted file mode 100644
index bc79bab..0000000
--- a/xv6-public/Operating-System-Project/entry.S
+++ /dev/null
@@ -1,68 +0,0 @@
-# The xv6 kernel starts executing in this file. This file is linked with
-# the kernel C code, so it can refer to kernel symbols such as main().
-# The boot block (bootasm.S and bootmain.c) jumps to entry below.
-        
-# Multiboot header, for multiboot boot loaders like GNU Grub.
-# http://www.gnu.org/software/grub/manual/multiboot/multiboot.html
-#
-# Using GRUB 2, you can boot xv6 from a file stored in a
-# Linux file system by copying kernel or kernelmemfs to /boot
-# and then adding this menu entry:
-#
-# menuentry "xv6" {
-# 	insmod ext2
-# 	set root='(hd0,msdos1)'
-# 	set kernel='/boot/kernel'
-# 	echo "Loading ${kernel}..."
-# 	multiboot ${kernel} ${kernel}
-# 	boot
-# }
-
-#include "asm.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "param.h"
-
-# Multiboot header.  Data to direct multiboot loader.
-.p2align 2
-.text
-.globl multiboot_header
-multiboot_header:
-  #define magic 0x1badb002
-  #define flags 0
-  .long magic
-  .long flags
-  .long (-magic-flags)
-
-# By convention, the _start symbol specifies the ELF entry point.
-# Since we haven't set up virtual memory yet, our entry point is
-# the physical address of 'entry'.
-.globl _start
-_start = V2P_WO(entry)
-
-# Entering xv6 on boot processor, with paging off.
-.globl entry
-entry:
-  # Turn on page size extension for 4Mbyte pages
-  movl    %cr4, %eax
-  orl     $(CR4_PSE), %eax
-  movl    %eax, %cr4
-  # Set page directory
-  movl    $(V2P_WO(entrypgdir)), %eax
-  movl    %eax, %cr3
-  # Turn on paging.
-  movl    %cr0, %eax
-  orl     $(CR0_PG|CR0_WP), %eax
-  movl    %eax, %cr0
-
-  # Set up the stack pointer.
-  movl $(stack + KSTACKSIZE), %esp
-
-  # Jump to main(), and switch to executing at
-  # high addresses. The indirect call is needed because
-  # the assembler produces a PC-relative instruction
-  # for a direct jump.
-  mov $main, %eax
-  jmp *%eax
-
-.comm stack, KSTACKSIZE
diff --git a/xv6-public/Operating-System-Project/entry.o b/xv6-public/Operating-System-Project/entry.o
deleted file mode 100644
index 5e2b770..0000000
Binary files a/xv6-public/Operating-System-Project/entry.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/entryother b/xv6-public/Operating-System-Project/entryother
deleted file mode 100644
index a7673de..0000000
Binary files a/xv6-public/Operating-System-Project/entryother and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/entryother.S b/xv6-public/Operating-System-Project/entryother.S
deleted file mode 100644
index a3b6dc2..0000000
--- a/xv6-public/Operating-System-Project/entryother.S
+++ /dev/null
@@ -1,93 +0,0 @@
-#include "asm.h"
-#include "memlayout.h"
-#include "mmu.h"
-	
-# Each non-boot CPU ("AP") is started up in response to a STARTUP
-# IPI from the boot CPU.  Section B.4.2 of the Multi-Processor
-# Specification says that the AP will start in real mode with CS:IP
-# set to XY00:0000, where XY is an 8-bit value sent with the
-# STARTUP. Thus this code must start at a 4096-byte boundary.
-#
-# Because this code sets DS to zero, it must sit
-# at an address in the low 2^16 bytes.
-#
-# Startothers (in main.c) sends the STARTUPs one at a time.
-# It copies this code (start) at 0x7000.  It puts the address of
-# a newly allocated per-core stack in start-4,the address of the
-# place to jump to (mpenter) in start-8, and the physical address
-# of entrypgdir in start-12.
-#
-# This code combines elements of bootasm.S and entry.S.
-
-.code16           
-.globl start
-start:
-  cli            
-
-  # Zero data segment registers DS, ES, and SS.
-  xorw    %ax,%ax
-  movw    %ax,%ds
-  movw    %ax,%es
-  movw    %ax,%ss
-
-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
-  # virtual addresses map directly to physical addresses so that the
-  # effective memory map doesn't change during the transition.
-  lgdt    gdtdesc
-  movl    %cr0, %eax
-  orl     $CR0_PE, %eax
-  movl    %eax, %cr0
-
-  # Complete the transition to 32-bit protected mode by using a long jmp
-  # to reload %cs and %eip.  The segment descriptors are set up with no
-  # translation, so that the mapping is still the identity mapping.
-  ljmpl    $(SEG_KCODE<<3), $(start32)
-
-//PAGEBREAK!
-.code32  # Tell assembler to generate 32-bit code now.
-start32:
-  # Set up the protected-mode data segment registers
-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
-  movw    %ax, %ds                # -> DS: Data Segment
-  movw    %ax, %es                # -> ES: Extra Segment
-  movw    %ax, %ss                # -> SS: Stack Segment
-  movw    $0, %ax                 # Zero segments not ready for use
-  movw    %ax, %fs                # -> FS
-  movw    %ax, %gs                # -> GS
-
-  # Turn on page size extension for 4Mbyte pages
-  movl    %cr4, %eax
-  orl     $(CR4_PSE), %eax
-  movl    %eax, %cr4
-  # Use entrypgdir as our initial page table
-  movl    (start-12), %eax
-  movl    %eax, %cr3
-  # Turn on paging.
-  movl    %cr0, %eax
-  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
-  movl    %eax, %cr0
-
-  # Switch to the stack allocated by startothers()
-  movl    (start-4), %esp
-  # Call mpenter()
-  call	 *(start-8)
-
-  movw    $0x8a00, %ax
-  movw    %ax, %dx
-  outw    %ax, %dx
-  movw    $0x8ae0, %ax
-  outw    %ax, %dx
-spin:
-  jmp     spin
-
-.p2align 2
-gdt:
-  SEG_NULLASM
-  SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
-  SEG_ASM(STA_W, 0, 0xffffffff)
-
-
-gdtdesc:
-  .word   (gdtdesc - gdt - 1)
-  .long   gdt
-
diff --git a/xv6-public/Operating-System-Project/entryother.asm b/xv6-public/Operating-System-Project/entryother.asm
deleted file mode 100644
index c845a5d..0000000
--- a/xv6-public/Operating-System-Project/entryother.asm
+++ /dev/null
@@ -1,125 +0,0 @@
-
-bootblockother.o:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00007000 <start>:
-# This code combines elements of bootasm.S and entry.S.
-
-.code16           
-.globl start
-start:
-  cli            
-    7000:	fa                   	cli    
-
-  # Zero data segment registers DS, ES, and SS.
-  xorw    %ax,%ax
-    7001:	31 c0                	xor    %eax,%eax
-  movw    %ax,%ds
-    7003:	8e d8                	mov    %eax,%ds
-  movw    %ax,%es
-    7005:	8e c0                	mov    %eax,%es
-  movw    %ax,%ss
-    7007:	8e d0                	mov    %eax,%ss
-
-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
-  # virtual addresses map directly to physical addresses so that the
-  # effective memory map doesn't change during the transition.
-  lgdt    gdtdesc
-    7009:	0f 01 16             	lgdtl  (%esi)
-    700c:	84 70 0f             	test   %dh,0xf(%eax)
-  movl    %cr0, %eax
-    700f:	20 c0                	and    %al,%al
-  orl     $CR0_PE, %eax
-    7011:	66 83 c8 01          	or     $0x1,%ax
-  movl    %eax, %cr0
-    7015:	0f 22 c0             	mov    %eax,%cr0
-
-  # Complete the transition to 32-bit protected mode by using a long jmp
-  # to reload %cs and %eip.  The segment descriptors are set up with no
-  # translation, so that the mapping is still the identity mapping.
-  ljmpl    $(SEG_KCODE<<3), $(start32)
-    7018:	66 ea 20 70 00 00    	ljmpw  $0x0,$0x7020
-    701e:	08 00                	or     %al,(%eax)
-
-00007020 <start32>:
-
-//PAGEBREAK!
-.code32  # Tell assembler to generate 32-bit code now.
-start32:
-  # Set up the protected-mode data segment registers
-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
-    7020:	66 b8 10 00          	mov    $0x10,%ax
-  movw    %ax, %ds                # -> DS: Data Segment
-    7024:	8e d8                	mov    %eax,%ds
-  movw    %ax, %es                # -> ES: Extra Segment
-    7026:	8e c0                	mov    %eax,%es
-  movw    %ax, %ss                # -> SS: Stack Segment
-    7028:	8e d0                	mov    %eax,%ss
-  movw    $0, %ax                 # Zero segments not ready for use
-    702a:	66 b8 00 00          	mov    $0x0,%ax
-  movw    %ax, %fs                # -> FS
-    702e:	8e e0                	mov    %eax,%fs
-  movw    %ax, %gs                # -> GS
-    7030:	8e e8                	mov    %eax,%gs
-
-  # Turn on page size extension for 4Mbyte pages
-  movl    %cr4, %eax
-    7032:	0f 20 e0             	mov    %cr4,%eax
-  orl     $(CR4_PSE), %eax
-    7035:	83 c8 10             	or     $0x10,%eax
-  movl    %eax, %cr4
-    7038:	0f 22 e0             	mov    %eax,%cr4
-  # Use entrypgdir as our initial page table
-  movl    (start-12), %eax
-    703b:	a1 f4 6f 00 00       	mov    0x6ff4,%eax
-  movl    %eax, %cr3
-    7040:	0f 22 d8             	mov    %eax,%cr3
-  # Turn on paging.
-  movl    %cr0, %eax
-    7043:	0f 20 c0             	mov    %cr0,%eax
-  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
-    7046:	0d 01 00 01 80       	or     $0x80010001,%eax
-  movl    %eax, %cr0
-    704b:	0f 22 c0             	mov    %eax,%cr0
-
-  # Switch to the stack allocated by startothers()
-  movl    (start-4), %esp
-    704e:	8b 25 fc 6f 00 00    	mov    0x6ffc,%esp
-  # Call mpenter()
-  call	 *(start-8)
-    7054:	ff 15 f8 6f 00 00    	call   *0x6ff8
-
-  movw    $0x8a00, %ax
-    705a:	66 b8 00 8a          	mov    $0x8a00,%ax
-  movw    %ax, %dx
-    705e:	66 89 c2             	mov    %ax,%dx
-  outw    %ax, %dx
-    7061:	66 ef                	out    %ax,(%dx)
-  movw    $0x8ae0, %ax
-    7063:	66 b8 e0 8a          	mov    $0x8ae0,%ax
-  outw    %ax, %dx
-    7067:	66 ef                	out    %ax,(%dx)
-
-00007069 <spin>:
-spin:
-  jmp     spin
-    7069:	eb fe                	jmp    7069 <spin>
-    706b:	90                   	nop
-
-0000706c <gdt>:
-	...
-    7074:	ff                   	(bad)  
-    7075:	ff 00                	incl   (%eax)
-    7077:	00 00                	add    %al,(%eax)
-    7079:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
-    7080:	00                   	.byte 0x0
-    7081:	92                   	xchg   %eax,%edx
-    7082:	cf                   	iret   
-	...
-
-00007084 <gdtdesc>:
-    7084:	17                   	pop    %ss
-    7085:	00 6c 70 00          	add    %ch,0x0(%eax,%esi,2)
-	...
diff --git a/xv6-public/Operating-System-Project/entryother.d b/xv6-public/Operating-System-Project/entryother.d
deleted file mode 100644
index a140303..0000000
--- a/xv6-public/Operating-System-Project/entryother.d
+++ /dev/null
@@ -1 +0,0 @@
-entryother.o: entryother.S asm.h memlayout.h mmu.h
diff --git a/xv6-public/Operating-System-Project/entryother.o b/xv6-public/Operating-System-Project/entryother.o
deleted file mode 100644
index 9497a94..0000000
Binary files a/xv6-public/Operating-System-Project/entryother.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/exec.c b/xv6-public/Operating-System-Project/exec.c
deleted file mode 100644
index b40134f..0000000
--- a/xv6-public/Operating-System-Project/exec.c
+++ /dev/null
@@ -1,114 +0,0 @@
-#include "types.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "defs.h"
-#include "x86.h"
-#include "elf.h"
-
-int
-exec(char *path, char **argv)
-{
-  char *s, *last;
-  int i, off;
-  uint argc, sz, sp, ustack[3+MAXARG+1];
-  struct elfhdr elf;
-  struct inode *ip;
-  struct proghdr ph;
-  pde_t *pgdir, *oldpgdir;
-  struct proc *curproc = myproc();
-
-  begin_op();
-
-  if((ip = namei(path)) == 0){
-    end_op();
-    cprintf("exec: fail\n");
-    return -1;
-  }
-  ilock(ip);
-  pgdir = 0;
-
-  // Check ELF header
-  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
-    goto bad;
-  if(elf.magic != ELF_MAGIC)
-    goto bad;
-
-  if((pgdir = setupkvm()) == 0)
-    goto bad;
-
-  // Load program into memory.
-  sz = 0;
-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
-    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
-      goto bad;
-    if(ph.type != ELF_PROG_LOAD)
-      continue;
-    if(ph.memsz < ph.filesz)
-      goto bad;
-    if(ph.vaddr + ph.memsz < ph.vaddr)
-      goto bad;
-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
-      goto bad;
-    if(ph.vaddr % PGSIZE != 0)
-      goto bad;
-    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
-      goto bad;
-  }
-  iunlockput(ip);
-  end_op();
-  ip = 0;
-
-  // Allocate two pages at the next page boundary.
-  // Make the first inaccessible.  Use the second as the user stack.
-  sz = PGROUNDUP(sz);
-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
-    goto bad;
-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
-  sp = sz;
-
-  // Push argument strings, prepare rest of stack in ustack.
-  for(argc = 0; argv[argc]; argc++) {
-    if(argc >= MAXARG)
-      goto bad;
-    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
-    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
-      goto bad;
-    ustack[3+argc] = sp;
-  }
-  ustack[3+argc] = 0;
-
-  ustack[0] = 0xffffffff;  // fake return PC
-  ustack[1] = argc;
-  ustack[2] = sp - (argc+1)*4;  // argv pointer
-
-  sp -= (3+argc+1) * 4;
-  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
-    goto bad;
-
-  // Save program name for debugging.
-  for(last=s=path; *s; s++)
-    if(*s == '/')
-      last = s+1;
-  safestrcpy(curproc->name, last, sizeof(curproc->name));
-
-  // Commit to the user image.
-  oldpgdir = curproc->pgdir;
-  curproc->pgdir = pgdir;
-  curproc->sz = sz;
-  curproc->tf->eip = elf.entry;  // main
-  curproc->tf->esp = sp;
-  switchuvm(curproc);
-  freevm(oldpgdir);
-  return 0;
-
- bad:
-  if(pgdir)
-    freevm(pgdir);
-  if(ip){
-    iunlockput(ip);
-    end_op();
-  }
-  return -1;
-}
diff --git a/xv6-public/Operating-System-Project/exec.d b/xv6-public/Operating-System-Project/exec.d
deleted file mode 100644
index 0400275..0000000
--- a/xv6-public/Operating-System-Project/exec.d
+++ /dev/null
@@ -1,2 +0,0 @@
-exec.o: exec.c /usr/include/stdc-predef.h types.h param.h memlayout.h \
- mmu.h proc.h defs.h x86.h elf.h
diff --git a/xv6-public/Operating-System-Project/exec.o b/xv6-public/Operating-System-Project/exec.o
deleted file mode 100644
index 0798529..0000000
Binary files a/xv6-public/Operating-System-Project/exec.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/fcntl.h b/xv6-public/Operating-System-Project/fcntl.h
deleted file mode 100644
index d565483..0000000
--- a/xv6-public/Operating-System-Project/fcntl.h
+++ /dev/null
@@ -1,4 +0,0 @@
-#define O_RDONLY  0x000
-#define O_WRONLY  0x001
-#define O_RDWR    0x002
-#define O_CREATE  0x200
diff --git a/xv6-public/Operating-System-Project/file.c b/xv6-public/Operating-System-Project/file.c
deleted file mode 100644
index 24b32c2..0000000
--- a/xv6-public/Operating-System-Project/file.c
+++ /dev/null
@@ -1,157 +0,0 @@
-//
-// File descriptors
-//
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "fs.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "file.h"
-
-struct devsw devsw[NDEV];
-struct {
-  struct spinlock lock;
-  struct file file[NFILE];
-} ftable;
-
-void
-fileinit(void)
-{
-  initlock(&ftable.lock, "ftable");
-}
-
-// Allocate a file structure.
-struct file*
-filealloc(void)
-{
-  struct file *f;
-
-  acquire(&ftable.lock);
-  for(f = ftable.file; f < ftable.file + NFILE; f++){
-    if(f->ref == 0){
-      f->ref = 1;
-      release(&ftable.lock);
-      return f;
-    }
-  }
-  release(&ftable.lock);
-  return 0;
-}
-
-// Increment ref count for file f.
-struct file*
-filedup(struct file *f)
-{
-  acquire(&ftable.lock);
-  if(f->ref < 1)
-    panic("filedup");
-  f->ref++;
-  release(&ftable.lock);
-  return f;
-}
-
-// Close file f.  (Decrement ref count, close when reaches 0.)
-void
-fileclose(struct file *f)
-{
-  struct file ff;
-
-  acquire(&ftable.lock);
-  if(f->ref < 1)
-    panic("fileclose");
-  if(--f->ref > 0){
-    release(&ftable.lock);
-    return;
-  }
-  ff = *f;
-  f->ref = 0;
-  f->type = FD_NONE;
-  release(&ftable.lock);
-
-  if(ff.type == FD_PIPE)
-    pipeclose(ff.pipe, ff.writable);
-  else if(ff.type == FD_INODE){
-    begin_op();
-    iput(ff.ip);
-    end_op();
-  }
-}
-
-// Get metadata about file f.
-int
-filestat(struct file *f, struct stat *st)
-{
-  if(f->type == FD_INODE){
-    ilock(f->ip);
-    stati(f->ip, st);
-    iunlock(f->ip);
-    return 0;
-  }
-  return -1;
-}
-
-// Read from file f.
-int
-fileread(struct file *f, char *addr, int n)
-{
-  int r;
-
-  if(f->readable == 0)
-    return -1;
-  if(f->type == FD_PIPE)
-    return piperead(f->pipe, addr, n);
-  if(f->type == FD_INODE){
-    ilock(f->ip);
-    if((r = readi(f->ip, addr, f->off, n)) > 0)
-      f->off += r;
-    iunlock(f->ip);
-    return r;
-  }
-  panic("fileread");
-}
-
-//PAGEBREAK!
-// Write to file f.
-int
-filewrite(struct file *f, char *addr, int n)
-{
-  int r;
-
-  if(f->writable == 0)
-    return -1;
-  if(f->type == FD_PIPE)
-    return pipewrite(f->pipe, addr, n);
-  if(f->type == FD_INODE){
-    // write a few blocks at a time to avoid exceeding
-    // the maximum log transaction size, including
-    // i-node, indirect block, allocation blocks,
-    // and 2 blocks of slop for non-aligned writes.
-    // this really belongs lower down, since writei()
-    // might be writing a device like the console.
-    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
-    int i = 0;
-    while(i < n){
-      int n1 = n - i;
-      if(n1 > max)
-        n1 = max;
-
-      begin_op();
-      ilock(f->ip);
-      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
-        f->off += r;
-      iunlock(f->ip);
-      end_op();
-
-      if(r < 0)
-        break;
-      if(r != n1)
-        panic("short filewrite");
-      i += r;
-    }
-    return i == n ? n : -1;
-  }
-  panic("filewrite");
-}
-
diff --git a/xv6-public/Operating-System-Project/file.d b/xv6-public/Operating-System-Project/file.d
deleted file mode 100644
index fea73d1..0000000
--- a/xv6-public/Operating-System-Project/file.d
+++ /dev/null
@@ -1,2 +0,0 @@
-file.o: file.c /usr/include/stdc-predef.h types.h defs.h param.h fs.h \
- spinlock.h sleeplock.h file.h
diff --git a/xv6-public/Operating-System-Project/file.h b/xv6-public/Operating-System-Project/file.h
deleted file mode 100644
index 0990c82..0000000
--- a/xv6-public/Operating-System-Project/file.h
+++ /dev/null
@@ -1,37 +0,0 @@
-struct file {
-  enum { FD_NONE, FD_PIPE, FD_INODE } type;
-  int ref; // reference count
-  char readable;
-  char writable;
-  struct pipe *pipe;
-  struct inode *ip;
-  uint off;
-};
-
-
-// in-memory copy of an inode
-struct inode {
-  uint dev;           // Device number
-  uint inum;          // Inode number
-  int ref;            // Reference count
-  struct sleeplock lock; // protects everything below here
-  int valid;          // inode has been read from disk?
-
-  short type;         // copy of disk inode
-  short major;
-  short minor;
-  short nlink;
-  uint size;
-  uint addrs[NDIRECT+1];
-};
-
-// table mapping major device number to
-// device functions
-struct devsw {
-  int (*read)(struct inode*, char*, int);
-  int (*write)(struct inode*, char*, int);
-};
-
-extern struct devsw devsw[];
-
-#define CONSOLE 1
diff --git a/xv6-public/Operating-System-Project/file.o b/xv6-public/Operating-System-Project/file.o
deleted file mode 100644
index af01941..0000000
Binary files a/xv6-public/Operating-System-Project/file.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/forktest.asm b/xv6-public/Operating-System-Project/forktest.asm
deleted file mode 100644
index 6096922..0000000
--- a/xv6-public/Operating-System-Project/forktest.asm
+++ /dev/null
@@ -1,750 +0,0 @@
-
-_forktest:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-  printf(1, "fork test OK\n");
-}
-
-int
-main(void)
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	55                   	push   %ebp
-   5:	89 e5                	mov    %esp,%ebp
-   7:	83 e4 f0             	and    $0xfffffff0,%esp
-  forktest();
-   a:	e8 41 00 00 00       	call   50 <forktest>
-  exit();
-   f:	e8 9f 03 00 00       	call   3b3 <exit>
-  14:	66 90                	xchg   %ax,%ax
-  16:	66 90                	xchg   %ax,%ax
-  18:	66 90                	xchg   %ax,%ax
-  1a:	66 90                	xchg   %ax,%ax
-  1c:	66 90                	xchg   %ax,%ax
-  1e:	66 90                	xchg   %ax,%ax
-
-00000020 <printf>:
-{
-  20:	f3 0f 1e fb          	endbr32 
-  24:	55                   	push   %ebp
-  25:	89 e5                	mov    %esp,%ebp
-  27:	53                   	push   %ebx
-  28:	83 ec 10             	sub    $0x10,%esp
-  2b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  write(fd, s, strlen(s));
-  2e:	53                   	push   %ebx
-  2f:	e8 9c 01 00 00       	call   1d0 <strlen>
-  34:	83 c4 0c             	add    $0xc,%esp
-  37:	50                   	push   %eax
-  38:	53                   	push   %ebx
-  39:	ff 75 08             	pushl  0x8(%ebp)
-  3c:	e8 92 03 00 00       	call   3d3 <write>
-}
-  41:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-  44:	83 c4 10             	add    $0x10,%esp
-  47:	c9                   	leave  
-  48:	c3                   	ret    
-  49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-00000050 <forktest>:
-{
-  50:	f3 0f 1e fb          	endbr32 
-  54:	55                   	push   %ebp
-  55:	89 e5                	mov    %esp,%ebp
-  57:	53                   	push   %ebx
-  for(n=0; n<N; n++){
-  58:	31 db                	xor    %ebx,%ebx
-{
-  5a:	83 ec 10             	sub    $0x10,%esp
-  write(fd, s, strlen(s));
-  5d:	68 b4 04 00 00       	push   $0x4b4
-  62:	e8 69 01 00 00       	call   1d0 <strlen>
-  67:	83 c4 0c             	add    $0xc,%esp
-  6a:	50                   	push   %eax
-  6b:	68 b4 04 00 00       	push   $0x4b4
-  70:	6a 01                	push   $0x1
-  72:	e8 5c 03 00 00       	call   3d3 <write>
-  77:	83 c4 10             	add    $0x10,%esp
-  7a:	eb 15                	jmp    91 <forktest+0x41>
-  7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    if(pid == 0)
-  80:	74 58                	je     da <forktest+0x8a>
-  for(n=0; n<N; n++){
-  82:	83 c3 01             	add    $0x1,%ebx
-  85:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
-  8b:	0f 84 92 00 00 00    	je     123 <forktest+0xd3>
-    pid = fork();
-  91:	e8 15 03 00 00       	call   3ab <fork>
-    if(pid < 0)
-  96:	85 c0                	test   %eax,%eax
-  98:	79 e6                	jns    80 <forktest+0x30>
-  for(; n > 0; n--){
-  9a:	85 db                	test   %ebx,%ebx
-  9c:	74 10                	je     ae <forktest+0x5e>
-  9e:	66 90                	xchg   %ax,%ax
-    if(wait() < 0){
-  a0:	e8 16 03 00 00       	call   3bb <wait>
-  a5:	85 c0                	test   %eax,%eax
-  a7:	78 36                	js     df <forktest+0x8f>
-  for(; n > 0; n--){
-  a9:	83 eb 01             	sub    $0x1,%ebx
-  ac:	75 f2                	jne    a0 <forktest+0x50>
-  if(wait() != -1){
-  ae:	e8 08 03 00 00       	call   3bb <wait>
-  b3:	83 f8 ff             	cmp    $0xffffffff,%eax
-  b6:	75 49                	jne    101 <forktest+0xb1>
-  write(fd, s, strlen(s));
-  b8:	83 ec 0c             	sub    $0xc,%esp
-  bb:	68 e6 04 00 00       	push   $0x4e6
-  c0:	e8 0b 01 00 00       	call   1d0 <strlen>
-  c5:	83 c4 0c             	add    $0xc,%esp
-  c8:	50                   	push   %eax
-  c9:	68 e6 04 00 00       	push   $0x4e6
-  ce:	6a 01                	push   $0x1
-  d0:	e8 fe 02 00 00       	call   3d3 <write>
-}
-  d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-  d8:	c9                   	leave  
-  d9:	c3                   	ret    
-      exit();
-  da:	e8 d4 02 00 00       	call   3b3 <exit>
-  write(fd, s, strlen(s));
-  df:	83 ec 0c             	sub    $0xc,%esp
-  e2:	68 bf 04 00 00       	push   $0x4bf
-  e7:	e8 e4 00 00 00       	call   1d0 <strlen>
-  ec:	83 c4 0c             	add    $0xc,%esp
-  ef:	50                   	push   %eax
-  f0:	68 bf 04 00 00       	push   $0x4bf
-  f5:	6a 01                	push   $0x1
-  f7:	e8 d7 02 00 00       	call   3d3 <write>
-      exit();
-  fc:	e8 b2 02 00 00       	call   3b3 <exit>
-  write(fd, s, strlen(s));
- 101:	83 ec 0c             	sub    $0xc,%esp
- 104:	68 d3 04 00 00       	push   $0x4d3
- 109:	e8 c2 00 00 00       	call   1d0 <strlen>
- 10e:	83 c4 0c             	add    $0xc,%esp
- 111:	50                   	push   %eax
- 112:	68 d3 04 00 00       	push   $0x4d3
- 117:	6a 01                	push   $0x1
- 119:	e8 b5 02 00 00       	call   3d3 <write>
-    exit();
- 11e:	e8 90 02 00 00       	call   3b3 <exit>
-  write(fd, s, strlen(s));
- 123:	83 ec 0c             	sub    $0xc,%esp
- 126:	68 f4 04 00 00       	push   $0x4f4
- 12b:	e8 a0 00 00 00       	call   1d0 <strlen>
- 130:	83 c4 0c             	add    $0xc,%esp
- 133:	50                   	push   %eax
- 134:	68 f4 04 00 00       	push   $0x4f4
- 139:	6a 01                	push   $0x1
- 13b:	e8 93 02 00 00       	call   3d3 <write>
-    exit();
- 140:	e8 6e 02 00 00       	call   3b3 <exit>
- 145:	66 90                	xchg   %ax,%ax
- 147:	66 90                	xchg   %ax,%ax
- 149:	66 90                	xchg   %ax,%ax
- 14b:	66 90                	xchg   %ax,%ax
- 14d:	66 90                	xchg   %ax,%ax
- 14f:	90                   	nop
-
-00000150 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
- 150:	f3 0f 1e fb          	endbr32 
- 154:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
- 155:	31 c0                	xor    %eax,%eax
-{
- 157:	89 e5                	mov    %esp,%ebp
- 159:	53                   	push   %ebx
- 15a:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 15d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
- 160:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
- 164:	88 14 01             	mov    %dl,(%ecx,%eax,1)
- 167:	83 c0 01             	add    $0x1,%eax
- 16a:	84 d2                	test   %dl,%dl
- 16c:	75 f2                	jne    160 <strcpy+0x10>
-    ;
-  return os;
-}
- 16e:	89 c8                	mov    %ecx,%eax
- 170:	5b                   	pop    %ebx
- 171:	5d                   	pop    %ebp
- 172:	c3                   	ret    
- 173:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 17a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000180 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
- 180:	f3 0f 1e fb          	endbr32 
- 184:	55                   	push   %ebp
- 185:	89 e5                	mov    %esp,%ebp
- 187:	53                   	push   %ebx
- 188:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 18b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
- 18e:	0f b6 01             	movzbl (%ecx),%eax
- 191:	0f b6 1a             	movzbl (%edx),%ebx
- 194:	84 c0                	test   %al,%al
- 196:	75 19                	jne    1b1 <strcmp+0x31>
- 198:	eb 26                	jmp    1c0 <strcmp+0x40>
- 19a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 1a0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
- 1a4:	83 c1 01             	add    $0x1,%ecx
- 1a7:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
- 1aa:	0f b6 1a             	movzbl (%edx),%ebx
- 1ad:	84 c0                	test   %al,%al
- 1af:	74 0f                	je     1c0 <strcmp+0x40>
- 1b1:	38 d8                	cmp    %bl,%al
- 1b3:	74 eb                	je     1a0 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
- 1b5:	29 d8                	sub    %ebx,%eax
-}
- 1b7:	5b                   	pop    %ebx
- 1b8:	5d                   	pop    %ebp
- 1b9:	c3                   	ret    
- 1ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 1c0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
- 1c2:	29 d8                	sub    %ebx,%eax
-}
- 1c4:	5b                   	pop    %ebx
- 1c5:	5d                   	pop    %ebp
- 1c6:	c3                   	ret    
- 1c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1ce:	66 90                	xchg   %ax,%ax
-
-000001d0 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 1d0:	f3 0f 1e fb          	endbr32 
- 1d4:	55                   	push   %ebp
- 1d5:	89 e5                	mov    %esp,%ebp
- 1d7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 1da:	80 3a 00             	cmpb   $0x0,(%edx)
- 1dd:	74 21                	je     200 <strlen+0x30>
- 1df:	31 c0                	xor    %eax,%eax
- 1e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1e8:	83 c0 01             	add    $0x1,%eax
- 1eb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 1ef:	89 c1                	mov    %eax,%ecx
- 1f1:	75 f5                	jne    1e8 <strlen+0x18>
-    ;
-  return n;
-}
- 1f3:	89 c8                	mov    %ecx,%eax
- 1f5:	5d                   	pop    %ebp
- 1f6:	c3                   	ret    
- 1f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1fe:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 200:	31 c9                	xor    %ecx,%ecx
-}
- 202:	5d                   	pop    %ebp
- 203:	89 c8                	mov    %ecx,%eax
- 205:	c3                   	ret    
- 206:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 20d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000210 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 210:	f3 0f 1e fb          	endbr32 
- 214:	55                   	push   %ebp
- 215:	89 e5                	mov    %esp,%ebp
- 217:	57                   	push   %edi
- 218:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 21b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 21e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 221:	89 d7                	mov    %edx,%edi
- 223:	fc                   	cld    
- 224:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 226:	89 d0                	mov    %edx,%eax
- 228:	5f                   	pop    %edi
- 229:	5d                   	pop    %ebp
- 22a:	c3                   	ret    
- 22b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 22f:	90                   	nop
-
-00000230 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 230:	f3 0f 1e fb          	endbr32 
- 234:	55                   	push   %ebp
- 235:	89 e5                	mov    %esp,%ebp
- 237:	8b 45 08             	mov    0x8(%ebp),%eax
- 23a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 23e:	0f b6 10             	movzbl (%eax),%edx
- 241:	84 d2                	test   %dl,%dl
- 243:	75 16                	jne    25b <strchr+0x2b>
- 245:	eb 21                	jmp    268 <strchr+0x38>
- 247:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 24e:	66 90                	xchg   %ax,%ax
- 250:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 254:	83 c0 01             	add    $0x1,%eax
- 257:	84 d2                	test   %dl,%dl
- 259:	74 0d                	je     268 <strchr+0x38>
-    if(*s == c)
- 25b:	38 d1                	cmp    %dl,%cl
- 25d:	75 f1                	jne    250 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 25f:	5d                   	pop    %ebp
- 260:	c3                   	ret    
- 261:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 268:	31 c0                	xor    %eax,%eax
-}
- 26a:	5d                   	pop    %ebp
- 26b:	c3                   	ret    
- 26c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000270 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 270:	f3 0f 1e fb          	endbr32 
- 274:	55                   	push   %ebp
- 275:	89 e5                	mov    %esp,%ebp
- 277:	57                   	push   %edi
- 278:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 279:	31 f6                	xor    %esi,%esi
-{
- 27b:	53                   	push   %ebx
- 27c:	89 f3                	mov    %esi,%ebx
- 27e:	83 ec 1c             	sub    $0x1c,%esp
- 281:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 284:	eb 33                	jmp    2b9 <gets+0x49>
- 286:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 28d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 290:	83 ec 04             	sub    $0x4,%esp
- 293:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 296:	6a 01                	push   $0x1
- 298:	50                   	push   %eax
- 299:	6a 00                	push   $0x0
- 29b:	e8 2b 01 00 00       	call   3cb <read>
-    if(cc < 1)
- 2a0:	83 c4 10             	add    $0x10,%esp
- 2a3:	85 c0                	test   %eax,%eax
- 2a5:	7e 1c                	jle    2c3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 2a7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 2ab:	83 c7 01             	add    $0x1,%edi
- 2ae:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 2b1:	3c 0a                	cmp    $0xa,%al
- 2b3:	74 23                	je     2d8 <gets+0x68>
- 2b5:	3c 0d                	cmp    $0xd,%al
- 2b7:	74 1f                	je     2d8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 2b9:	83 c3 01             	add    $0x1,%ebx
- 2bc:	89 fe                	mov    %edi,%esi
- 2be:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 2c1:	7c cd                	jl     290 <gets+0x20>
- 2c3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 2c5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 2c8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 2cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 2ce:	5b                   	pop    %ebx
- 2cf:	5e                   	pop    %esi
- 2d0:	5f                   	pop    %edi
- 2d1:	5d                   	pop    %ebp
- 2d2:	c3                   	ret    
- 2d3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 2d7:	90                   	nop
- 2d8:	8b 75 08             	mov    0x8(%ebp),%esi
- 2db:	8b 45 08             	mov    0x8(%ebp),%eax
- 2de:	01 de                	add    %ebx,%esi
- 2e0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 2e2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 2e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 2e8:	5b                   	pop    %ebx
- 2e9:	5e                   	pop    %esi
- 2ea:	5f                   	pop    %edi
- 2eb:	5d                   	pop    %ebp
- 2ec:	c3                   	ret    
- 2ed:	8d 76 00             	lea    0x0(%esi),%esi
-
-000002f0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 2f0:	f3 0f 1e fb          	endbr32 
- 2f4:	55                   	push   %ebp
- 2f5:	89 e5                	mov    %esp,%ebp
- 2f7:	56                   	push   %esi
- 2f8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 2f9:	83 ec 08             	sub    $0x8,%esp
- 2fc:	6a 00                	push   $0x0
- 2fe:	ff 75 08             	pushl  0x8(%ebp)
- 301:	e8 ed 00 00 00       	call   3f3 <open>
-  if(fd < 0)
- 306:	83 c4 10             	add    $0x10,%esp
- 309:	85 c0                	test   %eax,%eax
- 30b:	78 2b                	js     338 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 30d:	83 ec 08             	sub    $0x8,%esp
- 310:	ff 75 0c             	pushl  0xc(%ebp)
- 313:	89 c3                	mov    %eax,%ebx
- 315:	50                   	push   %eax
- 316:	e8 f0 00 00 00       	call   40b <fstat>
-  close(fd);
- 31b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 31e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 320:	e8 b6 00 00 00       	call   3db <close>
-  return r;
- 325:	83 c4 10             	add    $0x10,%esp
-}
- 328:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 32b:	89 f0                	mov    %esi,%eax
- 32d:	5b                   	pop    %ebx
- 32e:	5e                   	pop    %esi
- 32f:	5d                   	pop    %ebp
- 330:	c3                   	ret    
- 331:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 338:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 33d:	eb e9                	jmp    328 <stat+0x38>
- 33f:	90                   	nop
-
-00000340 <atoi>:
-
-int
-atoi(const char *s)
-{
- 340:	f3 0f 1e fb          	endbr32 
- 344:	55                   	push   %ebp
- 345:	89 e5                	mov    %esp,%ebp
- 347:	53                   	push   %ebx
- 348:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 34b:	0f be 02             	movsbl (%edx),%eax
- 34e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 351:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 354:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 359:	77 1a                	ja     375 <atoi+0x35>
- 35b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 35f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 360:	83 c2 01             	add    $0x1,%edx
- 363:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 366:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 36a:	0f be 02             	movsbl (%edx),%eax
- 36d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 370:	80 fb 09             	cmp    $0x9,%bl
- 373:	76 eb                	jbe    360 <atoi+0x20>
-  return n;
-}
- 375:	89 c8                	mov    %ecx,%eax
- 377:	5b                   	pop    %ebx
- 378:	5d                   	pop    %ebp
- 379:	c3                   	ret    
- 37a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000380 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 380:	f3 0f 1e fb          	endbr32 
- 384:	55                   	push   %ebp
- 385:	89 e5                	mov    %esp,%ebp
- 387:	57                   	push   %edi
- 388:	8b 45 10             	mov    0x10(%ebp),%eax
- 38b:	8b 55 08             	mov    0x8(%ebp),%edx
- 38e:	56                   	push   %esi
- 38f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 392:	85 c0                	test   %eax,%eax
- 394:	7e 0f                	jle    3a5 <memmove+0x25>
- 396:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 398:	89 d7                	mov    %edx,%edi
- 39a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 3a0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 3a1:	39 f8                	cmp    %edi,%eax
- 3a3:	75 fb                	jne    3a0 <memmove+0x20>
-  return vdst;
-}
- 3a5:	5e                   	pop    %esi
- 3a6:	89 d0                	mov    %edx,%eax
- 3a8:	5f                   	pop    %edi
- 3a9:	5d                   	pop    %ebp
- 3aa:	c3                   	ret    
-
-000003ab <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 3ab:	b8 01 00 00 00       	mov    $0x1,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
-
-000003b3 <exit>:
-SYSCALL(exit)
- 3b3:	b8 02 00 00 00       	mov    $0x2,%eax
- 3b8:	cd 40                	int    $0x40
- 3ba:	c3                   	ret    
-
-000003bb <wait>:
-SYSCALL(wait)
- 3bb:	b8 03 00 00 00       	mov    $0x3,%eax
- 3c0:	cd 40                	int    $0x40
- 3c2:	c3                   	ret    
-
-000003c3 <pipe>:
-SYSCALL(pipe)
- 3c3:	b8 04 00 00 00       	mov    $0x4,%eax
- 3c8:	cd 40                	int    $0x40
- 3ca:	c3                   	ret    
-
-000003cb <read>:
-SYSCALL(read)
- 3cb:	b8 05 00 00 00       	mov    $0x5,%eax
- 3d0:	cd 40                	int    $0x40
- 3d2:	c3                   	ret    
-
-000003d3 <write>:
-SYSCALL(write)
- 3d3:	b8 10 00 00 00       	mov    $0x10,%eax
- 3d8:	cd 40                	int    $0x40
- 3da:	c3                   	ret    
-
-000003db <close>:
-SYSCALL(close)
- 3db:	b8 15 00 00 00       	mov    $0x15,%eax
- 3e0:	cd 40                	int    $0x40
- 3e2:	c3                   	ret    
-
-000003e3 <kill>:
-SYSCALL(kill)
- 3e3:	b8 06 00 00 00       	mov    $0x6,%eax
- 3e8:	cd 40                	int    $0x40
- 3ea:	c3                   	ret    
-
-000003eb <exec>:
-SYSCALL(exec)
- 3eb:	b8 07 00 00 00       	mov    $0x7,%eax
- 3f0:	cd 40                	int    $0x40
- 3f2:	c3                   	ret    
-
-000003f3 <open>:
-SYSCALL(open)
- 3f3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 3f8:	cd 40                	int    $0x40
- 3fa:	c3                   	ret    
-
-000003fb <mknod>:
-SYSCALL(mknod)
- 3fb:	b8 11 00 00 00       	mov    $0x11,%eax
- 400:	cd 40                	int    $0x40
- 402:	c3                   	ret    
-
-00000403 <unlink>:
-SYSCALL(unlink)
- 403:	b8 12 00 00 00       	mov    $0x12,%eax
- 408:	cd 40                	int    $0x40
- 40a:	c3                   	ret    
-
-0000040b <fstat>:
-SYSCALL(fstat)
- 40b:	b8 08 00 00 00       	mov    $0x8,%eax
- 410:	cd 40                	int    $0x40
- 412:	c3                   	ret    
-
-00000413 <link>:
-SYSCALL(link)
- 413:	b8 13 00 00 00       	mov    $0x13,%eax
- 418:	cd 40                	int    $0x40
- 41a:	c3                   	ret    
-
-0000041b <mkdir>:
-SYSCALL(mkdir)
- 41b:	b8 14 00 00 00       	mov    $0x14,%eax
- 420:	cd 40                	int    $0x40
- 422:	c3                   	ret    
-
-00000423 <chdir>:
-SYSCALL(chdir)
- 423:	b8 09 00 00 00       	mov    $0x9,%eax
- 428:	cd 40                	int    $0x40
- 42a:	c3                   	ret    
-
-0000042b <dup>:
-SYSCALL(dup)
- 42b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 430:	cd 40                	int    $0x40
- 432:	c3                   	ret    
-
-00000433 <getpid>:
-SYSCALL(getpid)
- 433:	b8 0b 00 00 00       	mov    $0xb,%eax
- 438:	cd 40                	int    $0x40
- 43a:	c3                   	ret    
-
-0000043b <sbrk>:
-SYSCALL(sbrk)
- 43b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 440:	cd 40                	int    $0x40
- 442:	c3                   	ret    
-
-00000443 <sleep>:
-SYSCALL(sleep)
- 443:	b8 0d 00 00 00       	mov    $0xd,%eax
- 448:	cd 40                	int    $0x40
- 44a:	c3                   	ret    
-
-0000044b <uptime>:
-SYSCALL(uptime)
- 44b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 450:	cd 40                	int    $0x40
- 452:	c3                   	ret    
-
-00000453 <getParentID>:
-SYSCALL(getParentID)
- 453:	b8 16 00 00 00       	mov    $0x16,%eax
- 458:	cd 40                	int    $0x40
- 45a:	c3                   	ret    
-
-0000045b <getChildren>:
-SYSCALL(getChildren)
- 45b:	b8 17 00 00 00       	mov    $0x17,%eax
- 460:	cd 40                	int    $0x40
- 462:	c3                   	ret    
-
-00000463 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 463:	b8 18 00 00 00       	mov    $0x18,%eax
- 468:	cd 40                	int    $0x40
- 46a:	c3                   	ret    
-
-0000046b <setPriority>:
-SYSCALL(setPriority)
- 46b:	b8 19 00 00 00       	mov    $0x19,%eax
- 470:	cd 40                	int    $0x40
- 472:	c3                   	ret    
-
-00000473 <changePolicy>:
-SYSCALL(changePolicy)
- 473:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 478:	cd 40                	int    $0x40
- 47a:	c3                   	ret    
-
-0000047b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 47b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 480:	cd 40                	int    $0x40
- 482:	c3                   	ret    
-
-00000483 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 483:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 488:	cd 40                	int    $0x40
- 48a:	c3                   	ret    
-
-0000048b <getCBT>:
-SYSCALL(getCBT)
- 48b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 490:	cd 40                	int    $0x40
- 492:	c3                   	ret    
-
-00000493 <customWait>:
-SYSCALL(customWait)
- 493:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 498:	cd 40                	int    $0x40
- 49a:	c3                   	ret    
-
-0000049b <setQueue>:
-SYSCALL(setQueue)
- 49b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 4a0:	cd 40                	int    $0x40
- 4a2:	c3                   	ret    
-
-000004a3 <getBurstTime>:
-SYSCALL(getBurstTime)
- 4a3:	b8 20 00 00 00       	mov    $0x20,%eax
- 4a8:	cd 40                	int    $0x40
- 4aa:	c3                   	ret    
-
-000004ab <getCreationTime>:
- 4ab:	b8 21 00 00 00       	mov    $0x21,%eax
- 4b0:	cd 40                	int    $0x40
- 4b2:	c3                   	ret    
diff --git a/xv6-public/Operating-System-Project/forktest.c b/xv6-public/Operating-System-Project/forktest.c
deleted file mode 100644
index 8bc984d..0000000
--- a/xv6-public/Operating-System-Project/forktest.c
+++ /dev/null
@@ -1,56 +0,0 @@
-// Test that fork fails gracefully.
-// Tiny executable so that the limit can be filling the proc table.
-
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-#define N  1000
-
-void
-printf(int fd, const char *s, ...)
-{
-  write(fd, s, strlen(s));
-}
-
-void
-forktest(void)
-{
-  int n, pid;
-
-  printf(1, "fork test\n");
-
-  for(n=0; n<N; n++){
-    pid = fork();
-    if(pid < 0)
-      break;
-    if(pid == 0)
-      exit();
-  }
-
-  if(n == N){
-    printf(1, "fork claimed to work N times!\n", N);
-    exit();
-  }
-
-  for(; n > 0; n--){
-    if(wait() < 0){
-      printf(1, "wait stopped early\n");
-      exit();
-    }
-  }
-
-  if(wait() != -1){
-    printf(1, "wait got too many\n");
-    exit();
-  }
-
-  printf(1, "fork test OK\n");
-}
-
-int
-main(void)
-{
-  forktest();
-  exit();
-}
diff --git a/xv6-public/Operating-System-Project/forktest.d b/xv6-public/Operating-System-Project/forktest.d
deleted file mode 100644
index d31a0c2..0000000
--- a/xv6-public/Operating-System-Project/forktest.d
+++ /dev/null
@@ -1 +0,0 @@
-forktest.o: forktest.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/forktest.o b/xv6-public/Operating-System-Project/forktest.o
deleted file mode 100644
index 1902ab2..0000000
Binary files a/xv6-public/Operating-System-Project/forktest.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/fs.c b/xv6-public/Operating-System-Project/fs.c
deleted file mode 100644
index f77275f..0000000
--- a/xv6-public/Operating-System-Project/fs.c
+++ /dev/null
@@ -1,670 +0,0 @@
-// File system implementation.  Five layers:
-//   + Blocks: allocator for raw disk blocks.
-//   + Log: crash recovery for multi-step updates.
-//   + Files: inode allocator, reading, writing, metadata.
-//   + Directories: inode with special contents (list of other inodes!)
-//   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
-//
-// This file contains the low-level file system manipulation
-// routines.  The (higher-level) system call implementations
-// are in sysfile.c.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "stat.h"
-#include "mmu.h"
-#include "proc.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "buf.h"
-#include "file.h"
-
-#define min(a, b) ((a) < (b) ? (a) : (b))
-static void itrunc(struct inode*);
-// there should be one superblock per disk device, but we run with
-// only one device
-struct superblock sb; 
-
-// Read the super block.
-void
-readsb(int dev, struct superblock *sb)
-{
-  struct buf *bp;
-
-  bp = bread(dev, 1);
-  memmove(sb, bp->data, sizeof(*sb));
-  brelse(bp);
-}
-
-// Zero a block.
-static void
-bzero(int dev, int bno)
-{
-  struct buf *bp;
-
-  bp = bread(dev, bno);
-  memset(bp->data, 0, BSIZE);
-  log_write(bp);
-  brelse(bp);
-}
-
-// Blocks.
-
-// Allocate a zeroed disk block.
-static uint
-balloc(uint dev)
-{
-  int b, bi, m;
-  struct buf *bp;
-
-  bp = 0;
-  for(b = 0; b < sb.size; b += BPB){
-    bp = bread(dev, BBLOCK(b, sb));
-    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
-      m = 1 << (bi % 8);
-      if((bp->data[bi/8] & m) == 0){  // Is block free?
-        bp->data[bi/8] |= m;  // Mark block in use.
-        log_write(bp);
-        brelse(bp);
-        bzero(dev, b + bi);
-        return b + bi;
-      }
-    }
-    brelse(bp);
-  }
-  panic("balloc: out of blocks");
-}
-
-// Free a disk block.
-static void
-bfree(int dev, uint b)
-{
-  struct buf *bp;
-  int bi, m;
-
-  bp = bread(dev, BBLOCK(b, sb));
-  bi = b % BPB;
-  m = 1 << (bi % 8);
-  if((bp->data[bi/8] & m) == 0)
-    panic("freeing free block");
-  bp->data[bi/8] &= ~m;
-  log_write(bp);
-  brelse(bp);
-}
-
-// Inodes.
-//
-// An inode describes a single unnamed file.
-// The inode disk structure holds metadata: the file's type,
-// its size, the number of links referring to it, and the
-// list of blocks holding the file's content.
-//
-// The inodes are laid out sequentially on disk at
-// sb.startinode. Each inode has a number, indicating its
-// position on the disk.
-//
-// The kernel keeps a cache of in-use inodes in memory
-// to provide a place for synchronizing access
-// to inodes used by multiple processes. The cached
-// inodes include book-keeping information that is
-// not stored on disk: ip->ref and ip->valid.
-//
-// An inode and its in-memory representation go through a
-// sequence of states before they can be used by the
-// rest of the file system code.
-//
-// * Allocation: an inode is allocated if its type (on disk)
-//   is non-zero. ialloc() allocates, and iput() frees if
-//   the reference and link counts have fallen to zero.
-//
-// * Referencing in cache: an entry in the inode cache
-//   is free if ip->ref is zero. Otherwise ip->ref tracks
-//   the number of in-memory pointers to the entry (open
-//   files and current directories). iget() finds or
-//   creates a cache entry and increments its ref; iput()
-//   decrements ref.
-//
-// * Valid: the information (type, size, &c) in an inode
-//   cache entry is only correct when ip->valid is 1.
-//   ilock() reads the inode from
-//   the disk and sets ip->valid, while iput() clears
-//   ip->valid if ip->ref has fallen to zero.
-//
-// * Locked: file system code may only examine and modify
-//   the information in an inode and its content if it
-//   has first locked the inode.
-//
-// Thus a typical sequence is:
-//   ip = iget(dev, inum)
-//   ilock(ip)
-//   ... examine and modify ip->xxx ...
-//   iunlock(ip)
-//   iput(ip)
-//
-// ilock() is separate from iget() so that system calls can
-// get a long-term reference to an inode (as for an open file)
-// and only lock it for short periods (e.g., in read()).
-// The separation also helps avoid deadlock and races during
-// pathname lookup. iget() increments ip->ref so that the inode
-// stays cached and pointers to it remain valid.
-//
-// Many internal file system functions expect the caller to
-// have locked the inodes involved; this lets callers create
-// multi-step atomic operations.
-//
-// The icache.lock spin-lock protects the allocation of icache
-// entries. Since ip->ref indicates whether an entry is free,
-// and ip->dev and ip->inum indicate which i-node an entry
-// holds, one must hold icache.lock while using any of those fields.
-//
-// An ip->lock sleep-lock protects all ip-> fields other than ref,
-// dev, and inum.  One must hold ip->lock in order to
-// read or write that inode's ip->valid, ip->size, ip->type, &c.
-
-struct {
-  struct spinlock lock;
-  struct inode inode[NINODE];
-} icache;
-
-void
-iinit(int dev)
-{
-  int i = 0;
-  
-  initlock(&icache.lock, "icache");
-  for(i = 0; i < NINODE; i++) {
-    initsleeplock(&icache.inode[i].lock, "inode");
-  }
-
-  readsb(dev, &sb);
-  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
- inodestart %d bmap start %d\n", sb.size, sb.nblocks,
-          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
-          sb.bmapstart);
-}
-
-static struct inode* iget(uint dev, uint inum);
-
-//PAGEBREAK!
-// Allocate an inode on device dev.
-// Mark it as allocated by  giving it type type.
-// Returns an unlocked but allocated and referenced inode.
-struct inode*
-ialloc(uint dev, short type)
-{
-  int inum;
-  struct buf *bp;
-  struct dinode *dip;
-
-  for(inum = 1; inum < sb.ninodes; inum++){
-    bp = bread(dev, IBLOCK(inum, sb));
-    dip = (struct dinode*)bp->data + inum%IPB;
-    if(dip->type == 0){  // a free inode
-      memset(dip, 0, sizeof(*dip));
-      dip->type = type;
-      log_write(bp);   // mark it allocated on the disk
-      brelse(bp);
-      return iget(dev, inum);
-    }
-    brelse(bp);
-  }
-  panic("ialloc: no inodes");
-}
-
-// Copy a modified in-memory inode to disk.
-// Must be called after every change to an ip->xxx field
-// that lives on disk, since i-node cache is write-through.
-// Caller must hold ip->lock.
-void
-iupdate(struct inode *ip)
-{
-  struct buf *bp;
-  struct dinode *dip;
-
-  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
-  dip = (struct dinode*)bp->data + ip->inum%IPB;
-  dip->type = ip->type;
-  dip->major = ip->major;
-  dip->minor = ip->minor;
-  dip->nlink = ip->nlink;
-  dip->size = ip->size;
-  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
-  log_write(bp);
-  brelse(bp);
-}
-
-// Find the inode with number inum on device dev
-// and return the in-memory copy. Does not lock
-// the inode and does not read it from disk.
-static struct inode*
-iget(uint dev, uint inum)
-{
-  struct inode *ip, *empty;
-
-  acquire(&icache.lock);
-
-  // Is the inode already cached?
-  empty = 0;
-  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
-    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
-      ip->ref++;
-      release(&icache.lock);
-      return ip;
-    }
-    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
-      empty = ip;
-  }
-
-  // Recycle an inode cache entry.
-  if(empty == 0)
-    panic("iget: no inodes");
-
-  ip = empty;
-  ip->dev = dev;
-  ip->inum = inum;
-  ip->ref = 1;
-  ip->valid = 0;
-  release(&icache.lock);
-
-  return ip;
-}
-
-// Increment reference count for ip.
-// Returns ip to enable ip = idup(ip1) idiom.
-struct inode*
-idup(struct inode *ip)
-{
-  acquire(&icache.lock);
-  ip->ref++;
-  release(&icache.lock);
-  return ip;
-}
-
-// Lock the given inode.
-// Reads the inode from disk if necessary.
-void
-ilock(struct inode *ip)
-{
-  struct buf *bp;
-  struct dinode *dip;
-
-  if(ip == 0 || ip->ref < 1)
-    panic("ilock");
-
-  acquiresleep(&ip->lock);
-
-  if(ip->valid == 0){
-    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
-    dip = (struct dinode*)bp->data + ip->inum%IPB;
-    ip->type = dip->type;
-    ip->major = dip->major;
-    ip->minor = dip->minor;
-    ip->nlink = dip->nlink;
-    ip->size = dip->size;
-    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
-    brelse(bp);
-    ip->valid = 1;
-    if(ip->type == 0)
-      panic("ilock: no type");
-  }
-}
-
-// Unlock the given inode.
-void
-iunlock(struct inode *ip)
-{
-  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
-    panic("iunlock");
-
-  releasesleep(&ip->lock);
-}
-
-// Drop a reference to an in-memory inode.
-// If that was the last reference, the inode cache entry can
-// be recycled.
-// If that was the last reference and the inode has no links
-// to it, free the inode (and its content) on disk.
-// All calls to iput() must be inside a transaction in
-// case it has to free the inode.
-void
-iput(struct inode *ip)
-{
-  acquiresleep(&ip->lock);
-  if(ip->valid && ip->nlink == 0){
-    acquire(&icache.lock);
-    int r = ip->ref;
-    release(&icache.lock);
-    if(r == 1){
-      // inode has no links and no other references: truncate and free.
-      itrunc(ip);
-      ip->type = 0;
-      iupdate(ip);
-      ip->valid = 0;
-    }
-  }
-  releasesleep(&ip->lock);
-
-  acquire(&icache.lock);
-  ip->ref--;
-  release(&icache.lock);
-}
-
-// Common idiom: unlock, then put.
-void
-iunlockput(struct inode *ip)
-{
-  iunlock(ip);
-  iput(ip);
-}
-
-//PAGEBREAK!
-// Inode content
-//
-// The content (data) associated with each inode is stored
-// in blocks on the disk. The first NDIRECT block numbers
-// are listed in ip->addrs[].  The next NINDIRECT blocks are
-// listed in block ip->addrs[NDIRECT].
-
-// Return the disk block address of the nth block in inode ip.
-// If there is no such block, bmap allocates one.
-static uint
-bmap(struct inode *ip, uint bn)
-{
-  uint addr, *a;
-  struct buf *bp;
-
-  if(bn < NDIRECT){
-    if((addr = ip->addrs[bn]) == 0)
-      ip->addrs[bn] = addr = balloc(ip->dev);
-    return addr;
-  }
-  bn -= NDIRECT;
-
-  if(bn < NINDIRECT){
-    // Load indirect block, allocating if necessary.
-    if((addr = ip->addrs[NDIRECT]) == 0)
-      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
-    bp = bread(ip->dev, addr);
-    a = (uint*)bp->data;
-    if((addr = a[bn]) == 0){
-      a[bn] = addr = balloc(ip->dev);
-      log_write(bp);
-    }
-    brelse(bp);
-    return addr;
-  }
-
-  panic("bmap: out of range");
-}
-
-// Truncate inode (discard contents).
-// Only called when the inode has no links
-// to it (no directory entries referring to it)
-// and has no in-memory reference to it (is
-// not an open file or current directory).
-static void
-itrunc(struct inode *ip)
-{
-  int i, j;
-  struct buf *bp;
-  uint *a;
-
-  for(i = 0; i < NDIRECT; i++){
-    if(ip->addrs[i]){
-      bfree(ip->dev, ip->addrs[i]);
-      ip->addrs[i] = 0;
-    }
-  }
-
-  if(ip->addrs[NDIRECT]){
-    bp = bread(ip->dev, ip->addrs[NDIRECT]);
-    a = (uint*)bp->data;
-    for(j = 0; j < NINDIRECT; j++){
-      if(a[j])
-        bfree(ip->dev, a[j]);
-    }
-    brelse(bp);
-    bfree(ip->dev, ip->addrs[NDIRECT]);
-    ip->addrs[NDIRECT] = 0;
-  }
-
-  ip->size = 0;
-  iupdate(ip);
-}
-
-// Copy stat information from inode.
-// Caller must hold ip->lock.
-void
-stati(struct inode *ip, struct stat *st)
-{
-  st->dev = ip->dev;
-  st->ino = ip->inum;
-  st->type = ip->type;
-  st->nlink = ip->nlink;
-  st->size = ip->size;
-}
-
-//PAGEBREAK!
-// Read data from inode.
-// Caller must hold ip->lock.
-int
-readi(struct inode *ip, char *dst, uint off, uint n)
-{
-  uint tot, m;
-  struct buf *bp;
-
-  if(ip->type == T_DEV){
-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
-      return -1;
-    return devsw[ip->major].read(ip, dst, n);
-  }
-
-  if(off > ip->size || off + n < off)
-    return -1;
-  if(off + n > ip->size)
-    n = ip->size - off;
-
-  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
-    m = min(n - tot, BSIZE - off%BSIZE);
-    memmove(dst, bp->data + off%BSIZE, m);
-    brelse(bp);
-  }
-  return n;
-}
-
-// PAGEBREAK!
-// Write data to inode.
-// Caller must hold ip->lock.
-int
-writei(struct inode *ip, char *src, uint off, uint n)
-{
-  uint tot, m;
-  struct buf *bp;
-
-  if(ip->type == T_DEV){
-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
-      return -1;
-    return devsw[ip->major].write(ip, src, n);
-  }
-
-  if(off > ip->size || off + n < off)
-    return -1;
-  if(off + n > MAXFILE*BSIZE)
-    return -1;
-
-  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
-    m = min(n - tot, BSIZE - off%BSIZE);
-    memmove(bp->data + off%BSIZE, src, m);
-    log_write(bp);
-    brelse(bp);
-  }
-
-  if(n > 0 && off > ip->size){
-    ip->size = off;
-    iupdate(ip);
-  }
-  return n;
-}
-
-//PAGEBREAK!
-// Directories
-
-int
-namecmp(const char *s, const char *t)
-{
-  return strncmp(s, t, DIRSIZ);
-}
-
-// Look for a directory entry in a directory.
-// If found, set *poff to byte offset of entry.
-struct inode*
-dirlookup(struct inode *dp, char *name, uint *poff)
-{
-  uint off, inum;
-  struct dirent de;
-
-  if(dp->type != T_DIR)
-    panic("dirlookup not DIR");
-
-  for(off = 0; off < dp->size; off += sizeof(de)){
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-      panic("dirlookup read");
-    if(de.inum == 0)
-      continue;
-    if(namecmp(name, de.name) == 0){
-      // entry matches path element
-      if(poff)
-        *poff = off;
-      inum = de.inum;
-      return iget(dp->dev, inum);
-    }
-  }
-
-  return 0;
-}
-
-// Write a new directory entry (name, inum) into the directory dp.
-int
-dirlink(struct inode *dp, char *name, uint inum)
-{
-  int off;
-  struct dirent de;
-  struct inode *ip;
-
-  // Check that name is not present.
-  if((ip = dirlookup(dp, name, 0)) != 0){
-    iput(ip);
-    return -1;
-  }
-
-  // Look for an empty dirent.
-  for(off = 0; off < dp->size; off += sizeof(de)){
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-      panic("dirlink read");
-    if(de.inum == 0)
-      break;
-  }
-
-  strncpy(de.name, name, DIRSIZ);
-  de.inum = inum;
-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-    panic("dirlink");
-
-  return 0;
-}
-
-//PAGEBREAK!
-// Paths
-
-// Copy the next path element from path into name.
-// Return a pointer to the element following the copied one.
-// The returned path has no leading slashes,
-// so the caller can check *path=='\0' to see if the name is the last one.
-// If no name to remove, return 0.
-//
-// Examples:
-//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
-//   skipelem("///a//bb", name) = "bb", setting name = "a"
-//   skipelem("a", name) = "", setting name = "a"
-//   skipelem("", name) = skipelem("////", name) = 0
-//
-static char*
-skipelem(char *path, char *name)
-{
-  char *s;
-  int len;
-
-  while(*path == '/')
-    path++;
-  if(*path == 0)
-    return 0;
-  s = path;
-  while(*path != '/' && *path != 0)
-    path++;
-  len = path - s;
-  if(len >= DIRSIZ)
-    memmove(name, s, DIRSIZ);
-  else {
-    memmove(name, s, len);
-    name[len] = 0;
-  }
-  while(*path == '/')
-    path++;
-  return path;
-}
-
-// Look up and return the inode for a path name.
-// If parent != 0, return the inode for the parent and copy the final
-// path element into name, which must have room for DIRSIZ bytes.
-// Must be called inside a transaction since it calls iput().
-static struct inode*
-namex(char *path, int nameiparent, char *name)
-{
-  struct inode *ip, *next;
-
-  if(*path == '/')
-    ip = iget(ROOTDEV, ROOTINO);
-  else
-    ip = idup(myproc()->cwd);
-
-  while((path = skipelem(path, name)) != 0){
-    ilock(ip);
-    if(ip->type != T_DIR){
-      iunlockput(ip);
-      return 0;
-    }
-    if(nameiparent && *path == '\0'){
-      // Stop one level early.
-      iunlock(ip);
-      return ip;
-    }
-    if((next = dirlookup(ip, name, 0)) == 0){
-      iunlockput(ip);
-      return 0;
-    }
-    iunlockput(ip);
-    ip = next;
-  }
-  if(nameiparent){
-    iput(ip);
-    return 0;
-  }
-  return ip;
-}
-
-struct inode*
-namei(char *path)
-{
-  char name[DIRSIZ];
-  return namex(path, 0, name);
-}
-
-struct inode*
-nameiparent(char *path, char *name)
-{
-  return namex(path, 1, name);
-}
diff --git a/xv6-public/Operating-System-Project/fs.d b/xv6-public/Operating-System-Project/fs.d
deleted file mode 100644
index a1d05cc..0000000
--- a/xv6-public/Operating-System-Project/fs.d
+++ /dev/null
@@ -1,2 +0,0 @@
-fs.o: fs.c /usr/include/stdc-predef.h types.h defs.h param.h stat.h mmu.h \
- proc.h spinlock.h sleeplock.h fs.h buf.h file.h
diff --git a/xv6-public/Operating-System-Project/fs.h b/xv6-public/Operating-System-Project/fs.h
deleted file mode 100644
index 3214f1d..0000000
--- a/xv6-public/Operating-System-Project/fs.h
+++ /dev/null
@@ -1,57 +0,0 @@
-// On-disk file system format.
-// Both the kernel and user programs use this header file.
-
-
-#define ROOTINO 1  // root i-number
-#define BSIZE 512  // block size
-
-// Disk layout:
-// [ boot block | super block | log | inode blocks |
-//                                          free bit map | data blocks]
-//
-// mkfs computes the super block and builds an initial file system. The
-// super block describes the disk layout:
-struct superblock {
-  uint size;         // Size of file system image (blocks)
-  uint nblocks;      // Number of data blocks
-  uint ninodes;      // Number of inodes.
-  uint nlog;         // Number of log blocks
-  uint logstart;     // Block number of first log block
-  uint inodestart;   // Block number of first inode block
-  uint bmapstart;    // Block number of first free map block
-};
-
-#define NDIRECT 12
-#define NINDIRECT (BSIZE / sizeof(uint))
-#define MAXFILE (NDIRECT + NINDIRECT)
-
-// On-disk inode structure
-struct dinode {
-  short type;           // File type
-  short major;          // Major device number (T_DEV only)
-  short minor;          // Minor device number (T_DEV only)
-  short nlink;          // Number of links to inode in file system
-  uint size;            // Size of file (bytes)
-  uint addrs[NDIRECT+1];   // Data block addresses
-};
-
-// Inodes per block.
-#define IPB           (BSIZE / sizeof(struct dinode))
-
-// Block containing inode i
-#define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
-
-// Bitmap bits per block
-#define BPB           (BSIZE*8)
-
-// Block of free map containing bit for block b
-#define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
-
-// Directory is a file containing a sequence of dirent structures.
-#define DIRSIZ 14
-
-struct dirent {
-  ushort inum;
-  char name[DIRSIZ];
-};
-
diff --git a/xv6-public/Operating-System-Project/fs.img b/xv6-public/Operating-System-Project/fs.img
deleted file mode 100644
index f963fbc..0000000
Binary files a/xv6-public/Operating-System-Project/fs.img and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/fs.o b/xv6-public/Operating-System-Project/fs.o
deleted file mode 100644
index fb70c3a..0000000
Binary files a/xv6-public/Operating-System-Project/fs.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/gdbutil b/xv6-public/Operating-System-Project/gdbutil
deleted file mode 100644
index e0c362f..0000000
--- a/xv6-public/Operating-System-Project/gdbutil
+++ /dev/null
@@ -1,291 +0,0 @@
-# -*- gdb-script -*-
-
-# Utility functions to pretty-print x86 segment/interrupt descriptors.
-# To load this file, run "source gdbutil" in gdb.
-# printdesc and printdescs are the main entry points.
-
-# IA32 2007, Volume 3A, Table 3-2
-set $STS_T16A = 0x1
-set $STS_LDT  = 0x2
-set $STS_T16B = 0x3
-set $STS_CG16 = 0x4
-set $STS_TG   = 0x5
-set $STS_IG16 = 0x6
-set $STS_TG16 = 0x7
-set $STS_T32A = 0x9
-set $STS_T32B = 0xB
-set $STS_CG32 = 0xC
-set $STS_IG32 = 0xE
-set $STS_TG32 = 0xF
-
-define outputsts
-  while 1
-    if $arg0 == $STS_T16A
-      echo STS_T16A
-      loop_break
-    end
-    if $arg0 == $STS_LDT
-      echo STS_LDT\ 
-      loop_break
-    end
-    if $arg0 == $STS_T16B
-      echo STS_T16B
-      loop_break
-    end
-    if $arg0 == $STS_CG16
-      echo STS_CG16
-      loop_break
-    end
-    if $arg0 == $STS_TG
-      echo STS_TG\ \ 
-      loop_break
-    end
-    if $arg0 == $STS_IG16
-      echo STS_IG16
-      loop_break
-    end
-    if $arg0 == $STS_TG16
-      echo STS_TG16
-      loop_break
-    end
-    if $arg0 == $STS_T32A
-      echo STS_T32A
-      loop_break
-    end
-    if $arg0 == $STS_T32B
-      echo STS_T32B
-      loop_break
-    end
-    if $arg0 == $STS_CG32
-      echo STS_CG32
-      loop_break
-    end
-    if $arg0 == $STS_IG32
-      echo STS_IG32
-      loop_break
-    end
-    if $arg0 == $STS_TG32
-      echo STS_TG32
-      loop_break
-    end
-    echo Reserved
-    loop_break
-  end
-end  
-
-# IA32 2007, Volume 3A, Table 3-1
-set $STA_X = 0x8
-set $STA_E = 0x4
-set $STA_C = 0x4
-set $STA_W = 0x2
-set $STA_R = 0x2
-set $STA_A = 0x1
-
-define outputsta
-  if $arg0 & $STA_X
-    # Code segment
-    echo code
-    if $arg0 & $STA_C
-      echo |STA_C
-    end
-    if $arg0 & $STA_R
-      echo |STA_R
-    end
-  else
-    # Data segment
-    echo data
-    if $arg0 & $STA_E
-      echo |STA_E
-    end
-    if $arg0 & $STA_W
-      echo |STA_W
-    end
-  end
-  if $arg0 & $STA_A
-    echo |STA_A
-  else
-    printf "      "
-  end
-end
-
-# xv6-specific
-set $SEG_KCODE = 1
-set $SEG_KDATA = 2
-set $SEG_KCPU  = 3
-set $SEG_UCODE = 4
-set $SEG_UDATA = 5
-set $SEG_TSS   = 6
-
-define outputcs
-  if ($arg0 & 4) == 0
-    if $arg0 >> 3 == $SEG_KCODE
-      printf "SEG_KCODE<<3"
-    end
-    if $arg0 >> 3 == $SEG_KDATA
-      printf "SEG_KDATA<<3"
-    end
-    if $arg0 >> 3 == $SEG_KCPU
-      printf "SEG_KCPU<<3"
-    end
-    if $arg0 >> 3 == $SEG_UCODE
-      printf "SEG_UCODE<<3"
-    end
-    if $arg0 >> 3 == $SEG_UDATA
-      printf "SEG_UDATA<<3"
-    end
-    if $arg0 >> 3 == $SEG_TSS
-      printf "SEG_TSS<<3"
-    end
-    if ($arg0 >> 3 < 1) + ($arg0 >> 3 > 6)
-      printf "GDT[%d]", $arg0 >> 3
-    end
-  else
-    printf "LDT[%d]", $arg0 >> 3
-  end
-  if ($arg0 & 3) > 0
-    printf "|"
-    outputdpl ($arg0&3)
-  end
-end
-
-define outputdpl
-  if $arg0 == 0
-    printf "DPL_KERN"
-  else
-    if $arg0 == 3
-      printf "DPL_USER"
-    else
-      printf "DPL%d", $arg0
-    end
-  end
-end
-
-define printdesc
-  if $argc != 1
-    echo Usage: printdesc expr
-  else
-    _printdesc ((uint*)&($arg0))[0] ((uint*)&($arg0))[1]
-    printf "\n"
-  end
-end
-
-document printdesc
-Print an x86 segment or gate descriptor.
-printdesc EXPR
-EXPR must evaluate to a descriptor value.  It can be of any C type.
-end
-
-define _printdesc
-  _printdesc1 $arg0 $arg1 ($arg1>>15&1) ($arg1>>13&3) ($arg1>>12&1) ($arg1>>8&15)
-end
-
-define _printdesc1
-  # 2:P 3:DPL 4:S 5:Type
-  if $arg2 == 0
-    printf "P = 0 (Not present)"
-  else
-    printf "type = "
-    if $arg4 == 0
-      # System segment
-      outputsts $arg5
-      printf " (0x%x)    ", $arg5
-      _printsysdesc $arg0 $arg1 $arg5
-    else
-      # Code/data segment
-      outputsta $arg5
-      printf "  "
-      _printsegdesc $arg0 $arg1
-    end
-
-    printf "  DPL = "
-    outputdpl $arg3
-    printf " (%d)", $arg3
-  end
-end
-
-define _printsysdesc
-  # 2:Type
-  # GDB's || is buggy
-  if ($arg2 == $STS_TG) + (($arg2&7) == $STS_IG16) + (($arg2&7) == $STS_TG16)
-    # Gate descriptor
-    _printgate $arg2 ($arg0>>16) ($arg0&0xFFFF) ($arg1>>16)
-  else
-    # System segment descriptor
-    _printsegdesc $arg0 $arg1
-  end
-end
-
-define _printgate
-  # IA32 2007, Voume 3A, Figure 5-2
-  # 0:Type 1:CS 2:Offset 15..0 3:Offset 31..16
-  printf "CS = "
-  outputcs $arg1
-  printf " (%d)", $arg1
-
-  if (($arg0&7) == $STS_IG16) + (($arg0&7) == $STS_TG16)
-    printf "  Offset = "
-    output/a $arg3 << 16 | $arg2
-  end
-end
-
-define _printsegdesc
-  # IA32 20007, Volume 3A, Figure 3-8 and Figure 4-1
-  _printsegdesc1 ($arg0>>16) ($arg1&0xFF) ($arg1>>24) ($arg0&0xFFFF) ($arg1>>16&15) ($arg1>>23&1)
-  if ($arg1>>12&1) == 1
-    printf "  AVL = %d", $arg1>>20&1
-    if ($arg1>>11&1) == 0
-      # Data segment
-      if ($arg1>>22&1) == 0
-        printf "  B = small (0) "
-      else
-        printf "  B = big (1)   "
-      end
-    else
-      # Code segment
-      printf "  D = "
-      if ($arg1>>22&1) == 0
-        printf "16-bit (0)"
-      else
-        printf "32-bit (1)"
-      end
-    end
-  end
-end
-
-define _printsegdesc1
-  # 0:Base 0..15  1:Base 16..23  2:Base 24..32  3:Limit 0..15  4:Limit 16..19  5:G
-  printf "base = 0x%08x", $arg0 | ($arg1<<16) | ($arg2<<24)
-  printf "  limit = 0x"
-  if $arg5 == 0
-    printf "%08x", $arg3 | ($arg4<<16)
-  else
-    printf "%08x", (($arg3 | ($arg4<<16)) << 12) | 0xFFF
-  end
-end
-
-define printdescs
-  if $argc < 1 || $argc > 2
-    echo Usage: printdescs expr [count]
-  else
-    if $argc == 1
-      _printdescs ($arg0) (sizeof($arg0)/sizeof(($arg0)[0]))
-    else
-      _printdescs ($arg0) ($arg1)
-    end
-  end
-end
-
-document printdescs
-Print an array of x86 segment or gate descriptors.
-printdescs EXPR [COUNT]
-EXPR must evaluate to an array of descriptors.
-end
-
-define _printdescs
-  set $i = 0
-  while $i < $arg1
-    printf "[%d] ", $i
-    printdesc $arg0[$i]
-    set $i = $i + 1
-  end
-end
diff --git a/xv6-public/Operating-System-Project/getCBTtest.asm b/xv6-public/Operating-System-Project/getCBTtest.asm
deleted file mode 100644
index 28ee109..0000000
--- a/xv6-public/Operating-System-Project/getCBTtest.asm
+++ /dev/null
@@ -1,1245 +0,0 @@
-
-_getCBTtest:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main()
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	51                   	push   %ecx
-  12:	83 ec 0c             	sub    $0xc,%esp
-    printf(1, "This is getCBTtest template!");
-  15:	68 c8 07 00 00       	push   $0x7c8
-  1a:	6a 01                	push   $0x1
-  1c:	e8 3f 04 00 00       	call   460 <printf>
-
-    while (wait() != -1)
-  21:	83 c4 10             	add    $0x10,%esp
-  24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  28:	e8 7e 02 00 00       	call   2ab <wait>
-  2d:	83 f8 ff             	cmp    $0xffffffff,%eax
-  30:	75 f6                	jne    28 <main+0x28>
-        ;
-
-    exit();
-  32:	e8 6c 02 00 00       	call   2a3 <exit>
-  37:	66 90                	xchg   %ax,%ax
-  39:	66 90                	xchg   %ax,%ax
-  3b:	66 90                	xchg   %ax,%ax
-  3d:	66 90                	xchg   %ax,%ax
-  3f:	90                   	nop
-
-00000040 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  40:	f3 0f 1e fb          	endbr32 
-  44:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  45:	31 c0                	xor    %eax,%eax
-{
-  47:	89 e5                	mov    %esp,%ebp
-  49:	53                   	push   %ebx
-  4a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  4d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-  50:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-  54:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-  57:	83 c0 01             	add    $0x1,%eax
-  5a:	84 d2                	test   %dl,%dl
-  5c:	75 f2                	jne    50 <strcpy+0x10>
-    ;
-  return os;
-}
-  5e:	89 c8                	mov    %ecx,%eax
-  60:	5b                   	pop    %ebx
-  61:	5d                   	pop    %ebp
-  62:	c3                   	ret    
-  63:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000070 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-  70:	f3 0f 1e fb          	endbr32 
-  74:	55                   	push   %ebp
-  75:	89 e5                	mov    %esp,%ebp
-  77:	53                   	push   %ebx
-  78:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  7b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-  7e:	0f b6 01             	movzbl (%ecx),%eax
-  81:	0f b6 1a             	movzbl (%edx),%ebx
-  84:	84 c0                	test   %al,%al
-  86:	75 19                	jne    a1 <strcmp+0x31>
-  88:	eb 26                	jmp    b0 <strcmp+0x40>
-  8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  90:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-  94:	83 c1 01             	add    $0x1,%ecx
-  97:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-  9a:	0f b6 1a             	movzbl (%edx),%ebx
-  9d:	84 c0                	test   %al,%al
-  9f:	74 0f                	je     b0 <strcmp+0x40>
-  a1:	38 d8                	cmp    %bl,%al
-  a3:	74 eb                	je     90 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-  a5:	29 d8                	sub    %ebx,%eax
-}
-  a7:	5b                   	pop    %ebx
-  a8:	5d                   	pop    %ebp
-  a9:	c3                   	ret    
-  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  b0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-  b2:	29 d8                	sub    %ebx,%eax
-}
-  b4:	5b                   	pop    %ebx
-  b5:	5d                   	pop    %ebp
-  b6:	c3                   	ret    
-  b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  be:	66 90                	xchg   %ax,%ax
-
-000000c0 <strlen>:
-
-uint
-strlen(const char *s)
-{
-  c0:	f3 0f 1e fb          	endbr32 
-  c4:	55                   	push   %ebp
-  c5:	89 e5                	mov    %esp,%ebp
-  c7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
-  ca:	80 3a 00             	cmpb   $0x0,(%edx)
-  cd:	74 21                	je     f0 <strlen+0x30>
-  cf:	31 c0                	xor    %eax,%eax
-  d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  d8:	83 c0 01             	add    $0x1,%eax
-  db:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
-  df:	89 c1                	mov    %eax,%ecx
-  e1:	75 f5                	jne    d8 <strlen+0x18>
-    ;
-  return n;
-}
-  e3:	89 c8                	mov    %ecx,%eax
-  e5:	5d                   	pop    %ebp
-  e6:	c3                   	ret    
-  e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  ee:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
-  f0:	31 c9                	xor    %ecx,%ecx
-}
-  f2:	5d                   	pop    %ebp
-  f3:	89 c8                	mov    %ecx,%eax
-  f5:	c3                   	ret    
-  f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  fd:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000100 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 100:	f3 0f 1e fb          	endbr32 
- 104:	55                   	push   %ebp
- 105:	89 e5                	mov    %esp,%ebp
- 107:	57                   	push   %edi
- 108:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 10b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 10e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 111:	89 d7                	mov    %edx,%edi
- 113:	fc                   	cld    
- 114:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 116:	89 d0                	mov    %edx,%eax
- 118:	5f                   	pop    %edi
- 119:	5d                   	pop    %ebp
- 11a:	c3                   	ret    
- 11b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 11f:	90                   	nop
-
-00000120 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 120:	f3 0f 1e fb          	endbr32 
- 124:	55                   	push   %ebp
- 125:	89 e5                	mov    %esp,%ebp
- 127:	8b 45 08             	mov    0x8(%ebp),%eax
- 12a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 12e:	0f b6 10             	movzbl (%eax),%edx
- 131:	84 d2                	test   %dl,%dl
- 133:	75 16                	jne    14b <strchr+0x2b>
- 135:	eb 21                	jmp    158 <strchr+0x38>
- 137:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 13e:	66 90                	xchg   %ax,%ax
- 140:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 144:	83 c0 01             	add    $0x1,%eax
- 147:	84 d2                	test   %dl,%dl
- 149:	74 0d                	je     158 <strchr+0x38>
-    if(*s == c)
- 14b:	38 d1                	cmp    %dl,%cl
- 14d:	75 f1                	jne    140 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 14f:	5d                   	pop    %ebp
- 150:	c3                   	ret    
- 151:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 158:	31 c0                	xor    %eax,%eax
-}
- 15a:	5d                   	pop    %ebp
- 15b:	c3                   	ret    
- 15c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000160 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 160:	f3 0f 1e fb          	endbr32 
- 164:	55                   	push   %ebp
- 165:	89 e5                	mov    %esp,%ebp
- 167:	57                   	push   %edi
- 168:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 169:	31 f6                	xor    %esi,%esi
-{
- 16b:	53                   	push   %ebx
- 16c:	89 f3                	mov    %esi,%ebx
- 16e:	83 ec 1c             	sub    $0x1c,%esp
- 171:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 174:	eb 33                	jmp    1a9 <gets+0x49>
- 176:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 17d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 180:	83 ec 04             	sub    $0x4,%esp
- 183:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 186:	6a 01                	push   $0x1
- 188:	50                   	push   %eax
- 189:	6a 00                	push   $0x0
- 18b:	e8 2b 01 00 00       	call   2bb <read>
-    if(cc < 1)
- 190:	83 c4 10             	add    $0x10,%esp
- 193:	85 c0                	test   %eax,%eax
- 195:	7e 1c                	jle    1b3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 197:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 19b:	83 c7 01             	add    $0x1,%edi
- 19e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 1a1:	3c 0a                	cmp    $0xa,%al
- 1a3:	74 23                	je     1c8 <gets+0x68>
- 1a5:	3c 0d                	cmp    $0xd,%al
- 1a7:	74 1f                	je     1c8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 1a9:	83 c3 01             	add    $0x1,%ebx
- 1ac:	89 fe                	mov    %edi,%esi
- 1ae:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 1b1:	7c cd                	jl     180 <gets+0x20>
- 1b3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 1b5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 1b8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1be:	5b                   	pop    %ebx
- 1bf:	5e                   	pop    %esi
- 1c0:	5f                   	pop    %edi
- 1c1:	5d                   	pop    %ebp
- 1c2:	c3                   	ret    
- 1c3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 1c7:	90                   	nop
- 1c8:	8b 75 08             	mov    0x8(%ebp),%esi
- 1cb:	8b 45 08             	mov    0x8(%ebp),%eax
- 1ce:	01 de                	add    %ebx,%esi
- 1d0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 1d2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1d8:	5b                   	pop    %ebx
- 1d9:	5e                   	pop    %esi
- 1da:	5f                   	pop    %edi
- 1db:	5d                   	pop    %ebp
- 1dc:	c3                   	ret    
- 1dd:	8d 76 00             	lea    0x0(%esi),%esi
-
-000001e0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 1e0:	f3 0f 1e fb          	endbr32 
- 1e4:	55                   	push   %ebp
- 1e5:	89 e5                	mov    %esp,%ebp
- 1e7:	56                   	push   %esi
- 1e8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 1e9:	83 ec 08             	sub    $0x8,%esp
- 1ec:	6a 00                	push   $0x0
- 1ee:	ff 75 08             	pushl  0x8(%ebp)
- 1f1:	e8 ed 00 00 00       	call   2e3 <open>
-  if(fd < 0)
- 1f6:	83 c4 10             	add    $0x10,%esp
- 1f9:	85 c0                	test   %eax,%eax
- 1fb:	78 2b                	js     228 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 1fd:	83 ec 08             	sub    $0x8,%esp
- 200:	ff 75 0c             	pushl  0xc(%ebp)
- 203:	89 c3                	mov    %eax,%ebx
- 205:	50                   	push   %eax
- 206:	e8 f0 00 00 00       	call   2fb <fstat>
-  close(fd);
- 20b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 20e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 210:	e8 b6 00 00 00       	call   2cb <close>
-  return r;
- 215:	83 c4 10             	add    $0x10,%esp
-}
- 218:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 21b:	89 f0                	mov    %esi,%eax
- 21d:	5b                   	pop    %ebx
- 21e:	5e                   	pop    %esi
- 21f:	5d                   	pop    %ebp
- 220:	c3                   	ret    
- 221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 228:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 22d:	eb e9                	jmp    218 <stat+0x38>
- 22f:	90                   	nop
-
-00000230 <atoi>:
-
-int
-atoi(const char *s)
-{
- 230:	f3 0f 1e fb          	endbr32 
- 234:	55                   	push   %ebp
- 235:	89 e5                	mov    %esp,%ebp
- 237:	53                   	push   %ebx
- 238:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 23b:	0f be 02             	movsbl (%edx),%eax
- 23e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 241:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 244:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 249:	77 1a                	ja     265 <atoi+0x35>
- 24b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 24f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 250:	83 c2 01             	add    $0x1,%edx
- 253:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 256:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 25a:	0f be 02             	movsbl (%edx),%eax
- 25d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 260:	80 fb 09             	cmp    $0x9,%bl
- 263:	76 eb                	jbe    250 <atoi+0x20>
-  return n;
-}
- 265:	89 c8                	mov    %ecx,%eax
- 267:	5b                   	pop    %ebx
- 268:	5d                   	pop    %ebp
- 269:	c3                   	ret    
- 26a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000270 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 270:	f3 0f 1e fb          	endbr32 
- 274:	55                   	push   %ebp
- 275:	89 e5                	mov    %esp,%ebp
- 277:	57                   	push   %edi
- 278:	8b 45 10             	mov    0x10(%ebp),%eax
- 27b:	8b 55 08             	mov    0x8(%ebp),%edx
- 27e:	56                   	push   %esi
- 27f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 282:	85 c0                	test   %eax,%eax
- 284:	7e 0f                	jle    295 <memmove+0x25>
- 286:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 288:	89 d7                	mov    %edx,%edi
- 28a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 290:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 291:	39 f8                	cmp    %edi,%eax
- 293:	75 fb                	jne    290 <memmove+0x20>
-  return vdst;
-}
- 295:	5e                   	pop    %esi
- 296:	89 d0                	mov    %edx,%eax
- 298:	5f                   	pop    %edi
- 299:	5d                   	pop    %ebp
- 29a:	c3                   	ret    
-
-0000029b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 29b:	b8 01 00 00 00       	mov    $0x1,%eax
- 2a0:	cd 40                	int    $0x40
- 2a2:	c3                   	ret    
-
-000002a3 <exit>:
-SYSCALL(exit)
- 2a3:	b8 02 00 00 00       	mov    $0x2,%eax
- 2a8:	cd 40                	int    $0x40
- 2aa:	c3                   	ret    
-
-000002ab <wait>:
-SYSCALL(wait)
- 2ab:	b8 03 00 00 00       	mov    $0x3,%eax
- 2b0:	cd 40                	int    $0x40
- 2b2:	c3                   	ret    
-
-000002b3 <pipe>:
-SYSCALL(pipe)
- 2b3:	b8 04 00 00 00       	mov    $0x4,%eax
- 2b8:	cd 40                	int    $0x40
- 2ba:	c3                   	ret    
-
-000002bb <read>:
-SYSCALL(read)
- 2bb:	b8 05 00 00 00       	mov    $0x5,%eax
- 2c0:	cd 40                	int    $0x40
- 2c2:	c3                   	ret    
-
-000002c3 <write>:
-SYSCALL(write)
- 2c3:	b8 10 00 00 00       	mov    $0x10,%eax
- 2c8:	cd 40                	int    $0x40
- 2ca:	c3                   	ret    
-
-000002cb <close>:
-SYSCALL(close)
- 2cb:	b8 15 00 00 00       	mov    $0x15,%eax
- 2d0:	cd 40                	int    $0x40
- 2d2:	c3                   	ret    
-
-000002d3 <kill>:
-SYSCALL(kill)
- 2d3:	b8 06 00 00 00       	mov    $0x6,%eax
- 2d8:	cd 40                	int    $0x40
- 2da:	c3                   	ret    
-
-000002db <exec>:
-SYSCALL(exec)
- 2db:	b8 07 00 00 00       	mov    $0x7,%eax
- 2e0:	cd 40                	int    $0x40
- 2e2:	c3                   	ret    
-
-000002e3 <open>:
-SYSCALL(open)
- 2e3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 2e8:	cd 40                	int    $0x40
- 2ea:	c3                   	ret    
-
-000002eb <mknod>:
-SYSCALL(mknod)
- 2eb:	b8 11 00 00 00       	mov    $0x11,%eax
- 2f0:	cd 40                	int    $0x40
- 2f2:	c3                   	ret    
-
-000002f3 <unlink>:
-SYSCALL(unlink)
- 2f3:	b8 12 00 00 00       	mov    $0x12,%eax
- 2f8:	cd 40                	int    $0x40
- 2fa:	c3                   	ret    
-
-000002fb <fstat>:
-SYSCALL(fstat)
- 2fb:	b8 08 00 00 00       	mov    $0x8,%eax
- 300:	cd 40                	int    $0x40
- 302:	c3                   	ret    
-
-00000303 <link>:
-SYSCALL(link)
- 303:	b8 13 00 00 00       	mov    $0x13,%eax
- 308:	cd 40                	int    $0x40
- 30a:	c3                   	ret    
-
-0000030b <mkdir>:
-SYSCALL(mkdir)
- 30b:	b8 14 00 00 00       	mov    $0x14,%eax
- 310:	cd 40                	int    $0x40
- 312:	c3                   	ret    
-
-00000313 <chdir>:
-SYSCALL(chdir)
- 313:	b8 09 00 00 00       	mov    $0x9,%eax
- 318:	cd 40                	int    $0x40
- 31a:	c3                   	ret    
-
-0000031b <dup>:
-SYSCALL(dup)
- 31b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 320:	cd 40                	int    $0x40
- 322:	c3                   	ret    
-
-00000323 <getpid>:
-SYSCALL(getpid)
- 323:	b8 0b 00 00 00       	mov    $0xb,%eax
- 328:	cd 40                	int    $0x40
- 32a:	c3                   	ret    
-
-0000032b <sbrk>:
-SYSCALL(sbrk)
- 32b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 330:	cd 40                	int    $0x40
- 332:	c3                   	ret    
-
-00000333 <sleep>:
-SYSCALL(sleep)
- 333:	b8 0d 00 00 00       	mov    $0xd,%eax
- 338:	cd 40                	int    $0x40
- 33a:	c3                   	ret    
-
-0000033b <uptime>:
-SYSCALL(uptime)
- 33b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 340:	cd 40                	int    $0x40
- 342:	c3                   	ret    
-
-00000343 <getParentID>:
-SYSCALL(getParentID)
- 343:	b8 16 00 00 00       	mov    $0x16,%eax
- 348:	cd 40                	int    $0x40
- 34a:	c3                   	ret    
-
-0000034b <getChildren>:
-SYSCALL(getChildren)
- 34b:	b8 17 00 00 00       	mov    $0x17,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 353:	b8 18 00 00 00       	mov    $0x18,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <setPriority>:
-SYSCALL(setPriority)
- 35b:	b8 19 00 00 00       	mov    $0x19,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <changePolicy>:
-SYSCALL(changePolicy)
- 363:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 36b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 373:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <getCBT>:
-SYSCALL(getCBT)
- 37b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <customWait>:
-SYSCALL(customWait)
- 383:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <setQueue>:
-SYSCALL(setQueue)
- 38b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <getBurstTime>:
-SYSCALL(getBurstTime)
- 393:	b8 20 00 00 00       	mov    $0x20,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <getCreationTime>:
- 39b:	b8 21 00 00 00       	mov    $0x21,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
- 3a3:	66 90                	xchg   %ax,%ax
- 3a5:	66 90                	xchg   %ax,%ax
- 3a7:	66 90                	xchg   %ax,%ax
- 3a9:	66 90                	xchg   %ax,%ax
- 3ab:	66 90                	xchg   %ax,%ax
- 3ad:	66 90                	xchg   %ax,%ax
- 3af:	90                   	nop
-
-000003b0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 3b0:	55                   	push   %ebp
- 3b1:	89 e5                	mov    %esp,%ebp
- 3b3:	57                   	push   %edi
- 3b4:	56                   	push   %esi
- 3b5:	53                   	push   %ebx
- 3b6:	83 ec 3c             	sub    $0x3c,%esp
- 3b9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 3bc:	89 d1                	mov    %edx,%ecx
-{
- 3be:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 3c1:	85 d2                	test   %edx,%edx
- 3c3:	0f 89 7f 00 00 00    	jns    448 <printint+0x98>
- 3c9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 3cd:	74 79                	je     448 <printint+0x98>
-    neg = 1;
- 3cf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 3d6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 3d8:	31 db                	xor    %ebx,%ebx
- 3da:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 3dd:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 3e0:	89 c8                	mov    %ecx,%eax
- 3e2:	31 d2                	xor    %edx,%edx
- 3e4:	89 cf                	mov    %ecx,%edi
- 3e6:	f7 75 c4             	divl   -0x3c(%ebp)
- 3e9:	0f b6 92 ec 07 00 00 	movzbl 0x7ec(%edx),%edx
- 3f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 3f3:	89 d8                	mov    %ebx,%eax
- 3f5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 3f8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 3fb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 3fe:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 401:	76 dd                	jbe    3e0 <printint+0x30>
-  if(neg)
- 403:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 406:	85 c9                	test   %ecx,%ecx
- 408:	74 0c                	je     416 <printint+0x66>
-    buf[i++] = '-';
- 40a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 40f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 411:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 416:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 419:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 41d:	eb 07                	jmp    426 <printint+0x76>
- 41f:	90                   	nop
- 420:	0f b6 13             	movzbl (%ebx),%edx
- 423:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 426:	83 ec 04             	sub    $0x4,%esp
- 429:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 42c:	6a 01                	push   $0x1
- 42e:	56                   	push   %esi
- 42f:	57                   	push   %edi
- 430:	e8 8e fe ff ff       	call   2c3 <write>
-  while(--i >= 0)
- 435:	83 c4 10             	add    $0x10,%esp
- 438:	39 de                	cmp    %ebx,%esi
- 43a:	75 e4                	jne    420 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 43c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 43f:	5b                   	pop    %ebx
- 440:	5e                   	pop    %esi
- 441:	5f                   	pop    %edi
- 442:	5d                   	pop    %ebp
- 443:	c3                   	ret    
- 444:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 448:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 44f:	eb 87                	jmp    3d8 <printint+0x28>
- 451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 458:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 45f:	90                   	nop
-
-00000460 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 460:	f3 0f 1e fb          	endbr32 
- 464:	55                   	push   %ebp
- 465:	89 e5                	mov    %esp,%ebp
- 467:	57                   	push   %edi
- 468:	56                   	push   %esi
- 469:	53                   	push   %ebx
- 46a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 46d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 470:	0f b6 1e             	movzbl (%esi),%ebx
- 473:	84 db                	test   %bl,%bl
- 475:	0f 84 b4 00 00 00    	je     52f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 47b:	8d 45 10             	lea    0x10(%ebp),%eax
- 47e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 481:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 484:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 486:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 489:	eb 33                	jmp    4be <printf+0x5e>
- 48b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 48f:	90                   	nop
- 490:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 493:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 498:	83 f8 25             	cmp    $0x25,%eax
- 49b:	74 17                	je     4b4 <printf+0x54>
-  write(fd, &c, 1);
- 49d:	83 ec 04             	sub    $0x4,%esp
- 4a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 4a3:	6a 01                	push   $0x1
- 4a5:	57                   	push   %edi
- 4a6:	ff 75 08             	pushl  0x8(%ebp)
- 4a9:	e8 15 fe ff ff       	call   2c3 <write>
- 4ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 4b1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 4b4:	0f b6 1e             	movzbl (%esi),%ebx
- 4b7:	83 c6 01             	add    $0x1,%esi
- 4ba:	84 db                	test   %bl,%bl
- 4bc:	74 71                	je     52f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 4be:	0f be cb             	movsbl %bl,%ecx
- 4c1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 4c4:	85 d2                	test   %edx,%edx
- 4c6:	74 c8                	je     490 <printf+0x30>
-      }
-    } else if(state == '%'){
- 4c8:	83 fa 25             	cmp    $0x25,%edx
- 4cb:	75 e7                	jne    4b4 <printf+0x54>
-      if(c == 'd'){
- 4cd:	83 f8 64             	cmp    $0x64,%eax
- 4d0:	0f 84 9a 00 00 00    	je     570 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 4d6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 4dc:	83 f9 70             	cmp    $0x70,%ecx
- 4df:	74 5f                	je     540 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 4e1:	83 f8 73             	cmp    $0x73,%eax
- 4e4:	0f 84 d6 00 00 00    	je     5c0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 4ea:	83 f8 63             	cmp    $0x63,%eax
- 4ed:	0f 84 8d 00 00 00    	je     580 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 4f3:	83 f8 25             	cmp    $0x25,%eax
- 4f6:	0f 84 b4 00 00 00    	je     5b0 <printf+0x150>
-  write(fd, &c, 1);
- 4fc:	83 ec 04             	sub    $0x4,%esp
- 4ff:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 503:	6a 01                	push   $0x1
- 505:	57                   	push   %edi
- 506:	ff 75 08             	pushl  0x8(%ebp)
- 509:	e8 b5 fd ff ff       	call   2c3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 50e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 511:	83 c4 0c             	add    $0xc,%esp
- 514:	6a 01                	push   $0x1
- 516:	83 c6 01             	add    $0x1,%esi
- 519:	57                   	push   %edi
- 51a:	ff 75 08             	pushl  0x8(%ebp)
- 51d:	e8 a1 fd ff ff       	call   2c3 <write>
-  for(i = 0; fmt[i]; i++){
- 522:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 526:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 529:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 52b:	84 db                	test   %bl,%bl
- 52d:	75 8f                	jne    4be <printf+0x5e>
-    }
-  }
-}
- 52f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 532:	5b                   	pop    %ebx
- 533:	5e                   	pop    %esi
- 534:	5f                   	pop    %edi
- 535:	5d                   	pop    %ebp
- 536:	c3                   	ret    
- 537:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 53e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 540:	83 ec 0c             	sub    $0xc,%esp
- 543:	b9 10 00 00 00       	mov    $0x10,%ecx
- 548:	6a 00                	push   $0x0
- 54a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 54d:	8b 45 08             	mov    0x8(%ebp),%eax
- 550:	8b 13                	mov    (%ebx),%edx
- 552:	e8 59 fe ff ff       	call   3b0 <printint>
-        ap++;
- 557:	89 d8                	mov    %ebx,%eax
- 559:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 55c:	31 d2                	xor    %edx,%edx
-        ap++;
- 55e:	83 c0 04             	add    $0x4,%eax
- 561:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 564:	e9 4b ff ff ff       	jmp    4b4 <printf+0x54>
- 569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 570:	83 ec 0c             	sub    $0xc,%esp
- 573:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 578:	6a 01                	push   $0x1
- 57a:	eb ce                	jmp    54a <printf+0xea>
- 57c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 580:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 583:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 586:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 588:	6a 01                	push   $0x1
-        ap++;
- 58a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 58d:	57                   	push   %edi
- 58e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 591:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 594:	e8 2a fd ff ff       	call   2c3 <write>
-        ap++;
- 599:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 59c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 59f:	31 d2                	xor    %edx,%edx
- 5a1:	e9 0e ff ff ff       	jmp    4b4 <printf+0x54>
- 5a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5ad:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 5b0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5b3:	83 ec 04             	sub    $0x4,%esp
- 5b6:	e9 59 ff ff ff       	jmp    514 <printf+0xb4>
- 5bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 5bf:	90                   	nop
-        s = (char*)*ap;
- 5c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 5c3:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 5c5:	83 c0 04             	add    $0x4,%eax
- 5c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 5cb:	85 db                	test   %ebx,%ebx
- 5cd:	74 17                	je     5e6 <printf+0x186>
-        while(*s != 0){
- 5cf:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 5d2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 5d4:	84 c0                	test   %al,%al
- 5d6:	0f 84 d8 fe ff ff    	je     4b4 <printf+0x54>
- 5dc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5df:	89 de                	mov    %ebx,%esi
- 5e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 5e4:	eb 1a                	jmp    600 <printf+0x1a0>
-          s = "(null)";
- 5e6:	bb e5 07 00 00       	mov    $0x7e5,%ebx
-        while(*s != 0){
- 5eb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5ee:	b8 28 00 00 00       	mov    $0x28,%eax
- 5f3:	89 de                	mov    %ebx,%esi
- 5f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 5f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5ff:	90                   	nop
-  write(fd, &c, 1);
- 600:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 603:	83 c6 01             	add    $0x1,%esi
- 606:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 609:	6a 01                	push   $0x1
- 60b:	57                   	push   %edi
- 60c:	53                   	push   %ebx
- 60d:	e8 b1 fc ff ff       	call   2c3 <write>
-        while(*s != 0){
- 612:	0f b6 06             	movzbl (%esi),%eax
- 615:	83 c4 10             	add    $0x10,%esp
- 618:	84 c0                	test   %al,%al
- 61a:	75 e4                	jne    600 <printf+0x1a0>
- 61c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 61f:	31 d2                	xor    %edx,%edx
- 621:	e9 8e fe ff ff       	jmp    4b4 <printf+0x54>
- 626:	66 90                	xchg   %ax,%ax
- 628:	66 90                	xchg   %ax,%ax
- 62a:	66 90                	xchg   %ax,%ax
- 62c:	66 90                	xchg   %ax,%ax
- 62e:	66 90                	xchg   %ax,%ax
-
-00000630 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 630:	f3 0f 1e fb          	endbr32 
- 634:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 635:	a1 94 0a 00 00       	mov    0xa94,%eax
-{
- 63a:	89 e5                	mov    %esp,%ebp
- 63c:	57                   	push   %edi
- 63d:	56                   	push   %esi
- 63e:	53                   	push   %ebx
- 63f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 642:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 644:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 647:	39 c8                	cmp    %ecx,%eax
- 649:	73 15                	jae    660 <free+0x30>
- 64b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 64f:	90                   	nop
- 650:	39 d1                	cmp    %edx,%ecx
- 652:	72 14                	jb     668 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 654:	39 d0                	cmp    %edx,%eax
- 656:	73 10                	jae    668 <free+0x38>
-{
- 658:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 65a:	8b 10                	mov    (%eax),%edx
- 65c:	39 c8                	cmp    %ecx,%eax
- 65e:	72 f0                	jb     650 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 660:	39 d0                	cmp    %edx,%eax
- 662:	72 f4                	jb     658 <free+0x28>
- 664:	39 d1                	cmp    %edx,%ecx
- 666:	73 f0                	jae    658 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 668:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 66b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 66e:	39 fa                	cmp    %edi,%edx
- 670:	74 1e                	je     690 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 672:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 675:	8b 50 04             	mov    0x4(%eax),%edx
- 678:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 67b:	39 f1                	cmp    %esi,%ecx
- 67d:	74 28                	je     6a7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 67f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 681:	5b                   	pop    %ebx
-  freep = p;
- 682:	a3 94 0a 00 00       	mov    %eax,0xa94
-}
- 687:	5e                   	pop    %esi
- 688:	5f                   	pop    %edi
- 689:	5d                   	pop    %ebp
- 68a:	c3                   	ret    
- 68b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 68f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 690:	03 72 04             	add    0x4(%edx),%esi
- 693:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 696:	8b 10                	mov    (%eax),%edx
- 698:	8b 12                	mov    (%edx),%edx
- 69a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 69d:	8b 50 04             	mov    0x4(%eax),%edx
- 6a0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6a3:	39 f1                	cmp    %esi,%ecx
- 6a5:	75 d8                	jne    67f <free+0x4f>
-    p->s.size += bp->s.size;
- 6a7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 6aa:	a3 94 0a 00 00       	mov    %eax,0xa94
-    p->s.size += bp->s.size;
- 6af:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 6b2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 6b5:	89 10                	mov    %edx,(%eax)
-}
- 6b7:	5b                   	pop    %ebx
- 6b8:	5e                   	pop    %esi
- 6b9:	5f                   	pop    %edi
- 6ba:	5d                   	pop    %ebp
- 6bb:	c3                   	ret    
- 6bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000006c0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 6c0:	f3 0f 1e fb          	endbr32 
- 6c4:	55                   	push   %ebp
- 6c5:	89 e5                	mov    %esp,%ebp
- 6c7:	57                   	push   %edi
- 6c8:	56                   	push   %esi
- 6c9:	53                   	push   %ebx
- 6ca:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6cd:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 6d0:	8b 3d 94 0a 00 00    	mov    0xa94,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6d6:	8d 70 07             	lea    0x7(%eax),%esi
- 6d9:	c1 ee 03             	shr    $0x3,%esi
- 6dc:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 6df:	85 ff                	test   %edi,%edi
- 6e1:	0f 84 a9 00 00 00    	je     790 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 6e7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 6e9:	8b 48 04             	mov    0x4(%eax),%ecx
- 6ec:	39 f1                	cmp    %esi,%ecx
- 6ee:	73 6d                	jae    75d <malloc+0x9d>
- 6f0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 6f6:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 6fb:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 6fe:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 705:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 708:	eb 17                	jmp    721 <malloc+0x61>
- 70a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 710:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 712:	8b 4a 04             	mov    0x4(%edx),%ecx
- 715:	39 f1                	cmp    %esi,%ecx
- 717:	73 4f                	jae    768 <malloc+0xa8>
- 719:	8b 3d 94 0a 00 00    	mov    0xa94,%edi
- 71f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 721:	39 c7                	cmp    %eax,%edi
- 723:	75 eb                	jne    710 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 725:	83 ec 0c             	sub    $0xc,%esp
- 728:	ff 75 e4             	pushl  -0x1c(%ebp)
- 72b:	e8 fb fb ff ff       	call   32b <sbrk>
-  if(p == (char*)-1)
- 730:	83 c4 10             	add    $0x10,%esp
- 733:	83 f8 ff             	cmp    $0xffffffff,%eax
- 736:	74 1b                	je     753 <malloc+0x93>
-  hp->s.size = nu;
- 738:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 73b:	83 ec 0c             	sub    $0xc,%esp
- 73e:	83 c0 08             	add    $0x8,%eax
- 741:	50                   	push   %eax
- 742:	e8 e9 fe ff ff       	call   630 <free>
-  return freep;
- 747:	a1 94 0a 00 00       	mov    0xa94,%eax
-      if((p = morecore(nunits)) == 0)
- 74c:	83 c4 10             	add    $0x10,%esp
- 74f:	85 c0                	test   %eax,%eax
- 751:	75 bd                	jne    710 <malloc+0x50>
-        return 0;
-  }
-}
- 753:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 756:	31 c0                	xor    %eax,%eax
-}
- 758:	5b                   	pop    %ebx
- 759:	5e                   	pop    %esi
- 75a:	5f                   	pop    %edi
- 75b:	5d                   	pop    %ebp
- 75c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 75d:	89 c2                	mov    %eax,%edx
- 75f:	89 f8                	mov    %edi,%eax
- 761:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 768:	39 ce                	cmp    %ecx,%esi
- 76a:	74 54                	je     7c0 <malloc+0x100>
-        p->s.size -= nunits;
- 76c:	29 f1                	sub    %esi,%ecx
- 76e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 771:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 774:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 777:	a3 94 0a 00 00       	mov    %eax,0xa94
-}
- 77c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 77f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 782:	5b                   	pop    %ebx
- 783:	5e                   	pop    %esi
- 784:	5f                   	pop    %edi
- 785:	5d                   	pop    %ebp
- 786:	c3                   	ret    
- 787:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 78e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 790:	c7 05 94 0a 00 00 98 	movl   $0xa98,0xa94
- 797:	0a 00 00 
-    base.s.size = 0;
- 79a:	bf 98 0a 00 00       	mov    $0xa98,%edi
-    base.s.ptr = freep = prevp = &base;
- 79f:	c7 05 98 0a 00 00 98 	movl   $0xa98,0xa98
- 7a6:	0a 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7a9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 7ab:	c7 05 9c 0a 00 00 00 	movl   $0x0,0xa9c
- 7b2:	00 00 00 
-    if(p->s.size >= nunits){
- 7b5:	e9 36 ff ff ff       	jmp    6f0 <malloc+0x30>
- 7ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 7c0:	8b 0a                	mov    (%edx),%ecx
- 7c2:	89 08                	mov    %ecx,(%eax)
- 7c4:	eb b1                	jmp    777 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/getCBTtest.c b/xv6-public/Operating-System-Project/getCBTtest.c
deleted file mode 100644
index 92e630e..0000000
--- a/xv6-public/Operating-System-Project/getCBTtest.c
+++ /dev/null
@@ -1,13 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main()
-{
-    printf(1, "This is getCBTtest template!");
-
-    while (wait() != -1)
-        ;
-
-    exit();
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/getCBTtest.d b/xv6-public/Operating-System-Project/getCBTtest.d
deleted file mode 100644
index 456addb..0000000
--- a/xv6-public/Operating-System-Project/getCBTtest.d
+++ /dev/null
@@ -1,2 +0,0 @@
-getCBTtest.o: getCBTtest.c /usr/include/stdc-predef.h types.h stat.h \
- user.h
diff --git a/xv6-public/Operating-System-Project/getCBTtest.o b/xv6-public/Operating-System-Project/getCBTtest.o
deleted file mode 100644
index c9db802..0000000
Binary files a/xv6-public/Operating-System-Project/getCBTtest.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/getCBTtest.sym b/xv6-public/Operating-System-Project/getCBTtest.sym
deleted file mode 100644
index 0d37e17..0000000
--- a/xv6-public/Operating-System-Project/getCBTtest.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-000007c8 .rodata
-00000800 .eh_frame
-00000a94 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 getCBTtest.c
-00000000 ulib.c
-00000000 printf.c
-000003b0 printint
-000007ec digits.1109
-00000000 umalloc.c
-00000a94 freep
-00000a98 base
-00000040 strcpy
-0000034b getChildren
-00000460 printf
-00000270 memmove
-000002eb mknod
-00000160 gets
-00000323 getpid
-00000383 customWait
-0000037b getCBT
-000006c0 malloc
-00000333 sleep
-000002b3 pipe
-00000363 changePolicy
-000002c3 write
-000002fb fstat
-000002d3 kill
-00000313 chdir
-0000038b setQueue
-000002db exec
-000002ab wait
-000002bb read
-00000393 getBurstTime
-000002f3 unlink
-0000029b fork
-0000036b getTurnAroundTime
-0000032b sbrk
-0000033b uptime
-00000a94 __bss_start
-00000100 memset
-00000000 main
-00000070 strcmp
-0000031b dup
-00000353 getSyscallCounter
-00000343 getParentID
-000001e0 stat
-00000a94 _edata
-00000aa0 _end
-00000303 link
-000002a3 exit
-0000035b setPriority
-00000230 atoi
-0000039b getCreationTime
-000000c0 strlen
-000002e3 open
-00000120 strchr
-0000030b mkdir
-000002cb close
-00000373 getWaitingTime
-00000630 free
diff --git a/xv6-public/Operating-System-Project/getChildrenTest.asm b/xv6-public/Operating-System-Project/getChildrenTest.asm
deleted file mode 100644
index 5e6f0ce..0000000
--- a/xv6-public/Operating-System-Project/getChildrenTest.asm
+++ /dev/null
@@ -1,1318 +0,0 @@
-
-_getChildrenTest:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main()
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	57                   	push   %edi
-  12:	56                   	push   %esi
-  13:	53                   	push   %ebx
-  14:	51                   	push   %ecx
-  15:	83 ec 08             	sub    $0x8,%esp
-    int original_pid = getpid();
-  18:	e8 96 03 00 00       	call   3b3 <getpid>
-
-    int num_children;
-    int *children_pid = malloc(64 * sizeof(int));
-  1d:	83 ec 0c             	sub    $0xc,%esp
-  20:	68 00 01 00 00       	push   $0x100
-    int original_pid = getpid();
-  25:	89 c7                	mov    %eax,%edi
-    int *children_pid = malloc(64 * sizeof(int));
-  27:	e8 24 07 00 00       	call   750 <malloc>
-  2c:	89 c3                	mov    %eax,%ebx
-
-    for (int i = 0; i < 3; i++)
-    {
-        fork();
-  2e:	e8 f8 02 00 00       	call   32b <fork>
-  33:	e8 f3 02 00 00       	call   32b <fork>
-  38:	e8 ee 02 00 00       	call   32b <fork>
-    }
-
-    num_children = getChildren(children_pid);
-  3d:	89 1c 24             	mov    %ebx,(%esp)
-  40:	e8 96 03 00 00       	call   3db <getChildren>
-  45:	89 c6                	mov    %eax,%esi
-
-    if (getpid() == original_pid)
-  47:	e8 67 03 00 00       	call   3b3 <getpid>
-  4c:	83 c4 10             	add    $0x10,%esp
-  4f:	39 f8                	cmp    %edi,%eax
-  51:	74 14                	je     67 <main+0x67>
-  53:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  57:	90                   	nop
-            printf(1, "%d, ", children_pid[i]);
-        }
-        printf(1, "]\n");
-    }
-
-    while (wait() != -1)
-  58:	e8 de 02 00 00       	call   33b <wait>
-  5d:	83 f8 ff             	cmp    $0xffffffff,%eax
-  60:	75 f6                	jne    58 <main+0x58>
-        ;
-
-    exit();
-  62:	e8 cc 02 00 00       	call   333 <exit>
-        printf(1, "Original process ID: %d\n", original_pid);
-  67:	52                   	push   %edx
-  68:	50                   	push   %eax
-  69:	68 58 08 00 00       	push   $0x858
-  6e:	6a 01                	push   $0x1
-  70:	e8 7b 04 00 00       	call   4f0 <printf>
-        printf(1, "Number of children: %d\n", num_children);
-  75:	83 c4 0c             	add    $0xc,%esp
-  78:	56                   	push   %esi
-  79:	68 71 08 00 00       	push   $0x871
-  7e:	6a 01                	push   $0x1
-  80:	e8 6b 04 00 00       	call   4f0 <printf>
-        printf(1, "Child proccesses: [");
-  85:	59                   	pop    %ecx
-  86:	5f                   	pop    %edi
-  87:	68 89 08 00 00       	push   $0x889
-  8c:	6a 01                	push   $0x1
-  8e:	e8 5d 04 00 00       	call   4f0 <printf>
-        for (int i = 0; i < num_children; i++)
-  93:	83 c4 10             	add    $0x10,%esp
-  96:	85 f6                	test   %esi,%esi
-  98:	7e 21                	jle    bb <main+0xbb>
-  9a:	8d 34 b3             	lea    (%ebx,%esi,4),%esi
-  9d:	8d 76 00             	lea    0x0(%esi),%esi
-            printf(1, "%d, ", children_pid[i]);
-  a0:	83 ec 04             	sub    $0x4,%esp
-  a3:	ff 33                	pushl  (%ebx)
-  a5:	83 c3 04             	add    $0x4,%ebx
-  a8:	68 9d 08 00 00       	push   $0x89d
-  ad:	6a 01                	push   $0x1
-  af:	e8 3c 04 00 00       	call   4f0 <printf>
-        for (int i = 0; i < num_children; i++)
-  b4:	83 c4 10             	add    $0x10,%esp
-  b7:	39 de                	cmp    %ebx,%esi
-  b9:	75 e5                	jne    a0 <main+0xa0>
-        printf(1, "]\n");
-  bb:	50                   	push   %eax
-  bc:	50                   	push   %eax
-  bd:	68 a2 08 00 00       	push   $0x8a2
-  c2:	6a 01                	push   $0x1
-  c4:	e8 27 04 00 00       	call   4f0 <printf>
-  c9:	83 c4 10             	add    $0x10,%esp
-  cc:	eb 8a                	jmp    58 <main+0x58>
-  ce:	66 90                	xchg   %ax,%ax
-
-000000d0 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  d0:	f3 0f 1e fb          	endbr32 
-  d4:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  d5:	31 c0                	xor    %eax,%eax
-{
-  d7:	89 e5                	mov    %esp,%ebp
-  d9:	53                   	push   %ebx
-  da:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  dd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-  e0:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-  e4:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-  e7:	83 c0 01             	add    $0x1,%eax
-  ea:	84 d2                	test   %dl,%dl
-  ec:	75 f2                	jne    e0 <strcpy+0x10>
-    ;
-  return os;
-}
-  ee:	89 c8                	mov    %ecx,%eax
-  f0:	5b                   	pop    %ebx
-  f1:	5d                   	pop    %ebp
-  f2:	c3                   	ret    
-  f3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000100 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
- 100:	f3 0f 1e fb          	endbr32 
- 104:	55                   	push   %ebp
- 105:	89 e5                	mov    %esp,%ebp
- 107:	53                   	push   %ebx
- 108:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 10b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
- 10e:	0f b6 01             	movzbl (%ecx),%eax
- 111:	0f b6 1a             	movzbl (%edx),%ebx
- 114:	84 c0                	test   %al,%al
- 116:	75 19                	jne    131 <strcmp+0x31>
- 118:	eb 26                	jmp    140 <strcmp+0x40>
- 11a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 120:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
- 124:	83 c1 01             	add    $0x1,%ecx
- 127:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
- 12a:	0f b6 1a             	movzbl (%edx),%ebx
- 12d:	84 c0                	test   %al,%al
- 12f:	74 0f                	je     140 <strcmp+0x40>
- 131:	38 d8                	cmp    %bl,%al
- 133:	74 eb                	je     120 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
- 135:	29 d8                	sub    %ebx,%eax
-}
- 137:	5b                   	pop    %ebx
- 138:	5d                   	pop    %ebp
- 139:	c3                   	ret    
- 13a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 140:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
- 142:	29 d8                	sub    %ebx,%eax
-}
- 144:	5b                   	pop    %ebx
- 145:	5d                   	pop    %ebp
- 146:	c3                   	ret    
- 147:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 14e:	66 90                	xchg   %ax,%ax
-
-00000150 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 150:	f3 0f 1e fb          	endbr32 
- 154:	55                   	push   %ebp
- 155:	89 e5                	mov    %esp,%ebp
- 157:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 15a:	80 3a 00             	cmpb   $0x0,(%edx)
- 15d:	74 21                	je     180 <strlen+0x30>
- 15f:	31 c0                	xor    %eax,%eax
- 161:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 168:	83 c0 01             	add    $0x1,%eax
- 16b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 16f:	89 c1                	mov    %eax,%ecx
- 171:	75 f5                	jne    168 <strlen+0x18>
-    ;
-  return n;
-}
- 173:	89 c8                	mov    %ecx,%eax
- 175:	5d                   	pop    %ebp
- 176:	c3                   	ret    
- 177:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 17e:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 180:	31 c9                	xor    %ecx,%ecx
-}
- 182:	5d                   	pop    %ebp
- 183:	89 c8                	mov    %ecx,%eax
- 185:	c3                   	ret    
- 186:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 18d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000190 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 190:	f3 0f 1e fb          	endbr32 
- 194:	55                   	push   %ebp
- 195:	89 e5                	mov    %esp,%ebp
- 197:	57                   	push   %edi
- 198:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 19b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 19e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 1a1:	89 d7                	mov    %edx,%edi
- 1a3:	fc                   	cld    
- 1a4:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 1a6:	89 d0                	mov    %edx,%eax
- 1a8:	5f                   	pop    %edi
- 1a9:	5d                   	pop    %ebp
- 1aa:	c3                   	ret    
- 1ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 1af:	90                   	nop
-
-000001b0 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 1b0:	f3 0f 1e fb          	endbr32 
- 1b4:	55                   	push   %ebp
- 1b5:	89 e5                	mov    %esp,%ebp
- 1b7:	8b 45 08             	mov    0x8(%ebp),%eax
- 1ba:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 1be:	0f b6 10             	movzbl (%eax),%edx
- 1c1:	84 d2                	test   %dl,%dl
- 1c3:	75 16                	jne    1db <strchr+0x2b>
- 1c5:	eb 21                	jmp    1e8 <strchr+0x38>
- 1c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1ce:	66 90                	xchg   %ax,%ax
- 1d0:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 1d4:	83 c0 01             	add    $0x1,%eax
- 1d7:	84 d2                	test   %dl,%dl
- 1d9:	74 0d                	je     1e8 <strchr+0x38>
-    if(*s == c)
- 1db:	38 d1                	cmp    %dl,%cl
- 1dd:	75 f1                	jne    1d0 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 1df:	5d                   	pop    %ebp
- 1e0:	c3                   	ret    
- 1e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 1e8:	31 c0                	xor    %eax,%eax
-}
- 1ea:	5d                   	pop    %ebp
- 1eb:	c3                   	ret    
- 1ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000001f0 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 1f0:	f3 0f 1e fb          	endbr32 
- 1f4:	55                   	push   %ebp
- 1f5:	89 e5                	mov    %esp,%ebp
- 1f7:	57                   	push   %edi
- 1f8:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 1f9:	31 f6                	xor    %esi,%esi
-{
- 1fb:	53                   	push   %ebx
- 1fc:	89 f3                	mov    %esi,%ebx
- 1fe:	83 ec 1c             	sub    $0x1c,%esp
- 201:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 204:	eb 33                	jmp    239 <gets+0x49>
- 206:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 20d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 210:	83 ec 04             	sub    $0x4,%esp
- 213:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 216:	6a 01                	push   $0x1
- 218:	50                   	push   %eax
- 219:	6a 00                	push   $0x0
- 21b:	e8 2b 01 00 00       	call   34b <read>
-    if(cc < 1)
- 220:	83 c4 10             	add    $0x10,%esp
- 223:	85 c0                	test   %eax,%eax
- 225:	7e 1c                	jle    243 <gets+0x53>
-      break;
-    buf[i++] = c;
- 227:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 22b:	83 c7 01             	add    $0x1,%edi
- 22e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 231:	3c 0a                	cmp    $0xa,%al
- 233:	74 23                	je     258 <gets+0x68>
- 235:	3c 0d                	cmp    $0xd,%al
- 237:	74 1f                	je     258 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 239:	83 c3 01             	add    $0x1,%ebx
- 23c:	89 fe                	mov    %edi,%esi
- 23e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 241:	7c cd                	jl     210 <gets+0x20>
- 243:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 245:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 248:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 24b:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 24e:	5b                   	pop    %ebx
- 24f:	5e                   	pop    %esi
- 250:	5f                   	pop    %edi
- 251:	5d                   	pop    %ebp
- 252:	c3                   	ret    
- 253:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 257:	90                   	nop
- 258:	8b 75 08             	mov    0x8(%ebp),%esi
- 25b:	8b 45 08             	mov    0x8(%ebp),%eax
- 25e:	01 de                	add    %ebx,%esi
- 260:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 262:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 265:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 268:	5b                   	pop    %ebx
- 269:	5e                   	pop    %esi
- 26a:	5f                   	pop    %edi
- 26b:	5d                   	pop    %ebp
- 26c:	c3                   	ret    
- 26d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000270 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 270:	f3 0f 1e fb          	endbr32 
- 274:	55                   	push   %ebp
- 275:	89 e5                	mov    %esp,%ebp
- 277:	56                   	push   %esi
- 278:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 279:	83 ec 08             	sub    $0x8,%esp
- 27c:	6a 00                	push   $0x0
- 27e:	ff 75 08             	pushl  0x8(%ebp)
- 281:	e8 ed 00 00 00       	call   373 <open>
-  if(fd < 0)
- 286:	83 c4 10             	add    $0x10,%esp
- 289:	85 c0                	test   %eax,%eax
- 28b:	78 2b                	js     2b8 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 28d:	83 ec 08             	sub    $0x8,%esp
- 290:	ff 75 0c             	pushl  0xc(%ebp)
- 293:	89 c3                	mov    %eax,%ebx
- 295:	50                   	push   %eax
- 296:	e8 f0 00 00 00       	call   38b <fstat>
-  close(fd);
- 29b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 29e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 2a0:	e8 b6 00 00 00       	call   35b <close>
-  return r;
- 2a5:	83 c4 10             	add    $0x10,%esp
-}
- 2a8:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 2ab:	89 f0                	mov    %esi,%eax
- 2ad:	5b                   	pop    %ebx
- 2ae:	5e                   	pop    %esi
- 2af:	5d                   	pop    %ebp
- 2b0:	c3                   	ret    
- 2b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 2b8:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 2bd:	eb e9                	jmp    2a8 <stat+0x38>
- 2bf:	90                   	nop
-
-000002c0 <atoi>:
-
-int
-atoi(const char *s)
-{
- 2c0:	f3 0f 1e fb          	endbr32 
- 2c4:	55                   	push   %ebp
- 2c5:	89 e5                	mov    %esp,%ebp
- 2c7:	53                   	push   %ebx
- 2c8:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 2cb:	0f be 02             	movsbl (%edx),%eax
- 2ce:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 2d1:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 2d4:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 2d9:	77 1a                	ja     2f5 <atoi+0x35>
- 2db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 2df:	90                   	nop
-    n = n*10 + *s++ - '0';
- 2e0:	83 c2 01             	add    $0x1,%edx
- 2e3:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 2e6:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 2ea:	0f be 02             	movsbl (%edx),%eax
- 2ed:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 2f0:	80 fb 09             	cmp    $0x9,%bl
- 2f3:	76 eb                	jbe    2e0 <atoi+0x20>
-  return n;
-}
- 2f5:	89 c8                	mov    %ecx,%eax
- 2f7:	5b                   	pop    %ebx
- 2f8:	5d                   	pop    %ebp
- 2f9:	c3                   	ret    
- 2fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000300 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 300:	f3 0f 1e fb          	endbr32 
- 304:	55                   	push   %ebp
- 305:	89 e5                	mov    %esp,%ebp
- 307:	57                   	push   %edi
- 308:	8b 45 10             	mov    0x10(%ebp),%eax
- 30b:	8b 55 08             	mov    0x8(%ebp),%edx
- 30e:	56                   	push   %esi
- 30f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 312:	85 c0                	test   %eax,%eax
- 314:	7e 0f                	jle    325 <memmove+0x25>
- 316:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 318:	89 d7                	mov    %edx,%edi
- 31a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 320:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 321:	39 f8                	cmp    %edi,%eax
- 323:	75 fb                	jne    320 <memmove+0x20>
-  return vdst;
-}
- 325:	5e                   	pop    %esi
- 326:	89 d0                	mov    %edx,%eax
- 328:	5f                   	pop    %edi
- 329:	5d                   	pop    %ebp
- 32a:	c3                   	ret    
-
-0000032b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 32b:	b8 01 00 00 00       	mov    $0x1,%eax
- 330:	cd 40                	int    $0x40
- 332:	c3                   	ret    
-
-00000333 <exit>:
-SYSCALL(exit)
- 333:	b8 02 00 00 00       	mov    $0x2,%eax
- 338:	cd 40                	int    $0x40
- 33a:	c3                   	ret    
-
-0000033b <wait>:
-SYSCALL(wait)
- 33b:	b8 03 00 00 00       	mov    $0x3,%eax
- 340:	cd 40                	int    $0x40
- 342:	c3                   	ret    
-
-00000343 <pipe>:
-SYSCALL(pipe)
- 343:	b8 04 00 00 00       	mov    $0x4,%eax
- 348:	cd 40                	int    $0x40
- 34a:	c3                   	ret    
-
-0000034b <read>:
-SYSCALL(read)
- 34b:	b8 05 00 00 00       	mov    $0x5,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <write>:
-SYSCALL(write)
- 353:	b8 10 00 00 00       	mov    $0x10,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <close>:
-SYSCALL(close)
- 35b:	b8 15 00 00 00       	mov    $0x15,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <kill>:
-SYSCALL(kill)
- 363:	b8 06 00 00 00       	mov    $0x6,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <exec>:
-SYSCALL(exec)
- 36b:	b8 07 00 00 00       	mov    $0x7,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <open>:
-SYSCALL(open)
- 373:	b8 0f 00 00 00       	mov    $0xf,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <mknod>:
-SYSCALL(mknod)
- 37b:	b8 11 00 00 00       	mov    $0x11,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <unlink>:
-SYSCALL(unlink)
- 383:	b8 12 00 00 00       	mov    $0x12,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <fstat>:
-SYSCALL(fstat)
- 38b:	b8 08 00 00 00       	mov    $0x8,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <link>:
-SYSCALL(link)
- 393:	b8 13 00 00 00       	mov    $0x13,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <mkdir>:
-SYSCALL(mkdir)
- 39b:	b8 14 00 00 00       	mov    $0x14,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
-
-000003a3 <chdir>:
-SYSCALL(chdir)
- 3a3:	b8 09 00 00 00       	mov    $0x9,%eax
- 3a8:	cd 40                	int    $0x40
- 3aa:	c3                   	ret    
-
-000003ab <dup>:
-SYSCALL(dup)
- 3ab:	b8 0a 00 00 00       	mov    $0xa,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
-
-000003b3 <getpid>:
-SYSCALL(getpid)
- 3b3:	b8 0b 00 00 00       	mov    $0xb,%eax
- 3b8:	cd 40                	int    $0x40
- 3ba:	c3                   	ret    
-
-000003bb <sbrk>:
-SYSCALL(sbrk)
- 3bb:	b8 0c 00 00 00       	mov    $0xc,%eax
- 3c0:	cd 40                	int    $0x40
- 3c2:	c3                   	ret    
-
-000003c3 <sleep>:
-SYSCALL(sleep)
- 3c3:	b8 0d 00 00 00       	mov    $0xd,%eax
- 3c8:	cd 40                	int    $0x40
- 3ca:	c3                   	ret    
-
-000003cb <uptime>:
-SYSCALL(uptime)
- 3cb:	b8 0e 00 00 00       	mov    $0xe,%eax
- 3d0:	cd 40                	int    $0x40
- 3d2:	c3                   	ret    
-
-000003d3 <getParentID>:
-SYSCALL(getParentID)
- 3d3:	b8 16 00 00 00       	mov    $0x16,%eax
- 3d8:	cd 40                	int    $0x40
- 3da:	c3                   	ret    
-
-000003db <getChildren>:
-SYSCALL(getChildren)
- 3db:	b8 17 00 00 00       	mov    $0x17,%eax
- 3e0:	cd 40                	int    $0x40
- 3e2:	c3                   	ret    
-
-000003e3 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 3e3:	b8 18 00 00 00       	mov    $0x18,%eax
- 3e8:	cd 40                	int    $0x40
- 3ea:	c3                   	ret    
-
-000003eb <setPriority>:
-SYSCALL(setPriority)
- 3eb:	b8 19 00 00 00       	mov    $0x19,%eax
- 3f0:	cd 40                	int    $0x40
- 3f2:	c3                   	ret    
-
-000003f3 <changePolicy>:
-SYSCALL(changePolicy)
- 3f3:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 3f8:	cd 40                	int    $0x40
- 3fa:	c3                   	ret    
-
-000003fb <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 3fb:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 400:	cd 40                	int    $0x40
- 402:	c3                   	ret    
-
-00000403 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 403:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 408:	cd 40                	int    $0x40
- 40a:	c3                   	ret    
-
-0000040b <getCBT>:
-SYSCALL(getCBT)
- 40b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 410:	cd 40                	int    $0x40
- 412:	c3                   	ret    
-
-00000413 <customWait>:
-SYSCALL(customWait)
- 413:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 418:	cd 40                	int    $0x40
- 41a:	c3                   	ret    
-
-0000041b <setQueue>:
-SYSCALL(setQueue)
- 41b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 420:	cd 40                	int    $0x40
- 422:	c3                   	ret    
-
-00000423 <getBurstTime>:
-SYSCALL(getBurstTime)
- 423:	b8 20 00 00 00       	mov    $0x20,%eax
- 428:	cd 40                	int    $0x40
- 42a:	c3                   	ret    
-
-0000042b <getCreationTime>:
- 42b:	b8 21 00 00 00       	mov    $0x21,%eax
- 430:	cd 40                	int    $0x40
- 432:	c3                   	ret    
- 433:	66 90                	xchg   %ax,%ax
- 435:	66 90                	xchg   %ax,%ax
- 437:	66 90                	xchg   %ax,%ax
- 439:	66 90                	xchg   %ax,%ax
- 43b:	66 90                	xchg   %ax,%ax
- 43d:	66 90                	xchg   %ax,%ax
- 43f:	90                   	nop
-
-00000440 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 440:	55                   	push   %ebp
- 441:	89 e5                	mov    %esp,%ebp
- 443:	57                   	push   %edi
- 444:	56                   	push   %esi
- 445:	53                   	push   %ebx
- 446:	83 ec 3c             	sub    $0x3c,%esp
- 449:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 44c:	89 d1                	mov    %edx,%ecx
-{
- 44e:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 451:	85 d2                	test   %edx,%edx
- 453:	0f 89 7f 00 00 00    	jns    4d8 <printint+0x98>
- 459:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 45d:	74 79                	je     4d8 <printint+0x98>
-    neg = 1;
- 45f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 466:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 468:	31 db                	xor    %ebx,%ebx
- 46a:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 46d:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 470:	89 c8                	mov    %ecx,%eax
- 472:	31 d2                	xor    %edx,%edx
- 474:	89 cf                	mov    %ecx,%edi
- 476:	f7 75 c4             	divl   -0x3c(%ebp)
- 479:	0f b6 92 ac 08 00 00 	movzbl 0x8ac(%edx),%edx
- 480:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 483:	89 d8                	mov    %ebx,%eax
- 485:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 488:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 48b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 48e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 491:	76 dd                	jbe    470 <printint+0x30>
-  if(neg)
- 493:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 496:	85 c9                	test   %ecx,%ecx
- 498:	74 0c                	je     4a6 <printint+0x66>
-    buf[i++] = '-';
- 49a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 49f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 4a1:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 4a6:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 4a9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 4ad:	eb 07                	jmp    4b6 <printint+0x76>
- 4af:	90                   	nop
- 4b0:	0f b6 13             	movzbl (%ebx),%edx
- 4b3:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 4b6:	83 ec 04             	sub    $0x4,%esp
- 4b9:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 4bc:	6a 01                	push   $0x1
- 4be:	56                   	push   %esi
- 4bf:	57                   	push   %edi
- 4c0:	e8 8e fe ff ff       	call   353 <write>
-  while(--i >= 0)
- 4c5:	83 c4 10             	add    $0x10,%esp
- 4c8:	39 de                	cmp    %ebx,%esi
- 4ca:	75 e4                	jne    4b0 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 4cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 4cf:	5b                   	pop    %ebx
- 4d0:	5e                   	pop    %esi
- 4d1:	5f                   	pop    %edi
- 4d2:	5d                   	pop    %ebp
- 4d3:	c3                   	ret    
- 4d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 4d8:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 4df:	eb 87                	jmp    468 <printint+0x28>
- 4e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 4e8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 4ef:	90                   	nop
-
-000004f0 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 4f0:	f3 0f 1e fb          	endbr32 
- 4f4:	55                   	push   %ebp
- 4f5:	89 e5                	mov    %esp,%ebp
- 4f7:	57                   	push   %edi
- 4f8:	56                   	push   %esi
- 4f9:	53                   	push   %ebx
- 4fa:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 4fd:	8b 75 0c             	mov    0xc(%ebp),%esi
- 500:	0f b6 1e             	movzbl (%esi),%ebx
- 503:	84 db                	test   %bl,%bl
- 505:	0f 84 b4 00 00 00    	je     5bf <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 50b:	8d 45 10             	lea    0x10(%ebp),%eax
- 50e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 511:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 514:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 516:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 519:	eb 33                	jmp    54e <printf+0x5e>
- 51b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 51f:	90                   	nop
- 520:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 523:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 528:	83 f8 25             	cmp    $0x25,%eax
- 52b:	74 17                	je     544 <printf+0x54>
-  write(fd, &c, 1);
- 52d:	83 ec 04             	sub    $0x4,%esp
- 530:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 533:	6a 01                	push   $0x1
- 535:	57                   	push   %edi
- 536:	ff 75 08             	pushl  0x8(%ebp)
- 539:	e8 15 fe ff ff       	call   353 <write>
- 53e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 541:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 544:	0f b6 1e             	movzbl (%esi),%ebx
- 547:	83 c6 01             	add    $0x1,%esi
- 54a:	84 db                	test   %bl,%bl
- 54c:	74 71                	je     5bf <printf+0xcf>
-    c = fmt[i] & 0xff;
- 54e:	0f be cb             	movsbl %bl,%ecx
- 551:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 554:	85 d2                	test   %edx,%edx
- 556:	74 c8                	je     520 <printf+0x30>
-      }
-    } else if(state == '%'){
- 558:	83 fa 25             	cmp    $0x25,%edx
- 55b:	75 e7                	jne    544 <printf+0x54>
-      if(c == 'd'){
- 55d:	83 f8 64             	cmp    $0x64,%eax
- 560:	0f 84 9a 00 00 00    	je     600 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 566:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 56c:	83 f9 70             	cmp    $0x70,%ecx
- 56f:	74 5f                	je     5d0 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 571:	83 f8 73             	cmp    $0x73,%eax
- 574:	0f 84 d6 00 00 00    	je     650 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 57a:	83 f8 63             	cmp    $0x63,%eax
- 57d:	0f 84 8d 00 00 00    	je     610 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 583:	83 f8 25             	cmp    $0x25,%eax
- 586:	0f 84 b4 00 00 00    	je     640 <printf+0x150>
-  write(fd, &c, 1);
- 58c:	83 ec 04             	sub    $0x4,%esp
- 58f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 593:	6a 01                	push   $0x1
- 595:	57                   	push   %edi
- 596:	ff 75 08             	pushl  0x8(%ebp)
- 599:	e8 b5 fd ff ff       	call   353 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 59e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5a1:	83 c4 0c             	add    $0xc,%esp
- 5a4:	6a 01                	push   $0x1
- 5a6:	83 c6 01             	add    $0x1,%esi
- 5a9:	57                   	push   %edi
- 5aa:	ff 75 08             	pushl  0x8(%ebp)
- 5ad:	e8 a1 fd ff ff       	call   353 <write>
-  for(i = 0; fmt[i]; i++){
- 5b2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 5b6:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 5b9:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 5bb:	84 db                	test   %bl,%bl
- 5bd:	75 8f                	jne    54e <printf+0x5e>
-    }
-  }
-}
- 5bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 5c2:	5b                   	pop    %ebx
- 5c3:	5e                   	pop    %esi
- 5c4:	5f                   	pop    %edi
- 5c5:	5d                   	pop    %ebp
- 5c6:	c3                   	ret    
- 5c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5ce:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 5d0:	83 ec 0c             	sub    $0xc,%esp
- 5d3:	b9 10 00 00 00       	mov    $0x10,%ecx
- 5d8:	6a 00                	push   $0x0
- 5da:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 5dd:	8b 45 08             	mov    0x8(%ebp),%eax
- 5e0:	8b 13                	mov    (%ebx),%edx
- 5e2:	e8 59 fe ff ff       	call   440 <printint>
-        ap++;
- 5e7:	89 d8                	mov    %ebx,%eax
- 5e9:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 5ec:	31 d2                	xor    %edx,%edx
-        ap++;
- 5ee:	83 c0 04             	add    $0x4,%eax
- 5f1:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 5f4:	e9 4b ff ff ff       	jmp    544 <printf+0x54>
- 5f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 600:	83 ec 0c             	sub    $0xc,%esp
- 603:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 608:	6a 01                	push   $0x1
- 60a:	eb ce                	jmp    5da <printf+0xea>
- 60c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 610:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 613:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 616:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 618:	6a 01                	push   $0x1
-        ap++;
- 61a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 61d:	57                   	push   %edi
- 61e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 621:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 624:	e8 2a fd ff ff       	call   353 <write>
-        ap++;
- 629:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 62c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 62f:	31 d2                	xor    %edx,%edx
- 631:	e9 0e ff ff ff       	jmp    544 <printf+0x54>
- 636:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 63d:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 640:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 643:	83 ec 04             	sub    $0x4,%esp
- 646:	e9 59 ff ff ff       	jmp    5a4 <printf+0xb4>
- 64b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 64f:	90                   	nop
-        s = (char*)*ap;
- 650:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 653:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 655:	83 c0 04             	add    $0x4,%eax
- 658:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 65b:	85 db                	test   %ebx,%ebx
- 65d:	74 17                	je     676 <printf+0x186>
-        while(*s != 0){
- 65f:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 662:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 664:	84 c0                	test   %al,%al
- 666:	0f 84 d8 fe ff ff    	je     544 <printf+0x54>
- 66c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 66f:	89 de                	mov    %ebx,%esi
- 671:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 674:	eb 1a                	jmp    690 <printf+0x1a0>
-          s = "(null)";
- 676:	bb a5 08 00 00       	mov    $0x8a5,%ebx
-        while(*s != 0){
- 67b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 67e:	b8 28 00 00 00       	mov    $0x28,%eax
- 683:	89 de                	mov    %ebx,%esi
- 685:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 688:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 68f:	90                   	nop
-  write(fd, &c, 1);
- 690:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 693:	83 c6 01             	add    $0x1,%esi
- 696:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 699:	6a 01                	push   $0x1
- 69b:	57                   	push   %edi
- 69c:	53                   	push   %ebx
- 69d:	e8 b1 fc ff ff       	call   353 <write>
-        while(*s != 0){
- 6a2:	0f b6 06             	movzbl (%esi),%eax
- 6a5:	83 c4 10             	add    $0x10,%esp
- 6a8:	84 c0                	test   %al,%al
- 6aa:	75 e4                	jne    690 <printf+0x1a0>
- 6ac:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 6af:	31 d2                	xor    %edx,%edx
- 6b1:	e9 8e fe ff ff       	jmp    544 <printf+0x54>
- 6b6:	66 90                	xchg   %ax,%ax
- 6b8:	66 90                	xchg   %ax,%ax
- 6ba:	66 90                	xchg   %ax,%ax
- 6bc:	66 90                	xchg   %ax,%ax
- 6be:	66 90                	xchg   %ax,%ax
-
-000006c0 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 6c0:	f3 0f 1e fb          	endbr32 
- 6c4:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 6c5:	a1 60 0b 00 00       	mov    0xb60,%eax
-{
- 6ca:	89 e5                	mov    %esp,%ebp
- 6cc:	57                   	push   %edi
- 6cd:	56                   	push   %esi
- 6ce:	53                   	push   %ebx
- 6cf:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 6d2:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 6d4:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 6d7:	39 c8                	cmp    %ecx,%eax
- 6d9:	73 15                	jae    6f0 <free+0x30>
- 6db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 6df:	90                   	nop
- 6e0:	39 d1                	cmp    %edx,%ecx
- 6e2:	72 14                	jb     6f8 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 6e4:	39 d0                	cmp    %edx,%eax
- 6e6:	73 10                	jae    6f8 <free+0x38>
-{
- 6e8:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 6ea:	8b 10                	mov    (%eax),%edx
- 6ec:	39 c8                	cmp    %ecx,%eax
- 6ee:	72 f0                	jb     6e0 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 6f0:	39 d0                	cmp    %edx,%eax
- 6f2:	72 f4                	jb     6e8 <free+0x28>
- 6f4:	39 d1                	cmp    %edx,%ecx
- 6f6:	73 f0                	jae    6e8 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 6f8:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 6fb:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 6fe:	39 fa                	cmp    %edi,%edx
- 700:	74 1e                	je     720 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 702:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 705:	8b 50 04             	mov    0x4(%eax),%edx
- 708:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 70b:	39 f1                	cmp    %esi,%ecx
- 70d:	74 28                	je     737 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 70f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 711:	5b                   	pop    %ebx
-  freep = p;
- 712:	a3 60 0b 00 00       	mov    %eax,0xb60
-}
- 717:	5e                   	pop    %esi
- 718:	5f                   	pop    %edi
- 719:	5d                   	pop    %ebp
- 71a:	c3                   	ret    
- 71b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 71f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 720:	03 72 04             	add    0x4(%edx),%esi
- 723:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 726:	8b 10                	mov    (%eax),%edx
- 728:	8b 12                	mov    (%edx),%edx
- 72a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 72d:	8b 50 04             	mov    0x4(%eax),%edx
- 730:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 733:	39 f1                	cmp    %esi,%ecx
- 735:	75 d8                	jne    70f <free+0x4f>
-    p->s.size += bp->s.size;
- 737:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 73a:	a3 60 0b 00 00       	mov    %eax,0xb60
-    p->s.size += bp->s.size;
- 73f:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 742:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 745:	89 10                	mov    %edx,(%eax)
-}
- 747:	5b                   	pop    %ebx
- 748:	5e                   	pop    %esi
- 749:	5f                   	pop    %edi
- 74a:	5d                   	pop    %ebp
- 74b:	c3                   	ret    
- 74c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000750 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 750:	f3 0f 1e fb          	endbr32 
- 754:	55                   	push   %ebp
- 755:	89 e5                	mov    %esp,%ebp
- 757:	57                   	push   %edi
- 758:	56                   	push   %esi
- 759:	53                   	push   %ebx
- 75a:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 75d:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 760:	8b 3d 60 0b 00 00    	mov    0xb60,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 766:	8d 70 07             	lea    0x7(%eax),%esi
- 769:	c1 ee 03             	shr    $0x3,%esi
- 76c:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 76f:	85 ff                	test   %edi,%edi
- 771:	0f 84 a9 00 00 00    	je     820 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 777:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 779:	8b 48 04             	mov    0x4(%eax),%ecx
- 77c:	39 f1                	cmp    %esi,%ecx
- 77e:	73 6d                	jae    7ed <malloc+0x9d>
- 780:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 786:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 78b:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 78e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 795:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 798:	eb 17                	jmp    7b1 <malloc+0x61>
- 79a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7a0:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 7a2:	8b 4a 04             	mov    0x4(%edx),%ecx
- 7a5:	39 f1                	cmp    %esi,%ecx
- 7a7:	73 4f                	jae    7f8 <malloc+0xa8>
- 7a9:	8b 3d 60 0b 00 00    	mov    0xb60,%edi
- 7af:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 7b1:	39 c7                	cmp    %eax,%edi
- 7b3:	75 eb                	jne    7a0 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 7b5:	83 ec 0c             	sub    $0xc,%esp
- 7b8:	ff 75 e4             	pushl  -0x1c(%ebp)
- 7bb:	e8 fb fb ff ff       	call   3bb <sbrk>
-  if(p == (char*)-1)
- 7c0:	83 c4 10             	add    $0x10,%esp
- 7c3:	83 f8 ff             	cmp    $0xffffffff,%eax
- 7c6:	74 1b                	je     7e3 <malloc+0x93>
-  hp->s.size = nu;
- 7c8:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 7cb:	83 ec 0c             	sub    $0xc,%esp
- 7ce:	83 c0 08             	add    $0x8,%eax
- 7d1:	50                   	push   %eax
- 7d2:	e8 e9 fe ff ff       	call   6c0 <free>
-  return freep;
- 7d7:	a1 60 0b 00 00       	mov    0xb60,%eax
-      if((p = morecore(nunits)) == 0)
- 7dc:	83 c4 10             	add    $0x10,%esp
- 7df:	85 c0                	test   %eax,%eax
- 7e1:	75 bd                	jne    7a0 <malloc+0x50>
-        return 0;
-  }
-}
- 7e3:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 7e6:	31 c0                	xor    %eax,%eax
-}
- 7e8:	5b                   	pop    %ebx
- 7e9:	5e                   	pop    %esi
- 7ea:	5f                   	pop    %edi
- 7eb:	5d                   	pop    %ebp
- 7ec:	c3                   	ret    
-    if(p->s.size >= nunits){
- 7ed:	89 c2                	mov    %eax,%edx
- 7ef:	89 f8                	mov    %edi,%eax
- 7f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 7f8:	39 ce                	cmp    %ecx,%esi
- 7fa:	74 54                	je     850 <malloc+0x100>
-        p->s.size -= nunits;
- 7fc:	29 f1                	sub    %esi,%ecx
- 7fe:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 801:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 804:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 807:	a3 60 0b 00 00       	mov    %eax,0xb60
-}
- 80c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 80f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 812:	5b                   	pop    %ebx
- 813:	5e                   	pop    %esi
- 814:	5f                   	pop    %edi
- 815:	5d                   	pop    %ebp
- 816:	c3                   	ret    
- 817:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 81e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 820:	c7 05 60 0b 00 00 64 	movl   $0xb64,0xb60
- 827:	0b 00 00 
-    base.s.size = 0;
- 82a:	bf 64 0b 00 00       	mov    $0xb64,%edi
-    base.s.ptr = freep = prevp = &base;
- 82f:	c7 05 64 0b 00 00 64 	movl   $0xb64,0xb64
- 836:	0b 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 839:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 83b:	c7 05 68 0b 00 00 00 	movl   $0x0,0xb68
- 842:	00 00 00 
-    if(p->s.size >= nunits){
- 845:	e9 36 ff ff ff       	jmp    780 <malloc+0x30>
- 84a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 850:	8b 0a                	mov    (%edx),%ecx
- 852:	89 08                	mov    %ecx,(%eax)
- 854:	eb b1                	jmp    807 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/getChildrenTest.c b/xv6-public/Operating-System-Project/getChildrenTest.c
deleted file mode 100644
index ef8882e..0000000
--- a/xv6-public/Operating-System-Project/getChildrenTest.c
+++ /dev/null
@@ -1,35 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main()
-{
-    int original_pid = getpid();
-
-    int num_children;
-    int *children_pid = malloc(64 * sizeof(int));
-
-    for (int i = 0; i < 3; i++)
-    {
-        fork();
-    }
-
-    num_children = getChildren(children_pid);
-
-    if (getpid() == original_pid)
-    {
-        printf(1, "Original process ID: %d\n", original_pid);
-        printf(1, "Number of children: %d\n", num_children);
-        printf(1, "Child proccesses: [");
-        for (int i = 0; i < num_children; i++)
-        {
-            printf(1, "%d, ", children_pid[i]);
-        }
-        printf(1, "]\n");
-    }
-
-    while (wait() != -1)
-        ;
-
-    exit();
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/getChildrenTest.d b/xv6-public/Operating-System-Project/getChildrenTest.d
deleted file mode 100644
index 023aad5..0000000
--- a/xv6-public/Operating-System-Project/getChildrenTest.d
+++ /dev/null
@@ -1,2 +0,0 @@
-getChildrenTest.o: getChildrenTest.c /usr/include/stdc-predef.h types.h \
- stat.h user.h
diff --git a/xv6-public/Operating-System-Project/getChildrenTest.o b/xv6-public/Operating-System-Project/getChildrenTest.o
deleted file mode 100644
index 1f5949d..0000000
Binary files a/xv6-public/Operating-System-Project/getChildrenTest.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/getChildrenTest.sym b/xv6-public/Operating-System-Project/getChildrenTest.sym
deleted file mode 100644
index 6eac3a7..0000000
--- a/xv6-public/Operating-System-Project/getChildrenTest.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-00000858 .rodata
-000008c0 .eh_frame
-00000b60 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 getChildrenTest.c
-00000000 ulib.c
-00000000 printf.c
-00000440 printint
-000008ac digits.1109
-00000000 umalloc.c
-00000b60 freep
-00000b64 base
-000000d0 strcpy
-000003db getChildren
-000004f0 printf
-00000300 memmove
-0000037b mknod
-000001f0 gets
-000003b3 getpid
-00000413 customWait
-0000040b getCBT
-00000750 malloc
-000003c3 sleep
-00000343 pipe
-000003f3 changePolicy
-00000353 write
-0000038b fstat
-00000363 kill
-000003a3 chdir
-0000041b setQueue
-0000036b exec
-0000033b wait
-0000034b read
-00000423 getBurstTime
-00000383 unlink
-0000032b fork
-000003fb getTurnAroundTime
-000003bb sbrk
-000003cb uptime
-00000b60 __bss_start
-00000190 memset
-00000000 main
-00000100 strcmp
-000003ab dup
-000003e3 getSyscallCounter
-000003d3 getParentID
-00000270 stat
-00000b60 _edata
-00000b6c _end
-00000393 link
-00000333 exit
-000003eb setPriority
-000002c0 atoi
-0000042b getCreationTime
-00000150 strlen
-00000373 open
-000001b0 strchr
-0000039b mkdir
-0000035b close
-00000403 getWaitingTime
-000006c0 free
diff --git a/xv6-public/Operating-System-Project/getParentIDtest.asm b/xv6-public/Operating-System-Project/getParentIDtest.asm
deleted file mode 100644
index 19a673f..0000000
--- a/xv6-public/Operating-System-Project/getParentIDtest.asm
+++ /dev/null
@@ -1,1257 +0,0 @@
-
-_getParentIDtest:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main()
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	53                   	push   %ebx
-  12:	51                   	push   %ecx
-    for (int i = 0; i < 1; i++)
-    {
-        int pid = fork();
-  13:	e8 93 02 00 00       	call   2ab <fork>
-        if (pid > 0){ // parent
-  18:	85 c0                	test   %eax,%eax
-  1a:	7e 05                	jle    21 <main+0x21>
-            wait();
-  1c:	e8 9a 02 00 00       	call   2bb <wait>
-            printf(1, "This is process (getpid) %d and the parent id is %d\n", getpid(), getParentID());
-        }
-        else // child
-            printf(1, "This is process (getpid) %d and the parent id is %d\n", getpid(), getParentID());
-  21:	e8 2d 03 00 00       	call   353 <getParentID>
-  26:	89 c3                	mov    %eax,%ebx
-  28:	e8 06 03 00 00       	call   333 <getpid>
-  2d:	53                   	push   %ebx
-  2e:	50                   	push   %eax
-  2f:	68 d8 07 00 00       	push   $0x7d8
-  34:	6a 01                	push   $0x1
-  36:	e8 35 04 00 00       	call   470 <printf>
-  3b:	83 c4 10             	add    $0x10,%esp
-    }
-    exit();
-  3e:	e8 70 02 00 00       	call   2b3 <exit>
-  43:	66 90                	xchg   %ax,%ax
-  45:	66 90                	xchg   %ax,%ax
-  47:	66 90                	xchg   %ax,%ax
-  49:	66 90                	xchg   %ax,%ax
-  4b:	66 90                	xchg   %ax,%ax
-  4d:	66 90                	xchg   %ax,%ax
-  4f:	90                   	nop
-
-00000050 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  50:	f3 0f 1e fb          	endbr32 
-  54:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  55:	31 c0                	xor    %eax,%eax
-{
-  57:	89 e5                	mov    %esp,%ebp
-  59:	53                   	push   %ebx
-  5a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  5d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-  60:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-  64:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-  67:	83 c0 01             	add    $0x1,%eax
-  6a:	84 d2                	test   %dl,%dl
-  6c:	75 f2                	jne    60 <strcpy+0x10>
-    ;
-  return os;
-}
-  6e:	89 c8                	mov    %ecx,%eax
-  70:	5b                   	pop    %ebx
-  71:	5d                   	pop    %ebp
-  72:	c3                   	ret    
-  73:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000080 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-  80:	f3 0f 1e fb          	endbr32 
-  84:	55                   	push   %ebp
-  85:	89 e5                	mov    %esp,%ebp
-  87:	53                   	push   %ebx
-  88:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  8b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-  8e:	0f b6 01             	movzbl (%ecx),%eax
-  91:	0f b6 1a             	movzbl (%edx),%ebx
-  94:	84 c0                	test   %al,%al
-  96:	75 19                	jne    b1 <strcmp+0x31>
-  98:	eb 26                	jmp    c0 <strcmp+0x40>
-  9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  a0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-  a4:	83 c1 01             	add    $0x1,%ecx
-  a7:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-  aa:	0f b6 1a             	movzbl (%edx),%ebx
-  ad:	84 c0                	test   %al,%al
-  af:	74 0f                	je     c0 <strcmp+0x40>
-  b1:	38 d8                	cmp    %bl,%al
-  b3:	74 eb                	je     a0 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-  b5:	29 d8                	sub    %ebx,%eax
-}
-  b7:	5b                   	pop    %ebx
-  b8:	5d                   	pop    %ebp
-  b9:	c3                   	ret    
-  ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  c0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-  c2:	29 d8                	sub    %ebx,%eax
-}
-  c4:	5b                   	pop    %ebx
-  c5:	5d                   	pop    %ebp
-  c6:	c3                   	ret    
-  c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  ce:	66 90                	xchg   %ax,%ax
-
-000000d0 <strlen>:
-
-uint
-strlen(const char *s)
-{
-  d0:	f3 0f 1e fb          	endbr32 
-  d4:	55                   	push   %ebp
-  d5:	89 e5                	mov    %esp,%ebp
-  d7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
-  da:	80 3a 00             	cmpb   $0x0,(%edx)
-  dd:	74 21                	je     100 <strlen+0x30>
-  df:	31 c0                	xor    %eax,%eax
-  e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  e8:	83 c0 01             	add    $0x1,%eax
-  eb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
-  ef:	89 c1                	mov    %eax,%ecx
-  f1:	75 f5                	jne    e8 <strlen+0x18>
-    ;
-  return n;
-}
-  f3:	89 c8                	mov    %ecx,%eax
-  f5:	5d                   	pop    %ebp
-  f6:	c3                   	ret    
-  f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  fe:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 100:	31 c9                	xor    %ecx,%ecx
-}
- 102:	5d                   	pop    %ebp
- 103:	89 c8                	mov    %ecx,%eax
- 105:	c3                   	ret    
- 106:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 10d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000110 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 110:	f3 0f 1e fb          	endbr32 
- 114:	55                   	push   %ebp
- 115:	89 e5                	mov    %esp,%ebp
- 117:	57                   	push   %edi
- 118:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 11b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 11e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 121:	89 d7                	mov    %edx,%edi
- 123:	fc                   	cld    
- 124:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 126:	89 d0                	mov    %edx,%eax
- 128:	5f                   	pop    %edi
- 129:	5d                   	pop    %ebp
- 12a:	c3                   	ret    
- 12b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 12f:	90                   	nop
-
-00000130 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 130:	f3 0f 1e fb          	endbr32 
- 134:	55                   	push   %ebp
- 135:	89 e5                	mov    %esp,%ebp
- 137:	8b 45 08             	mov    0x8(%ebp),%eax
- 13a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 13e:	0f b6 10             	movzbl (%eax),%edx
- 141:	84 d2                	test   %dl,%dl
- 143:	75 16                	jne    15b <strchr+0x2b>
- 145:	eb 21                	jmp    168 <strchr+0x38>
- 147:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 14e:	66 90                	xchg   %ax,%ax
- 150:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 154:	83 c0 01             	add    $0x1,%eax
- 157:	84 d2                	test   %dl,%dl
- 159:	74 0d                	je     168 <strchr+0x38>
-    if(*s == c)
- 15b:	38 d1                	cmp    %dl,%cl
- 15d:	75 f1                	jne    150 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 15f:	5d                   	pop    %ebp
- 160:	c3                   	ret    
- 161:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 168:	31 c0                	xor    %eax,%eax
-}
- 16a:	5d                   	pop    %ebp
- 16b:	c3                   	ret    
- 16c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000170 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 170:	f3 0f 1e fb          	endbr32 
- 174:	55                   	push   %ebp
- 175:	89 e5                	mov    %esp,%ebp
- 177:	57                   	push   %edi
- 178:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 179:	31 f6                	xor    %esi,%esi
-{
- 17b:	53                   	push   %ebx
- 17c:	89 f3                	mov    %esi,%ebx
- 17e:	83 ec 1c             	sub    $0x1c,%esp
- 181:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 184:	eb 33                	jmp    1b9 <gets+0x49>
- 186:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 18d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 190:	83 ec 04             	sub    $0x4,%esp
- 193:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 196:	6a 01                	push   $0x1
- 198:	50                   	push   %eax
- 199:	6a 00                	push   $0x0
- 19b:	e8 2b 01 00 00       	call   2cb <read>
-    if(cc < 1)
- 1a0:	83 c4 10             	add    $0x10,%esp
- 1a3:	85 c0                	test   %eax,%eax
- 1a5:	7e 1c                	jle    1c3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 1a7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 1ab:	83 c7 01             	add    $0x1,%edi
- 1ae:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 1b1:	3c 0a                	cmp    $0xa,%al
- 1b3:	74 23                	je     1d8 <gets+0x68>
- 1b5:	3c 0d                	cmp    $0xd,%al
- 1b7:	74 1f                	je     1d8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 1b9:	83 c3 01             	add    $0x1,%ebx
- 1bc:	89 fe                	mov    %edi,%esi
- 1be:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 1c1:	7c cd                	jl     190 <gets+0x20>
- 1c3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 1c5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 1c8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1ce:	5b                   	pop    %ebx
- 1cf:	5e                   	pop    %esi
- 1d0:	5f                   	pop    %edi
- 1d1:	5d                   	pop    %ebp
- 1d2:	c3                   	ret    
- 1d3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 1d7:	90                   	nop
- 1d8:	8b 75 08             	mov    0x8(%ebp),%esi
- 1db:	8b 45 08             	mov    0x8(%ebp),%eax
- 1de:	01 de                	add    %ebx,%esi
- 1e0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 1e2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1e8:	5b                   	pop    %ebx
- 1e9:	5e                   	pop    %esi
- 1ea:	5f                   	pop    %edi
- 1eb:	5d                   	pop    %ebp
- 1ec:	c3                   	ret    
- 1ed:	8d 76 00             	lea    0x0(%esi),%esi
-
-000001f0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 1f0:	f3 0f 1e fb          	endbr32 
- 1f4:	55                   	push   %ebp
- 1f5:	89 e5                	mov    %esp,%ebp
- 1f7:	56                   	push   %esi
- 1f8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 1f9:	83 ec 08             	sub    $0x8,%esp
- 1fc:	6a 00                	push   $0x0
- 1fe:	ff 75 08             	pushl  0x8(%ebp)
- 201:	e8 ed 00 00 00       	call   2f3 <open>
-  if(fd < 0)
- 206:	83 c4 10             	add    $0x10,%esp
- 209:	85 c0                	test   %eax,%eax
- 20b:	78 2b                	js     238 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 20d:	83 ec 08             	sub    $0x8,%esp
- 210:	ff 75 0c             	pushl  0xc(%ebp)
- 213:	89 c3                	mov    %eax,%ebx
- 215:	50                   	push   %eax
- 216:	e8 f0 00 00 00       	call   30b <fstat>
-  close(fd);
- 21b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 21e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 220:	e8 b6 00 00 00       	call   2db <close>
-  return r;
- 225:	83 c4 10             	add    $0x10,%esp
-}
- 228:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 22b:	89 f0                	mov    %esi,%eax
- 22d:	5b                   	pop    %ebx
- 22e:	5e                   	pop    %esi
- 22f:	5d                   	pop    %ebp
- 230:	c3                   	ret    
- 231:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 238:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 23d:	eb e9                	jmp    228 <stat+0x38>
- 23f:	90                   	nop
-
-00000240 <atoi>:
-
-int
-atoi(const char *s)
-{
- 240:	f3 0f 1e fb          	endbr32 
- 244:	55                   	push   %ebp
- 245:	89 e5                	mov    %esp,%ebp
- 247:	53                   	push   %ebx
- 248:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 24b:	0f be 02             	movsbl (%edx),%eax
- 24e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 251:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 254:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 259:	77 1a                	ja     275 <atoi+0x35>
- 25b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 25f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 260:	83 c2 01             	add    $0x1,%edx
- 263:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 266:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 26a:	0f be 02             	movsbl (%edx),%eax
- 26d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 270:	80 fb 09             	cmp    $0x9,%bl
- 273:	76 eb                	jbe    260 <atoi+0x20>
-  return n;
-}
- 275:	89 c8                	mov    %ecx,%eax
- 277:	5b                   	pop    %ebx
- 278:	5d                   	pop    %ebp
- 279:	c3                   	ret    
- 27a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000280 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 280:	f3 0f 1e fb          	endbr32 
- 284:	55                   	push   %ebp
- 285:	89 e5                	mov    %esp,%ebp
- 287:	57                   	push   %edi
- 288:	8b 45 10             	mov    0x10(%ebp),%eax
- 28b:	8b 55 08             	mov    0x8(%ebp),%edx
- 28e:	56                   	push   %esi
- 28f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 292:	85 c0                	test   %eax,%eax
- 294:	7e 0f                	jle    2a5 <memmove+0x25>
- 296:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 298:	89 d7                	mov    %edx,%edi
- 29a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 2a0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 2a1:	39 f8                	cmp    %edi,%eax
- 2a3:	75 fb                	jne    2a0 <memmove+0x20>
-  return vdst;
-}
- 2a5:	5e                   	pop    %esi
- 2a6:	89 d0                	mov    %edx,%eax
- 2a8:	5f                   	pop    %edi
- 2a9:	5d                   	pop    %ebp
- 2aa:	c3                   	ret    
-
-000002ab <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 2ab:	b8 01 00 00 00       	mov    $0x1,%eax
- 2b0:	cd 40                	int    $0x40
- 2b2:	c3                   	ret    
-
-000002b3 <exit>:
-SYSCALL(exit)
- 2b3:	b8 02 00 00 00       	mov    $0x2,%eax
- 2b8:	cd 40                	int    $0x40
- 2ba:	c3                   	ret    
-
-000002bb <wait>:
-SYSCALL(wait)
- 2bb:	b8 03 00 00 00       	mov    $0x3,%eax
- 2c0:	cd 40                	int    $0x40
- 2c2:	c3                   	ret    
-
-000002c3 <pipe>:
-SYSCALL(pipe)
- 2c3:	b8 04 00 00 00       	mov    $0x4,%eax
- 2c8:	cd 40                	int    $0x40
- 2ca:	c3                   	ret    
-
-000002cb <read>:
-SYSCALL(read)
- 2cb:	b8 05 00 00 00       	mov    $0x5,%eax
- 2d0:	cd 40                	int    $0x40
- 2d2:	c3                   	ret    
-
-000002d3 <write>:
-SYSCALL(write)
- 2d3:	b8 10 00 00 00       	mov    $0x10,%eax
- 2d8:	cd 40                	int    $0x40
- 2da:	c3                   	ret    
-
-000002db <close>:
-SYSCALL(close)
- 2db:	b8 15 00 00 00       	mov    $0x15,%eax
- 2e0:	cd 40                	int    $0x40
- 2e2:	c3                   	ret    
-
-000002e3 <kill>:
-SYSCALL(kill)
- 2e3:	b8 06 00 00 00       	mov    $0x6,%eax
- 2e8:	cd 40                	int    $0x40
- 2ea:	c3                   	ret    
-
-000002eb <exec>:
-SYSCALL(exec)
- 2eb:	b8 07 00 00 00       	mov    $0x7,%eax
- 2f0:	cd 40                	int    $0x40
- 2f2:	c3                   	ret    
-
-000002f3 <open>:
-SYSCALL(open)
- 2f3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 2f8:	cd 40                	int    $0x40
- 2fa:	c3                   	ret    
-
-000002fb <mknod>:
-SYSCALL(mknod)
- 2fb:	b8 11 00 00 00       	mov    $0x11,%eax
- 300:	cd 40                	int    $0x40
- 302:	c3                   	ret    
-
-00000303 <unlink>:
-SYSCALL(unlink)
- 303:	b8 12 00 00 00       	mov    $0x12,%eax
- 308:	cd 40                	int    $0x40
- 30a:	c3                   	ret    
-
-0000030b <fstat>:
-SYSCALL(fstat)
- 30b:	b8 08 00 00 00       	mov    $0x8,%eax
- 310:	cd 40                	int    $0x40
- 312:	c3                   	ret    
-
-00000313 <link>:
-SYSCALL(link)
- 313:	b8 13 00 00 00       	mov    $0x13,%eax
- 318:	cd 40                	int    $0x40
- 31a:	c3                   	ret    
-
-0000031b <mkdir>:
-SYSCALL(mkdir)
- 31b:	b8 14 00 00 00       	mov    $0x14,%eax
- 320:	cd 40                	int    $0x40
- 322:	c3                   	ret    
-
-00000323 <chdir>:
-SYSCALL(chdir)
- 323:	b8 09 00 00 00       	mov    $0x9,%eax
- 328:	cd 40                	int    $0x40
- 32a:	c3                   	ret    
-
-0000032b <dup>:
-SYSCALL(dup)
- 32b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 330:	cd 40                	int    $0x40
- 332:	c3                   	ret    
-
-00000333 <getpid>:
-SYSCALL(getpid)
- 333:	b8 0b 00 00 00       	mov    $0xb,%eax
- 338:	cd 40                	int    $0x40
- 33a:	c3                   	ret    
-
-0000033b <sbrk>:
-SYSCALL(sbrk)
- 33b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 340:	cd 40                	int    $0x40
- 342:	c3                   	ret    
-
-00000343 <sleep>:
-SYSCALL(sleep)
- 343:	b8 0d 00 00 00       	mov    $0xd,%eax
- 348:	cd 40                	int    $0x40
- 34a:	c3                   	ret    
-
-0000034b <uptime>:
-SYSCALL(uptime)
- 34b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <getParentID>:
-SYSCALL(getParentID)
- 353:	b8 16 00 00 00       	mov    $0x16,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <getChildren>:
-SYSCALL(getChildren)
- 35b:	b8 17 00 00 00       	mov    $0x17,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 363:	b8 18 00 00 00       	mov    $0x18,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <setPriority>:
-SYSCALL(setPriority)
- 36b:	b8 19 00 00 00       	mov    $0x19,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <changePolicy>:
-SYSCALL(changePolicy)
- 373:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 37b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 383:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <getCBT>:
-SYSCALL(getCBT)
- 38b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <customWait>:
-SYSCALL(customWait)
- 393:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <setQueue>:
-SYSCALL(setQueue)
- 39b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
-
-000003a3 <getBurstTime>:
-SYSCALL(getBurstTime)
- 3a3:	b8 20 00 00 00       	mov    $0x20,%eax
- 3a8:	cd 40                	int    $0x40
- 3aa:	c3                   	ret    
-
-000003ab <getCreationTime>:
- 3ab:	b8 21 00 00 00       	mov    $0x21,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
- 3b3:	66 90                	xchg   %ax,%ax
- 3b5:	66 90                	xchg   %ax,%ax
- 3b7:	66 90                	xchg   %ax,%ax
- 3b9:	66 90                	xchg   %ax,%ax
- 3bb:	66 90                	xchg   %ax,%ax
- 3bd:	66 90                	xchg   %ax,%ax
- 3bf:	90                   	nop
-
-000003c0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 3c0:	55                   	push   %ebp
- 3c1:	89 e5                	mov    %esp,%ebp
- 3c3:	57                   	push   %edi
- 3c4:	56                   	push   %esi
- 3c5:	53                   	push   %ebx
- 3c6:	83 ec 3c             	sub    $0x3c,%esp
- 3c9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 3cc:	89 d1                	mov    %edx,%ecx
-{
- 3ce:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 3d1:	85 d2                	test   %edx,%edx
- 3d3:	0f 89 7f 00 00 00    	jns    458 <printint+0x98>
- 3d9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 3dd:	74 79                	je     458 <printint+0x98>
-    neg = 1;
- 3df:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 3e6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 3e8:	31 db                	xor    %ebx,%ebx
- 3ea:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 3ed:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 3f0:	89 c8                	mov    %ecx,%eax
- 3f2:	31 d2                	xor    %edx,%edx
- 3f4:	89 cf                	mov    %ecx,%edi
- 3f6:	f7 75 c4             	divl   -0x3c(%ebp)
- 3f9:	0f b6 92 14 08 00 00 	movzbl 0x814(%edx),%edx
- 400:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 403:	89 d8                	mov    %ebx,%eax
- 405:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 408:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 40b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 40e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 411:	76 dd                	jbe    3f0 <printint+0x30>
-  if(neg)
- 413:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 416:	85 c9                	test   %ecx,%ecx
- 418:	74 0c                	je     426 <printint+0x66>
-    buf[i++] = '-';
- 41a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 41f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 421:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 426:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 429:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 42d:	eb 07                	jmp    436 <printint+0x76>
- 42f:	90                   	nop
- 430:	0f b6 13             	movzbl (%ebx),%edx
- 433:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 436:	83 ec 04             	sub    $0x4,%esp
- 439:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 43c:	6a 01                	push   $0x1
- 43e:	56                   	push   %esi
- 43f:	57                   	push   %edi
- 440:	e8 8e fe ff ff       	call   2d3 <write>
-  while(--i >= 0)
- 445:	83 c4 10             	add    $0x10,%esp
- 448:	39 de                	cmp    %ebx,%esi
- 44a:	75 e4                	jne    430 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 44c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 44f:	5b                   	pop    %ebx
- 450:	5e                   	pop    %esi
- 451:	5f                   	pop    %edi
- 452:	5d                   	pop    %ebp
- 453:	c3                   	ret    
- 454:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 458:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 45f:	eb 87                	jmp    3e8 <printint+0x28>
- 461:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 468:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 46f:	90                   	nop
-
-00000470 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 470:	f3 0f 1e fb          	endbr32 
- 474:	55                   	push   %ebp
- 475:	89 e5                	mov    %esp,%ebp
- 477:	57                   	push   %edi
- 478:	56                   	push   %esi
- 479:	53                   	push   %ebx
- 47a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 47d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 480:	0f b6 1e             	movzbl (%esi),%ebx
- 483:	84 db                	test   %bl,%bl
- 485:	0f 84 b4 00 00 00    	je     53f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 48b:	8d 45 10             	lea    0x10(%ebp),%eax
- 48e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 491:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 494:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 496:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 499:	eb 33                	jmp    4ce <printf+0x5e>
- 49b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 49f:	90                   	nop
- 4a0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 4a3:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 4a8:	83 f8 25             	cmp    $0x25,%eax
- 4ab:	74 17                	je     4c4 <printf+0x54>
-  write(fd, &c, 1);
- 4ad:	83 ec 04             	sub    $0x4,%esp
- 4b0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 4b3:	6a 01                	push   $0x1
- 4b5:	57                   	push   %edi
- 4b6:	ff 75 08             	pushl  0x8(%ebp)
- 4b9:	e8 15 fe ff ff       	call   2d3 <write>
- 4be:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 4c1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 4c4:	0f b6 1e             	movzbl (%esi),%ebx
- 4c7:	83 c6 01             	add    $0x1,%esi
- 4ca:	84 db                	test   %bl,%bl
- 4cc:	74 71                	je     53f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 4ce:	0f be cb             	movsbl %bl,%ecx
- 4d1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 4d4:	85 d2                	test   %edx,%edx
- 4d6:	74 c8                	je     4a0 <printf+0x30>
-      }
-    } else if(state == '%'){
- 4d8:	83 fa 25             	cmp    $0x25,%edx
- 4db:	75 e7                	jne    4c4 <printf+0x54>
-      if(c == 'd'){
- 4dd:	83 f8 64             	cmp    $0x64,%eax
- 4e0:	0f 84 9a 00 00 00    	je     580 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 4e6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 4ec:	83 f9 70             	cmp    $0x70,%ecx
- 4ef:	74 5f                	je     550 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 4f1:	83 f8 73             	cmp    $0x73,%eax
- 4f4:	0f 84 d6 00 00 00    	je     5d0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 4fa:	83 f8 63             	cmp    $0x63,%eax
- 4fd:	0f 84 8d 00 00 00    	je     590 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 503:	83 f8 25             	cmp    $0x25,%eax
- 506:	0f 84 b4 00 00 00    	je     5c0 <printf+0x150>
-  write(fd, &c, 1);
- 50c:	83 ec 04             	sub    $0x4,%esp
- 50f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 513:	6a 01                	push   $0x1
- 515:	57                   	push   %edi
- 516:	ff 75 08             	pushl  0x8(%ebp)
- 519:	e8 b5 fd ff ff       	call   2d3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 51e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 521:	83 c4 0c             	add    $0xc,%esp
- 524:	6a 01                	push   $0x1
- 526:	83 c6 01             	add    $0x1,%esi
- 529:	57                   	push   %edi
- 52a:	ff 75 08             	pushl  0x8(%ebp)
- 52d:	e8 a1 fd ff ff       	call   2d3 <write>
-  for(i = 0; fmt[i]; i++){
- 532:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 536:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 539:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 53b:	84 db                	test   %bl,%bl
- 53d:	75 8f                	jne    4ce <printf+0x5e>
-    }
-  }
-}
- 53f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 542:	5b                   	pop    %ebx
- 543:	5e                   	pop    %esi
- 544:	5f                   	pop    %edi
- 545:	5d                   	pop    %ebp
- 546:	c3                   	ret    
- 547:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 54e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 550:	83 ec 0c             	sub    $0xc,%esp
- 553:	b9 10 00 00 00       	mov    $0x10,%ecx
- 558:	6a 00                	push   $0x0
- 55a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 55d:	8b 45 08             	mov    0x8(%ebp),%eax
- 560:	8b 13                	mov    (%ebx),%edx
- 562:	e8 59 fe ff ff       	call   3c0 <printint>
-        ap++;
- 567:	89 d8                	mov    %ebx,%eax
- 569:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 56c:	31 d2                	xor    %edx,%edx
-        ap++;
- 56e:	83 c0 04             	add    $0x4,%eax
- 571:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 574:	e9 4b ff ff ff       	jmp    4c4 <printf+0x54>
- 579:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 580:	83 ec 0c             	sub    $0xc,%esp
- 583:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 588:	6a 01                	push   $0x1
- 58a:	eb ce                	jmp    55a <printf+0xea>
- 58c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 590:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 593:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 596:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 598:	6a 01                	push   $0x1
-        ap++;
- 59a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 59d:	57                   	push   %edi
- 59e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 5a1:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 5a4:	e8 2a fd ff ff       	call   2d3 <write>
-        ap++;
- 5a9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 5ac:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 5af:	31 d2                	xor    %edx,%edx
- 5b1:	e9 0e ff ff ff       	jmp    4c4 <printf+0x54>
- 5b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5bd:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 5c0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5c3:	83 ec 04             	sub    $0x4,%esp
- 5c6:	e9 59 ff ff ff       	jmp    524 <printf+0xb4>
- 5cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 5cf:	90                   	nop
-        s = (char*)*ap;
- 5d0:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 5d3:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 5d5:	83 c0 04             	add    $0x4,%eax
- 5d8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 5db:	85 db                	test   %ebx,%ebx
- 5dd:	74 17                	je     5f6 <printf+0x186>
-        while(*s != 0){
- 5df:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 5e2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 5e4:	84 c0                	test   %al,%al
- 5e6:	0f 84 d8 fe ff ff    	je     4c4 <printf+0x54>
- 5ec:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5ef:	89 de                	mov    %ebx,%esi
- 5f1:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 5f4:	eb 1a                	jmp    610 <printf+0x1a0>
-          s = "(null)";
- 5f6:	bb 0d 08 00 00       	mov    $0x80d,%ebx
-        while(*s != 0){
- 5fb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5fe:	b8 28 00 00 00       	mov    $0x28,%eax
- 603:	89 de                	mov    %ebx,%esi
- 605:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 608:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 60f:	90                   	nop
-  write(fd, &c, 1);
- 610:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 613:	83 c6 01             	add    $0x1,%esi
- 616:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 619:	6a 01                	push   $0x1
- 61b:	57                   	push   %edi
- 61c:	53                   	push   %ebx
- 61d:	e8 b1 fc ff ff       	call   2d3 <write>
-        while(*s != 0){
- 622:	0f b6 06             	movzbl (%esi),%eax
- 625:	83 c4 10             	add    $0x10,%esp
- 628:	84 c0                	test   %al,%al
- 62a:	75 e4                	jne    610 <printf+0x1a0>
- 62c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 62f:	31 d2                	xor    %edx,%edx
- 631:	e9 8e fe ff ff       	jmp    4c4 <printf+0x54>
- 636:	66 90                	xchg   %ax,%ax
- 638:	66 90                	xchg   %ax,%ax
- 63a:	66 90                	xchg   %ax,%ax
- 63c:	66 90                	xchg   %ax,%ax
- 63e:	66 90                	xchg   %ax,%ax
-
-00000640 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 640:	f3 0f 1e fb          	endbr32 
- 644:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 645:	a1 c0 0a 00 00       	mov    0xac0,%eax
-{
- 64a:	89 e5                	mov    %esp,%ebp
- 64c:	57                   	push   %edi
- 64d:	56                   	push   %esi
- 64e:	53                   	push   %ebx
- 64f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 652:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 654:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 657:	39 c8                	cmp    %ecx,%eax
- 659:	73 15                	jae    670 <free+0x30>
- 65b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 65f:	90                   	nop
- 660:	39 d1                	cmp    %edx,%ecx
- 662:	72 14                	jb     678 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 664:	39 d0                	cmp    %edx,%eax
- 666:	73 10                	jae    678 <free+0x38>
-{
- 668:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 66a:	8b 10                	mov    (%eax),%edx
- 66c:	39 c8                	cmp    %ecx,%eax
- 66e:	72 f0                	jb     660 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 670:	39 d0                	cmp    %edx,%eax
- 672:	72 f4                	jb     668 <free+0x28>
- 674:	39 d1                	cmp    %edx,%ecx
- 676:	73 f0                	jae    668 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 678:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 67b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 67e:	39 fa                	cmp    %edi,%edx
- 680:	74 1e                	je     6a0 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 682:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 685:	8b 50 04             	mov    0x4(%eax),%edx
- 688:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 68b:	39 f1                	cmp    %esi,%ecx
- 68d:	74 28                	je     6b7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 68f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 691:	5b                   	pop    %ebx
-  freep = p;
- 692:	a3 c0 0a 00 00       	mov    %eax,0xac0
-}
- 697:	5e                   	pop    %esi
- 698:	5f                   	pop    %edi
- 699:	5d                   	pop    %ebp
- 69a:	c3                   	ret    
- 69b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 69f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 6a0:	03 72 04             	add    0x4(%edx),%esi
- 6a3:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 6a6:	8b 10                	mov    (%eax),%edx
- 6a8:	8b 12                	mov    (%edx),%edx
- 6aa:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 6ad:	8b 50 04             	mov    0x4(%eax),%edx
- 6b0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6b3:	39 f1                	cmp    %esi,%ecx
- 6b5:	75 d8                	jne    68f <free+0x4f>
-    p->s.size += bp->s.size;
- 6b7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 6ba:	a3 c0 0a 00 00       	mov    %eax,0xac0
-    p->s.size += bp->s.size;
- 6bf:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 6c2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 6c5:	89 10                	mov    %edx,(%eax)
-}
- 6c7:	5b                   	pop    %ebx
- 6c8:	5e                   	pop    %esi
- 6c9:	5f                   	pop    %edi
- 6ca:	5d                   	pop    %ebp
- 6cb:	c3                   	ret    
- 6cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000006d0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 6d0:	f3 0f 1e fb          	endbr32 
- 6d4:	55                   	push   %ebp
- 6d5:	89 e5                	mov    %esp,%ebp
- 6d7:	57                   	push   %edi
- 6d8:	56                   	push   %esi
- 6d9:	53                   	push   %ebx
- 6da:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6dd:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 6e0:	8b 3d c0 0a 00 00    	mov    0xac0,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6e6:	8d 70 07             	lea    0x7(%eax),%esi
- 6e9:	c1 ee 03             	shr    $0x3,%esi
- 6ec:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 6ef:	85 ff                	test   %edi,%edi
- 6f1:	0f 84 a9 00 00 00    	je     7a0 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 6f7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 6f9:	8b 48 04             	mov    0x4(%eax),%ecx
- 6fc:	39 f1                	cmp    %esi,%ecx
- 6fe:	73 6d                	jae    76d <malloc+0x9d>
- 700:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 706:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 70b:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 70e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 715:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 718:	eb 17                	jmp    731 <malloc+0x61>
- 71a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 720:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 722:	8b 4a 04             	mov    0x4(%edx),%ecx
- 725:	39 f1                	cmp    %esi,%ecx
- 727:	73 4f                	jae    778 <malloc+0xa8>
- 729:	8b 3d c0 0a 00 00    	mov    0xac0,%edi
- 72f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 731:	39 c7                	cmp    %eax,%edi
- 733:	75 eb                	jne    720 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 735:	83 ec 0c             	sub    $0xc,%esp
- 738:	ff 75 e4             	pushl  -0x1c(%ebp)
- 73b:	e8 fb fb ff ff       	call   33b <sbrk>
-  if(p == (char*)-1)
- 740:	83 c4 10             	add    $0x10,%esp
- 743:	83 f8 ff             	cmp    $0xffffffff,%eax
- 746:	74 1b                	je     763 <malloc+0x93>
-  hp->s.size = nu;
- 748:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 74b:	83 ec 0c             	sub    $0xc,%esp
- 74e:	83 c0 08             	add    $0x8,%eax
- 751:	50                   	push   %eax
- 752:	e8 e9 fe ff ff       	call   640 <free>
-  return freep;
- 757:	a1 c0 0a 00 00       	mov    0xac0,%eax
-      if((p = morecore(nunits)) == 0)
- 75c:	83 c4 10             	add    $0x10,%esp
- 75f:	85 c0                	test   %eax,%eax
- 761:	75 bd                	jne    720 <malloc+0x50>
-        return 0;
-  }
-}
- 763:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 766:	31 c0                	xor    %eax,%eax
-}
- 768:	5b                   	pop    %ebx
- 769:	5e                   	pop    %esi
- 76a:	5f                   	pop    %edi
- 76b:	5d                   	pop    %ebp
- 76c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 76d:	89 c2                	mov    %eax,%edx
- 76f:	89 f8                	mov    %edi,%eax
- 771:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 778:	39 ce                	cmp    %ecx,%esi
- 77a:	74 54                	je     7d0 <malloc+0x100>
-        p->s.size -= nunits;
- 77c:	29 f1                	sub    %esi,%ecx
- 77e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 781:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 784:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 787:	a3 c0 0a 00 00       	mov    %eax,0xac0
-}
- 78c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 78f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 792:	5b                   	pop    %ebx
- 793:	5e                   	pop    %esi
- 794:	5f                   	pop    %edi
- 795:	5d                   	pop    %ebp
- 796:	c3                   	ret    
- 797:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 79e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 7a0:	c7 05 c0 0a 00 00 c4 	movl   $0xac4,0xac0
- 7a7:	0a 00 00 
-    base.s.size = 0;
- 7aa:	bf c4 0a 00 00       	mov    $0xac4,%edi
-    base.s.ptr = freep = prevp = &base;
- 7af:	c7 05 c4 0a 00 00 c4 	movl   $0xac4,0xac4
- 7b6:	0a 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7b9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 7bb:	c7 05 c8 0a 00 00 00 	movl   $0x0,0xac8
- 7c2:	00 00 00 
-    if(p->s.size >= nunits){
- 7c5:	e9 36 ff ff ff       	jmp    700 <malloc+0x30>
- 7ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 7d0:	8b 0a                	mov    (%edx),%ecx
- 7d2:	89 08                	mov    %ecx,(%eax)
- 7d4:	eb b1                	jmp    787 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/getParentIDtest.c b/xv6-public/Operating-System-Project/getParentIDtest.c
deleted file mode 100644
index c85b900..0000000
--- a/xv6-public/Operating-System-Project/getParentIDtest.c
+++ /dev/null
@@ -1,18 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main()
-{
-    for (int i = 0; i < 1; i++)
-    {
-        int pid = fork();
-        if (pid > 0){ // parent
-            wait();
-            printf(1, "This is process (getpid) %d and the parent id is %d\n", getpid(), getParentID());
-        }
-        else // child
-            printf(1, "This is process (getpid) %d and the parent id is %d\n", getpid(), getParentID());
-    }
-    exit();
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/getParentIDtest.d b/xv6-public/Operating-System-Project/getParentIDtest.d
deleted file mode 100644
index 782bec4..0000000
--- a/xv6-public/Operating-System-Project/getParentIDtest.d
+++ /dev/null
@@ -1,2 +0,0 @@
-getParentIDtest.o: getParentIDtest.c /usr/include/stdc-predef.h types.h \
- stat.h user.h
diff --git a/xv6-public/Operating-System-Project/getParentIDtest.o b/xv6-public/Operating-System-Project/getParentIDtest.o
deleted file mode 100644
index fd90e37..0000000
Binary files a/xv6-public/Operating-System-Project/getParentIDtest.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/getParentIDtest.sym b/xv6-public/Operating-System-Project/getParentIDtest.sym
deleted file mode 100644
index 458d458..0000000
--- a/xv6-public/Operating-System-Project/getParentIDtest.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-000007d8 .rodata
-00000828 .eh_frame
-00000ac0 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 getParentIDtest.c
-00000000 ulib.c
-00000000 printf.c
-000003c0 printint
-00000814 digits.1109
-00000000 umalloc.c
-00000ac0 freep
-00000ac4 base
-00000050 strcpy
-0000035b getChildren
-00000470 printf
-00000280 memmove
-000002fb mknod
-00000170 gets
-00000333 getpid
-00000393 customWait
-0000038b getCBT
-000006d0 malloc
-00000343 sleep
-000002c3 pipe
-00000373 changePolicy
-000002d3 write
-0000030b fstat
-000002e3 kill
-00000323 chdir
-0000039b setQueue
-000002eb exec
-000002bb wait
-000002cb read
-000003a3 getBurstTime
-00000303 unlink
-000002ab fork
-0000037b getTurnAroundTime
-0000033b sbrk
-0000034b uptime
-00000ac0 __bss_start
-00000110 memset
-00000000 main
-00000080 strcmp
-0000032b dup
-00000363 getSyscallCounter
-00000353 getParentID
-000001f0 stat
-00000ac0 _edata
-00000acc _end
-00000313 link
-000002b3 exit
-0000036b setPriority
-00000240 atoi
-000003ab getCreationTime
-000000d0 strlen
-000002f3 open
-00000130 strchr
-0000031b mkdir
-000002db close
-00000383 getWaitingTime
-00000640 free
diff --git a/xv6-public/Operating-System-Project/getSyscallCounterTest.asm b/xv6-public/Operating-System-Project/getSyscallCounterTest.asm
deleted file mode 100644
index 0b66226..0000000
--- a/xv6-public/Operating-System-Project/getSyscallCounterTest.asm
+++ /dev/null
@@ -1,1252 +0,0 @@
-
-_getSyscallCounterTest:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	53                   	push   %ebx
-  12:	51                   	push   %ecx
-  13:	8b 41 04             	mov    0x4(%ecx),%eax
-    int syscall_num = atoi(argv[1]);
-  16:	83 ec 0c             	sub    $0xc,%esp
-  19:	ff 70 04             	pushl  0x4(%eax)
-  1c:	e8 1f 02 00 00       	call   240 <atoi>
-    printf(1, "Syscall #%d has been called %d times\n", syscall_num, getSyscallCounter(syscall_num));
-  21:	89 04 24             	mov    %eax,(%esp)
-    int syscall_num = atoi(argv[1]);
-  24:	89 c3                	mov    %eax,%ebx
-    printf(1, "Syscall #%d has been called %d times\n", syscall_num, getSyscallCounter(syscall_num));
-  26:	e8 38 03 00 00       	call   363 <getSyscallCounter>
-  2b:	50                   	push   %eax
-  2c:	53                   	push   %ebx
-  2d:	68 d8 07 00 00       	push   $0x7d8
-  32:	6a 01                	push   $0x1
-  34:	e8 37 04 00 00       	call   470 <printf>
-    exit();
-  39:	83 c4 20             	add    $0x20,%esp
-  3c:	e8 72 02 00 00       	call   2b3 <exit>
-  41:	66 90                	xchg   %ax,%ax
-  43:	66 90                	xchg   %ax,%ax
-  45:	66 90                	xchg   %ax,%ax
-  47:	66 90                	xchg   %ax,%ax
-  49:	66 90                	xchg   %ax,%ax
-  4b:	66 90                	xchg   %ax,%ax
-  4d:	66 90                	xchg   %ax,%ax
-  4f:	90                   	nop
-
-00000050 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  50:	f3 0f 1e fb          	endbr32 
-  54:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  55:	31 c0                	xor    %eax,%eax
-{
-  57:	89 e5                	mov    %esp,%ebp
-  59:	53                   	push   %ebx
-  5a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  5d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-  60:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-  64:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-  67:	83 c0 01             	add    $0x1,%eax
-  6a:	84 d2                	test   %dl,%dl
-  6c:	75 f2                	jne    60 <strcpy+0x10>
-    ;
-  return os;
-}
-  6e:	89 c8                	mov    %ecx,%eax
-  70:	5b                   	pop    %ebx
-  71:	5d                   	pop    %ebp
-  72:	c3                   	ret    
-  73:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000080 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-  80:	f3 0f 1e fb          	endbr32 
-  84:	55                   	push   %ebp
-  85:	89 e5                	mov    %esp,%ebp
-  87:	53                   	push   %ebx
-  88:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  8b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-  8e:	0f b6 01             	movzbl (%ecx),%eax
-  91:	0f b6 1a             	movzbl (%edx),%ebx
-  94:	84 c0                	test   %al,%al
-  96:	75 19                	jne    b1 <strcmp+0x31>
-  98:	eb 26                	jmp    c0 <strcmp+0x40>
-  9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  a0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-  a4:	83 c1 01             	add    $0x1,%ecx
-  a7:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-  aa:	0f b6 1a             	movzbl (%edx),%ebx
-  ad:	84 c0                	test   %al,%al
-  af:	74 0f                	je     c0 <strcmp+0x40>
-  b1:	38 d8                	cmp    %bl,%al
-  b3:	74 eb                	je     a0 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-  b5:	29 d8                	sub    %ebx,%eax
-}
-  b7:	5b                   	pop    %ebx
-  b8:	5d                   	pop    %ebp
-  b9:	c3                   	ret    
-  ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  c0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-  c2:	29 d8                	sub    %ebx,%eax
-}
-  c4:	5b                   	pop    %ebx
-  c5:	5d                   	pop    %ebp
-  c6:	c3                   	ret    
-  c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  ce:	66 90                	xchg   %ax,%ax
-
-000000d0 <strlen>:
-
-uint
-strlen(const char *s)
-{
-  d0:	f3 0f 1e fb          	endbr32 
-  d4:	55                   	push   %ebp
-  d5:	89 e5                	mov    %esp,%ebp
-  d7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
-  da:	80 3a 00             	cmpb   $0x0,(%edx)
-  dd:	74 21                	je     100 <strlen+0x30>
-  df:	31 c0                	xor    %eax,%eax
-  e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  e8:	83 c0 01             	add    $0x1,%eax
-  eb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
-  ef:	89 c1                	mov    %eax,%ecx
-  f1:	75 f5                	jne    e8 <strlen+0x18>
-    ;
-  return n;
-}
-  f3:	89 c8                	mov    %ecx,%eax
-  f5:	5d                   	pop    %ebp
-  f6:	c3                   	ret    
-  f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  fe:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 100:	31 c9                	xor    %ecx,%ecx
-}
- 102:	5d                   	pop    %ebp
- 103:	89 c8                	mov    %ecx,%eax
- 105:	c3                   	ret    
- 106:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 10d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000110 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 110:	f3 0f 1e fb          	endbr32 
- 114:	55                   	push   %ebp
- 115:	89 e5                	mov    %esp,%ebp
- 117:	57                   	push   %edi
- 118:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 11b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 11e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 121:	89 d7                	mov    %edx,%edi
- 123:	fc                   	cld    
- 124:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 126:	89 d0                	mov    %edx,%eax
- 128:	5f                   	pop    %edi
- 129:	5d                   	pop    %ebp
- 12a:	c3                   	ret    
- 12b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 12f:	90                   	nop
-
-00000130 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 130:	f3 0f 1e fb          	endbr32 
- 134:	55                   	push   %ebp
- 135:	89 e5                	mov    %esp,%ebp
- 137:	8b 45 08             	mov    0x8(%ebp),%eax
- 13a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 13e:	0f b6 10             	movzbl (%eax),%edx
- 141:	84 d2                	test   %dl,%dl
- 143:	75 16                	jne    15b <strchr+0x2b>
- 145:	eb 21                	jmp    168 <strchr+0x38>
- 147:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 14e:	66 90                	xchg   %ax,%ax
- 150:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 154:	83 c0 01             	add    $0x1,%eax
- 157:	84 d2                	test   %dl,%dl
- 159:	74 0d                	je     168 <strchr+0x38>
-    if(*s == c)
- 15b:	38 d1                	cmp    %dl,%cl
- 15d:	75 f1                	jne    150 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 15f:	5d                   	pop    %ebp
- 160:	c3                   	ret    
- 161:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 168:	31 c0                	xor    %eax,%eax
-}
- 16a:	5d                   	pop    %ebp
- 16b:	c3                   	ret    
- 16c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000170 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 170:	f3 0f 1e fb          	endbr32 
- 174:	55                   	push   %ebp
- 175:	89 e5                	mov    %esp,%ebp
- 177:	57                   	push   %edi
- 178:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 179:	31 f6                	xor    %esi,%esi
-{
- 17b:	53                   	push   %ebx
- 17c:	89 f3                	mov    %esi,%ebx
- 17e:	83 ec 1c             	sub    $0x1c,%esp
- 181:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 184:	eb 33                	jmp    1b9 <gets+0x49>
- 186:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 18d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 190:	83 ec 04             	sub    $0x4,%esp
- 193:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 196:	6a 01                	push   $0x1
- 198:	50                   	push   %eax
- 199:	6a 00                	push   $0x0
- 19b:	e8 2b 01 00 00       	call   2cb <read>
-    if(cc < 1)
- 1a0:	83 c4 10             	add    $0x10,%esp
- 1a3:	85 c0                	test   %eax,%eax
- 1a5:	7e 1c                	jle    1c3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 1a7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 1ab:	83 c7 01             	add    $0x1,%edi
- 1ae:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 1b1:	3c 0a                	cmp    $0xa,%al
- 1b3:	74 23                	je     1d8 <gets+0x68>
- 1b5:	3c 0d                	cmp    $0xd,%al
- 1b7:	74 1f                	je     1d8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 1b9:	83 c3 01             	add    $0x1,%ebx
- 1bc:	89 fe                	mov    %edi,%esi
- 1be:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 1c1:	7c cd                	jl     190 <gets+0x20>
- 1c3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 1c5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 1c8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1ce:	5b                   	pop    %ebx
- 1cf:	5e                   	pop    %esi
- 1d0:	5f                   	pop    %edi
- 1d1:	5d                   	pop    %ebp
- 1d2:	c3                   	ret    
- 1d3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 1d7:	90                   	nop
- 1d8:	8b 75 08             	mov    0x8(%ebp),%esi
- 1db:	8b 45 08             	mov    0x8(%ebp),%eax
- 1de:	01 de                	add    %ebx,%esi
- 1e0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 1e2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1e8:	5b                   	pop    %ebx
- 1e9:	5e                   	pop    %esi
- 1ea:	5f                   	pop    %edi
- 1eb:	5d                   	pop    %ebp
- 1ec:	c3                   	ret    
- 1ed:	8d 76 00             	lea    0x0(%esi),%esi
-
-000001f0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 1f0:	f3 0f 1e fb          	endbr32 
- 1f4:	55                   	push   %ebp
- 1f5:	89 e5                	mov    %esp,%ebp
- 1f7:	56                   	push   %esi
- 1f8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 1f9:	83 ec 08             	sub    $0x8,%esp
- 1fc:	6a 00                	push   $0x0
- 1fe:	ff 75 08             	pushl  0x8(%ebp)
- 201:	e8 ed 00 00 00       	call   2f3 <open>
-  if(fd < 0)
- 206:	83 c4 10             	add    $0x10,%esp
- 209:	85 c0                	test   %eax,%eax
- 20b:	78 2b                	js     238 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 20d:	83 ec 08             	sub    $0x8,%esp
- 210:	ff 75 0c             	pushl  0xc(%ebp)
- 213:	89 c3                	mov    %eax,%ebx
- 215:	50                   	push   %eax
- 216:	e8 f0 00 00 00       	call   30b <fstat>
-  close(fd);
- 21b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 21e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 220:	e8 b6 00 00 00       	call   2db <close>
-  return r;
- 225:	83 c4 10             	add    $0x10,%esp
-}
- 228:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 22b:	89 f0                	mov    %esi,%eax
- 22d:	5b                   	pop    %ebx
- 22e:	5e                   	pop    %esi
- 22f:	5d                   	pop    %ebp
- 230:	c3                   	ret    
- 231:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 238:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 23d:	eb e9                	jmp    228 <stat+0x38>
- 23f:	90                   	nop
-
-00000240 <atoi>:
-
-int
-atoi(const char *s)
-{
- 240:	f3 0f 1e fb          	endbr32 
- 244:	55                   	push   %ebp
- 245:	89 e5                	mov    %esp,%ebp
- 247:	53                   	push   %ebx
- 248:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 24b:	0f be 02             	movsbl (%edx),%eax
- 24e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 251:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 254:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 259:	77 1a                	ja     275 <atoi+0x35>
- 25b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 25f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 260:	83 c2 01             	add    $0x1,%edx
- 263:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 266:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 26a:	0f be 02             	movsbl (%edx),%eax
- 26d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 270:	80 fb 09             	cmp    $0x9,%bl
- 273:	76 eb                	jbe    260 <atoi+0x20>
-  return n;
-}
- 275:	89 c8                	mov    %ecx,%eax
- 277:	5b                   	pop    %ebx
- 278:	5d                   	pop    %ebp
- 279:	c3                   	ret    
- 27a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000280 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 280:	f3 0f 1e fb          	endbr32 
- 284:	55                   	push   %ebp
- 285:	89 e5                	mov    %esp,%ebp
- 287:	57                   	push   %edi
- 288:	8b 45 10             	mov    0x10(%ebp),%eax
- 28b:	8b 55 08             	mov    0x8(%ebp),%edx
- 28e:	56                   	push   %esi
- 28f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 292:	85 c0                	test   %eax,%eax
- 294:	7e 0f                	jle    2a5 <memmove+0x25>
- 296:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 298:	89 d7                	mov    %edx,%edi
- 29a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 2a0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 2a1:	39 f8                	cmp    %edi,%eax
- 2a3:	75 fb                	jne    2a0 <memmove+0x20>
-  return vdst;
-}
- 2a5:	5e                   	pop    %esi
- 2a6:	89 d0                	mov    %edx,%eax
- 2a8:	5f                   	pop    %edi
- 2a9:	5d                   	pop    %ebp
- 2aa:	c3                   	ret    
-
-000002ab <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 2ab:	b8 01 00 00 00       	mov    $0x1,%eax
- 2b0:	cd 40                	int    $0x40
- 2b2:	c3                   	ret    
-
-000002b3 <exit>:
-SYSCALL(exit)
- 2b3:	b8 02 00 00 00       	mov    $0x2,%eax
- 2b8:	cd 40                	int    $0x40
- 2ba:	c3                   	ret    
-
-000002bb <wait>:
-SYSCALL(wait)
- 2bb:	b8 03 00 00 00       	mov    $0x3,%eax
- 2c0:	cd 40                	int    $0x40
- 2c2:	c3                   	ret    
-
-000002c3 <pipe>:
-SYSCALL(pipe)
- 2c3:	b8 04 00 00 00       	mov    $0x4,%eax
- 2c8:	cd 40                	int    $0x40
- 2ca:	c3                   	ret    
-
-000002cb <read>:
-SYSCALL(read)
- 2cb:	b8 05 00 00 00       	mov    $0x5,%eax
- 2d0:	cd 40                	int    $0x40
- 2d2:	c3                   	ret    
-
-000002d3 <write>:
-SYSCALL(write)
- 2d3:	b8 10 00 00 00       	mov    $0x10,%eax
- 2d8:	cd 40                	int    $0x40
- 2da:	c3                   	ret    
-
-000002db <close>:
-SYSCALL(close)
- 2db:	b8 15 00 00 00       	mov    $0x15,%eax
- 2e0:	cd 40                	int    $0x40
- 2e2:	c3                   	ret    
-
-000002e3 <kill>:
-SYSCALL(kill)
- 2e3:	b8 06 00 00 00       	mov    $0x6,%eax
- 2e8:	cd 40                	int    $0x40
- 2ea:	c3                   	ret    
-
-000002eb <exec>:
-SYSCALL(exec)
- 2eb:	b8 07 00 00 00       	mov    $0x7,%eax
- 2f0:	cd 40                	int    $0x40
- 2f2:	c3                   	ret    
-
-000002f3 <open>:
-SYSCALL(open)
- 2f3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 2f8:	cd 40                	int    $0x40
- 2fa:	c3                   	ret    
-
-000002fb <mknod>:
-SYSCALL(mknod)
- 2fb:	b8 11 00 00 00       	mov    $0x11,%eax
- 300:	cd 40                	int    $0x40
- 302:	c3                   	ret    
-
-00000303 <unlink>:
-SYSCALL(unlink)
- 303:	b8 12 00 00 00       	mov    $0x12,%eax
- 308:	cd 40                	int    $0x40
- 30a:	c3                   	ret    
-
-0000030b <fstat>:
-SYSCALL(fstat)
- 30b:	b8 08 00 00 00       	mov    $0x8,%eax
- 310:	cd 40                	int    $0x40
- 312:	c3                   	ret    
-
-00000313 <link>:
-SYSCALL(link)
- 313:	b8 13 00 00 00       	mov    $0x13,%eax
- 318:	cd 40                	int    $0x40
- 31a:	c3                   	ret    
-
-0000031b <mkdir>:
-SYSCALL(mkdir)
- 31b:	b8 14 00 00 00       	mov    $0x14,%eax
- 320:	cd 40                	int    $0x40
- 322:	c3                   	ret    
-
-00000323 <chdir>:
-SYSCALL(chdir)
- 323:	b8 09 00 00 00       	mov    $0x9,%eax
- 328:	cd 40                	int    $0x40
- 32a:	c3                   	ret    
-
-0000032b <dup>:
-SYSCALL(dup)
- 32b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 330:	cd 40                	int    $0x40
- 332:	c3                   	ret    
-
-00000333 <getpid>:
-SYSCALL(getpid)
- 333:	b8 0b 00 00 00       	mov    $0xb,%eax
- 338:	cd 40                	int    $0x40
- 33a:	c3                   	ret    
-
-0000033b <sbrk>:
-SYSCALL(sbrk)
- 33b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 340:	cd 40                	int    $0x40
- 342:	c3                   	ret    
-
-00000343 <sleep>:
-SYSCALL(sleep)
- 343:	b8 0d 00 00 00       	mov    $0xd,%eax
- 348:	cd 40                	int    $0x40
- 34a:	c3                   	ret    
-
-0000034b <uptime>:
-SYSCALL(uptime)
- 34b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <getParentID>:
-SYSCALL(getParentID)
- 353:	b8 16 00 00 00       	mov    $0x16,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <getChildren>:
-SYSCALL(getChildren)
- 35b:	b8 17 00 00 00       	mov    $0x17,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 363:	b8 18 00 00 00       	mov    $0x18,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <setPriority>:
-SYSCALL(setPriority)
- 36b:	b8 19 00 00 00       	mov    $0x19,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <changePolicy>:
-SYSCALL(changePolicy)
- 373:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 37b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 383:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <getCBT>:
-SYSCALL(getCBT)
- 38b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <customWait>:
-SYSCALL(customWait)
- 393:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <setQueue>:
-SYSCALL(setQueue)
- 39b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
-
-000003a3 <getBurstTime>:
-SYSCALL(getBurstTime)
- 3a3:	b8 20 00 00 00       	mov    $0x20,%eax
- 3a8:	cd 40                	int    $0x40
- 3aa:	c3                   	ret    
-
-000003ab <getCreationTime>:
- 3ab:	b8 21 00 00 00       	mov    $0x21,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
- 3b3:	66 90                	xchg   %ax,%ax
- 3b5:	66 90                	xchg   %ax,%ax
- 3b7:	66 90                	xchg   %ax,%ax
- 3b9:	66 90                	xchg   %ax,%ax
- 3bb:	66 90                	xchg   %ax,%ax
- 3bd:	66 90                	xchg   %ax,%ax
- 3bf:	90                   	nop
-
-000003c0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 3c0:	55                   	push   %ebp
- 3c1:	89 e5                	mov    %esp,%ebp
- 3c3:	57                   	push   %edi
- 3c4:	56                   	push   %esi
- 3c5:	53                   	push   %ebx
- 3c6:	83 ec 3c             	sub    $0x3c,%esp
- 3c9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 3cc:	89 d1                	mov    %edx,%ecx
-{
- 3ce:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 3d1:	85 d2                	test   %edx,%edx
- 3d3:	0f 89 7f 00 00 00    	jns    458 <printint+0x98>
- 3d9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 3dd:	74 79                	je     458 <printint+0x98>
-    neg = 1;
- 3df:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 3e6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 3e8:	31 db                	xor    %ebx,%ebx
- 3ea:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 3ed:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 3f0:	89 c8                	mov    %ecx,%eax
- 3f2:	31 d2                	xor    %edx,%edx
- 3f4:	89 cf                	mov    %ecx,%edi
- 3f6:	f7 75 c4             	divl   -0x3c(%ebp)
- 3f9:	0f b6 92 08 08 00 00 	movzbl 0x808(%edx),%edx
- 400:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 403:	89 d8                	mov    %ebx,%eax
- 405:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 408:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 40b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 40e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 411:	76 dd                	jbe    3f0 <printint+0x30>
-  if(neg)
- 413:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 416:	85 c9                	test   %ecx,%ecx
- 418:	74 0c                	je     426 <printint+0x66>
-    buf[i++] = '-';
- 41a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 41f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 421:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 426:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 429:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 42d:	eb 07                	jmp    436 <printint+0x76>
- 42f:	90                   	nop
- 430:	0f b6 13             	movzbl (%ebx),%edx
- 433:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 436:	83 ec 04             	sub    $0x4,%esp
- 439:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 43c:	6a 01                	push   $0x1
- 43e:	56                   	push   %esi
- 43f:	57                   	push   %edi
- 440:	e8 8e fe ff ff       	call   2d3 <write>
-  while(--i >= 0)
- 445:	83 c4 10             	add    $0x10,%esp
- 448:	39 de                	cmp    %ebx,%esi
- 44a:	75 e4                	jne    430 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 44c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 44f:	5b                   	pop    %ebx
- 450:	5e                   	pop    %esi
- 451:	5f                   	pop    %edi
- 452:	5d                   	pop    %ebp
- 453:	c3                   	ret    
- 454:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 458:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 45f:	eb 87                	jmp    3e8 <printint+0x28>
- 461:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 468:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 46f:	90                   	nop
-
-00000470 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 470:	f3 0f 1e fb          	endbr32 
- 474:	55                   	push   %ebp
- 475:	89 e5                	mov    %esp,%ebp
- 477:	57                   	push   %edi
- 478:	56                   	push   %esi
- 479:	53                   	push   %ebx
- 47a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 47d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 480:	0f b6 1e             	movzbl (%esi),%ebx
- 483:	84 db                	test   %bl,%bl
- 485:	0f 84 b4 00 00 00    	je     53f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 48b:	8d 45 10             	lea    0x10(%ebp),%eax
- 48e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 491:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 494:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 496:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 499:	eb 33                	jmp    4ce <printf+0x5e>
- 49b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 49f:	90                   	nop
- 4a0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 4a3:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 4a8:	83 f8 25             	cmp    $0x25,%eax
- 4ab:	74 17                	je     4c4 <printf+0x54>
-  write(fd, &c, 1);
- 4ad:	83 ec 04             	sub    $0x4,%esp
- 4b0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 4b3:	6a 01                	push   $0x1
- 4b5:	57                   	push   %edi
- 4b6:	ff 75 08             	pushl  0x8(%ebp)
- 4b9:	e8 15 fe ff ff       	call   2d3 <write>
- 4be:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 4c1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 4c4:	0f b6 1e             	movzbl (%esi),%ebx
- 4c7:	83 c6 01             	add    $0x1,%esi
- 4ca:	84 db                	test   %bl,%bl
- 4cc:	74 71                	je     53f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 4ce:	0f be cb             	movsbl %bl,%ecx
- 4d1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 4d4:	85 d2                	test   %edx,%edx
- 4d6:	74 c8                	je     4a0 <printf+0x30>
-      }
-    } else if(state == '%'){
- 4d8:	83 fa 25             	cmp    $0x25,%edx
- 4db:	75 e7                	jne    4c4 <printf+0x54>
-      if(c == 'd'){
- 4dd:	83 f8 64             	cmp    $0x64,%eax
- 4e0:	0f 84 9a 00 00 00    	je     580 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 4e6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 4ec:	83 f9 70             	cmp    $0x70,%ecx
- 4ef:	74 5f                	je     550 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 4f1:	83 f8 73             	cmp    $0x73,%eax
- 4f4:	0f 84 d6 00 00 00    	je     5d0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 4fa:	83 f8 63             	cmp    $0x63,%eax
- 4fd:	0f 84 8d 00 00 00    	je     590 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 503:	83 f8 25             	cmp    $0x25,%eax
- 506:	0f 84 b4 00 00 00    	je     5c0 <printf+0x150>
-  write(fd, &c, 1);
- 50c:	83 ec 04             	sub    $0x4,%esp
- 50f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 513:	6a 01                	push   $0x1
- 515:	57                   	push   %edi
- 516:	ff 75 08             	pushl  0x8(%ebp)
- 519:	e8 b5 fd ff ff       	call   2d3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 51e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 521:	83 c4 0c             	add    $0xc,%esp
- 524:	6a 01                	push   $0x1
- 526:	83 c6 01             	add    $0x1,%esi
- 529:	57                   	push   %edi
- 52a:	ff 75 08             	pushl  0x8(%ebp)
- 52d:	e8 a1 fd ff ff       	call   2d3 <write>
-  for(i = 0; fmt[i]; i++){
- 532:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 536:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 539:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 53b:	84 db                	test   %bl,%bl
- 53d:	75 8f                	jne    4ce <printf+0x5e>
-    }
-  }
-}
- 53f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 542:	5b                   	pop    %ebx
- 543:	5e                   	pop    %esi
- 544:	5f                   	pop    %edi
- 545:	5d                   	pop    %ebp
- 546:	c3                   	ret    
- 547:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 54e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 550:	83 ec 0c             	sub    $0xc,%esp
- 553:	b9 10 00 00 00       	mov    $0x10,%ecx
- 558:	6a 00                	push   $0x0
- 55a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 55d:	8b 45 08             	mov    0x8(%ebp),%eax
- 560:	8b 13                	mov    (%ebx),%edx
- 562:	e8 59 fe ff ff       	call   3c0 <printint>
-        ap++;
- 567:	89 d8                	mov    %ebx,%eax
- 569:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 56c:	31 d2                	xor    %edx,%edx
-        ap++;
- 56e:	83 c0 04             	add    $0x4,%eax
- 571:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 574:	e9 4b ff ff ff       	jmp    4c4 <printf+0x54>
- 579:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 580:	83 ec 0c             	sub    $0xc,%esp
- 583:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 588:	6a 01                	push   $0x1
- 58a:	eb ce                	jmp    55a <printf+0xea>
- 58c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 590:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 593:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 596:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 598:	6a 01                	push   $0x1
-        ap++;
- 59a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 59d:	57                   	push   %edi
- 59e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 5a1:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 5a4:	e8 2a fd ff ff       	call   2d3 <write>
-        ap++;
- 5a9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 5ac:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 5af:	31 d2                	xor    %edx,%edx
- 5b1:	e9 0e ff ff ff       	jmp    4c4 <printf+0x54>
- 5b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5bd:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 5c0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5c3:	83 ec 04             	sub    $0x4,%esp
- 5c6:	e9 59 ff ff ff       	jmp    524 <printf+0xb4>
- 5cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 5cf:	90                   	nop
-        s = (char*)*ap;
- 5d0:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 5d3:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 5d5:	83 c0 04             	add    $0x4,%eax
- 5d8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 5db:	85 db                	test   %ebx,%ebx
- 5dd:	74 17                	je     5f6 <printf+0x186>
-        while(*s != 0){
- 5df:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 5e2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 5e4:	84 c0                	test   %al,%al
- 5e6:	0f 84 d8 fe ff ff    	je     4c4 <printf+0x54>
- 5ec:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5ef:	89 de                	mov    %ebx,%esi
- 5f1:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 5f4:	eb 1a                	jmp    610 <printf+0x1a0>
-          s = "(null)";
- 5f6:	bb fe 07 00 00       	mov    $0x7fe,%ebx
-        while(*s != 0){
- 5fb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5fe:	b8 28 00 00 00       	mov    $0x28,%eax
- 603:	89 de                	mov    %ebx,%esi
- 605:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 608:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 60f:	90                   	nop
-  write(fd, &c, 1);
- 610:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 613:	83 c6 01             	add    $0x1,%esi
- 616:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 619:	6a 01                	push   $0x1
- 61b:	57                   	push   %edi
- 61c:	53                   	push   %ebx
- 61d:	e8 b1 fc ff ff       	call   2d3 <write>
-        while(*s != 0){
- 622:	0f b6 06             	movzbl (%esi),%eax
- 625:	83 c4 10             	add    $0x10,%esp
- 628:	84 c0                	test   %al,%al
- 62a:	75 e4                	jne    610 <printf+0x1a0>
- 62c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 62f:	31 d2                	xor    %edx,%edx
- 631:	e9 8e fe ff ff       	jmp    4c4 <printf+0x54>
- 636:	66 90                	xchg   %ax,%ax
- 638:	66 90                	xchg   %ax,%ax
- 63a:	66 90                	xchg   %ax,%ax
- 63c:	66 90                	xchg   %ax,%ax
- 63e:	66 90                	xchg   %ax,%ax
-
-00000640 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 640:	f3 0f 1e fb          	endbr32 
- 644:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 645:	a1 b4 0a 00 00       	mov    0xab4,%eax
-{
- 64a:	89 e5                	mov    %esp,%ebp
- 64c:	57                   	push   %edi
- 64d:	56                   	push   %esi
- 64e:	53                   	push   %ebx
- 64f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 652:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 654:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 657:	39 c8                	cmp    %ecx,%eax
- 659:	73 15                	jae    670 <free+0x30>
- 65b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 65f:	90                   	nop
- 660:	39 d1                	cmp    %edx,%ecx
- 662:	72 14                	jb     678 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 664:	39 d0                	cmp    %edx,%eax
- 666:	73 10                	jae    678 <free+0x38>
-{
- 668:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 66a:	8b 10                	mov    (%eax),%edx
- 66c:	39 c8                	cmp    %ecx,%eax
- 66e:	72 f0                	jb     660 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 670:	39 d0                	cmp    %edx,%eax
- 672:	72 f4                	jb     668 <free+0x28>
- 674:	39 d1                	cmp    %edx,%ecx
- 676:	73 f0                	jae    668 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 678:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 67b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 67e:	39 fa                	cmp    %edi,%edx
- 680:	74 1e                	je     6a0 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 682:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 685:	8b 50 04             	mov    0x4(%eax),%edx
- 688:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 68b:	39 f1                	cmp    %esi,%ecx
- 68d:	74 28                	je     6b7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 68f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 691:	5b                   	pop    %ebx
-  freep = p;
- 692:	a3 b4 0a 00 00       	mov    %eax,0xab4
-}
- 697:	5e                   	pop    %esi
- 698:	5f                   	pop    %edi
- 699:	5d                   	pop    %ebp
- 69a:	c3                   	ret    
- 69b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 69f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 6a0:	03 72 04             	add    0x4(%edx),%esi
- 6a3:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 6a6:	8b 10                	mov    (%eax),%edx
- 6a8:	8b 12                	mov    (%edx),%edx
- 6aa:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 6ad:	8b 50 04             	mov    0x4(%eax),%edx
- 6b0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6b3:	39 f1                	cmp    %esi,%ecx
- 6b5:	75 d8                	jne    68f <free+0x4f>
-    p->s.size += bp->s.size;
- 6b7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 6ba:	a3 b4 0a 00 00       	mov    %eax,0xab4
-    p->s.size += bp->s.size;
- 6bf:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 6c2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 6c5:	89 10                	mov    %edx,(%eax)
-}
- 6c7:	5b                   	pop    %ebx
- 6c8:	5e                   	pop    %esi
- 6c9:	5f                   	pop    %edi
- 6ca:	5d                   	pop    %ebp
- 6cb:	c3                   	ret    
- 6cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000006d0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 6d0:	f3 0f 1e fb          	endbr32 
- 6d4:	55                   	push   %ebp
- 6d5:	89 e5                	mov    %esp,%ebp
- 6d7:	57                   	push   %edi
- 6d8:	56                   	push   %esi
- 6d9:	53                   	push   %ebx
- 6da:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6dd:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 6e0:	8b 3d b4 0a 00 00    	mov    0xab4,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6e6:	8d 70 07             	lea    0x7(%eax),%esi
- 6e9:	c1 ee 03             	shr    $0x3,%esi
- 6ec:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 6ef:	85 ff                	test   %edi,%edi
- 6f1:	0f 84 a9 00 00 00    	je     7a0 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 6f7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 6f9:	8b 48 04             	mov    0x4(%eax),%ecx
- 6fc:	39 f1                	cmp    %esi,%ecx
- 6fe:	73 6d                	jae    76d <malloc+0x9d>
- 700:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 706:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 70b:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 70e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 715:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 718:	eb 17                	jmp    731 <malloc+0x61>
- 71a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 720:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 722:	8b 4a 04             	mov    0x4(%edx),%ecx
- 725:	39 f1                	cmp    %esi,%ecx
- 727:	73 4f                	jae    778 <malloc+0xa8>
- 729:	8b 3d b4 0a 00 00    	mov    0xab4,%edi
- 72f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 731:	39 c7                	cmp    %eax,%edi
- 733:	75 eb                	jne    720 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 735:	83 ec 0c             	sub    $0xc,%esp
- 738:	ff 75 e4             	pushl  -0x1c(%ebp)
- 73b:	e8 fb fb ff ff       	call   33b <sbrk>
-  if(p == (char*)-1)
- 740:	83 c4 10             	add    $0x10,%esp
- 743:	83 f8 ff             	cmp    $0xffffffff,%eax
- 746:	74 1b                	je     763 <malloc+0x93>
-  hp->s.size = nu;
- 748:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 74b:	83 ec 0c             	sub    $0xc,%esp
- 74e:	83 c0 08             	add    $0x8,%eax
- 751:	50                   	push   %eax
- 752:	e8 e9 fe ff ff       	call   640 <free>
-  return freep;
- 757:	a1 b4 0a 00 00       	mov    0xab4,%eax
-      if((p = morecore(nunits)) == 0)
- 75c:	83 c4 10             	add    $0x10,%esp
- 75f:	85 c0                	test   %eax,%eax
- 761:	75 bd                	jne    720 <malloc+0x50>
-        return 0;
-  }
-}
- 763:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 766:	31 c0                	xor    %eax,%eax
-}
- 768:	5b                   	pop    %ebx
- 769:	5e                   	pop    %esi
- 76a:	5f                   	pop    %edi
- 76b:	5d                   	pop    %ebp
- 76c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 76d:	89 c2                	mov    %eax,%edx
- 76f:	89 f8                	mov    %edi,%eax
- 771:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 778:	39 ce                	cmp    %ecx,%esi
- 77a:	74 54                	je     7d0 <malloc+0x100>
-        p->s.size -= nunits;
- 77c:	29 f1                	sub    %esi,%ecx
- 77e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 781:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 784:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 787:	a3 b4 0a 00 00       	mov    %eax,0xab4
-}
- 78c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 78f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 792:	5b                   	pop    %ebx
- 793:	5e                   	pop    %esi
- 794:	5f                   	pop    %edi
- 795:	5d                   	pop    %ebp
- 796:	c3                   	ret    
- 797:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 79e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 7a0:	c7 05 b4 0a 00 00 b8 	movl   $0xab8,0xab4
- 7a7:	0a 00 00 
-    base.s.size = 0;
- 7aa:	bf b8 0a 00 00       	mov    $0xab8,%edi
-    base.s.ptr = freep = prevp = &base;
- 7af:	c7 05 b8 0a 00 00 b8 	movl   $0xab8,0xab8
- 7b6:	0a 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7b9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 7bb:	c7 05 bc 0a 00 00 00 	movl   $0x0,0xabc
- 7c2:	00 00 00 
-    if(p->s.size >= nunits){
- 7c5:	e9 36 ff ff ff       	jmp    700 <malloc+0x30>
- 7ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 7d0:	8b 0a                	mov    (%edx),%ecx
- 7d2:	89 08                	mov    %ecx,(%eax)
- 7d4:	eb b1                	jmp    787 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/getSyscallCounterTest.c b/xv6-public/Operating-System-Project/getSyscallCounterTest.c
deleted file mode 100644
index 8bf52b3..0000000
--- a/xv6-public/Operating-System-Project/getSyscallCounterTest.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main(int argc, char *argv[])
-{
-    int syscall_num = atoi(argv[1]);
-    printf(1, "Syscall #%d has been called %d times\n", syscall_num, getSyscallCounter(syscall_num));
-    exit();
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/getSyscallCounterTest.d b/xv6-public/Operating-System-Project/getSyscallCounterTest.d
deleted file mode 100644
index 37bc9a7..0000000
--- a/xv6-public/Operating-System-Project/getSyscallCounterTest.d
+++ /dev/null
@@ -1,2 +0,0 @@
-getSyscallCounterTest.o: getSyscallCounterTest.c \
- /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/getSyscallCounterTest.o b/xv6-public/Operating-System-Project/getSyscallCounterTest.o
deleted file mode 100644
index 3c7978d..0000000
Binary files a/xv6-public/Operating-System-Project/getSyscallCounterTest.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/getSyscallCounterTest.sym b/xv6-public/Operating-System-Project/getSyscallCounterTest.sym
deleted file mode 100644
index 8f1360b..0000000
--- a/xv6-public/Operating-System-Project/getSyscallCounterTest.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-000007d8 .rodata
-0000081c .eh_frame
-00000ab4 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 getSyscallCounterTest.c
-00000000 ulib.c
-00000000 printf.c
-000003c0 printint
-00000808 digits.1109
-00000000 umalloc.c
-00000ab4 freep
-00000ab8 base
-00000050 strcpy
-0000035b getChildren
-00000470 printf
-00000280 memmove
-000002fb mknod
-00000170 gets
-00000333 getpid
-00000393 customWait
-0000038b getCBT
-000006d0 malloc
-00000343 sleep
-000002c3 pipe
-00000373 changePolicy
-000002d3 write
-0000030b fstat
-000002e3 kill
-00000323 chdir
-0000039b setQueue
-000002eb exec
-000002bb wait
-000002cb read
-000003a3 getBurstTime
-00000303 unlink
-000002ab fork
-0000037b getTurnAroundTime
-0000033b sbrk
-0000034b uptime
-00000ab4 __bss_start
-00000110 memset
-00000000 main
-00000080 strcmp
-0000032b dup
-00000363 getSyscallCounter
-00000353 getParentID
-000001f0 stat
-00000ab4 _edata
-00000ac0 _end
-00000313 link
-000002b3 exit
-0000036b setPriority
-00000240 atoi
-000003ab getCreationTime
-000000d0 strlen
-000002f3 open
-00000130 strchr
-0000031b mkdir
-000002db close
-00000383 getWaitingTime
-00000640 free
diff --git a/xv6-public/Operating-System-Project/getTurnAroundTimeTest.asm b/xv6-public/Operating-System-Project/getTurnAroundTimeTest.asm
deleted file mode 100644
index 6218919..0000000
--- a/xv6-public/Operating-System-Project/getTurnAroundTimeTest.asm
+++ /dev/null
@@ -1,1245 +0,0 @@
-
-_getTurnAroundTimeTest:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main()
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	51                   	push   %ecx
-  12:	83 ec 0c             	sub    $0xc,%esp
-    printf(1, "This is getTurnAroundTimeTest template!");
-  15:	68 c8 07 00 00       	push   $0x7c8
-  1a:	6a 01                	push   $0x1
-  1c:	e8 3f 04 00 00       	call   460 <printf>
-
-    while (wait() != -1)
-  21:	83 c4 10             	add    $0x10,%esp
-  24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  28:	e8 7e 02 00 00       	call   2ab <wait>
-  2d:	83 f8 ff             	cmp    $0xffffffff,%eax
-  30:	75 f6                	jne    28 <main+0x28>
-        ;
-
-    exit();
-  32:	e8 6c 02 00 00       	call   2a3 <exit>
-  37:	66 90                	xchg   %ax,%ax
-  39:	66 90                	xchg   %ax,%ax
-  3b:	66 90                	xchg   %ax,%ax
-  3d:	66 90                	xchg   %ax,%ax
-  3f:	90                   	nop
-
-00000040 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  40:	f3 0f 1e fb          	endbr32 
-  44:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  45:	31 c0                	xor    %eax,%eax
-{
-  47:	89 e5                	mov    %esp,%ebp
-  49:	53                   	push   %ebx
-  4a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  4d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-  50:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-  54:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-  57:	83 c0 01             	add    $0x1,%eax
-  5a:	84 d2                	test   %dl,%dl
-  5c:	75 f2                	jne    50 <strcpy+0x10>
-    ;
-  return os;
-}
-  5e:	89 c8                	mov    %ecx,%eax
-  60:	5b                   	pop    %ebx
-  61:	5d                   	pop    %ebp
-  62:	c3                   	ret    
-  63:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000070 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-  70:	f3 0f 1e fb          	endbr32 
-  74:	55                   	push   %ebp
-  75:	89 e5                	mov    %esp,%ebp
-  77:	53                   	push   %ebx
-  78:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  7b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-  7e:	0f b6 01             	movzbl (%ecx),%eax
-  81:	0f b6 1a             	movzbl (%edx),%ebx
-  84:	84 c0                	test   %al,%al
-  86:	75 19                	jne    a1 <strcmp+0x31>
-  88:	eb 26                	jmp    b0 <strcmp+0x40>
-  8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  90:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-  94:	83 c1 01             	add    $0x1,%ecx
-  97:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-  9a:	0f b6 1a             	movzbl (%edx),%ebx
-  9d:	84 c0                	test   %al,%al
-  9f:	74 0f                	je     b0 <strcmp+0x40>
-  a1:	38 d8                	cmp    %bl,%al
-  a3:	74 eb                	je     90 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-  a5:	29 d8                	sub    %ebx,%eax
-}
-  a7:	5b                   	pop    %ebx
-  a8:	5d                   	pop    %ebp
-  a9:	c3                   	ret    
-  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  b0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-  b2:	29 d8                	sub    %ebx,%eax
-}
-  b4:	5b                   	pop    %ebx
-  b5:	5d                   	pop    %ebp
-  b6:	c3                   	ret    
-  b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  be:	66 90                	xchg   %ax,%ax
-
-000000c0 <strlen>:
-
-uint
-strlen(const char *s)
-{
-  c0:	f3 0f 1e fb          	endbr32 
-  c4:	55                   	push   %ebp
-  c5:	89 e5                	mov    %esp,%ebp
-  c7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
-  ca:	80 3a 00             	cmpb   $0x0,(%edx)
-  cd:	74 21                	je     f0 <strlen+0x30>
-  cf:	31 c0                	xor    %eax,%eax
-  d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  d8:	83 c0 01             	add    $0x1,%eax
-  db:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
-  df:	89 c1                	mov    %eax,%ecx
-  e1:	75 f5                	jne    d8 <strlen+0x18>
-    ;
-  return n;
-}
-  e3:	89 c8                	mov    %ecx,%eax
-  e5:	5d                   	pop    %ebp
-  e6:	c3                   	ret    
-  e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  ee:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
-  f0:	31 c9                	xor    %ecx,%ecx
-}
-  f2:	5d                   	pop    %ebp
-  f3:	89 c8                	mov    %ecx,%eax
-  f5:	c3                   	ret    
-  f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  fd:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000100 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 100:	f3 0f 1e fb          	endbr32 
- 104:	55                   	push   %ebp
- 105:	89 e5                	mov    %esp,%ebp
- 107:	57                   	push   %edi
- 108:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 10b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 10e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 111:	89 d7                	mov    %edx,%edi
- 113:	fc                   	cld    
- 114:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 116:	89 d0                	mov    %edx,%eax
- 118:	5f                   	pop    %edi
- 119:	5d                   	pop    %ebp
- 11a:	c3                   	ret    
- 11b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 11f:	90                   	nop
-
-00000120 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 120:	f3 0f 1e fb          	endbr32 
- 124:	55                   	push   %ebp
- 125:	89 e5                	mov    %esp,%ebp
- 127:	8b 45 08             	mov    0x8(%ebp),%eax
- 12a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 12e:	0f b6 10             	movzbl (%eax),%edx
- 131:	84 d2                	test   %dl,%dl
- 133:	75 16                	jne    14b <strchr+0x2b>
- 135:	eb 21                	jmp    158 <strchr+0x38>
- 137:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 13e:	66 90                	xchg   %ax,%ax
- 140:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 144:	83 c0 01             	add    $0x1,%eax
- 147:	84 d2                	test   %dl,%dl
- 149:	74 0d                	je     158 <strchr+0x38>
-    if(*s == c)
- 14b:	38 d1                	cmp    %dl,%cl
- 14d:	75 f1                	jne    140 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 14f:	5d                   	pop    %ebp
- 150:	c3                   	ret    
- 151:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 158:	31 c0                	xor    %eax,%eax
-}
- 15a:	5d                   	pop    %ebp
- 15b:	c3                   	ret    
- 15c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000160 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 160:	f3 0f 1e fb          	endbr32 
- 164:	55                   	push   %ebp
- 165:	89 e5                	mov    %esp,%ebp
- 167:	57                   	push   %edi
- 168:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 169:	31 f6                	xor    %esi,%esi
-{
- 16b:	53                   	push   %ebx
- 16c:	89 f3                	mov    %esi,%ebx
- 16e:	83 ec 1c             	sub    $0x1c,%esp
- 171:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 174:	eb 33                	jmp    1a9 <gets+0x49>
- 176:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 17d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 180:	83 ec 04             	sub    $0x4,%esp
- 183:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 186:	6a 01                	push   $0x1
- 188:	50                   	push   %eax
- 189:	6a 00                	push   $0x0
- 18b:	e8 2b 01 00 00       	call   2bb <read>
-    if(cc < 1)
- 190:	83 c4 10             	add    $0x10,%esp
- 193:	85 c0                	test   %eax,%eax
- 195:	7e 1c                	jle    1b3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 197:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 19b:	83 c7 01             	add    $0x1,%edi
- 19e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 1a1:	3c 0a                	cmp    $0xa,%al
- 1a3:	74 23                	je     1c8 <gets+0x68>
- 1a5:	3c 0d                	cmp    $0xd,%al
- 1a7:	74 1f                	je     1c8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 1a9:	83 c3 01             	add    $0x1,%ebx
- 1ac:	89 fe                	mov    %edi,%esi
- 1ae:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 1b1:	7c cd                	jl     180 <gets+0x20>
- 1b3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 1b5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 1b8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1be:	5b                   	pop    %ebx
- 1bf:	5e                   	pop    %esi
- 1c0:	5f                   	pop    %edi
- 1c1:	5d                   	pop    %ebp
- 1c2:	c3                   	ret    
- 1c3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 1c7:	90                   	nop
- 1c8:	8b 75 08             	mov    0x8(%ebp),%esi
- 1cb:	8b 45 08             	mov    0x8(%ebp),%eax
- 1ce:	01 de                	add    %ebx,%esi
- 1d0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 1d2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1d8:	5b                   	pop    %ebx
- 1d9:	5e                   	pop    %esi
- 1da:	5f                   	pop    %edi
- 1db:	5d                   	pop    %ebp
- 1dc:	c3                   	ret    
- 1dd:	8d 76 00             	lea    0x0(%esi),%esi
-
-000001e0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 1e0:	f3 0f 1e fb          	endbr32 
- 1e4:	55                   	push   %ebp
- 1e5:	89 e5                	mov    %esp,%ebp
- 1e7:	56                   	push   %esi
- 1e8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 1e9:	83 ec 08             	sub    $0x8,%esp
- 1ec:	6a 00                	push   $0x0
- 1ee:	ff 75 08             	pushl  0x8(%ebp)
- 1f1:	e8 ed 00 00 00       	call   2e3 <open>
-  if(fd < 0)
- 1f6:	83 c4 10             	add    $0x10,%esp
- 1f9:	85 c0                	test   %eax,%eax
- 1fb:	78 2b                	js     228 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 1fd:	83 ec 08             	sub    $0x8,%esp
- 200:	ff 75 0c             	pushl  0xc(%ebp)
- 203:	89 c3                	mov    %eax,%ebx
- 205:	50                   	push   %eax
- 206:	e8 f0 00 00 00       	call   2fb <fstat>
-  close(fd);
- 20b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 20e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 210:	e8 b6 00 00 00       	call   2cb <close>
-  return r;
- 215:	83 c4 10             	add    $0x10,%esp
-}
- 218:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 21b:	89 f0                	mov    %esi,%eax
- 21d:	5b                   	pop    %ebx
- 21e:	5e                   	pop    %esi
- 21f:	5d                   	pop    %ebp
- 220:	c3                   	ret    
- 221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 228:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 22d:	eb e9                	jmp    218 <stat+0x38>
- 22f:	90                   	nop
-
-00000230 <atoi>:
-
-int
-atoi(const char *s)
-{
- 230:	f3 0f 1e fb          	endbr32 
- 234:	55                   	push   %ebp
- 235:	89 e5                	mov    %esp,%ebp
- 237:	53                   	push   %ebx
- 238:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 23b:	0f be 02             	movsbl (%edx),%eax
- 23e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 241:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 244:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 249:	77 1a                	ja     265 <atoi+0x35>
- 24b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 24f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 250:	83 c2 01             	add    $0x1,%edx
- 253:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 256:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 25a:	0f be 02             	movsbl (%edx),%eax
- 25d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 260:	80 fb 09             	cmp    $0x9,%bl
- 263:	76 eb                	jbe    250 <atoi+0x20>
-  return n;
-}
- 265:	89 c8                	mov    %ecx,%eax
- 267:	5b                   	pop    %ebx
- 268:	5d                   	pop    %ebp
- 269:	c3                   	ret    
- 26a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000270 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 270:	f3 0f 1e fb          	endbr32 
- 274:	55                   	push   %ebp
- 275:	89 e5                	mov    %esp,%ebp
- 277:	57                   	push   %edi
- 278:	8b 45 10             	mov    0x10(%ebp),%eax
- 27b:	8b 55 08             	mov    0x8(%ebp),%edx
- 27e:	56                   	push   %esi
- 27f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 282:	85 c0                	test   %eax,%eax
- 284:	7e 0f                	jle    295 <memmove+0x25>
- 286:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 288:	89 d7                	mov    %edx,%edi
- 28a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 290:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 291:	39 f8                	cmp    %edi,%eax
- 293:	75 fb                	jne    290 <memmove+0x20>
-  return vdst;
-}
- 295:	5e                   	pop    %esi
- 296:	89 d0                	mov    %edx,%eax
- 298:	5f                   	pop    %edi
- 299:	5d                   	pop    %ebp
- 29a:	c3                   	ret    
-
-0000029b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 29b:	b8 01 00 00 00       	mov    $0x1,%eax
- 2a0:	cd 40                	int    $0x40
- 2a2:	c3                   	ret    
-
-000002a3 <exit>:
-SYSCALL(exit)
- 2a3:	b8 02 00 00 00       	mov    $0x2,%eax
- 2a8:	cd 40                	int    $0x40
- 2aa:	c3                   	ret    
-
-000002ab <wait>:
-SYSCALL(wait)
- 2ab:	b8 03 00 00 00       	mov    $0x3,%eax
- 2b0:	cd 40                	int    $0x40
- 2b2:	c3                   	ret    
-
-000002b3 <pipe>:
-SYSCALL(pipe)
- 2b3:	b8 04 00 00 00       	mov    $0x4,%eax
- 2b8:	cd 40                	int    $0x40
- 2ba:	c3                   	ret    
-
-000002bb <read>:
-SYSCALL(read)
- 2bb:	b8 05 00 00 00       	mov    $0x5,%eax
- 2c0:	cd 40                	int    $0x40
- 2c2:	c3                   	ret    
-
-000002c3 <write>:
-SYSCALL(write)
- 2c3:	b8 10 00 00 00       	mov    $0x10,%eax
- 2c8:	cd 40                	int    $0x40
- 2ca:	c3                   	ret    
-
-000002cb <close>:
-SYSCALL(close)
- 2cb:	b8 15 00 00 00       	mov    $0x15,%eax
- 2d0:	cd 40                	int    $0x40
- 2d2:	c3                   	ret    
-
-000002d3 <kill>:
-SYSCALL(kill)
- 2d3:	b8 06 00 00 00       	mov    $0x6,%eax
- 2d8:	cd 40                	int    $0x40
- 2da:	c3                   	ret    
-
-000002db <exec>:
-SYSCALL(exec)
- 2db:	b8 07 00 00 00       	mov    $0x7,%eax
- 2e0:	cd 40                	int    $0x40
- 2e2:	c3                   	ret    
-
-000002e3 <open>:
-SYSCALL(open)
- 2e3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 2e8:	cd 40                	int    $0x40
- 2ea:	c3                   	ret    
-
-000002eb <mknod>:
-SYSCALL(mknod)
- 2eb:	b8 11 00 00 00       	mov    $0x11,%eax
- 2f0:	cd 40                	int    $0x40
- 2f2:	c3                   	ret    
-
-000002f3 <unlink>:
-SYSCALL(unlink)
- 2f3:	b8 12 00 00 00       	mov    $0x12,%eax
- 2f8:	cd 40                	int    $0x40
- 2fa:	c3                   	ret    
-
-000002fb <fstat>:
-SYSCALL(fstat)
- 2fb:	b8 08 00 00 00       	mov    $0x8,%eax
- 300:	cd 40                	int    $0x40
- 302:	c3                   	ret    
-
-00000303 <link>:
-SYSCALL(link)
- 303:	b8 13 00 00 00       	mov    $0x13,%eax
- 308:	cd 40                	int    $0x40
- 30a:	c3                   	ret    
-
-0000030b <mkdir>:
-SYSCALL(mkdir)
- 30b:	b8 14 00 00 00       	mov    $0x14,%eax
- 310:	cd 40                	int    $0x40
- 312:	c3                   	ret    
-
-00000313 <chdir>:
-SYSCALL(chdir)
- 313:	b8 09 00 00 00       	mov    $0x9,%eax
- 318:	cd 40                	int    $0x40
- 31a:	c3                   	ret    
-
-0000031b <dup>:
-SYSCALL(dup)
- 31b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 320:	cd 40                	int    $0x40
- 322:	c3                   	ret    
-
-00000323 <getpid>:
-SYSCALL(getpid)
- 323:	b8 0b 00 00 00       	mov    $0xb,%eax
- 328:	cd 40                	int    $0x40
- 32a:	c3                   	ret    
-
-0000032b <sbrk>:
-SYSCALL(sbrk)
- 32b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 330:	cd 40                	int    $0x40
- 332:	c3                   	ret    
-
-00000333 <sleep>:
-SYSCALL(sleep)
- 333:	b8 0d 00 00 00       	mov    $0xd,%eax
- 338:	cd 40                	int    $0x40
- 33a:	c3                   	ret    
-
-0000033b <uptime>:
-SYSCALL(uptime)
- 33b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 340:	cd 40                	int    $0x40
- 342:	c3                   	ret    
-
-00000343 <getParentID>:
-SYSCALL(getParentID)
- 343:	b8 16 00 00 00       	mov    $0x16,%eax
- 348:	cd 40                	int    $0x40
- 34a:	c3                   	ret    
-
-0000034b <getChildren>:
-SYSCALL(getChildren)
- 34b:	b8 17 00 00 00       	mov    $0x17,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 353:	b8 18 00 00 00       	mov    $0x18,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <setPriority>:
-SYSCALL(setPriority)
- 35b:	b8 19 00 00 00       	mov    $0x19,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <changePolicy>:
-SYSCALL(changePolicy)
- 363:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 36b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 373:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <getCBT>:
-SYSCALL(getCBT)
- 37b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <customWait>:
-SYSCALL(customWait)
- 383:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <setQueue>:
-SYSCALL(setQueue)
- 38b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <getBurstTime>:
-SYSCALL(getBurstTime)
- 393:	b8 20 00 00 00       	mov    $0x20,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <getCreationTime>:
- 39b:	b8 21 00 00 00       	mov    $0x21,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
- 3a3:	66 90                	xchg   %ax,%ax
- 3a5:	66 90                	xchg   %ax,%ax
- 3a7:	66 90                	xchg   %ax,%ax
- 3a9:	66 90                	xchg   %ax,%ax
- 3ab:	66 90                	xchg   %ax,%ax
- 3ad:	66 90                	xchg   %ax,%ax
- 3af:	90                   	nop
-
-000003b0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 3b0:	55                   	push   %ebp
- 3b1:	89 e5                	mov    %esp,%ebp
- 3b3:	57                   	push   %edi
- 3b4:	56                   	push   %esi
- 3b5:	53                   	push   %ebx
- 3b6:	83 ec 3c             	sub    $0x3c,%esp
- 3b9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 3bc:	89 d1                	mov    %edx,%ecx
-{
- 3be:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 3c1:	85 d2                	test   %edx,%edx
- 3c3:	0f 89 7f 00 00 00    	jns    448 <printint+0x98>
- 3c9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 3cd:	74 79                	je     448 <printint+0x98>
-    neg = 1;
- 3cf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 3d6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 3d8:	31 db                	xor    %ebx,%ebx
- 3da:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 3dd:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 3e0:	89 c8                	mov    %ecx,%eax
- 3e2:	31 d2                	xor    %edx,%edx
- 3e4:	89 cf                	mov    %ecx,%edi
- 3e6:	f7 75 c4             	divl   -0x3c(%ebp)
- 3e9:	0f b6 92 f8 07 00 00 	movzbl 0x7f8(%edx),%edx
- 3f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 3f3:	89 d8                	mov    %ebx,%eax
- 3f5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 3f8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 3fb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 3fe:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 401:	76 dd                	jbe    3e0 <printint+0x30>
-  if(neg)
- 403:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 406:	85 c9                	test   %ecx,%ecx
- 408:	74 0c                	je     416 <printint+0x66>
-    buf[i++] = '-';
- 40a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 40f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 411:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 416:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 419:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 41d:	eb 07                	jmp    426 <printint+0x76>
- 41f:	90                   	nop
- 420:	0f b6 13             	movzbl (%ebx),%edx
- 423:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 426:	83 ec 04             	sub    $0x4,%esp
- 429:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 42c:	6a 01                	push   $0x1
- 42e:	56                   	push   %esi
- 42f:	57                   	push   %edi
- 430:	e8 8e fe ff ff       	call   2c3 <write>
-  while(--i >= 0)
- 435:	83 c4 10             	add    $0x10,%esp
- 438:	39 de                	cmp    %ebx,%esi
- 43a:	75 e4                	jne    420 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 43c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 43f:	5b                   	pop    %ebx
- 440:	5e                   	pop    %esi
- 441:	5f                   	pop    %edi
- 442:	5d                   	pop    %ebp
- 443:	c3                   	ret    
- 444:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 448:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 44f:	eb 87                	jmp    3d8 <printint+0x28>
- 451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 458:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 45f:	90                   	nop
-
-00000460 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 460:	f3 0f 1e fb          	endbr32 
- 464:	55                   	push   %ebp
- 465:	89 e5                	mov    %esp,%ebp
- 467:	57                   	push   %edi
- 468:	56                   	push   %esi
- 469:	53                   	push   %ebx
- 46a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 46d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 470:	0f b6 1e             	movzbl (%esi),%ebx
- 473:	84 db                	test   %bl,%bl
- 475:	0f 84 b4 00 00 00    	je     52f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 47b:	8d 45 10             	lea    0x10(%ebp),%eax
- 47e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 481:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 484:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 486:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 489:	eb 33                	jmp    4be <printf+0x5e>
- 48b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 48f:	90                   	nop
- 490:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 493:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 498:	83 f8 25             	cmp    $0x25,%eax
- 49b:	74 17                	je     4b4 <printf+0x54>
-  write(fd, &c, 1);
- 49d:	83 ec 04             	sub    $0x4,%esp
- 4a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 4a3:	6a 01                	push   $0x1
- 4a5:	57                   	push   %edi
- 4a6:	ff 75 08             	pushl  0x8(%ebp)
- 4a9:	e8 15 fe ff ff       	call   2c3 <write>
- 4ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 4b1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 4b4:	0f b6 1e             	movzbl (%esi),%ebx
- 4b7:	83 c6 01             	add    $0x1,%esi
- 4ba:	84 db                	test   %bl,%bl
- 4bc:	74 71                	je     52f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 4be:	0f be cb             	movsbl %bl,%ecx
- 4c1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 4c4:	85 d2                	test   %edx,%edx
- 4c6:	74 c8                	je     490 <printf+0x30>
-      }
-    } else if(state == '%'){
- 4c8:	83 fa 25             	cmp    $0x25,%edx
- 4cb:	75 e7                	jne    4b4 <printf+0x54>
-      if(c == 'd'){
- 4cd:	83 f8 64             	cmp    $0x64,%eax
- 4d0:	0f 84 9a 00 00 00    	je     570 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 4d6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 4dc:	83 f9 70             	cmp    $0x70,%ecx
- 4df:	74 5f                	je     540 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 4e1:	83 f8 73             	cmp    $0x73,%eax
- 4e4:	0f 84 d6 00 00 00    	je     5c0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 4ea:	83 f8 63             	cmp    $0x63,%eax
- 4ed:	0f 84 8d 00 00 00    	je     580 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 4f3:	83 f8 25             	cmp    $0x25,%eax
- 4f6:	0f 84 b4 00 00 00    	je     5b0 <printf+0x150>
-  write(fd, &c, 1);
- 4fc:	83 ec 04             	sub    $0x4,%esp
- 4ff:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 503:	6a 01                	push   $0x1
- 505:	57                   	push   %edi
- 506:	ff 75 08             	pushl  0x8(%ebp)
- 509:	e8 b5 fd ff ff       	call   2c3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 50e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 511:	83 c4 0c             	add    $0xc,%esp
- 514:	6a 01                	push   $0x1
- 516:	83 c6 01             	add    $0x1,%esi
- 519:	57                   	push   %edi
- 51a:	ff 75 08             	pushl  0x8(%ebp)
- 51d:	e8 a1 fd ff ff       	call   2c3 <write>
-  for(i = 0; fmt[i]; i++){
- 522:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 526:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 529:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 52b:	84 db                	test   %bl,%bl
- 52d:	75 8f                	jne    4be <printf+0x5e>
-    }
-  }
-}
- 52f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 532:	5b                   	pop    %ebx
- 533:	5e                   	pop    %esi
- 534:	5f                   	pop    %edi
- 535:	5d                   	pop    %ebp
- 536:	c3                   	ret    
- 537:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 53e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 540:	83 ec 0c             	sub    $0xc,%esp
- 543:	b9 10 00 00 00       	mov    $0x10,%ecx
- 548:	6a 00                	push   $0x0
- 54a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 54d:	8b 45 08             	mov    0x8(%ebp),%eax
- 550:	8b 13                	mov    (%ebx),%edx
- 552:	e8 59 fe ff ff       	call   3b0 <printint>
-        ap++;
- 557:	89 d8                	mov    %ebx,%eax
- 559:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 55c:	31 d2                	xor    %edx,%edx
-        ap++;
- 55e:	83 c0 04             	add    $0x4,%eax
- 561:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 564:	e9 4b ff ff ff       	jmp    4b4 <printf+0x54>
- 569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 570:	83 ec 0c             	sub    $0xc,%esp
- 573:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 578:	6a 01                	push   $0x1
- 57a:	eb ce                	jmp    54a <printf+0xea>
- 57c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 580:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 583:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 586:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 588:	6a 01                	push   $0x1
-        ap++;
- 58a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 58d:	57                   	push   %edi
- 58e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 591:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 594:	e8 2a fd ff ff       	call   2c3 <write>
-        ap++;
- 599:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 59c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 59f:	31 d2                	xor    %edx,%edx
- 5a1:	e9 0e ff ff ff       	jmp    4b4 <printf+0x54>
- 5a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5ad:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 5b0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5b3:	83 ec 04             	sub    $0x4,%esp
- 5b6:	e9 59 ff ff ff       	jmp    514 <printf+0xb4>
- 5bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 5bf:	90                   	nop
-        s = (char*)*ap;
- 5c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 5c3:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 5c5:	83 c0 04             	add    $0x4,%eax
- 5c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 5cb:	85 db                	test   %ebx,%ebx
- 5cd:	74 17                	je     5e6 <printf+0x186>
-        while(*s != 0){
- 5cf:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 5d2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 5d4:	84 c0                	test   %al,%al
- 5d6:	0f 84 d8 fe ff ff    	je     4b4 <printf+0x54>
- 5dc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5df:	89 de                	mov    %ebx,%esi
- 5e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 5e4:	eb 1a                	jmp    600 <printf+0x1a0>
-          s = "(null)";
- 5e6:	bb f0 07 00 00       	mov    $0x7f0,%ebx
-        while(*s != 0){
- 5eb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5ee:	b8 28 00 00 00       	mov    $0x28,%eax
- 5f3:	89 de                	mov    %ebx,%esi
- 5f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 5f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5ff:	90                   	nop
-  write(fd, &c, 1);
- 600:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 603:	83 c6 01             	add    $0x1,%esi
- 606:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 609:	6a 01                	push   $0x1
- 60b:	57                   	push   %edi
- 60c:	53                   	push   %ebx
- 60d:	e8 b1 fc ff ff       	call   2c3 <write>
-        while(*s != 0){
- 612:	0f b6 06             	movzbl (%esi),%eax
- 615:	83 c4 10             	add    $0x10,%esp
- 618:	84 c0                	test   %al,%al
- 61a:	75 e4                	jne    600 <printf+0x1a0>
- 61c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 61f:	31 d2                	xor    %edx,%edx
- 621:	e9 8e fe ff ff       	jmp    4b4 <printf+0x54>
- 626:	66 90                	xchg   %ax,%ax
- 628:	66 90                	xchg   %ax,%ax
- 62a:	66 90                	xchg   %ax,%ax
- 62c:	66 90                	xchg   %ax,%ax
- 62e:	66 90                	xchg   %ax,%ax
-
-00000630 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 630:	f3 0f 1e fb          	endbr32 
- 634:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 635:	a1 a0 0a 00 00       	mov    0xaa0,%eax
-{
- 63a:	89 e5                	mov    %esp,%ebp
- 63c:	57                   	push   %edi
- 63d:	56                   	push   %esi
- 63e:	53                   	push   %ebx
- 63f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 642:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 644:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 647:	39 c8                	cmp    %ecx,%eax
- 649:	73 15                	jae    660 <free+0x30>
- 64b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 64f:	90                   	nop
- 650:	39 d1                	cmp    %edx,%ecx
- 652:	72 14                	jb     668 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 654:	39 d0                	cmp    %edx,%eax
- 656:	73 10                	jae    668 <free+0x38>
-{
- 658:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 65a:	8b 10                	mov    (%eax),%edx
- 65c:	39 c8                	cmp    %ecx,%eax
- 65e:	72 f0                	jb     650 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 660:	39 d0                	cmp    %edx,%eax
- 662:	72 f4                	jb     658 <free+0x28>
- 664:	39 d1                	cmp    %edx,%ecx
- 666:	73 f0                	jae    658 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 668:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 66b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 66e:	39 fa                	cmp    %edi,%edx
- 670:	74 1e                	je     690 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 672:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 675:	8b 50 04             	mov    0x4(%eax),%edx
- 678:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 67b:	39 f1                	cmp    %esi,%ecx
- 67d:	74 28                	je     6a7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 67f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 681:	5b                   	pop    %ebx
-  freep = p;
- 682:	a3 a0 0a 00 00       	mov    %eax,0xaa0
-}
- 687:	5e                   	pop    %esi
- 688:	5f                   	pop    %edi
- 689:	5d                   	pop    %ebp
- 68a:	c3                   	ret    
- 68b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 68f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 690:	03 72 04             	add    0x4(%edx),%esi
- 693:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 696:	8b 10                	mov    (%eax),%edx
- 698:	8b 12                	mov    (%edx),%edx
- 69a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 69d:	8b 50 04             	mov    0x4(%eax),%edx
- 6a0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6a3:	39 f1                	cmp    %esi,%ecx
- 6a5:	75 d8                	jne    67f <free+0x4f>
-    p->s.size += bp->s.size;
- 6a7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 6aa:	a3 a0 0a 00 00       	mov    %eax,0xaa0
-    p->s.size += bp->s.size;
- 6af:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 6b2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 6b5:	89 10                	mov    %edx,(%eax)
-}
- 6b7:	5b                   	pop    %ebx
- 6b8:	5e                   	pop    %esi
- 6b9:	5f                   	pop    %edi
- 6ba:	5d                   	pop    %ebp
- 6bb:	c3                   	ret    
- 6bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000006c0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 6c0:	f3 0f 1e fb          	endbr32 
- 6c4:	55                   	push   %ebp
- 6c5:	89 e5                	mov    %esp,%ebp
- 6c7:	57                   	push   %edi
- 6c8:	56                   	push   %esi
- 6c9:	53                   	push   %ebx
- 6ca:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6cd:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 6d0:	8b 3d a0 0a 00 00    	mov    0xaa0,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6d6:	8d 70 07             	lea    0x7(%eax),%esi
- 6d9:	c1 ee 03             	shr    $0x3,%esi
- 6dc:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 6df:	85 ff                	test   %edi,%edi
- 6e1:	0f 84 a9 00 00 00    	je     790 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 6e7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 6e9:	8b 48 04             	mov    0x4(%eax),%ecx
- 6ec:	39 f1                	cmp    %esi,%ecx
- 6ee:	73 6d                	jae    75d <malloc+0x9d>
- 6f0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 6f6:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 6fb:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 6fe:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 705:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 708:	eb 17                	jmp    721 <malloc+0x61>
- 70a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 710:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 712:	8b 4a 04             	mov    0x4(%edx),%ecx
- 715:	39 f1                	cmp    %esi,%ecx
- 717:	73 4f                	jae    768 <malloc+0xa8>
- 719:	8b 3d a0 0a 00 00    	mov    0xaa0,%edi
- 71f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 721:	39 c7                	cmp    %eax,%edi
- 723:	75 eb                	jne    710 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 725:	83 ec 0c             	sub    $0xc,%esp
- 728:	ff 75 e4             	pushl  -0x1c(%ebp)
- 72b:	e8 fb fb ff ff       	call   32b <sbrk>
-  if(p == (char*)-1)
- 730:	83 c4 10             	add    $0x10,%esp
- 733:	83 f8 ff             	cmp    $0xffffffff,%eax
- 736:	74 1b                	je     753 <malloc+0x93>
-  hp->s.size = nu;
- 738:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 73b:	83 ec 0c             	sub    $0xc,%esp
- 73e:	83 c0 08             	add    $0x8,%eax
- 741:	50                   	push   %eax
- 742:	e8 e9 fe ff ff       	call   630 <free>
-  return freep;
- 747:	a1 a0 0a 00 00       	mov    0xaa0,%eax
-      if((p = morecore(nunits)) == 0)
- 74c:	83 c4 10             	add    $0x10,%esp
- 74f:	85 c0                	test   %eax,%eax
- 751:	75 bd                	jne    710 <malloc+0x50>
-        return 0;
-  }
-}
- 753:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 756:	31 c0                	xor    %eax,%eax
-}
- 758:	5b                   	pop    %ebx
- 759:	5e                   	pop    %esi
- 75a:	5f                   	pop    %edi
- 75b:	5d                   	pop    %ebp
- 75c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 75d:	89 c2                	mov    %eax,%edx
- 75f:	89 f8                	mov    %edi,%eax
- 761:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 768:	39 ce                	cmp    %ecx,%esi
- 76a:	74 54                	je     7c0 <malloc+0x100>
-        p->s.size -= nunits;
- 76c:	29 f1                	sub    %esi,%ecx
- 76e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 771:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 774:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 777:	a3 a0 0a 00 00       	mov    %eax,0xaa0
-}
- 77c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 77f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 782:	5b                   	pop    %ebx
- 783:	5e                   	pop    %esi
- 784:	5f                   	pop    %edi
- 785:	5d                   	pop    %ebp
- 786:	c3                   	ret    
- 787:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 78e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 790:	c7 05 a0 0a 00 00 a4 	movl   $0xaa4,0xaa0
- 797:	0a 00 00 
-    base.s.size = 0;
- 79a:	bf a4 0a 00 00       	mov    $0xaa4,%edi
-    base.s.ptr = freep = prevp = &base;
- 79f:	c7 05 a4 0a 00 00 a4 	movl   $0xaa4,0xaa4
- 7a6:	0a 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7a9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 7ab:	c7 05 a8 0a 00 00 00 	movl   $0x0,0xaa8
- 7b2:	00 00 00 
-    if(p->s.size >= nunits){
- 7b5:	e9 36 ff ff ff       	jmp    6f0 <malloc+0x30>
- 7ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 7c0:	8b 0a                	mov    (%edx),%ecx
- 7c2:	89 08                	mov    %ecx,(%eax)
- 7c4:	eb b1                	jmp    777 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/getTurnAroundTimeTest.c b/xv6-public/Operating-System-Project/getTurnAroundTimeTest.c
deleted file mode 100644
index 663cfff..0000000
--- a/xv6-public/Operating-System-Project/getTurnAroundTimeTest.c
+++ /dev/null
@@ -1,13 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main()
-{
-    printf(1, "This is getTurnAroundTimeTest template!");
-
-    while (wait() != -1)
-        ;
-
-    exit();
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/getTurnAroundTimeTest.d b/xv6-public/Operating-System-Project/getTurnAroundTimeTest.d
deleted file mode 100644
index 356d857..0000000
--- a/xv6-public/Operating-System-Project/getTurnAroundTimeTest.d
+++ /dev/null
@@ -1,2 +0,0 @@
-getTurnAroundTimeTest.o: getTurnAroundTimeTest.c \
- /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/getTurnAroundTimeTest.o b/xv6-public/Operating-System-Project/getTurnAroundTimeTest.o
deleted file mode 100644
index 1134578..0000000
Binary files a/xv6-public/Operating-System-Project/getTurnAroundTimeTest.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/getTurnAroundTimeTest.sym b/xv6-public/Operating-System-Project/getTurnAroundTimeTest.sym
deleted file mode 100644
index f8bdd5c..0000000
--- a/xv6-public/Operating-System-Project/getTurnAroundTimeTest.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-000007c8 .rodata
-0000080c .eh_frame
-00000aa0 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 getTurnAroundTimeTest.c
-00000000 ulib.c
-00000000 printf.c
-000003b0 printint
-000007f8 digits.1109
-00000000 umalloc.c
-00000aa0 freep
-00000aa4 base
-00000040 strcpy
-0000034b getChildren
-00000460 printf
-00000270 memmove
-000002eb mknod
-00000160 gets
-00000323 getpid
-00000383 customWait
-0000037b getCBT
-000006c0 malloc
-00000333 sleep
-000002b3 pipe
-00000363 changePolicy
-000002c3 write
-000002fb fstat
-000002d3 kill
-00000313 chdir
-0000038b setQueue
-000002db exec
-000002ab wait
-000002bb read
-00000393 getBurstTime
-000002f3 unlink
-0000029b fork
-0000036b getTurnAroundTime
-0000032b sbrk
-0000033b uptime
-00000aa0 __bss_start
-00000100 memset
-00000000 main
-00000070 strcmp
-0000031b dup
-00000353 getSyscallCounter
-00000343 getParentID
-000001e0 stat
-00000aa0 _edata
-00000aac _end
-00000303 link
-000002a3 exit
-0000035b setPriority
-00000230 atoi
-0000039b getCreationTime
-000000c0 strlen
-000002e3 open
-00000120 strchr
-0000030b mkdir
-000002cb close
-00000373 getWaitingTime
-00000630 free
diff --git a/xv6-public/Operating-System-Project/getWaitingTimeTest.asm b/xv6-public/Operating-System-Project/getWaitingTimeTest.asm
deleted file mode 100644
index 7038c39..0000000
--- a/xv6-public/Operating-System-Project/getWaitingTimeTest.asm
+++ /dev/null
@@ -1,1245 +0,0 @@
-
-_getWaitingTimeTest:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main()
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	51                   	push   %ecx
-  12:	83 ec 0c             	sub    $0xc,%esp
-    printf(1, "This is getWaitingTimeTest template!");
-  15:	68 c8 07 00 00       	push   $0x7c8
-  1a:	6a 01                	push   $0x1
-  1c:	e8 3f 04 00 00       	call   460 <printf>
-
-    while (wait() != -1)
-  21:	83 c4 10             	add    $0x10,%esp
-  24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  28:	e8 7e 02 00 00       	call   2ab <wait>
-  2d:	83 f8 ff             	cmp    $0xffffffff,%eax
-  30:	75 f6                	jne    28 <main+0x28>
-        ;
-
-    exit();
-  32:	e8 6c 02 00 00       	call   2a3 <exit>
-  37:	66 90                	xchg   %ax,%ax
-  39:	66 90                	xchg   %ax,%ax
-  3b:	66 90                	xchg   %ax,%ax
-  3d:	66 90                	xchg   %ax,%ax
-  3f:	90                   	nop
-
-00000040 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  40:	f3 0f 1e fb          	endbr32 
-  44:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  45:	31 c0                	xor    %eax,%eax
-{
-  47:	89 e5                	mov    %esp,%ebp
-  49:	53                   	push   %ebx
-  4a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  4d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-  50:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-  54:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-  57:	83 c0 01             	add    $0x1,%eax
-  5a:	84 d2                	test   %dl,%dl
-  5c:	75 f2                	jne    50 <strcpy+0x10>
-    ;
-  return os;
-}
-  5e:	89 c8                	mov    %ecx,%eax
-  60:	5b                   	pop    %ebx
-  61:	5d                   	pop    %ebp
-  62:	c3                   	ret    
-  63:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000070 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-  70:	f3 0f 1e fb          	endbr32 
-  74:	55                   	push   %ebp
-  75:	89 e5                	mov    %esp,%ebp
-  77:	53                   	push   %ebx
-  78:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  7b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-  7e:	0f b6 01             	movzbl (%ecx),%eax
-  81:	0f b6 1a             	movzbl (%edx),%ebx
-  84:	84 c0                	test   %al,%al
-  86:	75 19                	jne    a1 <strcmp+0x31>
-  88:	eb 26                	jmp    b0 <strcmp+0x40>
-  8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  90:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-  94:	83 c1 01             	add    $0x1,%ecx
-  97:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-  9a:	0f b6 1a             	movzbl (%edx),%ebx
-  9d:	84 c0                	test   %al,%al
-  9f:	74 0f                	je     b0 <strcmp+0x40>
-  a1:	38 d8                	cmp    %bl,%al
-  a3:	74 eb                	je     90 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-  a5:	29 d8                	sub    %ebx,%eax
-}
-  a7:	5b                   	pop    %ebx
-  a8:	5d                   	pop    %ebp
-  a9:	c3                   	ret    
-  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  b0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-  b2:	29 d8                	sub    %ebx,%eax
-}
-  b4:	5b                   	pop    %ebx
-  b5:	5d                   	pop    %ebp
-  b6:	c3                   	ret    
-  b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  be:	66 90                	xchg   %ax,%ax
-
-000000c0 <strlen>:
-
-uint
-strlen(const char *s)
-{
-  c0:	f3 0f 1e fb          	endbr32 
-  c4:	55                   	push   %ebp
-  c5:	89 e5                	mov    %esp,%ebp
-  c7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
-  ca:	80 3a 00             	cmpb   $0x0,(%edx)
-  cd:	74 21                	je     f0 <strlen+0x30>
-  cf:	31 c0                	xor    %eax,%eax
-  d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  d8:	83 c0 01             	add    $0x1,%eax
-  db:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
-  df:	89 c1                	mov    %eax,%ecx
-  e1:	75 f5                	jne    d8 <strlen+0x18>
-    ;
-  return n;
-}
-  e3:	89 c8                	mov    %ecx,%eax
-  e5:	5d                   	pop    %ebp
-  e6:	c3                   	ret    
-  e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  ee:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
-  f0:	31 c9                	xor    %ecx,%ecx
-}
-  f2:	5d                   	pop    %ebp
-  f3:	89 c8                	mov    %ecx,%eax
-  f5:	c3                   	ret    
-  f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  fd:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000100 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 100:	f3 0f 1e fb          	endbr32 
- 104:	55                   	push   %ebp
- 105:	89 e5                	mov    %esp,%ebp
- 107:	57                   	push   %edi
- 108:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 10b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 10e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 111:	89 d7                	mov    %edx,%edi
- 113:	fc                   	cld    
- 114:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 116:	89 d0                	mov    %edx,%eax
- 118:	5f                   	pop    %edi
- 119:	5d                   	pop    %ebp
- 11a:	c3                   	ret    
- 11b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 11f:	90                   	nop
-
-00000120 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 120:	f3 0f 1e fb          	endbr32 
- 124:	55                   	push   %ebp
- 125:	89 e5                	mov    %esp,%ebp
- 127:	8b 45 08             	mov    0x8(%ebp),%eax
- 12a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 12e:	0f b6 10             	movzbl (%eax),%edx
- 131:	84 d2                	test   %dl,%dl
- 133:	75 16                	jne    14b <strchr+0x2b>
- 135:	eb 21                	jmp    158 <strchr+0x38>
- 137:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 13e:	66 90                	xchg   %ax,%ax
- 140:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 144:	83 c0 01             	add    $0x1,%eax
- 147:	84 d2                	test   %dl,%dl
- 149:	74 0d                	je     158 <strchr+0x38>
-    if(*s == c)
- 14b:	38 d1                	cmp    %dl,%cl
- 14d:	75 f1                	jne    140 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 14f:	5d                   	pop    %ebp
- 150:	c3                   	ret    
- 151:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 158:	31 c0                	xor    %eax,%eax
-}
- 15a:	5d                   	pop    %ebp
- 15b:	c3                   	ret    
- 15c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000160 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 160:	f3 0f 1e fb          	endbr32 
- 164:	55                   	push   %ebp
- 165:	89 e5                	mov    %esp,%ebp
- 167:	57                   	push   %edi
- 168:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 169:	31 f6                	xor    %esi,%esi
-{
- 16b:	53                   	push   %ebx
- 16c:	89 f3                	mov    %esi,%ebx
- 16e:	83 ec 1c             	sub    $0x1c,%esp
- 171:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 174:	eb 33                	jmp    1a9 <gets+0x49>
- 176:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 17d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 180:	83 ec 04             	sub    $0x4,%esp
- 183:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 186:	6a 01                	push   $0x1
- 188:	50                   	push   %eax
- 189:	6a 00                	push   $0x0
- 18b:	e8 2b 01 00 00       	call   2bb <read>
-    if(cc < 1)
- 190:	83 c4 10             	add    $0x10,%esp
- 193:	85 c0                	test   %eax,%eax
- 195:	7e 1c                	jle    1b3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 197:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 19b:	83 c7 01             	add    $0x1,%edi
- 19e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 1a1:	3c 0a                	cmp    $0xa,%al
- 1a3:	74 23                	je     1c8 <gets+0x68>
- 1a5:	3c 0d                	cmp    $0xd,%al
- 1a7:	74 1f                	je     1c8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 1a9:	83 c3 01             	add    $0x1,%ebx
- 1ac:	89 fe                	mov    %edi,%esi
- 1ae:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 1b1:	7c cd                	jl     180 <gets+0x20>
- 1b3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 1b5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 1b8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1be:	5b                   	pop    %ebx
- 1bf:	5e                   	pop    %esi
- 1c0:	5f                   	pop    %edi
- 1c1:	5d                   	pop    %ebp
- 1c2:	c3                   	ret    
- 1c3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 1c7:	90                   	nop
- 1c8:	8b 75 08             	mov    0x8(%ebp),%esi
- 1cb:	8b 45 08             	mov    0x8(%ebp),%eax
- 1ce:	01 de                	add    %ebx,%esi
- 1d0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 1d2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1d8:	5b                   	pop    %ebx
- 1d9:	5e                   	pop    %esi
- 1da:	5f                   	pop    %edi
- 1db:	5d                   	pop    %ebp
- 1dc:	c3                   	ret    
- 1dd:	8d 76 00             	lea    0x0(%esi),%esi
-
-000001e0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 1e0:	f3 0f 1e fb          	endbr32 
- 1e4:	55                   	push   %ebp
- 1e5:	89 e5                	mov    %esp,%ebp
- 1e7:	56                   	push   %esi
- 1e8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 1e9:	83 ec 08             	sub    $0x8,%esp
- 1ec:	6a 00                	push   $0x0
- 1ee:	ff 75 08             	pushl  0x8(%ebp)
- 1f1:	e8 ed 00 00 00       	call   2e3 <open>
-  if(fd < 0)
- 1f6:	83 c4 10             	add    $0x10,%esp
- 1f9:	85 c0                	test   %eax,%eax
- 1fb:	78 2b                	js     228 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 1fd:	83 ec 08             	sub    $0x8,%esp
- 200:	ff 75 0c             	pushl  0xc(%ebp)
- 203:	89 c3                	mov    %eax,%ebx
- 205:	50                   	push   %eax
- 206:	e8 f0 00 00 00       	call   2fb <fstat>
-  close(fd);
- 20b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 20e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 210:	e8 b6 00 00 00       	call   2cb <close>
-  return r;
- 215:	83 c4 10             	add    $0x10,%esp
-}
- 218:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 21b:	89 f0                	mov    %esi,%eax
- 21d:	5b                   	pop    %ebx
- 21e:	5e                   	pop    %esi
- 21f:	5d                   	pop    %ebp
- 220:	c3                   	ret    
- 221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 228:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 22d:	eb e9                	jmp    218 <stat+0x38>
- 22f:	90                   	nop
-
-00000230 <atoi>:
-
-int
-atoi(const char *s)
-{
- 230:	f3 0f 1e fb          	endbr32 
- 234:	55                   	push   %ebp
- 235:	89 e5                	mov    %esp,%ebp
- 237:	53                   	push   %ebx
- 238:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 23b:	0f be 02             	movsbl (%edx),%eax
- 23e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 241:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 244:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 249:	77 1a                	ja     265 <atoi+0x35>
- 24b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 24f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 250:	83 c2 01             	add    $0x1,%edx
- 253:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 256:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 25a:	0f be 02             	movsbl (%edx),%eax
- 25d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 260:	80 fb 09             	cmp    $0x9,%bl
- 263:	76 eb                	jbe    250 <atoi+0x20>
-  return n;
-}
- 265:	89 c8                	mov    %ecx,%eax
- 267:	5b                   	pop    %ebx
- 268:	5d                   	pop    %ebp
- 269:	c3                   	ret    
- 26a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000270 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 270:	f3 0f 1e fb          	endbr32 
- 274:	55                   	push   %ebp
- 275:	89 e5                	mov    %esp,%ebp
- 277:	57                   	push   %edi
- 278:	8b 45 10             	mov    0x10(%ebp),%eax
- 27b:	8b 55 08             	mov    0x8(%ebp),%edx
- 27e:	56                   	push   %esi
- 27f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 282:	85 c0                	test   %eax,%eax
- 284:	7e 0f                	jle    295 <memmove+0x25>
- 286:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 288:	89 d7                	mov    %edx,%edi
- 28a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 290:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 291:	39 f8                	cmp    %edi,%eax
- 293:	75 fb                	jne    290 <memmove+0x20>
-  return vdst;
-}
- 295:	5e                   	pop    %esi
- 296:	89 d0                	mov    %edx,%eax
- 298:	5f                   	pop    %edi
- 299:	5d                   	pop    %ebp
- 29a:	c3                   	ret    
-
-0000029b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 29b:	b8 01 00 00 00       	mov    $0x1,%eax
- 2a0:	cd 40                	int    $0x40
- 2a2:	c3                   	ret    
-
-000002a3 <exit>:
-SYSCALL(exit)
- 2a3:	b8 02 00 00 00       	mov    $0x2,%eax
- 2a8:	cd 40                	int    $0x40
- 2aa:	c3                   	ret    
-
-000002ab <wait>:
-SYSCALL(wait)
- 2ab:	b8 03 00 00 00       	mov    $0x3,%eax
- 2b0:	cd 40                	int    $0x40
- 2b2:	c3                   	ret    
-
-000002b3 <pipe>:
-SYSCALL(pipe)
- 2b3:	b8 04 00 00 00       	mov    $0x4,%eax
- 2b8:	cd 40                	int    $0x40
- 2ba:	c3                   	ret    
-
-000002bb <read>:
-SYSCALL(read)
- 2bb:	b8 05 00 00 00       	mov    $0x5,%eax
- 2c0:	cd 40                	int    $0x40
- 2c2:	c3                   	ret    
-
-000002c3 <write>:
-SYSCALL(write)
- 2c3:	b8 10 00 00 00       	mov    $0x10,%eax
- 2c8:	cd 40                	int    $0x40
- 2ca:	c3                   	ret    
-
-000002cb <close>:
-SYSCALL(close)
- 2cb:	b8 15 00 00 00       	mov    $0x15,%eax
- 2d0:	cd 40                	int    $0x40
- 2d2:	c3                   	ret    
-
-000002d3 <kill>:
-SYSCALL(kill)
- 2d3:	b8 06 00 00 00       	mov    $0x6,%eax
- 2d8:	cd 40                	int    $0x40
- 2da:	c3                   	ret    
-
-000002db <exec>:
-SYSCALL(exec)
- 2db:	b8 07 00 00 00       	mov    $0x7,%eax
- 2e0:	cd 40                	int    $0x40
- 2e2:	c3                   	ret    
-
-000002e3 <open>:
-SYSCALL(open)
- 2e3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 2e8:	cd 40                	int    $0x40
- 2ea:	c3                   	ret    
-
-000002eb <mknod>:
-SYSCALL(mknod)
- 2eb:	b8 11 00 00 00       	mov    $0x11,%eax
- 2f0:	cd 40                	int    $0x40
- 2f2:	c3                   	ret    
-
-000002f3 <unlink>:
-SYSCALL(unlink)
- 2f3:	b8 12 00 00 00       	mov    $0x12,%eax
- 2f8:	cd 40                	int    $0x40
- 2fa:	c3                   	ret    
-
-000002fb <fstat>:
-SYSCALL(fstat)
- 2fb:	b8 08 00 00 00       	mov    $0x8,%eax
- 300:	cd 40                	int    $0x40
- 302:	c3                   	ret    
-
-00000303 <link>:
-SYSCALL(link)
- 303:	b8 13 00 00 00       	mov    $0x13,%eax
- 308:	cd 40                	int    $0x40
- 30a:	c3                   	ret    
-
-0000030b <mkdir>:
-SYSCALL(mkdir)
- 30b:	b8 14 00 00 00       	mov    $0x14,%eax
- 310:	cd 40                	int    $0x40
- 312:	c3                   	ret    
-
-00000313 <chdir>:
-SYSCALL(chdir)
- 313:	b8 09 00 00 00       	mov    $0x9,%eax
- 318:	cd 40                	int    $0x40
- 31a:	c3                   	ret    
-
-0000031b <dup>:
-SYSCALL(dup)
- 31b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 320:	cd 40                	int    $0x40
- 322:	c3                   	ret    
-
-00000323 <getpid>:
-SYSCALL(getpid)
- 323:	b8 0b 00 00 00       	mov    $0xb,%eax
- 328:	cd 40                	int    $0x40
- 32a:	c3                   	ret    
-
-0000032b <sbrk>:
-SYSCALL(sbrk)
- 32b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 330:	cd 40                	int    $0x40
- 332:	c3                   	ret    
-
-00000333 <sleep>:
-SYSCALL(sleep)
- 333:	b8 0d 00 00 00       	mov    $0xd,%eax
- 338:	cd 40                	int    $0x40
- 33a:	c3                   	ret    
-
-0000033b <uptime>:
-SYSCALL(uptime)
- 33b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 340:	cd 40                	int    $0x40
- 342:	c3                   	ret    
-
-00000343 <getParentID>:
-SYSCALL(getParentID)
- 343:	b8 16 00 00 00       	mov    $0x16,%eax
- 348:	cd 40                	int    $0x40
- 34a:	c3                   	ret    
-
-0000034b <getChildren>:
-SYSCALL(getChildren)
- 34b:	b8 17 00 00 00       	mov    $0x17,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 353:	b8 18 00 00 00       	mov    $0x18,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <setPriority>:
-SYSCALL(setPriority)
- 35b:	b8 19 00 00 00       	mov    $0x19,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <changePolicy>:
-SYSCALL(changePolicy)
- 363:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 36b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 373:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <getCBT>:
-SYSCALL(getCBT)
- 37b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <customWait>:
-SYSCALL(customWait)
- 383:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <setQueue>:
-SYSCALL(setQueue)
- 38b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <getBurstTime>:
-SYSCALL(getBurstTime)
- 393:	b8 20 00 00 00       	mov    $0x20,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <getCreationTime>:
- 39b:	b8 21 00 00 00       	mov    $0x21,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
- 3a3:	66 90                	xchg   %ax,%ax
- 3a5:	66 90                	xchg   %ax,%ax
- 3a7:	66 90                	xchg   %ax,%ax
- 3a9:	66 90                	xchg   %ax,%ax
- 3ab:	66 90                	xchg   %ax,%ax
- 3ad:	66 90                	xchg   %ax,%ax
- 3af:	90                   	nop
-
-000003b0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 3b0:	55                   	push   %ebp
- 3b1:	89 e5                	mov    %esp,%ebp
- 3b3:	57                   	push   %edi
- 3b4:	56                   	push   %esi
- 3b5:	53                   	push   %ebx
- 3b6:	83 ec 3c             	sub    $0x3c,%esp
- 3b9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 3bc:	89 d1                	mov    %edx,%ecx
-{
- 3be:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 3c1:	85 d2                	test   %edx,%edx
- 3c3:	0f 89 7f 00 00 00    	jns    448 <printint+0x98>
- 3c9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 3cd:	74 79                	je     448 <printint+0x98>
-    neg = 1;
- 3cf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 3d6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 3d8:	31 db                	xor    %ebx,%ebx
- 3da:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 3dd:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 3e0:	89 c8                	mov    %ecx,%eax
- 3e2:	31 d2                	xor    %edx,%edx
- 3e4:	89 cf                	mov    %ecx,%edi
- 3e6:	f7 75 c4             	divl   -0x3c(%ebp)
- 3e9:	0f b6 92 f4 07 00 00 	movzbl 0x7f4(%edx),%edx
- 3f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 3f3:	89 d8                	mov    %ebx,%eax
- 3f5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 3f8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 3fb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 3fe:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 401:	76 dd                	jbe    3e0 <printint+0x30>
-  if(neg)
- 403:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 406:	85 c9                	test   %ecx,%ecx
- 408:	74 0c                	je     416 <printint+0x66>
-    buf[i++] = '-';
- 40a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 40f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 411:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 416:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 419:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 41d:	eb 07                	jmp    426 <printint+0x76>
- 41f:	90                   	nop
- 420:	0f b6 13             	movzbl (%ebx),%edx
- 423:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 426:	83 ec 04             	sub    $0x4,%esp
- 429:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 42c:	6a 01                	push   $0x1
- 42e:	56                   	push   %esi
- 42f:	57                   	push   %edi
- 430:	e8 8e fe ff ff       	call   2c3 <write>
-  while(--i >= 0)
- 435:	83 c4 10             	add    $0x10,%esp
- 438:	39 de                	cmp    %ebx,%esi
- 43a:	75 e4                	jne    420 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 43c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 43f:	5b                   	pop    %ebx
- 440:	5e                   	pop    %esi
- 441:	5f                   	pop    %edi
- 442:	5d                   	pop    %ebp
- 443:	c3                   	ret    
- 444:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 448:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 44f:	eb 87                	jmp    3d8 <printint+0x28>
- 451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 458:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 45f:	90                   	nop
-
-00000460 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 460:	f3 0f 1e fb          	endbr32 
- 464:	55                   	push   %ebp
- 465:	89 e5                	mov    %esp,%ebp
- 467:	57                   	push   %edi
- 468:	56                   	push   %esi
- 469:	53                   	push   %ebx
- 46a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 46d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 470:	0f b6 1e             	movzbl (%esi),%ebx
- 473:	84 db                	test   %bl,%bl
- 475:	0f 84 b4 00 00 00    	je     52f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 47b:	8d 45 10             	lea    0x10(%ebp),%eax
- 47e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 481:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 484:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 486:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 489:	eb 33                	jmp    4be <printf+0x5e>
- 48b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 48f:	90                   	nop
- 490:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 493:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 498:	83 f8 25             	cmp    $0x25,%eax
- 49b:	74 17                	je     4b4 <printf+0x54>
-  write(fd, &c, 1);
- 49d:	83 ec 04             	sub    $0x4,%esp
- 4a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 4a3:	6a 01                	push   $0x1
- 4a5:	57                   	push   %edi
- 4a6:	ff 75 08             	pushl  0x8(%ebp)
- 4a9:	e8 15 fe ff ff       	call   2c3 <write>
- 4ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 4b1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 4b4:	0f b6 1e             	movzbl (%esi),%ebx
- 4b7:	83 c6 01             	add    $0x1,%esi
- 4ba:	84 db                	test   %bl,%bl
- 4bc:	74 71                	je     52f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 4be:	0f be cb             	movsbl %bl,%ecx
- 4c1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 4c4:	85 d2                	test   %edx,%edx
- 4c6:	74 c8                	je     490 <printf+0x30>
-      }
-    } else if(state == '%'){
- 4c8:	83 fa 25             	cmp    $0x25,%edx
- 4cb:	75 e7                	jne    4b4 <printf+0x54>
-      if(c == 'd'){
- 4cd:	83 f8 64             	cmp    $0x64,%eax
- 4d0:	0f 84 9a 00 00 00    	je     570 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 4d6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 4dc:	83 f9 70             	cmp    $0x70,%ecx
- 4df:	74 5f                	je     540 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 4e1:	83 f8 73             	cmp    $0x73,%eax
- 4e4:	0f 84 d6 00 00 00    	je     5c0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 4ea:	83 f8 63             	cmp    $0x63,%eax
- 4ed:	0f 84 8d 00 00 00    	je     580 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 4f3:	83 f8 25             	cmp    $0x25,%eax
- 4f6:	0f 84 b4 00 00 00    	je     5b0 <printf+0x150>
-  write(fd, &c, 1);
- 4fc:	83 ec 04             	sub    $0x4,%esp
- 4ff:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 503:	6a 01                	push   $0x1
- 505:	57                   	push   %edi
- 506:	ff 75 08             	pushl  0x8(%ebp)
- 509:	e8 b5 fd ff ff       	call   2c3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 50e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 511:	83 c4 0c             	add    $0xc,%esp
- 514:	6a 01                	push   $0x1
- 516:	83 c6 01             	add    $0x1,%esi
- 519:	57                   	push   %edi
- 51a:	ff 75 08             	pushl  0x8(%ebp)
- 51d:	e8 a1 fd ff ff       	call   2c3 <write>
-  for(i = 0; fmt[i]; i++){
- 522:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 526:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 529:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 52b:	84 db                	test   %bl,%bl
- 52d:	75 8f                	jne    4be <printf+0x5e>
-    }
-  }
-}
- 52f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 532:	5b                   	pop    %ebx
- 533:	5e                   	pop    %esi
- 534:	5f                   	pop    %edi
- 535:	5d                   	pop    %ebp
- 536:	c3                   	ret    
- 537:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 53e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 540:	83 ec 0c             	sub    $0xc,%esp
- 543:	b9 10 00 00 00       	mov    $0x10,%ecx
- 548:	6a 00                	push   $0x0
- 54a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 54d:	8b 45 08             	mov    0x8(%ebp),%eax
- 550:	8b 13                	mov    (%ebx),%edx
- 552:	e8 59 fe ff ff       	call   3b0 <printint>
-        ap++;
- 557:	89 d8                	mov    %ebx,%eax
- 559:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 55c:	31 d2                	xor    %edx,%edx
-        ap++;
- 55e:	83 c0 04             	add    $0x4,%eax
- 561:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 564:	e9 4b ff ff ff       	jmp    4b4 <printf+0x54>
- 569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 570:	83 ec 0c             	sub    $0xc,%esp
- 573:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 578:	6a 01                	push   $0x1
- 57a:	eb ce                	jmp    54a <printf+0xea>
- 57c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 580:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 583:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 586:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 588:	6a 01                	push   $0x1
-        ap++;
- 58a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 58d:	57                   	push   %edi
- 58e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 591:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 594:	e8 2a fd ff ff       	call   2c3 <write>
-        ap++;
- 599:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 59c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 59f:	31 d2                	xor    %edx,%edx
- 5a1:	e9 0e ff ff ff       	jmp    4b4 <printf+0x54>
- 5a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5ad:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 5b0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5b3:	83 ec 04             	sub    $0x4,%esp
- 5b6:	e9 59 ff ff ff       	jmp    514 <printf+0xb4>
- 5bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 5bf:	90                   	nop
-        s = (char*)*ap;
- 5c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 5c3:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 5c5:	83 c0 04             	add    $0x4,%eax
- 5c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 5cb:	85 db                	test   %ebx,%ebx
- 5cd:	74 17                	je     5e6 <printf+0x186>
-        while(*s != 0){
- 5cf:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 5d2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 5d4:	84 c0                	test   %al,%al
- 5d6:	0f 84 d8 fe ff ff    	je     4b4 <printf+0x54>
- 5dc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5df:	89 de                	mov    %ebx,%esi
- 5e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 5e4:	eb 1a                	jmp    600 <printf+0x1a0>
-          s = "(null)";
- 5e6:	bb ed 07 00 00       	mov    $0x7ed,%ebx
-        while(*s != 0){
- 5eb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5ee:	b8 28 00 00 00       	mov    $0x28,%eax
- 5f3:	89 de                	mov    %ebx,%esi
- 5f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 5f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5ff:	90                   	nop
-  write(fd, &c, 1);
- 600:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 603:	83 c6 01             	add    $0x1,%esi
- 606:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 609:	6a 01                	push   $0x1
- 60b:	57                   	push   %edi
- 60c:	53                   	push   %ebx
- 60d:	e8 b1 fc ff ff       	call   2c3 <write>
-        while(*s != 0){
- 612:	0f b6 06             	movzbl (%esi),%eax
- 615:	83 c4 10             	add    $0x10,%esp
- 618:	84 c0                	test   %al,%al
- 61a:	75 e4                	jne    600 <printf+0x1a0>
- 61c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 61f:	31 d2                	xor    %edx,%edx
- 621:	e9 8e fe ff ff       	jmp    4b4 <printf+0x54>
- 626:	66 90                	xchg   %ax,%ax
- 628:	66 90                	xchg   %ax,%ax
- 62a:	66 90                	xchg   %ax,%ax
- 62c:	66 90                	xchg   %ax,%ax
- 62e:	66 90                	xchg   %ax,%ax
-
-00000630 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 630:	f3 0f 1e fb          	endbr32 
- 634:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 635:	a1 9c 0a 00 00       	mov    0xa9c,%eax
-{
- 63a:	89 e5                	mov    %esp,%ebp
- 63c:	57                   	push   %edi
- 63d:	56                   	push   %esi
- 63e:	53                   	push   %ebx
- 63f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 642:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 644:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 647:	39 c8                	cmp    %ecx,%eax
- 649:	73 15                	jae    660 <free+0x30>
- 64b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 64f:	90                   	nop
- 650:	39 d1                	cmp    %edx,%ecx
- 652:	72 14                	jb     668 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 654:	39 d0                	cmp    %edx,%eax
- 656:	73 10                	jae    668 <free+0x38>
-{
- 658:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 65a:	8b 10                	mov    (%eax),%edx
- 65c:	39 c8                	cmp    %ecx,%eax
- 65e:	72 f0                	jb     650 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 660:	39 d0                	cmp    %edx,%eax
- 662:	72 f4                	jb     658 <free+0x28>
- 664:	39 d1                	cmp    %edx,%ecx
- 666:	73 f0                	jae    658 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 668:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 66b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 66e:	39 fa                	cmp    %edi,%edx
- 670:	74 1e                	je     690 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 672:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 675:	8b 50 04             	mov    0x4(%eax),%edx
- 678:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 67b:	39 f1                	cmp    %esi,%ecx
- 67d:	74 28                	je     6a7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 67f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 681:	5b                   	pop    %ebx
-  freep = p;
- 682:	a3 9c 0a 00 00       	mov    %eax,0xa9c
-}
- 687:	5e                   	pop    %esi
- 688:	5f                   	pop    %edi
- 689:	5d                   	pop    %ebp
- 68a:	c3                   	ret    
- 68b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 68f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 690:	03 72 04             	add    0x4(%edx),%esi
- 693:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 696:	8b 10                	mov    (%eax),%edx
- 698:	8b 12                	mov    (%edx),%edx
- 69a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 69d:	8b 50 04             	mov    0x4(%eax),%edx
- 6a0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6a3:	39 f1                	cmp    %esi,%ecx
- 6a5:	75 d8                	jne    67f <free+0x4f>
-    p->s.size += bp->s.size;
- 6a7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 6aa:	a3 9c 0a 00 00       	mov    %eax,0xa9c
-    p->s.size += bp->s.size;
- 6af:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 6b2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 6b5:	89 10                	mov    %edx,(%eax)
-}
- 6b7:	5b                   	pop    %ebx
- 6b8:	5e                   	pop    %esi
- 6b9:	5f                   	pop    %edi
- 6ba:	5d                   	pop    %ebp
- 6bb:	c3                   	ret    
- 6bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000006c0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 6c0:	f3 0f 1e fb          	endbr32 
- 6c4:	55                   	push   %ebp
- 6c5:	89 e5                	mov    %esp,%ebp
- 6c7:	57                   	push   %edi
- 6c8:	56                   	push   %esi
- 6c9:	53                   	push   %ebx
- 6ca:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6cd:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 6d0:	8b 3d 9c 0a 00 00    	mov    0xa9c,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6d6:	8d 70 07             	lea    0x7(%eax),%esi
- 6d9:	c1 ee 03             	shr    $0x3,%esi
- 6dc:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 6df:	85 ff                	test   %edi,%edi
- 6e1:	0f 84 a9 00 00 00    	je     790 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 6e7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 6e9:	8b 48 04             	mov    0x4(%eax),%ecx
- 6ec:	39 f1                	cmp    %esi,%ecx
- 6ee:	73 6d                	jae    75d <malloc+0x9d>
- 6f0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 6f6:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 6fb:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 6fe:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 705:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 708:	eb 17                	jmp    721 <malloc+0x61>
- 70a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 710:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 712:	8b 4a 04             	mov    0x4(%edx),%ecx
- 715:	39 f1                	cmp    %esi,%ecx
- 717:	73 4f                	jae    768 <malloc+0xa8>
- 719:	8b 3d 9c 0a 00 00    	mov    0xa9c,%edi
- 71f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 721:	39 c7                	cmp    %eax,%edi
- 723:	75 eb                	jne    710 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 725:	83 ec 0c             	sub    $0xc,%esp
- 728:	ff 75 e4             	pushl  -0x1c(%ebp)
- 72b:	e8 fb fb ff ff       	call   32b <sbrk>
-  if(p == (char*)-1)
- 730:	83 c4 10             	add    $0x10,%esp
- 733:	83 f8 ff             	cmp    $0xffffffff,%eax
- 736:	74 1b                	je     753 <malloc+0x93>
-  hp->s.size = nu;
- 738:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 73b:	83 ec 0c             	sub    $0xc,%esp
- 73e:	83 c0 08             	add    $0x8,%eax
- 741:	50                   	push   %eax
- 742:	e8 e9 fe ff ff       	call   630 <free>
-  return freep;
- 747:	a1 9c 0a 00 00       	mov    0xa9c,%eax
-      if((p = morecore(nunits)) == 0)
- 74c:	83 c4 10             	add    $0x10,%esp
- 74f:	85 c0                	test   %eax,%eax
- 751:	75 bd                	jne    710 <malloc+0x50>
-        return 0;
-  }
-}
- 753:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 756:	31 c0                	xor    %eax,%eax
-}
- 758:	5b                   	pop    %ebx
- 759:	5e                   	pop    %esi
- 75a:	5f                   	pop    %edi
- 75b:	5d                   	pop    %ebp
- 75c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 75d:	89 c2                	mov    %eax,%edx
- 75f:	89 f8                	mov    %edi,%eax
- 761:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 768:	39 ce                	cmp    %ecx,%esi
- 76a:	74 54                	je     7c0 <malloc+0x100>
-        p->s.size -= nunits;
- 76c:	29 f1                	sub    %esi,%ecx
- 76e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 771:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 774:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 777:	a3 9c 0a 00 00       	mov    %eax,0xa9c
-}
- 77c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 77f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 782:	5b                   	pop    %ebx
- 783:	5e                   	pop    %esi
- 784:	5f                   	pop    %edi
- 785:	5d                   	pop    %ebp
- 786:	c3                   	ret    
- 787:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 78e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 790:	c7 05 9c 0a 00 00 a0 	movl   $0xaa0,0xa9c
- 797:	0a 00 00 
-    base.s.size = 0;
- 79a:	bf a0 0a 00 00       	mov    $0xaa0,%edi
-    base.s.ptr = freep = prevp = &base;
- 79f:	c7 05 a0 0a 00 00 a0 	movl   $0xaa0,0xaa0
- 7a6:	0a 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7a9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 7ab:	c7 05 a4 0a 00 00 00 	movl   $0x0,0xaa4
- 7b2:	00 00 00 
-    if(p->s.size >= nunits){
- 7b5:	e9 36 ff ff ff       	jmp    6f0 <malloc+0x30>
- 7ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 7c0:	8b 0a                	mov    (%edx),%ecx
- 7c2:	89 08                	mov    %ecx,(%eax)
- 7c4:	eb b1                	jmp    777 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/getWaitingTimeTest.c b/xv6-public/Operating-System-Project/getWaitingTimeTest.c
deleted file mode 100644
index 67e4cf1..0000000
--- a/xv6-public/Operating-System-Project/getWaitingTimeTest.c
+++ /dev/null
@@ -1,13 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main()
-{
-    printf(1, "This is getWaitingTimeTest template!");
-
-    while (wait() != -1)
-        ;
-
-    exit();
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/getWaitingTimeTest.d b/xv6-public/Operating-System-Project/getWaitingTimeTest.d
deleted file mode 100644
index 5328973..0000000
--- a/xv6-public/Operating-System-Project/getWaitingTimeTest.d
+++ /dev/null
@@ -1,2 +0,0 @@
-getWaitingTimeTest.o: getWaitingTimeTest.c /usr/include/stdc-predef.h \
- types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/getWaitingTimeTest.o b/xv6-public/Operating-System-Project/getWaitingTimeTest.o
deleted file mode 100644
index cb2298d..0000000
Binary files a/xv6-public/Operating-System-Project/getWaitingTimeTest.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/getWaitingTimeTest.sym b/xv6-public/Operating-System-Project/getWaitingTimeTest.sym
deleted file mode 100644
index 99280f1..0000000
--- a/xv6-public/Operating-System-Project/getWaitingTimeTest.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-000007c8 .rodata
-00000808 .eh_frame
-00000a9c .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 getWaitingTimeTest.c
-00000000 ulib.c
-00000000 printf.c
-000003b0 printint
-000007f4 digits.1109
-00000000 umalloc.c
-00000a9c freep
-00000aa0 base
-00000040 strcpy
-0000034b getChildren
-00000460 printf
-00000270 memmove
-000002eb mknod
-00000160 gets
-00000323 getpid
-00000383 customWait
-0000037b getCBT
-000006c0 malloc
-00000333 sleep
-000002b3 pipe
-00000363 changePolicy
-000002c3 write
-000002fb fstat
-000002d3 kill
-00000313 chdir
-0000038b setQueue
-000002db exec
-000002ab wait
-000002bb read
-00000393 getBurstTime
-000002f3 unlink
-0000029b fork
-0000036b getTurnAroundTime
-0000032b sbrk
-0000033b uptime
-00000a9c __bss_start
-00000100 memset
-00000000 main
-00000070 strcmp
-0000031b dup
-00000353 getSyscallCounter
-00000343 getParentID
-000001e0 stat
-00000a9c _edata
-00000aa8 _end
-00000303 link
-000002a3 exit
-0000035b setPriority
-00000230 atoi
-0000039b getCreationTime
-000000c0 strlen
-000002e3 open
-00000120 strchr
-0000030b mkdir
-000002cb close
-00000373 getWaitingTime
-00000630 free
diff --git a/xv6-public/Operating-System-Project/grep.asm b/xv6-public/Operating-System-Project/grep.asm
deleted file mode 100644
index 9131cb5..0000000
--- a/xv6-public/Operating-System-Project/grep.asm
+++ /dev/null
@@ -1,1636 +0,0 @@
-
-_grep:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-  }
-}
-
-int
-main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	57                   	push   %edi
-  12:	56                   	push   %esi
-  13:	53                   	push   %ebx
-  14:	51                   	push   %ecx
-  15:	83 ec 18             	sub    $0x18,%esp
-  18:	8b 01                	mov    (%ecx),%eax
-  1a:	8b 59 04             	mov    0x4(%ecx),%ebx
-  1d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-  int fd, i;
-  char *pattern;
-
-  if(argc <= 1){
-  20:	83 f8 01             	cmp    $0x1,%eax
-  23:	7e 6b                	jle    90 <main+0x90>
-    printf(2, "usage: grep pattern [file ...]\n");
-    exit();
-  }
-  pattern = argv[1];
-  25:	8b 43 04             	mov    0x4(%ebx),%eax
-  28:	83 c3 08             	add    $0x8,%ebx
-
-  if(argc <= 2){
-  2b:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
-    grep(pattern, 0);
-    exit();
-  }
-
-  for(i = 2; i < argc; i++){
-  2f:	be 02 00 00 00       	mov    $0x2,%esi
-  pattern = argv[1];
-  34:	89 45 e0             	mov    %eax,-0x20(%ebp)
-  if(argc <= 2){
-  37:	75 29                	jne    62 <main+0x62>
-  39:	eb 68                	jmp    a3 <main+0xa3>
-  3b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  3f:	90                   	nop
-    if((fd = open(argv[i], 0)) < 0){
-      printf(1, "grep: cannot open %s\n", argv[i]);
-      exit();
-    }
-    grep(pattern, fd);
-  40:	83 ec 08             	sub    $0x8,%esp
-  for(i = 2; i < argc; i++){
-  43:	83 c6 01             	add    $0x1,%esi
-  46:	83 c3 04             	add    $0x4,%ebx
-    grep(pattern, fd);
-  49:	50                   	push   %eax
-  4a:	ff 75 e0             	pushl  -0x20(%ebp)
-  4d:	e8 de 01 00 00       	call   230 <grep>
-    close(fd);
-  52:	89 3c 24             	mov    %edi,(%esp)
-  55:	e8 71 05 00 00       	call   5cb <close>
-  for(i = 2; i < argc; i++){
-  5a:	83 c4 10             	add    $0x10,%esp
-  5d:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
-  60:	7e 29                	jle    8b <main+0x8b>
-    if((fd = open(argv[i], 0)) < 0){
-  62:	83 ec 08             	sub    $0x8,%esp
-  65:	6a 00                	push   $0x0
-  67:	ff 33                	pushl  (%ebx)
-  69:	e8 75 05 00 00       	call   5e3 <open>
-  6e:	83 c4 10             	add    $0x10,%esp
-  71:	89 c7                	mov    %eax,%edi
-  73:	85 c0                	test   %eax,%eax
-  75:	79 c9                	jns    40 <main+0x40>
-      printf(1, "grep: cannot open %s\n", argv[i]);
-  77:	50                   	push   %eax
-  78:	ff 33                	pushl  (%ebx)
-  7a:	68 e8 0a 00 00       	push   $0xae8
-  7f:	6a 01                	push   $0x1
-  81:	e8 da 06 00 00       	call   760 <printf>
-      exit();
-  86:	e8 18 05 00 00       	call   5a3 <exit>
-  }
-  exit();
-  8b:	e8 13 05 00 00       	call   5a3 <exit>
-    printf(2, "usage: grep pattern [file ...]\n");
-  90:	51                   	push   %ecx
-  91:	51                   	push   %ecx
-  92:	68 c8 0a 00 00       	push   $0xac8
-  97:	6a 02                	push   $0x2
-  99:	e8 c2 06 00 00       	call   760 <printf>
-    exit();
-  9e:	e8 00 05 00 00       	call   5a3 <exit>
-    grep(pattern, 0);
-  a3:	52                   	push   %edx
-  a4:	52                   	push   %edx
-  a5:	6a 00                	push   $0x0
-  a7:	50                   	push   %eax
-  a8:	e8 83 01 00 00       	call   230 <grep>
-    exit();
-  ad:	e8 f1 04 00 00       	call   5a3 <exit>
-  b2:	66 90                	xchg   %ax,%ax
-  b4:	66 90                	xchg   %ax,%ax
-  b6:	66 90                	xchg   %ax,%ax
-  b8:	66 90                	xchg   %ax,%ax
-  ba:	66 90                	xchg   %ax,%ax
-  bc:	66 90                	xchg   %ax,%ax
-  be:	66 90                	xchg   %ax,%ax
-
-000000c0 <matchstar>:
-  return 0;
-}
-
-// matchstar: search for c*re at beginning of text
-int matchstar(int c, char *re, char *text)
-{
-  c0:	f3 0f 1e fb          	endbr32 
-  c4:	55                   	push   %ebp
-  c5:	89 e5                	mov    %esp,%ebp
-  c7:	57                   	push   %edi
-  c8:	56                   	push   %esi
-  c9:	53                   	push   %ebx
-  ca:	83 ec 0c             	sub    $0xc,%esp
-  cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  d0:	8b 75 0c             	mov    0xc(%ebp),%esi
-  d3:	8b 7d 10             	mov    0x10(%ebp),%edi
-  d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  dd:	8d 76 00             	lea    0x0(%esi),%esi
-  do{  // a * matches zero or more instances
-    if(matchhere(re, text))
-  e0:	83 ec 08             	sub    $0x8,%esp
-  e3:	57                   	push   %edi
-  e4:	56                   	push   %esi
-  e5:	e8 36 00 00 00       	call   120 <matchhere>
-  ea:	83 c4 10             	add    $0x10,%esp
-  ed:	85 c0                	test   %eax,%eax
-  ef:	75 1f                	jne    110 <matchstar+0x50>
-      return 1;
-  }while(*text!='\0' && (*text++==c || c=='.'));
-  f1:	0f be 17             	movsbl (%edi),%edx
-  f4:	84 d2                	test   %dl,%dl
-  f6:	74 0c                	je     104 <matchstar+0x44>
-  f8:	83 c7 01             	add    $0x1,%edi
-  fb:	39 da                	cmp    %ebx,%edx
-  fd:	74 e1                	je     e0 <matchstar+0x20>
-  ff:	83 fb 2e             	cmp    $0x2e,%ebx
- 102:	74 dc                	je     e0 <matchstar+0x20>
-  return 0;
-}
- 104:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 107:	5b                   	pop    %ebx
- 108:	5e                   	pop    %esi
- 109:	5f                   	pop    %edi
- 10a:	5d                   	pop    %ebp
- 10b:	c3                   	ret    
- 10c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 110:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return 1;
- 113:	b8 01 00 00 00       	mov    $0x1,%eax
-}
- 118:	5b                   	pop    %ebx
- 119:	5e                   	pop    %esi
- 11a:	5f                   	pop    %edi
- 11b:	5d                   	pop    %ebp
- 11c:	c3                   	ret    
- 11d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000120 <matchhere>:
-{
- 120:	f3 0f 1e fb          	endbr32 
- 124:	55                   	push   %ebp
- 125:	89 e5                	mov    %esp,%ebp
- 127:	57                   	push   %edi
- 128:	56                   	push   %esi
- 129:	53                   	push   %ebx
- 12a:	83 ec 0c             	sub    $0xc,%esp
- 12d:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 130:	8b 7d 0c             	mov    0xc(%ebp),%edi
-  if(re[0] == '\0')
- 133:	0f b6 01             	movzbl (%ecx),%eax
- 136:	84 c0                	test   %al,%al
- 138:	75 2b                	jne    165 <matchhere+0x45>
- 13a:	eb 64                	jmp    1a0 <matchhere+0x80>
- 13c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  if(re[0] == '$' && re[1] == '\0')
- 140:	0f b6 37             	movzbl (%edi),%esi
- 143:	80 fa 24             	cmp    $0x24,%dl
- 146:	75 04                	jne    14c <matchhere+0x2c>
- 148:	84 c0                	test   %al,%al
- 14a:	74 61                	je     1ad <matchhere+0x8d>
-  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
- 14c:	89 f3                	mov    %esi,%ebx
- 14e:	84 db                	test   %bl,%bl
- 150:	74 3e                	je     190 <matchhere+0x70>
- 152:	80 fa 2e             	cmp    $0x2e,%dl
- 155:	74 04                	je     15b <matchhere+0x3b>
- 157:	38 d3                	cmp    %dl,%bl
- 159:	75 35                	jne    190 <matchhere+0x70>
-    return matchhere(re+1, text+1);
- 15b:	83 c7 01             	add    $0x1,%edi
- 15e:	83 c1 01             	add    $0x1,%ecx
-  if(re[0] == '\0')
- 161:	84 c0                	test   %al,%al
- 163:	74 3b                	je     1a0 <matchhere+0x80>
-  if(re[1] == '*')
- 165:	0f be d0             	movsbl %al,%edx
- 168:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
- 16c:	3c 2a                	cmp    $0x2a,%al
- 16e:	75 d0                	jne    140 <matchhere+0x20>
-    return matchstar(re[0], re+2, text);
- 170:	83 ec 04             	sub    $0x4,%esp
- 173:	83 c1 02             	add    $0x2,%ecx
- 176:	57                   	push   %edi
- 177:	51                   	push   %ecx
- 178:	52                   	push   %edx
- 179:	e8 42 ff ff ff       	call   c0 <matchstar>
- 17e:	83 c4 10             	add    $0x10,%esp
-}
- 181:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 184:	5b                   	pop    %ebx
- 185:	5e                   	pop    %esi
- 186:	5f                   	pop    %edi
- 187:	5d                   	pop    %ebp
- 188:	c3                   	ret    
- 189:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 190:	8d 65 f4             	lea    -0xc(%ebp),%esp
-  return 0;
- 193:	31 c0                	xor    %eax,%eax
-}
- 195:	5b                   	pop    %ebx
- 196:	5e                   	pop    %esi
- 197:	5f                   	pop    %edi
- 198:	5d                   	pop    %ebp
- 199:	c3                   	ret    
- 19a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 1a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    return 1;
- 1a3:	b8 01 00 00 00       	mov    $0x1,%eax
-}
- 1a8:	5b                   	pop    %ebx
- 1a9:	5e                   	pop    %esi
- 1aa:	5f                   	pop    %edi
- 1ab:	5d                   	pop    %ebp
- 1ac:	c3                   	ret    
-    return *text == '\0';
- 1ad:	89 f0                	mov    %esi,%eax
- 1af:	84 c0                	test   %al,%al
- 1b1:	0f 94 c0             	sete   %al
- 1b4:	0f b6 c0             	movzbl %al,%eax
- 1b7:	eb c8                	jmp    181 <matchhere+0x61>
- 1b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-000001c0 <match>:
-{
- 1c0:	f3 0f 1e fb          	endbr32 
- 1c4:	55                   	push   %ebp
- 1c5:	89 e5                	mov    %esp,%ebp
- 1c7:	56                   	push   %esi
- 1c8:	53                   	push   %ebx
- 1c9:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 1cc:	8b 75 0c             	mov    0xc(%ebp),%esi
-  if(re[0] == '^')
- 1cf:	80 3b 5e             	cmpb   $0x5e,(%ebx)
- 1d2:	75 15                	jne    1e9 <match+0x29>
- 1d4:	eb 3a                	jmp    210 <match+0x50>
- 1d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1dd:	8d 76 00             	lea    0x0(%esi),%esi
-  }while(*text++ != '\0');
- 1e0:	83 c6 01             	add    $0x1,%esi
- 1e3:	80 7e ff 00          	cmpb   $0x0,-0x1(%esi)
- 1e7:	74 16                	je     1ff <match+0x3f>
-    if(matchhere(re, text))
- 1e9:	83 ec 08             	sub    $0x8,%esp
- 1ec:	56                   	push   %esi
- 1ed:	53                   	push   %ebx
- 1ee:	e8 2d ff ff ff       	call   120 <matchhere>
- 1f3:	83 c4 10             	add    $0x10,%esp
- 1f6:	85 c0                	test   %eax,%eax
- 1f8:	74 e6                	je     1e0 <match+0x20>
-      return 1;
- 1fa:	b8 01 00 00 00       	mov    $0x1,%eax
-}
- 1ff:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 202:	5b                   	pop    %ebx
- 203:	5e                   	pop    %esi
- 204:	5d                   	pop    %ebp
- 205:	c3                   	ret    
- 206:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 20d:	8d 76 00             	lea    0x0(%esi),%esi
-    return matchhere(re+1, text);
- 210:	83 c3 01             	add    $0x1,%ebx
- 213:	89 5d 08             	mov    %ebx,0x8(%ebp)
-}
- 216:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 219:	5b                   	pop    %ebx
- 21a:	5e                   	pop    %esi
- 21b:	5d                   	pop    %ebp
-    return matchhere(re+1, text);
- 21c:	e9 ff fe ff ff       	jmp    120 <matchhere>
- 221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 228:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 22f:	90                   	nop
-
-00000230 <grep>:
-{
- 230:	f3 0f 1e fb          	endbr32 
- 234:	55                   	push   %ebp
- 235:	89 e5                	mov    %esp,%ebp
- 237:	57                   	push   %edi
- 238:	56                   	push   %esi
- 239:	53                   	push   %ebx
- 23a:	83 ec 1c             	sub    $0x1c,%esp
-  m = 0;
- 23d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
-{
- 244:	8b 75 08             	mov    0x8(%ebp),%esi
- 247:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 24e:	66 90                	xchg   %ax,%ax
-  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
- 250:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
- 253:	b8 ff 03 00 00       	mov    $0x3ff,%eax
- 258:	83 ec 04             	sub    $0x4,%esp
- 25b:	29 c8                	sub    %ecx,%eax
- 25d:	50                   	push   %eax
- 25e:	8d 81 e0 0e 00 00    	lea    0xee0(%ecx),%eax
- 264:	50                   	push   %eax
- 265:	ff 75 0c             	pushl  0xc(%ebp)
- 268:	e8 4e 03 00 00       	call   5bb <read>
- 26d:	83 c4 10             	add    $0x10,%esp
- 270:	85 c0                	test   %eax,%eax
- 272:	0f 8e b8 00 00 00    	jle    330 <grep+0x100>
-    m += n;
- 278:	01 45 e4             	add    %eax,-0x1c(%ebp)
- 27b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
-    p = buf;
- 27e:	bb e0 0e 00 00       	mov    $0xee0,%ebx
-    buf[m] = '\0';
- 283:	c6 81 e0 0e 00 00 00 	movb   $0x0,0xee0(%ecx)
-    while((q = strchr(p, '\n')) != 0){
- 28a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 290:	83 ec 08             	sub    $0x8,%esp
- 293:	6a 0a                	push   $0xa
- 295:	53                   	push   %ebx
- 296:	e8 85 01 00 00       	call   420 <strchr>
- 29b:	83 c4 10             	add    $0x10,%esp
- 29e:	89 c7                	mov    %eax,%edi
- 2a0:	85 c0                	test   %eax,%eax
- 2a2:	74 3c                	je     2e0 <grep+0xb0>
-      if(match(pattern, p)){
- 2a4:	83 ec 08             	sub    $0x8,%esp
-      *q = 0;
- 2a7:	c6 07 00             	movb   $0x0,(%edi)
-      if(match(pattern, p)){
- 2aa:	53                   	push   %ebx
- 2ab:	56                   	push   %esi
- 2ac:	e8 0f ff ff ff       	call   1c0 <match>
- 2b1:	83 c4 10             	add    $0x10,%esp
- 2b4:	8d 57 01             	lea    0x1(%edi),%edx
- 2b7:	85 c0                	test   %eax,%eax
- 2b9:	75 05                	jne    2c0 <grep+0x90>
-      p = q+1;
- 2bb:	89 d3                	mov    %edx,%ebx
- 2bd:	eb d1                	jmp    290 <grep+0x60>
- 2bf:	90                   	nop
-        write(1, p, q+1 - p);
- 2c0:	89 d0                	mov    %edx,%eax
- 2c2:	83 ec 04             	sub    $0x4,%esp
-        *q = '\n';
- 2c5:	c6 07 0a             	movb   $0xa,(%edi)
-        write(1, p, q+1 - p);
- 2c8:	29 d8                	sub    %ebx,%eax
- 2ca:	89 55 e0             	mov    %edx,-0x20(%ebp)
- 2cd:	50                   	push   %eax
- 2ce:	53                   	push   %ebx
- 2cf:	6a 01                	push   $0x1
- 2d1:	e8 ed 02 00 00       	call   5c3 <write>
- 2d6:	8b 55 e0             	mov    -0x20(%ebp),%edx
- 2d9:	83 c4 10             	add    $0x10,%esp
-      p = q+1;
- 2dc:	89 d3                	mov    %edx,%ebx
- 2de:	eb b0                	jmp    290 <grep+0x60>
-    if(p == buf)
- 2e0:	81 fb e0 0e 00 00    	cmp    $0xee0,%ebx
- 2e6:	74 38                	je     320 <grep+0xf0>
-    if(m > 0){
- 2e8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
- 2eb:	85 c9                	test   %ecx,%ecx
- 2ed:	0f 8e 5d ff ff ff    	jle    250 <grep+0x20>
-      m -= p - buf;
- 2f3:	89 d8                	mov    %ebx,%eax
-      memmove(buf, p, m);
- 2f5:	83 ec 04             	sub    $0x4,%esp
-      m -= p - buf;
- 2f8:	2d e0 0e 00 00       	sub    $0xee0,%eax
- 2fd:	29 c1                	sub    %eax,%ecx
-      memmove(buf, p, m);
- 2ff:	51                   	push   %ecx
- 300:	53                   	push   %ebx
- 301:	68 e0 0e 00 00       	push   $0xee0
-      m -= p - buf;
- 306:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
-      memmove(buf, p, m);
- 309:	e8 62 02 00 00       	call   570 <memmove>
- 30e:	83 c4 10             	add    $0x10,%esp
- 311:	e9 3a ff ff ff       	jmp    250 <grep+0x20>
- 316:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 31d:	8d 76 00             	lea    0x0(%esi),%esi
-      m = 0;
- 320:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
- 327:	e9 24 ff ff ff       	jmp    250 <grep+0x20>
- 32c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-}
- 330:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 333:	5b                   	pop    %ebx
- 334:	5e                   	pop    %esi
- 335:	5f                   	pop    %edi
- 336:	5d                   	pop    %ebp
- 337:	c3                   	ret    
- 338:	66 90                	xchg   %ax,%ax
- 33a:	66 90                	xchg   %ax,%ax
- 33c:	66 90                	xchg   %ax,%ax
- 33e:	66 90                	xchg   %ax,%ax
-
-00000340 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
- 340:	f3 0f 1e fb          	endbr32 
- 344:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
- 345:	31 c0                	xor    %eax,%eax
-{
- 347:	89 e5                	mov    %esp,%ebp
- 349:	53                   	push   %ebx
- 34a:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 34d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
- 350:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
- 354:	88 14 01             	mov    %dl,(%ecx,%eax,1)
- 357:	83 c0 01             	add    $0x1,%eax
- 35a:	84 d2                	test   %dl,%dl
- 35c:	75 f2                	jne    350 <strcpy+0x10>
-    ;
-  return os;
-}
- 35e:	89 c8                	mov    %ecx,%eax
- 360:	5b                   	pop    %ebx
- 361:	5d                   	pop    %ebp
- 362:	c3                   	ret    
- 363:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 36a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000370 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
- 370:	f3 0f 1e fb          	endbr32 
- 374:	55                   	push   %ebp
- 375:	89 e5                	mov    %esp,%ebp
- 377:	53                   	push   %ebx
- 378:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 37b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
- 37e:	0f b6 01             	movzbl (%ecx),%eax
- 381:	0f b6 1a             	movzbl (%edx),%ebx
- 384:	84 c0                	test   %al,%al
- 386:	75 19                	jne    3a1 <strcmp+0x31>
- 388:	eb 26                	jmp    3b0 <strcmp+0x40>
- 38a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 390:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
- 394:	83 c1 01             	add    $0x1,%ecx
- 397:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
- 39a:	0f b6 1a             	movzbl (%edx),%ebx
- 39d:	84 c0                	test   %al,%al
- 39f:	74 0f                	je     3b0 <strcmp+0x40>
- 3a1:	38 d8                	cmp    %bl,%al
- 3a3:	74 eb                	je     390 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
- 3a5:	29 d8                	sub    %ebx,%eax
-}
- 3a7:	5b                   	pop    %ebx
- 3a8:	5d                   	pop    %ebp
- 3a9:	c3                   	ret    
- 3aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 3b0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
- 3b2:	29 d8                	sub    %ebx,%eax
-}
- 3b4:	5b                   	pop    %ebx
- 3b5:	5d                   	pop    %ebp
- 3b6:	c3                   	ret    
- 3b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3be:	66 90                	xchg   %ax,%ax
-
-000003c0 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 3c0:	f3 0f 1e fb          	endbr32 
- 3c4:	55                   	push   %ebp
- 3c5:	89 e5                	mov    %esp,%ebp
- 3c7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 3ca:	80 3a 00             	cmpb   $0x0,(%edx)
- 3cd:	74 21                	je     3f0 <strlen+0x30>
- 3cf:	31 c0                	xor    %eax,%eax
- 3d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3d8:	83 c0 01             	add    $0x1,%eax
- 3db:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 3df:	89 c1                	mov    %eax,%ecx
- 3e1:	75 f5                	jne    3d8 <strlen+0x18>
-    ;
-  return n;
-}
- 3e3:	89 c8                	mov    %ecx,%eax
- 3e5:	5d                   	pop    %ebp
- 3e6:	c3                   	ret    
- 3e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3ee:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 3f0:	31 c9                	xor    %ecx,%ecx
-}
- 3f2:	5d                   	pop    %ebp
- 3f3:	89 c8                	mov    %ecx,%eax
- 3f5:	c3                   	ret    
- 3f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3fd:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000400 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 400:	f3 0f 1e fb          	endbr32 
- 404:	55                   	push   %ebp
- 405:	89 e5                	mov    %esp,%ebp
- 407:	57                   	push   %edi
- 408:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 40b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 40e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 411:	89 d7                	mov    %edx,%edi
- 413:	fc                   	cld    
- 414:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 416:	89 d0                	mov    %edx,%eax
- 418:	5f                   	pop    %edi
- 419:	5d                   	pop    %ebp
- 41a:	c3                   	ret    
- 41b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 41f:	90                   	nop
-
-00000420 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 420:	f3 0f 1e fb          	endbr32 
- 424:	55                   	push   %ebp
- 425:	89 e5                	mov    %esp,%ebp
- 427:	8b 45 08             	mov    0x8(%ebp),%eax
- 42a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 42e:	0f b6 10             	movzbl (%eax),%edx
- 431:	84 d2                	test   %dl,%dl
- 433:	75 16                	jne    44b <strchr+0x2b>
- 435:	eb 21                	jmp    458 <strchr+0x38>
- 437:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 43e:	66 90                	xchg   %ax,%ax
- 440:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 444:	83 c0 01             	add    $0x1,%eax
- 447:	84 d2                	test   %dl,%dl
- 449:	74 0d                	je     458 <strchr+0x38>
-    if(*s == c)
- 44b:	38 d1                	cmp    %dl,%cl
- 44d:	75 f1                	jne    440 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 44f:	5d                   	pop    %ebp
- 450:	c3                   	ret    
- 451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 458:	31 c0                	xor    %eax,%eax
-}
- 45a:	5d                   	pop    %ebp
- 45b:	c3                   	ret    
- 45c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000460 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 460:	f3 0f 1e fb          	endbr32 
- 464:	55                   	push   %ebp
- 465:	89 e5                	mov    %esp,%ebp
- 467:	57                   	push   %edi
- 468:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 469:	31 f6                	xor    %esi,%esi
-{
- 46b:	53                   	push   %ebx
- 46c:	89 f3                	mov    %esi,%ebx
- 46e:	83 ec 1c             	sub    $0x1c,%esp
- 471:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 474:	eb 33                	jmp    4a9 <gets+0x49>
- 476:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 47d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 480:	83 ec 04             	sub    $0x4,%esp
- 483:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 486:	6a 01                	push   $0x1
- 488:	50                   	push   %eax
- 489:	6a 00                	push   $0x0
- 48b:	e8 2b 01 00 00       	call   5bb <read>
-    if(cc < 1)
- 490:	83 c4 10             	add    $0x10,%esp
- 493:	85 c0                	test   %eax,%eax
- 495:	7e 1c                	jle    4b3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 497:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 49b:	83 c7 01             	add    $0x1,%edi
- 49e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 4a1:	3c 0a                	cmp    $0xa,%al
- 4a3:	74 23                	je     4c8 <gets+0x68>
- 4a5:	3c 0d                	cmp    $0xd,%al
- 4a7:	74 1f                	je     4c8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 4a9:	83 c3 01             	add    $0x1,%ebx
- 4ac:	89 fe                	mov    %edi,%esi
- 4ae:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 4b1:	7c cd                	jl     480 <gets+0x20>
- 4b3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 4b5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 4b8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 4bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 4be:	5b                   	pop    %ebx
- 4bf:	5e                   	pop    %esi
- 4c0:	5f                   	pop    %edi
- 4c1:	5d                   	pop    %ebp
- 4c2:	c3                   	ret    
- 4c3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 4c7:	90                   	nop
- 4c8:	8b 75 08             	mov    0x8(%ebp),%esi
- 4cb:	8b 45 08             	mov    0x8(%ebp),%eax
- 4ce:	01 de                	add    %ebx,%esi
- 4d0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 4d2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 4d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 4d8:	5b                   	pop    %ebx
- 4d9:	5e                   	pop    %esi
- 4da:	5f                   	pop    %edi
- 4db:	5d                   	pop    %ebp
- 4dc:	c3                   	ret    
- 4dd:	8d 76 00             	lea    0x0(%esi),%esi
-
-000004e0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 4e0:	f3 0f 1e fb          	endbr32 
- 4e4:	55                   	push   %ebp
- 4e5:	89 e5                	mov    %esp,%ebp
- 4e7:	56                   	push   %esi
- 4e8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 4e9:	83 ec 08             	sub    $0x8,%esp
- 4ec:	6a 00                	push   $0x0
- 4ee:	ff 75 08             	pushl  0x8(%ebp)
- 4f1:	e8 ed 00 00 00       	call   5e3 <open>
-  if(fd < 0)
- 4f6:	83 c4 10             	add    $0x10,%esp
- 4f9:	85 c0                	test   %eax,%eax
- 4fb:	78 2b                	js     528 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 4fd:	83 ec 08             	sub    $0x8,%esp
- 500:	ff 75 0c             	pushl  0xc(%ebp)
- 503:	89 c3                	mov    %eax,%ebx
- 505:	50                   	push   %eax
- 506:	e8 f0 00 00 00       	call   5fb <fstat>
-  close(fd);
- 50b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 50e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 510:	e8 b6 00 00 00       	call   5cb <close>
-  return r;
- 515:	83 c4 10             	add    $0x10,%esp
-}
- 518:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 51b:	89 f0                	mov    %esi,%eax
- 51d:	5b                   	pop    %ebx
- 51e:	5e                   	pop    %esi
- 51f:	5d                   	pop    %ebp
- 520:	c3                   	ret    
- 521:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 528:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 52d:	eb e9                	jmp    518 <stat+0x38>
- 52f:	90                   	nop
-
-00000530 <atoi>:
-
-int
-atoi(const char *s)
-{
- 530:	f3 0f 1e fb          	endbr32 
- 534:	55                   	push   %ebp
- 535:	89 e5                	mov    %esp,%ebp
- 537:	53                   	push   %ebx
- 538:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 53b:	0f be 02             	movsbl (%edx),%eax
- 53e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 541:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 544:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 549:	77 1a                	ja     565 <atoi+0x35>
- 54b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 54f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 550:	83 c2 01             	add    $0x1,%edx
- 553:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 556:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 55a:	0f be 02             	movsbl (%edx),%eax
- 55d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 560:	80 fb 09             	cmp    $0x9,%bl
- 563:	76 eb                	jbe    550 <atoi+0x20>
-  return n;
-}
- 565:	89 c8                	mov    %ecx,%eax
- 567:	5b                   	pop    %ebx
- 568:	5d                   	pop    %ebp
- 569:	c3                   	ret    
- 56a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000570 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 570:	f3 0f 1e fb          	endbr32 
- 574:	55                   	push   %ebp
- 575:	89 e5                	mov    %esp,%ebp
- 577:	57                   	push   %edi
- 578:	8b 45 10             	mov    0x10(%ebp),%eax
- 57b:	8b 55 08             	mov    0x8(%ebp),%edx
- 57e:	56                   	push   %esi
- 57f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 582:	85 c0                	test   %eax,%eax
- 584:	7e 0f                	jle    595 <memmove+0x25>
- 586:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 588:	89 d7                	mov    %edx,%edi
- 58a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 590:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 591:	39 f8                	cmp    %edi,%eax
- 593:	75 fb                	jne    590 <memmove+0x20>
-  return vdst;
-}
- 595:	5e                   	pop    %esi
- 596:	89 d0                	mov    %edx,%eax
- 598:	5f                   	pop    %edi
- 599:	5d                   	pop    %ebp
- 59a:	c3                   	ret    
-
-0000059b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 59b:	b8 01 00 00 00       	mov    $0x1,%eax
- 5a0:	cd 40                	int    $0x40
- 5a2:	c3                   	ret    
-
-000005a3 <exit>:
-SYSCALL(exit)
- 5a3:	b8 02 00 00 00       	mov    $0x2,%eax
- 5a8:	cd 40                	int    $0x40
- 5aa:	c3                   	ret    
-
-000005ab <wait>:
-SYSCALL(wait)
- 5ab:	b8 03 00 00 00       	mov    $0x3,%eax
- 5b0:	cd 40                	int    $0x40
- 5b2:	c3                   	ret    
-
-000005b3 <pipe>:
-SYSCALL(pipe)
- 5b3:	b8 04 00 00 00       	mov    $0x4,%eax
- 5b8:	cd 40                	int    $0x40
- 5ba:	c3                   	ret    
-
-000005bb <read>:
-SYSCALL(read)
- 5bb:	b8 05 00 00 00       	mov    $0x5,%eax
- 5c0:	cd 40                	int    $0x40
- 5c2:	c3                   	ret    
-
-000005c3 <write>:
-SYSCALL(write)
- 5c3:	b8 10 00 00 00       	mov    $0x10,%eax
- 5c8:	cd 40                	int    $0x40
- 5ca:	c3                   	ret    
-
-000005cb <close>:
-SYSCALL(close)
- 5cb:	b8 15 00 00 00       	mov    $0x15,%eax
- 5d0:	cd 40                	int    $0x40
- 5d2:	c3                   	ret    
-
-000005d3 <kill>:
-SYSCALL(kill)
- 5d3:	b8 06 00 00 00       	mov    $0x6,%eax
- 5d8:	cd 40                	int    $0x40
- 5da:	c3                   	ret    
-
-000005db <exec>:
-SYSCALL(exec)
- 5db:	b8 07 00 00 00       	mov    $0x7,%eax
- 5e0:	cd 40                	int    $0x40
- 5e2:	c3                   	ret    
-
-000005e3 <open>:
-SYSCALL(open)
- 5e3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 5e8:	cd 40                	int    $0x40
- 5ea:	c3                   	ret    
-
-000005eb <mknod>:
-SYSCALL(mknod)
- 5eb:	b8 11 00 00 00       	mov    $0x11,%eax
- 5f0:	cd 40                	int    $0x40
- 5f2:	c3                   	ret    
-
-000005f3 <unlink>:
-SYSCALL(unlink)
- 5f3:	b8 12 00 00 00       	mov    $0x12,%eax
- 5f8:	cd 40                	int    $0x40
- 5fa:	c3                   	ret    
-
-000005fb <fstat>:
-SYSCALL(fstat)
- 5fb:	b8 08 00 00 00       	mov    $0x8,%eax
- 600:	cd 40                	int    $0x40
- 602:	c3                   	ret    
-
-00000603 <link>:
-SYSCALL(link)
- 603:	b8 13 00 00 00       	mov    $0x13,%eax
- 608:	cd 40                	int    $0x40
- 60a:	c3                   	ret    
-
-0000060b <mkdir>:
-SYSCALL(mkdir)
- 60b:	b8 14 00 00 00       	mov    $0x14,%eax
- 610:	cd 40                	int    $0x40
- 612:	c3                   	ret    
-
-00000613 <chdir>:
-SYSCALL(chdir)
- 613:	b8 09 00 00 00       	mov    $0x9,%eax
- 618:	cd 40                	int    $0x40
- 61a:	c3                   	ret    
-
-0000061b <dup>:
-SYSCALL(dup)
- 61b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 620:	cd 40                	int    $0x40
- 622:	c3                   	ret    
-
-00000623 <getpid>:
-SYSCALL(getpid)
- 623:	b8 0b 00 00 00       	mov    $0xb,%eax
- 628:	cd 40                	int    $0x40
- 62a:	c3                   	ret    
-
-0000062b <sbrk>:
-SYSCALL(sbrk)
- 62b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 630:	cd 40                	int    $0x40
- 632:	c3                   	ret    
-
-00000633 <sleep>:
-SYSCALL(sleep)
- 633:	b8 0d 00 00 00       	mov    $0xd,%eax
- 638:	cd 40                	int    $0x40
- 63a:	c3                   	ret    
-
-0000063b <uptime>:
-SYSCALL(uptime)
- 63b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 640:	cd 40                	int    $0x40
- 642:	c3                   	ret    
-
-00000643 <getParentID>:
-SYSCALL(getParentID)
- 643:	b8 16 00 00 00       	mov    $0x16,%eax
- 648:	cd 40                	int    $0x40
- 64a:	c3                   	ret    
-
-0000064b <getChildren>:
-SYSCALL(getChildren)
- 64b:	b8 17 00 00 00       	mov    $0x17,%eax
- 650:	cd 40                	int    $0x40
- 652:	c3                   	ret    
-
-00000653 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 653:	b8 18 00 00 00       	mov    $0x18,%eax
- 658:	cd 40                	int    $0x40
- 65a:	c3                   	ret    
-
-0000065b <setPriority>:
-SYSCALL(setPriority)
- 65b:	b8 19 00 00 00       	mov    $0x19,%eax
- 660:	cd 40                	int    $0x40
- 662:	c3                   	ret    
-
-00000663 <changePolicy>:
-SYSCALL(changePolicy)
- 663:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 668:	cd 40                	int    $0x40
- 66a:	c3                   	ret    
-
-0000066b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 66b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 670:	cd 40                	int    $0x40
- 672:	c3                   	ret    
-
-00000673 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 673:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 678:	cd 40                	int    $0x40
- 67a:	c3                   	ret    
-
-0000067b <getCBT>:
-SYSCALL(getCBT)
- 67b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 680:	cd 40                	int    $0x40
- 682:	c3                   	ret    
-
-00000683 <customWait>:
-SYSCALL(customWait)
- 683:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 688:	cd 40                	int    $0x40
- 68a:	c3                   	ret    
-
-0000068b <setQueue>:
-SYSCALL(setQueue)
- 68b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 690:	cd 40                	int    $0x40
- 692:	c3                   	ret    
-
-00000693 <getBurstTime>:
-SYSCALL(getBurstTime)
- 693:	b8 20 00 00 00       	mov    $0x20,%eax
- 698:	cd 40                	int    $0x40
- 69a:	c3                   	ret    
-
-0000069b <getCreationTime>:
- 69b:	b8 21 00 00 00       	mov    $0x21,%eax
- 6a0:	cd 40                	int    $0x40
- 6a2:	c3                   	ret    
- 6a3:	66 90                	xchg   %ax,%ax
- 6a5:	66 90                	xchg   %ax,%ax
- 6a7:	66 90                	xchg   %ax,%ax
- 6a9:	66 90                	xchg   %ax,%ax
- 6ab:	66 90                	xchg   %ax,%ax
- 6ad:	66 90                	xchg   %ax,%ax
- 6af:	90                   	nop
-
-000006b0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 6b0:	55                   	push   %ebp
- 6b1:	89 e5                	mov    %esp,%ebp
- 6b3:	57                   	push   %edi
- 6b4:	56                   	push   %esi
- 6b5:	53                   	push   %ebx
- 6b6:	83 ec 3c             	sub    $0x3c,%esp
- 6b9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 6bc:	89 d1                	mov    %edx,%ecx
-{
- 6be:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 6c1:	85 d2                	test   %edx,%edx
- 6c3:	0f 89 7f 00 00 00    	jns    748 <printint+0x98>
- 6c9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 6cd:	74 79                	je     748 <printint+0x98>
-    neg = 1;
- 6cf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 6d6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 6d8:	31 db                	xor    %ebx,%ebx
- 6da:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 6dd:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 6e0:	89 c8                	mov    %ecx,%eax
- 6e2:	31 d2                	xor    %edx,%edx
- 6e4:	89 cf                	mov    %ecx,%edi
- 6e6:	f7 75 c4             	divl   -0x3c(%ebp)
- 6e9:	0f b6 92 08 0b 00 00 	movzbl 0xb08(%edx),%edx
- 6f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 6f3:	89 d8                	mov    %ebx,%eax
- 6f5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 6f8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 6fb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 6fe:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 701:	76 dd                	jbe    6e0 <printint+0x30>
-  if(neg)
- 703:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 706:	85 c9                	test   %ecx,%ecx
- 708:	74 0c                	je     716 <printint+0x66>
-    buf[i++] = '-';
- 70a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 70f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 711:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 716:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 719:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 71d:	eb 07                	jmp    726 <printint+0x76>
- 71f:	90                   	nop
- 720:	0f b6 13             	movzbl (%ebx),%edx
- 723:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 726:	83 ec 04             	sub    $0x4,%esp
- 729:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 72c:	6a 01                	push   $0x1
- 72e:	56                   	push   %esi
- 72f:	57                   	push   %edi
- 730:	e8 8e fe ff ff       	call   5c3 <write>
-  while(--i >= 0)
- 735:	83 c4 10             	add    $0x10,%esp
- 738:	39 de                	cmp    %ebx,%esi
- 73a:	75 e4                	jne    720 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 73c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 73f:	5b                   	pop    %ebx
- 740:	5e                   	pop    %esi
- 741:	5f                   	pop    %edi
- 742:	5d                   	pop    %ebp
- 743:	c3                   	ret    
- 744:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 748:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 74f:	eb 87                	jmp    6d8 <printint+0x28>
- 751:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 758:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 75f:	90                   	nop
-
-00000760 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 760:	f3 0f 1e fb          	endbr32 
- 764:	55                   	push   %ebp
- 765:	89 e5                	mov    %esp,%ebp
- 767:	57                   	push   %edi
- 768:	56                   	push   %esi
- 769:	53                   	push   %ebx
- 76a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 76d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 770:	0f b6 1e             	movzbl (%esi),%ebx
- 773:	84 db                	test   %bl,%bl
- 775:	0f 84 b4 00 00 00    	je     82f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 77b:	8d 45 10             	lea    0x10(%ebp),%eax
- 77e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 781:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 784:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 786:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 789:	eb 33                	jmp    7be <printf+0x5e>
- 78b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 78f:	90                   	nop
- 790:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 793:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 798:	83 f8 25             	cmp    $0x25,%eax
- 79b:	74 17                	je     7b4 <printf+0x54>
-  write(fd, &c, 1);
- 79d:	83 ec 04             	sub    $0x4,%esp
- 7a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 7a3:	6a 01                	push   $0x1
- 7a5:	57                   	push   %edi
- 7a6:	ff 75 08             	pushl  0x8(%ebp)
- 7a9:	e8 15 fe ff ff       	call   5c3 <write>
- 7ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 7b1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 7b4:	0f b6 1e             	movzbl (%esi),%ebx
- 7b7:	83 c6 01             	add    $0x1,%esi
- 7ba:	84 db                	test   %bl,%bl
- 7bc:	74 71                	je     82f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 7be:	0f be cb             	movsbl %bl,%ecx
- 7c1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 7c4:	85 d2                	test   %edx,%edx
- 7c6:	74 c8                	je     790 <printf+0x30>
-      }
-    } else if(state == '%'){
- 7c8:	83 fa 25             	cmp    $0x25,%edx
- 7cb:	75 e7                	jne    7b4 <printf+0x54>
-      if(c == 'd'){
- 7cd:	83 f8 64             	cmp    $0x64,%eax
- 7d0:	0f 84 9a 00 00 00    	je     870 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 7d6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 7dc:	83 f9 70             	cmp    $0x70,%ecx
- 7df:	74 5f                	je     840 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 7e1:	83 f8 73             	cmp    $0x73,%eax
- 7e4:	0f 84 d6 00 00 00    	je     8c0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 7ea:	83 f8 63             	cmp    $0x63,%eax
- 7ed:	0f 84 8d 00 00 00    	je     880 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 7f3:	83 f8 25             	cmp    $0x25,%eax
- 7f6:	0f 84 b4 00 00 00    	je     8b0 <printf+0x150>
-  write(fd, &c, 1);
- 7fc:	83 ec 04             	sub    $0x4,%esp
- 7ff:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 803:	6a 01                	push   $0x1
- 805:	57                   	push   %edi
- 806:	ff 75 08             	pushl  0x8(%ebp)
- 809:	e8 b5 fd ff ff       	call   5c3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 80e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 811:	83 c4 0c             	add    $0xc,%esp
- 814:	6a 01                	push   $0x1
- 816:	83 c6 01             	add    $0x1,%esi
- 819:	57                   	push   %edi
- 81a:	ff 75 08             	pushl  0x8(%ebp)
- 81d:	e8 a1 fd ff ff       	call   5c3 <write>
-  for(i = 0; fmt[i]; i++){
- 822:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 826:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 829:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 82b:	84 db                	test   %bl,%bl
- 82d:	75 8f                	jne    7be <printf+0x5e>
-    }
-  }
-}
- 82f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 832:	5b                   	pop    %ebx
- 833:	5e                   	pop    %esi
- 834:	5f                   	pop    %edi
- 835:	5d                   	pop    %ebp
- 836:	c3                   	ret    
- 837:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 83e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 840:	83 ec 0c             	sub    $0xc,%esp
- 843:	b9 10 00 00 00       	mov    $0x10,%ecx
- 848:	6a 00                	push   $0x0
- 84a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 84d:	8b 45 08             	mov    0x8(%ebp),%eax
- 850:	8b 13                	mov    (%ebx),%edx
- 852:	e8 59 fe ff ff       	call   6b0 <printint>
-        ap++;
- 857:	89 d8                	mov    %ebx,%eax
- 859:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 85c:	31 d2                	xor    %edx,%edx
-        ap++;
- 85e:	83 c0 04             	add    $0x4,%eax
- 861:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 864:	e9 4b ff ff ff       	jmp    7b4 <printf+0x54>
- 869:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 870:	83 ec 0c             	sub    $0xc,%esp
- 873:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 878:	6a 01                	push   $0x1
- 87a:	eb ce                	jmp    84a <printf+0xea>
- 87c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 880:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 883:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 886:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 888:	6a 01                	push   $0x1
-        ap++;
- 88a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 88d:	57                   	push   %edi
- 88e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 891:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 894:	e8 2a fd ff ff       	call   5c3 <write>
-        ap++;
- 899:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 89c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 89f:	31 d2                	xor    %edx,%edx
- 8a1:	e9 0e ff ff ff       	jmp    7b4 <printf+0x54>
- 8a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 8ad:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 8b0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 8b3:	83 ec 04             	sub    $0x4,%esp
- 8b6:	e9 59 ff ff ff       	jmp    814 <printf+0xb4>
- 8bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 8bf:	90                   	nop
-        s = (char*)*ap;
- 8c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 8c3:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 8c5:	83 c0 04             	add    $0x4,%eax
- 8c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 8cb:	85 db                	test   %ebx,%ebx
- 8cd:	74 17                	je     8e6 <printf+0x186>
-        while(*s != 0){
- 8cf:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 8d2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 8d4:	84 c0                	test   %al,%al
- 8d6:	0f 84 d8 fe ff ff    	je     7b4 <printf+0x54>
- 8dc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 8df:	89 de                	mov    %ebx,%esi
- 8e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 8e4:	eb 1a                	jmp    900 <printf+0x1a0>
-          s = "(null)";
- 8e6:	bb fe 0a 00 00       	mov    $0xafe,%ebx
-        while(*s != 0){
- 8eb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 8ee:	b8 28 00 00 00       	mov    $0x28,%eax
- 8f3:	89 de                	mov    %ebx,%esi
- 8f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 8f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 8ff:	90                   	nop
-  write(fd, &c, 1);
- 900:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 903:	83 c6 01             	add    $0x1,%esi
- 906:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 909:	6a 01                	push   $0x1
- 90b:	57                   	push   %edi
- 90c:	53                   	push   %ebx
- 90d:	e8 b1 fc ff ff       	call   5c3 <write>
-        while(*s != 0){
- 912:	0f b6 06             	movzbl (%esi),%eax
- 915:	83 c4 10             	add    $0x10,%esp
- 918:	84 c0                	test   %al,%al
- 91a:	75 e4                	jne    900 <printf+0x1a0>
- 91c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 91f:	31 d2                	xor    %edx,%edx
- 921:	e9 8e fe ff ff       	jmp    7b4 <printf+0x54>
- 926:	66 90                	xchg   %ax,%ax
- 928:	66 90                	xchg   %ax,%ax
- 92a:	66 90                	xchg   %ax,%ax
- 92c:	66 90                	xchg   %ax,%ax
- 92e:	66 90                	xchg   %ax,%ax
-
-00000930 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 930:	f3 0f 1e fb          	endbr32 
- 934:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 935:	a1 c0 0e 00 00       	mov    0xec0,%eax
-{
- 93a:	89 e5                	mov    %esp,%ebp
- 93c:	57                   	push   %edi
- 93d:	56                   	push   %esi
- 93e:	53                   	push   %ebx
- 93f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 942:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 944:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 947:	39 c8                	cmp    %ecx,%eax
- 949:	73 15                	jae    960 <free+0x30>
- 94b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 94f:	90                   	nop
- 950:	39 d1                	cmp    %edx,%ecx
- 952:	72 14                	jb     968 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 954:	39 d0                	cmp    %edx,%eax
- 956:	73 10                	jae    968 <free+0x38>
-{
- 958:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 95a:	8b 10                	mov    (%eax),%edx
- 95c:	39 c8                	cmp    %ecx,%eax
- 95e:	72 f0                	jb     950 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 960:	39 d0                	cmp    %edx,%eax
- 962:	72 f4                	jb     958 <free+0x28>
- 964:	39 d1                	cmp    %edx,%ecx
- 966:	73 f0                	jae    958 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 968:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 96b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 96e:	39 fa                	cmp    %edi,%edx
- 970:	74 1e                	je     990 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 972:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 975:	8b 50 04             	mov    0x4(%eax),%edx
- 978:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 97b:	39 f1                	cmp    %esi,%ecx
- 97d:	74 28                	je     9a7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 97f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 981:	5b                   	pop    %ebx
-  freep = p;
- 982:	a3 c0 0e 00 00       	mov    %eax,0xec0
-}
- 987:	5e                   	pop    %esi
- 988:	5f                   	pop    %edi
- 989:	5d                   	pop    %ebp
- 98a:	c3                   	ret    
- 98b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 98f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 990:	03 72 04             	add    0x4(%edx),%esi
- 993:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 996:	8b 10                	mov    (%eax),%edx
- 998:	8b 12                	mov    (%edx),%edx
- 99a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 99d:	8b 50 04             	mov    0x4(%eax),%edx
- 9a0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 9a3:	39 f1                	cmp    %esi,%ecx
- 9a5:	75 d8                	jne    97f <free+0x4f>
-    p->s.size += bp->s.size;
- 9a7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 9aa:	a3 c0 0e 00 00       	mov    %eax,0xec0
-    p->s.size += bp->s.size;
- 9af:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 9b2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 9b5:	89 10                	mov    %edx,(%eax)
-}
- 9b7:	5b                   	pop    %ebx
- 9b8:	5e                   	pop    %esi
- 9b9:	5f                   	pop    %edi
- 9ba:	5d                   	pop    %ebp
- 9bb:	c3                   	ret    
- 9bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000009c0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 9c0:	f3 0f 1e fb          	endbr32 
- 9c4:	55                   	push   %ebp
- 9c5:	89 e5                	mov    %esp,%ebp
- 9c7:	57                   	push   %edi
- 9c8:	56                   	push   %esi
- 9c9:	53                   	push   %ebx
- 9ca:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 9cd:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 9d0:	8b 3d c0 0e 00 00    	mov    0xec0,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 9d6:	8d 70 07             	lea    0x7(%eax),%esi
- 9d9:	c1 ee 03             	shr    $0x3,%esi
- 9dc:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 9df:	85 ff                	test   %edi,%edi
- 9e1:	0f 84 a9 00 00 00    	je     a90 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 9e7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 9e9:	8b 48 04             	mov    0x4(%eax),%ecx
- 9ec:	39 f1                	cmp    %esi,%ecx
- 9ee:	73 6d                	jae    a5d <malloc+0x9d>
- 9f0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 9f6:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 9fb:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 9fe:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- a05:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- a08:	eb 17                	jmp    a21 <malloc+0x61>
- a0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- a10:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- a12:	8b 4a 04             	mov    0x4(%edx),%ecx
- a15:	39 f1                	cmp    %esi,%ecx
- a17:	73 4f                	jae    a68 <malloc+0xa8>
- a19:	8b 3d c0 0e 00 00    	mov    0xec0,%edi
- a1f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- a21:	39 c7                	cmp    %eax,%edi
- a23:	75 eb                	jne    a10 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- a25:	83 ec 0c             	sub    $0xc,%esp
- a28:	ff 75 e4             	pushl  -0x1c(%ebp)
- a2b:	e8 fb fb ff ff       	call   62b <sbrk>
-  if(p == (char*)-1)
- a30:	83 c4 10             	add    $0x10,%esp
- a33:	83 f8 ff             	cmp    $0xffffffff,%eax
- a36:	74 1b                	je     a53 <malloc+0x93>
-  hp->s.size = nu;
- a38:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- a3b:	83 ec 0c             	sub    $0xc,%esp
- a3e:	83 c0 08             	add    $0x8,%eax
- a41:	50                   	push   %eax
- a42:	e8 e9 fe ff ff       	call   930 <free>
-  return freep;
- a47:	a1 c0 0e 00 00       	mov    0xec0,%eax
-      if((p = morecore(nunits)) == 0)
- a4c:	83 c4 10             	add    $0x10,%esp
- a4f:	85 c0                	test   %eax,%eax
- a51:	75 bd                	jne    a10 <malloc+0x50>
-        return 0;
-  }
-}
- a53:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- a56:	31 c0                	xor    %eax,%eax
-}
- a58:	5b                   	pop    %ebx
- a59:	5e                   	pop    %esi
- a5a:	5f                   	pop    %edi
- a5b:	5d                   	pop    %ebp
- a5c:	c3                   	ret    
-    if(p->s.size >= nunits){
- a5d:	89 c2                	mov    %eax,%edx
- a5f:	89 f8                	mov    %edi,%eax
- a61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- a68:	39 ce                	cmp    %ecx,%esi
- a6a:	74 54                	je     ac0 <malloc+0x100>
-        p->s.size -= nunits;
- a6c:	29 f1                	sub    %esi,%ecx
- a6e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- a71:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- a74:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- a77:	a3 c0 0e 00 00       	mov    %eax,0xec0
-}
- a7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- a7f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- a82:	5b                   	pop    %ebx
- a83:	5e                   	pop    %esi
- a84:	5f                   	pop    %edi
- a85:	5d                   	pop    %ebp
- a86:	c3                   	ret    
- a87:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- a8e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- a90:	c7 05 c0 0e 00 00 c4 	movl   $0xec4,0xec0
- a97:	0e 00 00 
-    base.s.size = 0;
- a9a:	bf c4 0e 00 00       	mov    $0xec4,%edi
-    base.s.ptr = freep = prevp = &base;
- a9f:	c7 05 c4 0e 00 00 c4 	movl   $0xec4,0xec4
- aa6:	0e 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- aa9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- aab:	c7 05 c8 0e 00 00 00 	movl   $0x0,0xec8
- ab2:	00 00 00 
-    if(p->s.size >= nunits){
- ab5:	e9 36 ff ff ff       	jmp    9f0 <malloc+0x30>
- aba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- ac0:	8b 0a                	mov    (%edx),%ecx
- ac2:	89 08                	mov    %ecx,(%eax)
- ac4:	eb b1                	jmp    a77 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/grep.c b/xv6-public/Operating-System-Project/grep.c
deleted file mode 100644
index adc4835..0000000
--- a/xv6-public/Operating-System-Project/grep.c
+++ /dev/null
@@ -1,107 +0,0 @@
-// Simple grep.  Only supports ^ . * $ operators.
-
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-char buf[1024];
-int match(char*, char*);
-
-void
-grep(char *pattern, int fd)
-{
-  int n, m;
-  char *p, *q;
-
-  m = 0;
-  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
-    m += n;
-    buf[m] = '\0';
-    p = buf;
-    while((q = strchr(p, '\n')) != 0){
-      *q = 0;
-      if(match(pattern, p)){
-        *q = '\n';
-        write(1, p, q+1 - p);
-      }
-      p = q+1;
-    }
-    if(p == buf)
-      m = 0;
-    if(m > 0){
-      m -= p - buf;
-      memmove(buf, p, m);
-    }
-  }
-}
-
-int
-main(int argc, char *argv[])
-{
-  int fd, i;
-  char *pattern;
-
-  if(argc <= 1){
-    printf(2, "usage: grep pattern [file ...]\n");
-    exit();
-  }
-  pattern = argv[1];
-
-  if(argc <= 2){
-    grep(pattern, 0);
-    exit();
-  }
-
-  for(i = 2; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
-      printf(1, "grep: cannot open %s\n", argv[i]);
-      exit();
-    }
-    grep(pattern, fd);
-    close(fd);
-  }
-  exit();
-}
-
-// Regexp matcher from Kernighan & Pike,
-// The Practice of Programming, Chapter 9.
-
-int matchhere(char*, char*);
-int matchstar(int, char*, char*);
-
-int
-match(char *re, char *text)
-{
-  if(re[0] == '^')
-    return matchhere(re+1, text);
-  do{  // must look at empty string
-    if(matchhere(re, text))
-      return 1;
-  }while(*text++ != '\0');
-  return 0;
-}
-
-// matchhere: search for re at beginning of text
-int matchhere(char *re, char *text)
-{
-  if(re[0] == '\0')
-    return 1;
-  if(re[1] == '*')
-    return matchstar(re[0], re+2, text);
-  if(re[0] == '$' && re[1] == '\0')
-    return *text == '\0';
-  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
-    return matchhere(re+1, text+1);
-  return 0;
-}
-
-// matchstar: search for c*re at beginning of text
-int matchstar(int c, char *re, char *text)
-{
-  do{  // a * matches zero or more instances
-    if(matchhere(re, text))
-      return 1;
-  }while(*text!='\0' && (*text++==c || c=='.'));
-  return 0;
-}
-
diff --git a/xv6-public/Operating-System-Project/grep.d b/xv6-public/Operating-System-Project/grep.d
deleted file mode 100644
index 15fc65b..0000000
--- a/xv6-public/Operating-System-Project/grep.d
+++ /dev/null
@@ -1 +0,0 @@
-grep.o: grep.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/grep.o b/xv6-public/Operating-System-Project/grep.o
deleted file mode 100644
index 939f790..0000000
Binary files a/xv6-public/Operating-System-Project/grep.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/grep.sym b/xv6-public/Operating-System-Project/grep.sym
deleted file mode 100644
index fb5894f..0000000
--- a/xv6-public/Operating-System-Project/grep.sym
+++ /dev/null
@@ -1,74 +0,0 @@
-00000000 .text
-00000ac8 .rodata
-00000b1c .eh_frame
-00000ec0 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 grep.c
-00000000 ulib.c
-00000000 printf.c
-000006b0 printint
-00000b08 digits.1109
-00000000 umalloc.c
-00000ec0 freep
-00000ec4 base
-00000340 strcpy
-0000064b getChildren
-00000760 printf
-00000570 memmove
-00000120 matchhere
-000005eb mknod
-00000460 gets
-00000623 getpid
-00000683 customWait
-0000067b getCBT
-00000230 grep
-000009c0 malloc
-00000633 sleep
-000005b3 pipe
-00000663 changePolicy
-000005c3 write
-000005fb fstat
-000005d3 kill
-00000613 chdir
-0000068b setQueue
-000005db exec
-000005ab wait
-000005bb read
-00000693 getBurstTime
-000005f3 unlink
-0000059b fork
-0000066b getTurnAroundTime
-0000062b sbrk
-0000063b uptime
-00000ea4 __bss_start
-00000400 memset
-00000000 main
-000000c0 matchstar
-00000370 strcmp
-0000061b dup
-00000653 getSyscallCounter
-00000ee0 buf
-00000643 getParentID
-000004e0 stat
-00000ea4 _edata
-000012e0 _end
-000001c0 match
-00000603 link
-000005a3 exit
-0000065b setPriority
-00000530 atoi
-0000069b getCreationTime
-000003c0 strlen
-000005e3 open
-00000420 strchr
-0000060b mkdir
-000005cb close
-00000673 getWaitingTime
-00000930 free
diff --git a/xv6-public/Operating-System-Project/ide.c b/xv6-public/Operating-System-Project/ide.c
deleted file mode 100644
index b4c0b1f..0000000
--- a/xv6-public/Operating-System-Project/ide.c
+++ /dev/null
@@ -1,168 +0,0 @@
-// Simple PIO-based (non-DMA) IDE driver code.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-#include "traps.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "buf.h"
-
-#define SECTOR_SIZE   512
-#define IDE_BSY       0x80
-#define IDE_DRDY      0x40
-#define IDE_DF        0x20
-#define IDE_ERR       0x01
-
-#define IDE_CMD_READ  0x20
-#define IDE_CMD_WRITE 0x30
-#define IDE_CMD_RDMUL 0xc4
-#define IDE_CMD_WRMUL 0xc5
-
-// idequeue points to the buf now being read/written to the disk.
-// idequeue->qnext points to the next buf to be processed.
-// You must hold idelock while manipulating queue.
-
-static struct spinlock idelock;
-static struct buf *idequeue;
-
-static int havedisk1;
-static void idestart(struct buf*);
-
-// Wait for IDE disk to become ready.
-static int
-idewait(int checkerr)
-{
-  int r;
-
-  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
-    ;
-  if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
-    return -1;
-  return 0;
-}
-
-void
-ideinit(void)
-{
-  int i;
-
-  initlock(&idelock, "ide");
-  ioapicenable(IRQ_IDE, ncpu - 1);
-  idewait(0);
-
-  // Check if disk 1 is present
-  outb(0x1f6, 0xe0 | (1<<4));
-  for(i=0; i<1000; i++){
-    if(inb(0x1f7) != 0){
-      havedisk1 = 1;
-      break;
-    }
-  }
-
-  // Switch back to disk 0.
-  outb(0x1f6, 0xe0 | (0<<4));
-}
-
-// Start the request for b.  Caller must hold idelock.
-static void
-idestart(struct buf *b)
-{
-  if(b == 0)
-    panic("idestart");
-  if(b->blockno >= FSSIZE)
-    panic("incorrect blockno");
-  int sector_per_block =  BSIZE/SECTOR_SIZE;
-  int sector = b->blockno * sector_per_block;
-  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
-  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
-
-  if (sector_per_block > 7) panic("idestart");
-
-  idewait(0);
-  outb(0x3f6, 0);  // generate interrupt
-  outb(0x1f2, sector_per_block);  // number of sectors
-  outb(0x1f3, sector & 0xff);
-  outb(0x1f4, (sector >> 8) & 0xff);
-  outb(0x1f5, (sector >> 16) & 0xff);
-  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
-  if(b->flags & B_DIRTY){
-    outb(0x1f7, write_cmd);
-    outsl(0x1f0, b->data, BSIZE/4);
-  } else {
-    outb(0x1f7, read_cmd);
-  }
-}
-
-// Interrupt handler.
-void
-ideintr(void)
-{
-  struct buf *b;
-
-  // First queued buffer is the active request.
-  acquire(&idelock);
-
-  if((b = idequeue) == 0){
-    release(&idelock);
-    return;
-  }
-  idequeue = b->qnext;
-
-  // Read data if needed.
-  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
-    insl(0x1f0, b->data, BSIZE/4);
-
-  // Wake process waiting for this buf.
-  b->flags |= B_VALID;
-  b->flags &= ~B_DIRTY;
-  wakeup(b);
-
-  // Start disk on next buf in queue.
-  if(idequeue != 0)
-    idestart(idequeue);
-
-  release(&idelock);
-}
-
-//PAGEBREAK!
-// Sync buf with disk.
-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
-// Else if B_VALID is not set, read buf from disk, set B_VALID.
-void
-iderw(struct buf *b)
-{
-  struct buf **pp;
-
-  if(!holdingsleep(&b->lock))
-    panic("iderw: buf not locked");
-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
-    panic("iderw: nothing to do");
-  if(b->dev != 0 && !havedisk1)
-    panic("iderw: ide disk 1 not present");
-
-  acquire(&idelock);  //DOC:acquire-lock
-
-  // Append b to idequeue.
-  b->qnext = 0;
-  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
-    ;
-  *pp = b;
-
-  // Start disk if necessary.
-  if(idequeue == b)
-    idestart(b);
-
-  // Wait for request to finish.
-  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
-    sleep(b, &idelock);
-  }
-
-
-  release(&idelock);
-}
diff --git a/xv6-public/Operating-System-Project/ide.d b/xv6-public/Operating-System-Project/ide.d
deleted file mode 100644
index 21155b9..0000000
--- a/xv6-public/Operating-System-Project/ide.d
+++ /dev/null
@@ -1,2 +0,0 @@
-ide.o: ide.c /usr/include/stdc-predef.h types.h defs.h param.h \
- memlayout.h mmu.h proc.h x86.h traps.h spinlock.h sleeplock.h fs.h buf.h
diff --git a/xv6-public/Operating-System-Project/ide.o b/xv6-public/Operating-System-Project/ide.o
deleted file mode 100644
index 6c328f5..0000000
Binary files a/xv6-public/Operating-System-Project/ide.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/init.asm b/xv6-public/Operating-System-Project/init.asm
deleted file mode 100644
index 791516d..0000000
--- a/xv6-public/Operating-System-Project/init.asm
+++ /dev/null
@@ -1,1325 +0,0 @@
-
-_init:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-
-char *argv[] = { "sh", 0 };
-
-int
-main(void)
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	53                   	push   %ebx
-  12:	51                   	push   %ecx
-  int pid, wpid;
-
-  if(open("console", O_RDWR) < 0){
-  13:	83 ec 08             	sub    $0x8,%esp
-  16:	6a 02                	push   $0x2
-  18:	68 78 08 00 00       	push   $0x878
-  1d:	e8 71 03 00 00       	call   393 <open>
-  22:	83 c4 10             	add    $0x10,%esp
-  25:	85 c0                	test   %eax,%eax
-  27:	0f 88 9b 00 00 00    	js     c8 <main+0xc8>
-    mknod("console", 1, 1);
-    open("console", O_RDWR);
-  }
-  dup(0);  // stdout
-  2d:	83 ec 0c             	sub    $0xc,%esp
-  30:	6a 00                	push   $0x0
-  32:	e8 94 03 00 00       	call   3cb <dup>
-  dup(0);  // stderr
-  37:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
-  3e:	e8 88 03 00 00       	call   3cb <dup>
-  43:	83 c4 10             	add    $0x10,%esp
-  46:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  4d:	8d 76 00             	lea    0x0(%esi),%esi
-
-  for(;;){
-    printf(1, "init: starting sh\n");
-  50:	83 ec 08             	sub    $0x8,%esp
-  53:	68 80 08 00 00       	push   $0x880
-  58:	6a 01                	push   $0x1
-  5a:	e8 b1 04 00 00       	call   510 <printf>
-    pid = fork();
-  5f:	e8 e7 02 00 00       	call   34b <fork>
-    if(pid < 0){
-  64:	83 c4 10             	add    $0x10,%esp
-    pid = fork();
-  67:	89 c3                	mov    %eax,%ebx
-    if(pid < 0){
-  69:	85 c0                	test   %eax,%eax
-  6b:	78 24                	js     91 <main+0x91>
-      printf(1, "init: fork failed\n");
-      exit();
-    }
-    if(pid == 0){
-  6d:	74 35                	je     a4 <main+0xa4>
-  6f:	90                   	nop
-      exec("sh", argv);
-      printf(1, "init: exec sh failed\n");
-      exit();
-    }
-    while((wpid=wait()) >= 0 && wpid != pid)
-  70:	e8 e6 02 00 00       	call   35b <wait>
-  75:	85 c0                	test   %eax,%eax
-  77:	78 d7                	js     50 <main+0x50>
-  79:	39 c3                	cmp    %eax,%ebx
-  7b:	74 d3                	je     50 <main+0x50>
-      printf(1, "zombie!\n");
-  7d:	83 ec 08             	sub    $0x8,%esp
-  80:	68 bf 08 00 00       	push   $0x8bf
-  85:	6a 01                	push   $0x1
-  87:	e8 84 04 00 00       	call   510 <printf>
-  8c:	83 c4 10             	add    $0x10,%esp
-  8f:	eb df                	jmp    70 <main+0x70>
-      printf(1, "init: fork failed\n");
-  91:	53                   	push   %ebx
-  92:	53                   	push   %ebx
-  93:	68 93 08 00 00       	push   $0x893
-  98:	6a 01                	push   $0x1
-  9a:	e8 71 04 00 00       	call   510 <printf>
-      exit();
-  9f:	e8 af 02 00 00       	call   353 <exit>
-      exec("sh", argv);
-  a4:	50                   	push   %eax
-  a5:	50                   	push   %eax
-  a6:	68 7c 0b 00 00       	push   $0xb7c
-  ab:	68 a6 08 00 00       	push   $0x8a6
-  b0:	e8 d6 02 00 00       	call   38b <exec>
-      printf(1, "init: exec sh failed\n");
-  b5:	5a                   	pop    %edx
-  b6:	59                   	pop    %ecx
-  b7:	68 a9 08 00 00       	push   $0x8a9
-  bc:	6a 01                	push   $0x1
-  be:	e8 4d 04 00 00       	call   510 <printf>
-      exit();
-  c3:	e8 8b 02 00 00       	call   353 <exit>
-    mknod("console", 1, 1);
-  c8:	50                   	push   %eax
-  c9:	6a 01                	push   $0x1
-  cb:	6a 01                	push   $0x1
-  cd:	68 78 08 00 00       	push   $0x878
-  d2:	e8 c4 02 00 00       	call   39b <mknod>
-    open("console", O_RDWR);
-  d7:	58                   	pop    %eax
-  d8:	5a                   	pop    %edx
-  d9:	6a 02                	push   $0x2
-  db:	68 78 08 00 00       	push   $0x878
-  e0:	e8 ae 02 00 00       	call   393 <open>
-  e5:	83 c4 10             	add    $0x10,%esp
-  e8:	e9 40 ff ff ff       	jmp    2d <main+0x2d>
-  ed:	66 90                	xchg   %ax,%ax
-  ef:	90                   	nop
-
-000000f0 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  f0:	f3 0f 1e fb          	endbr32 
-  f4:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  f5:	31 c0                	xor    %eax,%eax
-{
-  f7:	89 e5                	mov    %esp,%ebp
-  f9:	53                   	push   %ebx
-  fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  fd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
- 100:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
- 104:	88 14 01             	mov    %dl,(%ecx,%eax,1)
- 107:	83 c0 01             	add    $0x1,%eax
- 10a:	84 d2                	test   %dl,%dl
- 10c:	75 f2                	jne    100 <strcpy+0x10>
-    ;
-  return os;
-}
- 10e:	89 c8                	mov    %ecx,%eax
- 110:	5b                   	pop    %ebx
- 111:	5d                   	pop    %ebp
- 112:	c3                   	ret    
- 113:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 11a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000120 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
- 120:	f3 0f 1e fb          	endbr32 
- 124:	55                   	push   %ebp
- 125:	89 e5                	mov    %esp,%ebp
- 127:	53                   	push   %ebx
- 128:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 12b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
- 12e:	0f b6 01             	movzbl (%ecx),%eax
- 131:	0f b6 1a             	movzbl (%edx),%ebx
- 134:	84 c0                	test   %al,%al
- 136:	75 19                	jne    151 <strcmp+0x31>
- 138:	eb 26                	jmp    160 <strcmp+0x40>
- 13a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 140:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
- 144:	83 c1 01             	add    $0x1,%ecx
- 147:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
- 14a:	0f b6 1a             	movzbl (%edx),%ebx
- 14d:	84 c0                	test   %al,%al
- 14f:	74 0f                	je     160 <strcmp+0x40>
- 151:	38 d8                	cmp    %bl,%al
- 153:	74 eb                	je     140 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
- 155:	29 d8                	sub    %ebx,%eax
-}
- 157:	5b                   	pop    %ebx
- 158:	5d                   	pop    %ebp
- 159:	c3                   	ret    
- 15a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 160:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
- 162:	29 d8                	sub    %ebx,%eax
-}
- 164:	5b                   	pop    %ebx
- 165:	5d                   	pop    %ebp
- 166:	c3                   	ret    
- 167:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 16e:	66 90                	xchg   %ax,%ax
-
-00000170 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 170:	f3 0f 1e fb          	endbr32 
- 174:	55                   	push   %ebp
- 175:	89 e5                	mov    %esp,%ebp
- 177:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 17a:	80 3a 00             	cmpb   $0x0,(%edx)
- 17d:	74 21                	je     1a0 <strlen+0x30>
- 17f:	31 c0                	xor    %eax,%eax
- 181:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 188:	83 c0 01             	add    $0x1,%eax
- 18b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 18f:	89 c1                	mov    %eax,%ecx
- 191:	75 f5                	jne    188 <strlen+0x18>
-    ;
-  return n;
-}
- 193:	89 c8                	mov    %ecx,%eax
- 195:	5d                   	pop    %ebp
- 196:	c3                   	ret    
- 197:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 19e:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 1a0:	31 c9                	xor    %ecx,%ecx
-}
- 1a2:	5d                   	pop    %ebp
- 1a3:	89 c8                	mov    %ecx,%eax
- 1a5:	c3                   	ret    
- 1a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1ad:	8d 76 00             	lea    0x0(%esi),%esi
-
-000001b0 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 1b0:	f3 0f 1e fb          	endbr32 
- 1b4:	55                   	push   %ebp
- 1b5:	89 e5                	mov    %esp,%ebp
- 1b7:	57                   	push   %edi
- 1b8:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 1bb:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 1be:	8b 45 0c             	mov    0xc(%ebp),%eax
- 1c1:	89 d7                	mov    %edx,%edi
- 1c3:	fc                   	cld    
- 1c4:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 1c6:	89 d0                	mov    %edx,%eax
- 1c8:	5f                   	pop    %edi
- 1c9:	5d                   	pop    %ebp
- 1ca:	c3                   	ret    
- 1cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 1cf:	90                   	nop
-
-000001d0 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 1d0:	f3 0f 1e fb          	endbr32 
- 1d4:	55                   	push   %ebp
- 1d5:	89 e5                	mov    %esp,%ebp
- 1d7:	8b 45 08             	mov    0x8(%ebp),%eax
- 1da:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 1de:	0f b6 10             	movzbl (%eax),%edx
- 1e1:	84 d2                	test   %dl,%dl
- 1e3:	75 16                	jne    1fb <strchr+0x2b>
- 1e5:	eb 21                	jmp    208 <strchr+0x38>
- 1e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1ee:	66 90                	xchg   %ax,%ax
- 1f0:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 1f4:	83 c0 01             	add    $0x1,%eax
- 1f7:	84 d2                	test   %dl,%dl
- 1f9:	74 0d                	je     208 <strchr+0x38>
-    if(*s == c)
- 1fb:	38 d1                	cmp    %dl,%cl
- 1fd:	75 f1                	jne    1f0 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 1ff:	5d                   	pop    %ebp
- 200:	c3                   	ret    
- 201:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 208:	31 c0                	xor    %eax,%eax
-}
- 20a:	5d                   	pop    %ebp
- 20b:	c3                   	ret    
- 20c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000210 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 210:	f3 0f 1e fb          	endbr32 
- 214:	55                   	push   %ebp
- 215:	89 e5                	mov    %esp,%ebp
- 217:	57                   	push   %edi
- 218:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 219:	31 f6                	xor    %esi,%esi
-{
- 21b:	53                   	push   %ebx
- 21c:	89 f3                	mov    %esi,%ebx
- 21e:	83 ec 1c             	sub    $0x1c,%esp
- 221:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 224:	eb 33                	jmp    259 <gets+0x49>
- 226:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 22d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 230:	83 ec 04             	sub    $0x4,%esp
- 233:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 236:	6a 01                	push   $0x1
- 238:	50                   	push   %eax
- 239:	6a 00                	push   $0x0
- 23b:	e8 2b 01 00 00       	call   36b <read>
-    if(cc < 1)
- 240:	83 c4 10             	add    $0x10,%esp
- 243:	85 c0                	test   %eax,%eax
- 245:	7e 1c                	jle    263 <gets+0x53>
-      break;
-    buf[i++] = c;
- 247:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 24b:	83 c7 01             	add    $0x1,%edi
- 24e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 251:	3c 0a                	cmp    $0xa,%al
- 253:	74 23                	je     278 <gets+0x68>
- 255:	3c 0d                	cmp    $0xd,%al
- 257:	74 1f                	je     278 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 259:	83 c3 01             	add    $0x1,%ebx
- 25c:	89 fe                	mov    %edi,%esi
- 25e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 261:	7c cd                	jl     230 <gets+0x20>
- 263:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 265:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 268:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 26b:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 26e:	5b                   	pop    %ebx
- 26f:	5e                   	pop    %esi
- 270:	5f                   	pop    %edi
- 271:	5d                   	pop    %ebp
- 272:	c3                   	ret    
- 273:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 277:	90                   	nop
- 278:	8b 75 08             	mov    0x8(%ebp),%esi
- 27b:	8b 45 08             	mov    0x8(%ebp),%eax
- 27e:	01 de                	add    %ebx,%esi
- 280:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 282:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 285:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 288:	5b                   	pop    %ebx
- 289:	5e                   	pop    %esi
- 28a:	5f                   	pop    %edi
- 28b:	5d                   	pop    %ebp
- 28c:	c3                   	ret    
- 28d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000290 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 290:	f3 0f 1e fb          	endbr32 
- 294:	55                   	push   %ebp
- 295:	89 e5                	mov    %esp,%ebp
- 297:	56                   	push   %esi
- 298:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 299:	83 ec 08             	sub    $0x8,%esp
- 29c:	6a 00                	push   $0x0
- 29e:	ff 75 08             	pushl  0x8(%ebp)
- 2a1:	e8 ed 00 00 00       	call   393 <open>
-  if(fd < 0)
- 2a6:	83 c4 10             	add    $0x10,%esp
- 2a9:	85 c0                	test   %eax,%eax
- 2ab:	78 2b                	js     2d8 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 2ad:	83 ec 08             	sub    $0x8,%esp
- 2b0:	ff 75 0c             	pushl  0xc(%ebp)
- 2b3:	89 c3                	mov    %eax,%ebx
- 2b5:	50                   	push   %eax
- 2b6:	e8 f0 00 00 00       	call   3ab <fstat>
-  close(fd);
- 2bb:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 2be:	89 c6                	mov    %eax,%esi
-  close(fd);
- 2c0:	e8 b6 00 00 00       	call   37b <close>
-  return r;
- 2c5:	83 c4 10             	add    $0x10,%esp
-}
- 2c8:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 2cb:	89 f0                	mov    %esi,%eax
- 2cd:	5b                   	pop    %ebx
- 2ce:	5e                   	pop    %esi
- 2cf:	5d                   	pop    %ebp
- 2d0:	c3                   	ret    
- 2d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 2d8:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 2dd:	eb e9                	jmp    2c8 <stat+0x38>
- 2df:	90                   	nop
-
-000002e0 <atoi>:
-
-int
-atoi(const char *s)
-{
- 2e0:	f3 0f 1e fb          	endbr32 
- 2e4:	55                   	push   %ebp
- 2e5:	89 e5                	mov    %esp,%ebp
- 2e7:	53                   	push   %ebx
- 2e8:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 2eb:	0f be 02             	movsbl (%edx),%eax
- 2ee:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 2f1:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 2f4:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 2f9:	77 1a                	ja     315 <atoi+0x35>
- 2fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 2ff:	90                   	nop
-    n = n*10 + *s++ - '0';
- 300:	83 c2 01             	add    $0x1,%edx
- 303:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 306:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 30a:	0f be 02             	movsbl (%edx),%eax
- 30d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 310:	80 fb 09             	cmp    $0x9,%bl
- 313:	76 eb                	jbe    300 <atoi+0x20>
-  return n;
-}
- 315:	89 c8                	mov    %ecx,%eax
- 317:	5b                   	pop    %ebx
- 318:	5d                   	pop    %ebp
- 319:	c3                   	ret    
- 31a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000320 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 320:	f3 0f 1e fb          	endbr32 
- 324:	55                   	push   %ebp
- 325:	89 e5                	mov    %esp,%ebp
- 327:	57                   	push   %edi
- 328:	8b 45 10             	mov    0x10(%ebp),%eax
- 32b:	8b 55 08             	mov    0x8(%ebp),%edx
- 32e:	56                   	push   %esi
- 32f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 332:	85 c0                	test   %eax,%eax
- 334:	7e 0f                	jle    345 <memmove+0x25>
- 336:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 338:	89 d7                	mov    %edx,%edi
- 33a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 340:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 341:	39 f8                	cmp    %edi,%eax
- 343:	75 fb                	jne    340 <memmove+0x20>
-  return vdst;
-}
- 345:	5e                   	pop    %esi
- 346:	89 d0                	mov    %edx,%eax
- 348:	5f                   	pop    %edi
- 349:	5d                   	pop    %ebp
- 34a:	c3                   	ret    
-
-0000034b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 34b:	b8 01 00 00 00       	mov    $0x1,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <exit>:
-SYSCALL(exit)
- 353:	b8 02 00 00 00       	mov    $0x2,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <wait>:
-SYSCALL(wait)
- 35b:	b8 03 00 00 00       	mov    $0x3,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <pipe>:
-SYSCALL(pipe)
- 363:	b8 04 00 00 00       	mov    $0x4,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <read>:
-SYSCALL(read)
- 36b:	b8 05 00 00 00       	mov    $0x5,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <write>:
-SYSCALL(write)
- 373:	b8 10 00 00 00       	mov    $0x10,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <close>:
-SYSCALL(close)
- 37b:	b8 15 00 00 00       	mov    $0x15,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <kill>:
-SYSCALL(kill)
- 383:	b8 06 00 00 00       	mov    $0x6,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <exec>:
-SYSCALL(exec)
- 38b:	b8 07 00 00 00       	mov    $0x7,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <open>:
-SYSCALL(open)
- 393:	b8 0f 00 00 00       	mov    $0xf,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <mknod>:
-SYSCALL(mknod)
- 39b:	b8 11 00 00 00       	mov    $0x11,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
-
-000003a3 <unlink>:
-SYSCALL(unlink)
- 3a3:	b8 12 00 00 00       	mov    $0x12,%eax
- 3a8:	cd 40                	int    $0x40
- 3aa:	c3                   	ret    
-
-000003ab <fstat>:
-SYSCALL(fstat)
- 3ab:	b8 08 00 00 00       	mov    $0x8,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
-
-000003b3 <link>:
-SYSCALL(link)
- 3b3:	b8 13 00 00 00       	mov    $0x13,%eax
- 3b8:	cd 40                	int    $0x40
- 3ba:	c3                   	ret    
-
-000003bb <mkdir>:
-SYSCALL(mkdir)
- 3bb:	b8 14 00 00 00       	mov    $0x14,%eax
- 3c0:	cd 40                	int    $0x40
- 3c2:	c3                   	ret    
-
-000003c3 <chdir>:
-SYSCALL(chdir)
- 3c3:	b8 09 00 00 00       	mov    $0x9,%eax
- 3c8:	cd 40                	int    $0x40
- 3ca:	c3                   	ret    
-
-000003cb <dup>:
-SYSCALL(dup)
- 3cb:	b8 0a 00 00 00       	mov    $0xa,%eax
- 3d0:	cd 40                	int    $0x40
- 3d2:	c3                   	ret    
-
-000003d3 <getpid>:
-SYSCALL(getpid)
- 3d3:	b8 0b 00 00 00       	mov    $0xb,%eax
- 3d8:	cd 40                	int    $0x40
- 3da:	c3                   	ret    
-
-000003db <sbrk>:
-SYSCALL(sbrk)
- 3db:	b8 0c 00 00 00       	mov    $0xc,%eax
- 3e0:	cd 40                	int    $0x40
- 3e2:	c3                   	ret    
-
-000003e3 <sleep>:
-SYSCALL(sleep)
- 3e3:	b8 0d 00 00 00       	mov    $0xd,%eax
- 3e8:	cd 40                	int    $0x40
- 3ea:	c3                   	ret    
-
-000003eb <uptime>:
-SYSCALL(uptime)
- 3eb:	b8 0e 00 00 00       	mov    $0xe,%eax
- 3f0:	cd 40                	int    $0x40
- 3f2:	c3                   	ret    
-
-000003f3 <getParentID>:
-SYSCALL(getParentID)
- 3f3:	b8 16 00 00 00       	mov    $0x16,%eax
- 3f8:	cd 40                	int    $0x40
- 3fa:	c3                   	ret    
-
-000003fb <getChildren>:
-SYSCALL(getChildren)
- 3fb:	b8 17 00 00 00       	mov    $0x17,%eax
- 400:	cd 40                	int    $0x40
- 402:	c3                   	ret    
-
-00000403 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 403:	b8 18 00 00 00       	mov    $0x18,%eax
- 408:	cd 40                	int    $0x40
- 40a:	c3                   	ret    
-
-0000040b <setPriority>:
-SYSCALL(setPriority)
- 40b:	b8 19 00 00 00       	mov    $0x19,%eax
- 410:	cd 40                	int    $0x40
- 412:	c3                   	ret    
-
-00000413 <changePolicy>:
-SYSCALL(changePolicy)
- 413:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 418:	cd 40                	int    $0x40
- 41a:	c3                   	ret    
-
-0000041b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 41b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 420:	cd 40                	int    $0x40
- 422:	c3                   	ret    
-
-00000423 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 423:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 428:	cd 40                	int    $0x40
- 42a:	c3                   	ret    
-
-0000042b <getCBT>:
-SYSCALL(getCBT)
- 42b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 430:	cd 40                	int    $0x40
- 432:	c3                   	ret    
-
-00000433 <customWait>:
-SYSCALL(customWait)
- 433:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 438:	cd 40                	int    $0x40
- 43a:	c3                   	ret    
-
-0000043b <setQueue>:
-SYSCALL(setQueue)
- 43b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 440:	cd 40                	int    $0x40
- 442:	c3                   	ret    
-
-00000443 <getBurstTime>:
-SYSCALL(getBurstTime)
- 443:	b8 20 00 00 00       	mov    $0x20,%eax
- 448:	cd 40                	int    $0x40
- 44a:	c3                   	ret    
-
-0000044b <getCreationTime>:
- 44b:	b8 21 00 00 00       	mov    $0x21,%eax
- 450:	cd 40                	int    $0x40
- 452:	c3                   	ret    
- 453:	66 90                	xchg   %ax,%ax
- 455:	66 90                	xchg   %ax,%ax
- 457:	66 90                	xchg   %ax,%ax
- 459:	66 90                	xchg   %ax,%ax
- 45b:	66 90                	xchg   %ax,%ax
- 45d:	66 90                	xchg   %ax,%ax
- 45f:	90                   	nop
-
-00000460 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 460:	55                   	push   %ebp
- 461:	89 e5                	mov    %esp,%ebp
- 463:	57                   	push   %edi
- 464:	56                   	push   %esi
- 465:	53                   	push   %ebx
- 466:	83 ec 3c             	sub    $0x3c,%esp
- 469:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 46c:	89 d1                	mov    %edx,%ecx
-{
- 46e:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 471:	85 d2                	test   %edx,%edx
- 473:	0f 89 7f 00 00 00    	jns    4f8 <printint+0x98>
- 479:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 47d:	74 79                	je     4f8 <printint+0x98>
-    neg = 1;
- 47f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 486:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 488:	31 db                	xor    %ebx,%ebx
- 48a:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 48d:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 490:	89 c8                	mov    %ecx,%eax
- 492:	31 d2                	xor    %edx,%edx
- 494:	89 cf                	mov    %ecx,%edi
- 496:	f7 75 c4             	divl   -0x3c(%ebp)
- 499:	0f b6 92 d0 08 00 00 	movzbl 0x8d0(%edx),%edx
- 4a0:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 4a3:	89 d8                	mov    %ebx,%eax
- 4a5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 4a8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 4ab:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 4ae:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 4b1:	76 dd                	jbe    490 <printint+0x30>
-  if(neg)
- 4b3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 4b6:	85 c9                	test   %ecx,%ecx
- 4b8:	74 0c                	je     4c6 <printint+0x66>
-    buf[i++] = '-';
- 4ba:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 4bf:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 4c1:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 4c6:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 4c9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 4cd:	eb 07                	jmp    4d6 <printint+0x76>
- 4cf:	90                   	nop
- 4d0:	0f b6 13             	movzbl (%ebx),%edx
- 4d3:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 4d6:	83 ec 04             	sub    $0x4,%esp
- 4d9:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 4dc:	6a 01                	push   $0x1
- 4de:	56                   	push   %esi
- 4df:	57                   	push   %edi
- 4e0:	e8 8e fe ff ff       	call   373 <write>
-  while(--i >= 0)
- 4e5:	83 c4 10             	add    $0x10,%esp
- 4e8:	39 de                	cmp    %ebx,%esi
- 4ea:	75 e4                	jne    4d0 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 4ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 4ef:	5b                   	pop    %ebx
- 4f0:	5e                   	pop    %esi
- 4f1:	5f                   	pop    %edi
- 4f2:	5d                   	pop    %ebp
- 4f3:	c3                   	ret    
- 4f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 4f8:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 4ff:	eb 87                	jmp    488 <printint+0x28>
- 501:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 508:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 50f:	90                   	nop
-
-00000510 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 510:	f3 0f 1e fb          	endbr32 
- 514:	55                   	push   %ebp
- 515:	89 e5                	mov    %esp,%ebp
- 517:	57                   	push   %edi
- 518:	56                   	push   %esi
- 519:	53                   	push   %ebx
- 51a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 51d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 520:	0f b6 1e             	movzbl (%esi),%ebx
- 523:	84 db                	test   %bl,%bl
- 525:	0f 84 b4 00 00 00    	je     5df <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 52b:	8d 45 10             	lea    0x10(%ebp),%eax
- 52e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 531:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 534:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 536:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 539:	eb 33                	jmp    56e <printf+0x5e>
- 53b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 53f:	90                   	nop
- 540:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 543:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 548:	83 f8 25             	cmp    $0x25,%eax
- 54b:	74 17                	je     564 <printf+0x54>
-  write(fd, &c, 1);
- 54d:	83 ec 04             	sub    $0x4,%esp
- 550:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 553:	6a 01                	push   $0x1
- 555:	57                   	push   %edi
- 556:	ff 75 08             	pushl  0x8(%ebp)
- 559:	e8 15 fe ff ff       	call   373 <write>
- 55e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 561:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 564:	0f b6 1e             	movzbl (%esi),%ebx
- 567:	83 c6 01             	add    $0x1,%esi
- 56a:	84 db                	test   %bl,%bl
- 56c:	74 71                	je     5df <printf+0xcf>
-    c = fmt[i] & 0xff;
- 56e:	0f be cb             	movsbl %bl,%ecx
- 571:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 574:	85 d2                	test   %edx,%edx
- 576:	74 c8                	je     540 <printf+0x30>
-      }
-    } else if(state == '%'){
- 578:	83 fa 25             	cmp    $0x25,%edx
- 57b:	75 e7                	jne    564 <printf+0x54>
-      if(c == 'd'){
- 57d:	83 f8 64             	cmp    $0x64,%eax
- 580:	0f 84 9a 00 00 00    	je     620 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 586:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 58c:	83 f9 70             	cmp    $0x70,%ecx
- 58f:	74 5f                	je     5f0 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 591:	83 f8 73             	cmp    $0x73,%eax
- 594:	0f 84 d6 00 00 00    	je     670 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 59a:	83 f8 63             	cmp    $0x63,%eax
- 59d:	0f 84 8d 00 00 00    	je     630 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 5a3:	83 f8 25             	cmp    $0x25,%eax
- 5a6:	0f 84 b4 00 00 00    	je     660 <printf+0x150>
-  write(fd, &c, 1);
- 5ac:	83 ec 04             	sub    $0x4,%esp
- 5af:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 5b3:	6a 01                	push   $0x1
- 5b5:	57                   	push   %edi
- 5b6:	ff 75 08             	pushl  0x8(%ebp)
- 5b9:	e8 b5 fd ff ff       	call   373 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 5be:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5c1:	83 c4 0c             	add    $0xc,%esp
- 5c4:	6a 01                	push   $0x1
- 5c6:	83 c6 01             	add    $0x1,%esi
- 5c9:	57                   	push   %edi
- 5ca:	ff 75 08             	pushl  0x8(%ebp)
- 5cd:	e8 a1 fd ff ff       	call   373 <write>
-  for(i = 0; fmt[i]; i++){
- 5d2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 5d6:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 5d9:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 5db:	84 db                	test   %bl,%bl
- 5dd:	75 8f                	jne    56e <printf+0x5e>
-    }
-  }
-}
- 5df:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 5e2:	5b                   	pop    %ebx
- 5e3:	5e                   	pop    %esi
- 5e4:	5f                   	pop    %edi
- 5e5:	5d                   	pop    %ebp
- 5e6:	c3                   	ret    
- 5e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5ee:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 5f0:	83 ec 0c             	sub    $0xc,%esp
- 5f3:	b9 10 00 00 00       	mov    $0x10,%ecx
- 5f8:	6a 00                	push   $0x0
- 5fa:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 5fd:	8b 45 08             	mov    0x8(%ebp),%eax
- 600:	8b 13                	mov    (%ebx),%edx
- 602:	e8 59 fe ff ff       	call   460 <printint>
-        ap++;
- 607:	89 d8                	mov    %ebx,%eax
- 609:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 60c:	31 d2                	xor    %edx,%edx
-        ap++;
- 60e:	83 c0 04             	add    $0x4,%eax
- 611:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 614:	e9 4b ff ff ff       	jmp    564 <printf+0x54>
- 619:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 620:	83 ec 0c             	sub    $0xc,%esp
- 623:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 628:	6a 01                	push   $0x1
- 62a:	eb ce                	jmp    5fa <printf+0xea>
- 62c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 630:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 633:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 636:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 638:	6a 01                	push   $0x1
-        ap++;
- 63a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 63d:	57                   	push   %edi
- 63e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 641:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 644:	e8 2a fd ff ff       	call   373 <write>
-        ap++;
- 649:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 64c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 64f:	31 d2                	xor    %edx,%edx
- 651:	e9 0e ff ff ff       	jmp    564 <printf+0x54>
- 656:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 65d:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 660:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 663:	83 ec 04             	sub    $0x4,%esp
- 666:	e9 59 ff ff ff       	jmp    5c4 <printf+0xb4>
- 66b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 66f:	90                   	nop
-        s = (char*)*ap;
- 670:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 673:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 675:	83 c0 04             	add    $0x4,%eax
- 678:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 67b:	85 db                	test   %ebx,%ebx
- 67d:	74 17                	je     696 <printf+0x186>
-        while(*s != 0){
- 67f:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 682:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 684:	84 c0                	test   %al,%al
- 686:	0f 84 d8 fe ff ff    	je     564 <printf+0x54>
- 68c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 68f:	89 de                	mov    %ebx,%esi
- 691:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 694:	eb 1a                	jmp    6b0 <printf+0x1a0>
-          s = "(null)";
- 696:	bb c8 08 00 00       	mov    $0x8c8,%ebx
-        while(*s != 0){
- 69b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 69e:	b8 28 00 00 00       	mov    $0x28,%eax
- 6a3:	89 de                	mov    %ebx,%esi
- 6a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 6a8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 6af:	90                   	nop
-  write(fd, &c, 1);
- 6b0:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 6b3:	83 c6 01             	add    $0x1,%esi
- 6b6:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 6b9:	6a 01                	push   $0x1
- 6bb:	57                   	push   %edi
- 6bc:	53                   	push   %ebx
- 6bd:	e8 b1 fc ff ff       	call   373 <write>
-        while(*s != 0){
- 6c2:	0f b6 06             	movzbl (%esi),%eax
- 6c5:	83 c4 10             	add    $0x10,%esp
- 6c8:	84 c0                	test   %al,%al
- 6ca:	75 e4                	jne    6b0 <printf+0x1a0>
- 6cc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 6cf:	31 d2                	xor    %edx,%edx
- 6d1:	e9 8e fe ff ff       	jmp    564 <printf+0x54>
- 6d6:	66 90                	xchg   %ax,%ax
- 6d8:	66 90                	xchg   %ax,%ax
- 6da:	66 90                	xchg   %ax,%ax
- 6dc:	66 90                	xchg   %ax,%ax
- 6de:	66 90                	xchg   %ax,%ax
-
-000006e0 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 6e0:	f3 0f 1e fb          	endbr32 
- 6e4:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 6e5:	a1 84 0b 00 00       	mov    0xb84,%eax
-{
- 6ea:	89 e5                	mov    %esp,%ebp
- 6ec:	57                   	push   %edi
- 6ed:	56                   	push   %esi
- 6ee:	53                   	push   %ebx
- 6ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 6f2:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 6f4:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 6f7:	39 c8                	cmp    %ecx,%eax
- 6f9:	73 15                	jae    710 <free+0x30>
- 6fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 6ff:	90                   	nop
- 700:	39 d1                	cmp    %edx,%ecx
- 702:	72 14                	jb     718 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 704:	39 d0                	cmp    %edx,%eax
- 706:	73 10                	jae    718 <free+0x38>
-{
- 708:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 70a:	8b 10                	mov    (%eax),%edx
- 70c:	39 c8                	cmp    %ecx,%eax
- 70e:	72 f0                	jb     700 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 710:	39 d0                	cmp    %edx,%eax
- 712:	72 f4                	jb     708 <free+0x28>
- 714:	39 d1                	cmp    %edx,%ecx
- 716:	73 f0                	jae    708 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 718:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 71b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 71e:	39 fa                	cmp    %edi,%edx
- 720:	74 1e                	je     740 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 722:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 725:	8b 50 04             	mov    0x4(%eax),%edx
- 728:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 72b:	39 f1                	cmp    %esi,%ecx
- 72d:	74 28                	je     757 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 72f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 731:	5b                   	pop    %ebx
-  freep = p;
- 732:	a3 84 0b 00 00       	mov    %eax,0xb84
-}
- 737:	5e                   	pop    %esi
- 738:	5f                   	pop    %edi
- 739:	5d                   	pop    %ebp
- 73a:	c3                   	ret    
- 73b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 73f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 740:	03 72 04             	add    0x4(%edx),%esi
- 743:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 746:	8b 10                	mov    (%eax),%edx
- 748:	8b 12                	mov    (%edx),%edx
- 74a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 74d:	8b 50 04             	mov    0x4(%eax),%edx
- 750:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 753:	39 f1                	cmp    %esi,%ecx
- 755:	75 d8                	jne    72f <free+0x4f>
-    p->s.size += bp->s.size;
- 757:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 75a:	a3 84 0b 00 00       	mov    %eax,0xb84
-    p->s.size += bp->s.size;
- 75f:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 762:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 765:	89 10                	mov    %edx,(%eax)
-}
- 767:	5b                   	pop    %ebx
- 768:	5e                   	pop    %esi
- 769:	5f                   	pop    %edi
- 76a:	5d                   	pop    %ebp
- 76b:	c3                   	ret    
- 76c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000770 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 770:	f3 0f 1e fb          	endbr32 
- 774:	55                   	push   %ebp
- 775:	89 e5                	mov    %esp,%ebp
- 777:	57                   	push   %edi
- 778:	56                   	push   %esi
- 779:	53                   	push   %ebx
- 77a:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 77d:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 780:	8b 3d 84 0b 00 00    	mov    0xb84,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 786:	8d 70 07             	lea    0x7(%eax),%esi
- 789:	c1 ee 03             	shr    $0x3,%esi
- 78c:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 78f:	85 ff                	test   %edi,%edi
- 791:	0f 84 a9 00 00 00    	je     840 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 797:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 799:	8b 48 04             	mov    0x4(%eax),%ecx
- 79c:	39 f1                	cmp    %esi,%ecx
- 79e:	73 6d                	jae    80d <malloc+0x9d>
- 7a0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 7a6:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 7ab:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 7ae:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 7b5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 7b8:	eb 17                	jmp    7d1 <malloc+0x61>
- 7ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7c0:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 7c2:	8b 4a 04             	mov    0x4(%edx),%ecx
- 7c5:	39 f1                	cmp    %esi,%ecx
- 7c7:	73 4f                	jae    818 <malloc+0xa8>
- 7c9:	8b 3d 84 0b 00 00    	mov    0xb84,%edi
- 7cf:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 7d1:	39 c7                	cmp    %eax,%edi
- 7d3:	75 eb                	jne    7c0 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 7d5:	83 ec 0c             	sub    $0xc,%esp
- 7d8:	ff 75 e4             	pushl  -0x1c(%ebp)
- 7db:	e8 fb fb ff ff       	call   3db <sbrk>
-  if(p == (char*)-1)
- 7e0:	83 c4 10             	add    $0x10,%esp
- 7e3:	83 f8 ff             	cmp    $0xffffffff,%eax
- 7e6:	74 1b                	je     803 <malloc+0x93>
-  hp->s.size = nu;
- 7e8:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 7eb:	83 ec 0c             	sub    $0xc,%esp
- 7ee:	83 c0 08             	add    $0x8,%eax
- 7f1:	50                   	push   %eax
- 7f2:	e8 e9 fe ff ff       	call   6e0 <free>
-  return freep;
- 7f7:	a1 84 0b 00 00       	mov    0xb84,%eax
-      if((p = morecore(nunits)) == 0)
- 7fc:	83 c4 10             	add    $0x10,%esp
- 7ff:	85 c0                	test   %eax,%eax
- 801:	75 bd                	jne    7c0 <malloc+0x50>
-        return 0;
-  }
-}
- 803:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 806:	31 c0                	xor    %eax,%eax
-}
- 808:	5b                   	pop    %ebx
- 809:	5e                   	pop    %esi
- 80a:	5f                   	pop    %edi
- 80b:	5d                   	pop    %ebp
- 80c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 80d:	89 c2                	mov    %eax,%edx
- 80f:	89 f8                	mov    %edi,%eax
- 811:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 818:	39 ce                	cmp    %ecx,%esi
- 81a:	74 54                	je     870 <malloc+0x100>
-        p->s.size -= nunits;
- 81c:	29 f1                	sub    %esi,%ecx
- 81e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 821:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 824:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 827:	a3 84 0b 00 00       	mov    %eax,0xb84
-}
- 82c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 82f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 832:	5b                   	pop    %ebx
- 833:	5e                   	pop    %esi
- 834:	5f                   	pop    %edi
- 835:	5d                   	pop    %ebp
- 836:	c3                   	ret    
- 837:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 83e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 840:	c7 05 84 0b 00 00 88 	movl   $0xb88,0xb84
- 847:	0b 00 00 
-    base.s.size = 0;
- 84a:	bf 88 0b 00 00       	mov    $0xb88,%edi
-    base.s.ptr = freep = prevp = &base;
- 84f:	c7 05 88 0b 00 00 88 	movl   $0xb88,0xb88
- 856:	0b 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 859:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 85b:	c7 05 8c 0b 00 00 00 	movl   $0x0,0xb8c
- 862:	00 00 00 
-    if(p->s.size >= nunits){
- 865:	e9 36 ff ff ff       	jmp    7a0 <malloc+0x30>
- 86a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 870:	8b 0a                	mov    (%edx),%ecx
- 872:	89 08                	mov    %ecx,(%eax)
- 874:	eb b1                	jmp    827 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/init.c b/xv6-public/Operating-System-Project/init.c
deleted file mode 100644
index 046b551..0000000
--- a/xv6-public/Operating-System-Project/init.c
+++ /dev/null
@@ -1,37 +0,0 @@
-// init: The initial user-level program
-
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fcntl.h"
-
-char *argv[] = { "sh", 0 };
-
-int
-main(void)
-{
-  int pid, wpid;
-
-  if(open("console", O_RDWR) < 0){
-    mknod("console", 1, 1);
-    open("console", O_RDWR);
-  }
-  dup(0);  // stdout
-  dup(0);  // stderr
-
-  for(;;){
-    printf(1, "init: starting sh\n");
-    pid = fork();
-    if(pid < 0){
-      printf(1, "init: fork failed\n");
-      exit();
-    }
-    if(pid == 0){
-      exec("sh", argv);
-      printf(1, "init: exec sh failed\n");
-      exit();
-    }
-    while((wpid=wait()) >= 0 && wpid != pid)
-      printf(1, "zombie!\n");
-  }
-}
diff --git a/xv6-public/Operating-System-Project/init.d b/xv6-public/Operating-System-Project/init.d
deleted file mode 100644
index ee304c8..0000000
--- a/xv6-public/Operating-System-Project/init.d
+++ /dev/null
@@ -1 +0,0 @@
-init.o: init.c /usr/include/stdc-predef.h types.h stat.h user.h fcntl.h
diff --git a/xv6-public/Operating-System-Project/init.o b/xv6-public/Operating-System-Project/init.o
deleted file mode 100644
index 49e0d2d..0000000
Binary files a/xv6-public/Operating-System-Project/init.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/init.sym b/xv6-public/Operating-System-Project/init.sym
deleted file mode 100644
index ed3bbfc..0000000
--- a/xv6-public/Operating-System-Project/init.sym
+++ /dev/null
@@ -1,71 +0,0 @@
-00000000 .text
-00000878 .rodata
-000008e4 .eh_frame
-00000b7c .data
-00000b84 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 init.c
-00000000 ulib.c
-00000000 printf.c
-00000460 printint
-000008d0 digits.1109
-00000000 umalloc.c
-00000b84 freep
-00000b88 base
-000000f0 strcpy
-000003fb getChildren
-00000510 printf
-00000b7c argv
-00000320 memmove
-0000039b mknod
-00000210 gets
-000003d3 getpid
-00000433 customWait
-0000042b getCBT
-00000770 malloc
-000003e3 sleep
-00000363 pipe
-00000413 changePolicy
-00000373 write
-000003ab fstat
-00000383 kill
-000003c3 chdir
-0000043b setQueue
-0000038b exec
-0000035b wait
-0000036b read
-00000443 getBurstTime
-000003a3 unlink
-0000034b fork
-0000041b getTurnAroundTime
-000003db sbrk
-000003eb uptime
-00000b84 __bss_start
-000001b0 memset
-00000000 main
-00000120 strcmp
-000003cb dup
-00000403 getSyscallCounter
-000003f3 getParentID
-00000290 stat
-00000b84 _edata
-00000b90 _end
-000003b3 link
-00000353 exit
-0000040b setPriority
-000002e0 atoi
-0000044b getCreationTime
-00000170 strlen
-00000393 open
-000001d0 strchr
-000003bb mkdir
-0000037b close
-00000423 getWaitingTime
-000006e0 free
diff --git a/xv6-public/Operating-System-Project/initcode b/xv6-public/Operating-System-Project/initcode
deleted file mode 100644
index 773d26c..0000000
Binary files a/xv6-public/Operating-System-Project/initcode and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/initcode.S b/xv6-public/Operating-System-Project/initcode.S
deleted file mode 100644
index 80ac5d8..0000000
--- a/xv6-public/Operating-System-Project/initcode.S
+++ /dev/null
@@ -1,32 +0,0 @@
-# Initial process execs /init.
-# This code runs in user space.
-
-#include "syscall.h"
-#include "traps.h"
-
-
-# exec(init, argv)
-.globl start
-start:
-  pushl $argv
-  pushl $init
-  pushl $0  // where caller pc would be
-  movl $SYS_exec, %eax
-  int $T_SYSCALL
-
-# for(;;) exit();
-exit:
-  movl $SYS_exit, %eax
-  int $T_SYSCALL
-  jmp exit
-
-# char init[] = "/init\0";
-init:
-  .string "/init\0"
-
-# char *argv[] = { init, 0 };
-.p2align 2
-argv:
-  .long init
-  .long 0
-
diff --git a/xv6-public/Operating-System-Project/initcode.asm b/xv6-public/Operating-System-Project/initcode.asm
deleted file mode 100644
index 3d5dae2..0000000
--- a/xv6-public/Operating-System-Project/initcode.asm
+++ /dev/null
@@ -1,43 +0,0 @@
-
-initcode.o:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <start>:
-
-
-# exec(init, argv)
-.globl start
-start:
-  pushl $argv
-   0:	68 24 00 00 00       	push   $0x24
-  pushl $init
-   5:	68 1c 00 00 00       	push   $0x1c
-  pushl $0  // where caller pc would be
-   a:	6a 00                	push   $0x0
-  movl $SYS_exec, %eax
-   c:	b8 07 00 00 00       	mov    $0x7,%eax
-  int $T_SYSCALL
-  11:	cd 40                	int    $0x40
-
-00000013 <exit>:
-
-# for(;;) exit();
-exit:
-  movl $SYS_exit, %eax
-  13:	b8 02 00 00 00       	mov    $0x2,%eax
-  int $T_SYSCALL
-  18:	cd 40                	int    $0x40
-  jmp exit
-  1a:	eb f7                	jmp    13 <exit>
-
-0000001c <init>:
-  1c:	2f                   	das    
-  1d:	69 6e 69 74 00 00 90 	imul   $0x90000074,0x69(%esi),%ebp
-
-00000024 <argv>:
-  24:	1c 00                	sbb    $0x0,%al
-  26:	00 00                	add    %al,(%eax)
-  28:	00 00                	add    %al,(%eax)
-	...
diff --git a/xv6-public/Operating-System-Project/initcode.d b/xv6-public/Operating-System-Project/initcode.d
deleted file mode 100644
index ab1af4d..0000000
--- a/xv6-public/Operating-System-Project/initcode.d
+++ /dev/null
@@ -1 +0,0 @@
-initcode.o: initcode.S syscall.h traps.h
diff --git a/xv6-public/Operating-System-Project/initcode.o b/xv6-public/Operating-System-Project/initcode.o
deleted file mode 100644
index 4dc4e43..0000000
Binary files a/xv6-public/Operating-System-Project/initcode.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/initcode.out b/xv6-public/Operating-System-Project/initcode.out
deleted file mode 100644
index 048553c..0000000
Binary files a/xv6-public/Operating-System-Project/initcode.out and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/ioapic.c b/xv6-public/Operating-System-Project/ioapic.c
deleted file mode 100644
index cb0f015..0000000
--- a/xv6-public/Operating-System-Project/ioapic.c
+++ /dev/null
@@ -1,75 +0,0 @@
-// The I/O APIC manages hardware interrupts for an SMP system.
-// http://www.intel.com/design/chipsets/datashts/29056601.pdf
-// See also picirq.c.
-
-#include "types.h"
-#include "defs.h"
-#include "traps.h"
-
-#define IOAPIC  0xFEC00000   // Default physical address of IO APIC
-
-#define REG_ID     0x00  // Register index: ID
-#define REG_VER    0x01  // Register index: version
-#define REG_TABLE  0x10  // Redirection table base
-
-// The redirection table starts at REG_TABLE and uses
-// two registers to configure each interrupt.
-// The first (low) register in a pair contains configuration bits.
-// The second (high) register contains a bitmask telling which
-// CPUs can serve that interrupt.
-#define INT_DISABLED   0x00010000  // Interrupt disabled
-#define INT_LEVEL      0x00008000  // Level-triggered (vs edge-)
-#define INT_ACTIVELOW  0x00002000  // Active low (vs high)
-#define INT_LOGICAL    0x00000800  // Destination is CPU id (vs APIC ID)
-
-volatile struct ioapic *ioapic;
-
-// IO APIC MMIO structure: write reg, then read or write data.
-struct ioapic {
-  uint reg;
-  uint pad[3];
-  uint data;
-};
-
-static uint
-ioapicread(int reg)
-{
-  ioapic->reg = reg;
-  return ioapic->data;
-}
-
-static void
-ioapicwrite(int reg, uint data)
-{
-  ioapic->reg = reg;
-  ioapic->data = data;
-}
-
-void
-ioapicinit(void)
-{
-  int i, id, maxintr;
-
-  ioapic = (volatile struct ioapic*)IOAPIC;
-  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
-  id = ioapicread(REG_ID) >> 24;
-  if(id != ioapicid)
-    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
-
-  // Mark all interrupts edge-triggered, active high, disabled,
-  // and not routed to any CPUs.
-  for(i = 0; i <= maxintr; i++){
-    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
-    ioapicwrite(REG_TABLE+2*i+1, 0);
-  }
-}
-
-void
-ioapicenable(int irq, int cpunum)
-{
-  // Mark interrupt edge-triggered, active high,
-  // enabled, and routed to the given cpunum,
-  // which happens to be that cpu's APIC ID.
-  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
-  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
-}
diff --git a/xv6-public/Operating-System-Project/ioapic.d b/xv6-public/Operating-System-Project/ioapic.d
deleted file mode 100644
index f90182a..0000000
--- a/xv6-public/Operating-System-Project/ioapic.d
+++ /dev/null
@@ -1,2 +0,0 @@
-ioapic.o: ioapic.c /usr/include/stdc-predef.h types.h defs.h param.h \
- traps.h
diff --git a/xv6-public/Operating-System-Project/ioapic.o b/xv6-public/Operating-System-Project/ioapic.o
deleted file mode 100644
index ef6dd84..0000000
Binary files a/xv6-public/Operating-System-Project/ioapic.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/kalloc.c b/xv6-public/Operating-System-Project/kalloc.c
deleted file mode 100644
index 14cd4f4..0000000
--- a/xv6-public/Operating-System-Project/kalloc.c
+++ /dev/null
@@ -1,96 +0,0 @@
-// Physical memory allocator, intended to allocate
-// memory for user processes, kernel stacks, page table pages,
-// and pipe buffers. Allocates 4096-byte pages.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "spinlock.h"
-
-void freerange(void *vstart, void *vend);
-extern char end[]; // first address after kernel loaded from ELF file
-                   // defined by the kernel linker script in kernel.ld
-
-struct run {
-  struct run *next;
-};
-
-struct {
-  struct spinlock lock;
-  int use_lock;
-  struct run *freelist;
-} kmem;
-
-// Initialization happens in two phases.
-// 1. main() calls kinit1() while still using entrypgdir to place just
-// the pages mapped by entrypgdir on free list.
-// 2. main() calls kinit2() with the rest of the physical pages
-// after installing a full page table that maps them on all cores.
-void
-kinit1(void *vstart, void *vend)
-{
-  initlock(&kmem.lock, "kmem");
-  kmem.use_lock = 0;
-  freerange(vstart, vend);
-}
-
-void
-kinit2(void *vstart, void *vend)
-{
-  freerange(vstart, vend);
-  kmem.use_lock = 1;
-}
-
-void
-freerange(void *vstart, void *vend)
-{
-  char *p;
-  p = (char*)PGROUNDUP((uint)vstart);
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
-    kfree(p);
-}
-//PAGEBREAK: 21
-// Free the page of physical memory pointed at by v,
-// which normally should have been returned by a
-// call to kalloc().  (The exception is when
-// initializing the allocator; see kinit above.)
-void
-kfree(char *v)
-{
-  struct run *r;
-
-  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
-    panic("kfree");
-
-  // Fill with junk to catch dangling refs.
-  memset(v, 1, PGSIZE);
-
-  if(kmem.use_lock)
-    acquire(&kmem.lock);
-  r = (struct run*)v;
-  r->next = kmem.freelist;
-  kmem.freelist = r;
-  if(kmem.use_lock)
-    release(&kmem.lock);
-}
-
-// Allocate one 4096-byte page of physical memory.
-// Returns a pointer that the kernel can use.
-// Returns 0 if the memory cannot be allocated.
-char*
-kalloc(void)
-{
-  struct run *r;
-
-  if(kmem.use_lock)
-    acquire(&kmem.lock);
-  r = kmem.freelist;
-  if(r)
-    kmem.freelist = r->next;
-  if(kmem.use_lock)
-    release(&kmem.lock);
-  return (char*)r;
-}
-
diff --git a/xv6-public/Operating-System-Project/kalloc.d b/xv6-public/Operating-System-Project/kalloc.d
deleted file mode 100644
index 512c5db..0000000
--- a/xv6-public/Operating-System-Project/kalloc.d
+++ /dev/null
@@ -1,2 +0,0 @@
-kalloc.o: kalloc.c /usr/include/stdc-predef.h types.h defs.h param.h \
- memlayout.h mmu.h spinlock.h
diff --git a/xv6-public/Operating-System-Project/kalloc.o b/xv6-public/Operating-System-Project/kalloc.o
deleted file mode 100644
index 5c8715b..0000000
Binary files a/xv6-public/Operating-System-Project/kalloc.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/kbd.c b/xv6-public/Operating-System-Project/kbd.c
deleted file mode 100644
index 32c1463..0000000
--- a/xv6-public/Operating-System-Project/kbd.c
+++ /dev/null
@@ -1,50 +0,0 @@
-#include "types.h"
-#include "x86.h"
-#include "defs.h"
-#include "kbd.h"
-
-int
-kbdgetc(void)
-{
-  static uint shift;
-  static uchar *charcode[4] = {
-    normalmap, shiftmap, ctlmap, ctlmap
-  };
-  uint st, data, c;
-
-  st = inb(KBSTATP);
-  if((st & KBS_DIB) == 0)
-    return -1;
-  data = inb(KBDATAP);
-
-  if(data == 0xE0){
-    shift |= E0ESC;
-    return 0;
-  } else if(data & 0x80){
-    // Key released
-    data = (shift & E0ESC ? data : data & 0x7F);
-    shift &= ~(shiftcode[data] | E0ESC);
-    return 0;
-  } else if(shift & E0ESC){
-    // Last character was an E0 escape; or with 0x80
-    data |= 0x80;
-    shift &= ~E0ESC;
-  }
-
-  shift |= shiftcode[data];
-  shift ^= togglecode[data];
-  c = charcode[shift & (CTL | SHIFT)][data];
-  if(shift & CAPSLOCK){
-    if('a' <= c && c <= 'z')
-      c += 'A' - 'a';
-    else if('A' <= c && c <= 'Z')
-      c += 'a' - 'A';
-  }
-  return c;
-}
-
-void
-kbdintr(void)
-{
-  consoleintr(kbdgetc);
-}
diff --git a/xv6-public/Operating-System-Project/kbd.d b/xv6-public/Operating-System-Project/kbd.d
deleted file mode 100644
index bc8d64b..0000000
--- a/xv6-public/Operating-System-Project/kbd.d
+++ /dev/null
@@ -1,2 +0,0 @@
-kbd.o: kbd.c /usr/include/stdc-predef.h types.h x86.h defs.h param.h \
- kbd.h
diff --git a/xv6-public/Operating-System-Project/kbd.h b/xv6-public/Operating-System-Project/kbd.h
deleted file mode 100644
index babbd6e..0000000
--- a/xv6-public/Operating-System-Project/kbd.h
+++ /dev/null
@@ -1,112 +0,0 @@
-// PC keyboard interface constants
-
-#define KBSTATP         0x64    // kbd controller status port(I)
-#define KBS_DIB         0x01    // kbd data in buffer
-#define KBDATAP         0x60    // kbd data port(I)
-
-#define NO              0
-
-#define SHIFT           (1<<0)
-#define CTL             (1<<1)
-#define ALT             (1<<2)
-
-#define CAPSLOCK        (1<<3)
-#define NUMLOCK         (1<<4)
-#define SCROLLLOCK      (1<<5)
-
-#define E0ESC           (1<<6)
-
-// Special keycodes
-#define KEY_HOME        0xE0
-#define KEY_END         0xE1
-#define KEY_UP          0xE2
-#define KEY_DN          0xE3
-#define KEY_LF          0xE4
-#define KEY_RT          0xE5
-#define KEY_PGUP        0xE6
-#define KEY_PGDN        0xE7
-#define KEY_INS         0xE8
-#define KEY_DEL         0xE9
-
-// C('A') == Control-A
-#define C(x) (x - '@')
-
-static uchar shiftcode[256] =
-{
-  [0x1D] CTL,
-  [0x2A] SHIFT,
-  [0x36] SHIFT,
-  [0x38] ALT,
-  [0x9D] CTL,
-  [0xB8] ALT
-};
-
-static uchar togglecode[256] =
-{
-  [0x3A] CAPSLOCK,
-  [0x45] NUMLOCK,
-  [0x46] SCROLLLOCK
-};
-
-static uchar normalmap[256] =
-{
-  NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00
-  '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
-  'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10
-  'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
-  'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20
-  '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
-  'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  // 0x30
-  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
-  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
-  [0x9C] '\n',      // KP_Enter
-  [0xB5] '/',       // KP_Div
-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
-  [0x97] KEY_HOME,  [0xCF] KEY_END,
-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
-};
-
-static uchar shiftmap[256] =
-{
-  NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00
-  '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
-  'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10
-  'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
-  'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20
-  '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
-  'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  // 0x30
-  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
-  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
-  [0x9C] '\n',      // KP_Enter
-  [0xB5] '/',       // KP_Div
-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
-  [0x97] KEY_HOME,  [0xCF] KEY_END,
-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
-};
-
-static uchar ctlmap[256] =
-{
-  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
-  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
-  C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
-  C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
-  C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
-  NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
-  C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
-  [0x9C] '\r',      // KP_Enter
-  [0xB5] C('/'),    // KP_Div
-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
-  [0x97] KEY_HOME,  [0xCF] KEY_END,
-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
-};
-
diff --git a/xv6-public/Operating-System-Project/kbd.o b/xv6-public/Operating-System-Project/kbd.o
deleted file mode 100644
index 718dc1a..0000000
Binary files a/xv6-public/Operating-System-Project/kbd.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/kernel b/xv6-public/Operating-System-Project/kernel
deleted file mode 100644
index 8e418e2..0000000
Binary files a/xv6-public/Operating-System-Project/kernel and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/kernel.asm b/xv6-public/Operating-System-Project/kernel.asm
deleted file mode 100644
index 9e59f9d..0000000
--- a/xv6-public/Operating-System-Project/kernel.asm
+++ /dev/null
@@ -1,17031 +0,0 @@
-
-kernel:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-80100000 <multiboot_header>:
-80100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
-80100006:	00 00                	add    %al,(%eax)
-80100008:	fe 4f 52             	decb   0x52(%edi)
-8010000b:	e4                   	.byte 0xe4
-
-8010000c <entry>:
-
-# Entering xv6 on boot processor, with paging off.
-.globl entry
-entry:
-  # Turn on page size extension for 4Mbyte pages
-  movl    %cr4, %eax
-8010000c:	0f 20 e0             	mov    %cr4,%eax
-  orl     $(CR4_PSE), %eax
-8010000f:	83 c8 10             	or     $0x10,%eax
-  movl    %eax, %cr4
-80100012:	0f 22 e0             	mov    %eax,%cr4
-  # Set page directory
-  movl    $(V2P_WO(entrypgdir)), %eax
-80100015:	b8 00 a0 10 00       	mov    $0x10a000,%eax
-  movl    %eax, %cr3
-8010001a:	0f 22 d8             	mov    %eax,%cr3
-  # Turn on paging.
-  movl    %cr0, %eax
-8010001d:	0f 20 c0             	mov    %cr0,%eax
-  orl     $(CR0_PG|CR0_WP), %eax
-80100020:	0d 00 00 01 80       	or     $0x80010000,%eax
-  movl    %eax, %cr0
-80100025:	0f 22 c0             	mov    %eax,%cr0
-
-  # Set up the stack pointer.
-  movl $(stack + KSTACKSIZE), %esp
-80100028:	bc d0 c5 10 80       	mov    $0x8010c5d0,%esp
-
-  # Jump to main(), and switch to executing at
-  # high addresses. The indirect call is needed because
-  # the assembler produces a PC-relative instruction
-  # for a direct jump.
-  mov $main, %eax
-8010002d:	b8 40 30 10 80       	mov    $0x80103040,%eax
-  jmp *%eax
-80100032:	ff e0                	jmp    *%eax
-80100034:	66 90                	xchg   %ax,%ax
-80100036:	66 90                	xchg   %ax,%ax
-80100038:	66 90                	xchg   %ax,%ax
-8010003a:	66 90                	xchg   %ax,%ax
-8010003c:	66 90                	xchg   %ax,%ax
-8010003e:	66 90                	xchg   %ax,%ax
-
-80100040 <binit>:
-  struct buf head;
-} bcache;
-
-void
-binit(void)
-{
-80100040:	f3 0f 1e fb          	endbr32 
-80100044:	55                   	push   %ebp
-80100045:	89 e5                	mov    %esp,%ebp
-80100047:	53                   	push   %ebx
-
-//PAGEBREAK!
-  // Create linked list of buffers
-  bcache.head.prev = &bcache.head;
-  bcache.head.next = &bcache.head;
-  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
-80100048:	bb 14 c6 10 80       	mov    $0x8010c614,%ebx
-{
-8010004d:	83 ec 0c             	sub    $0xc,%esp
-  initlock(&bcache.lock, "bcache");
-80100050:	68 80 7c 10 80       	push   $0x80107c80
-80100055:	68 e0 c5 10 80       	push   $0x8010c5e0
-8010005a:	e8 e1 4b 00 00       	call   80104c40 <initlock>
-  bcache.head.next = &bcache.head;
-8010005f:	83 c4 10             	add    $0x10,%esp
-80100062:	b8 dc 0c 11 80       	mov    $0x80110cdc,%eax
-  bcache.head.prev = &bcache.head;
-80100067:	c7 05 2c 0d 11 80 dc 	movl   $0x80110cdc,0x80110d2c
-8010006e:	0c 11 80 
-  bcache.head.next = &bcache.head;
-80100071:	c7 05 30 0d 11 80 dc 	movl   $0x80110cdc,0x80110d30
-80100078:	0c 11 80 
-  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
-8010007b:	eb 05                	jmp    80100082 <binit+0x42>
-8010007d:	8d 76 00             	lea    0x0(%esi),%esi
-80100080:	89 d3                	mov    %edx,%ebx
-    b->next = bcache.head.next;
-80100082:	89 43 54             	mov    %eax,0x54(%ebx)
-    b->prev = &bcache.head;
-    initsleeplock(&b->lock, "buffer");
-80100085:	83 ec 08             	sub    $0x8,%esp
-80100088:	8d 43 0c             	lea    0xc(%ebx),%eax
-    b->prev = &bcache.head;
-8010008b:	c7 43 50 dc 0c 11 80 	movl   $0x80110cdc,0x50(%ebx)
-    initsleeplock(&b->lock, "buffer");
-80100092:	68 87 7c 10 80       	push   $0x80107c87
-80100097:	50                   	push   %eax
-80100098:	e8 63 4a 00 00       	call   80104b00 <initsleeplock>
-    bcache.head.next->prev = b;
-8010009d:	a1 30 0d 11 80       	mov    0x80110d30,%eax
-  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
-801000a2:	8d 93 5c 02 00 00    	lea    0x25c(%ebx),%edx
-801000a8:	83 c4 10             	add    $0x10,%esp
-    bcache.head.next->prev = b;
-801000ab:	89 58 50             	mov    %ebx,0x50(%eax)
-    bcache.head.next = b;
-801000ae:	89 d8                	mov    %ebx,%eax
-801000b0:	89 1d 30 0d 11 80    	mov    %ebx,0x80110d30
-  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
-801000b6:	81 fb 80 0a 11 80    	cmp    $0x80110a80,%ebx
-801000bc:	75 c2                	jne    80100080 <binit+0x40>
-  }
-}
-801000be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-801000c1:	c9                   	leave  
-801000c2:	c3                   	ret    
-801000c3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801000ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-801000d0 <bread>:
-}
-
-// Return a locked buf with the contents of the indicated block.
-struct buf*
-bread(uint dev, uint blockno)
-{
-801000d0:	f3 0f 1e fb          	endbr32 
-801000d4:	55                   	push   %ebp
-801000d5:	89 e5                	mov    %esp,%ebp
-801000d7:	57                   	push   %edi
-801000d8:	56                   	push   %esi
-801000d9:	53                   	push   %ebx
-801000da:	83 ec 18             	sub    $0x18,%esp
-801000dd:	8b 7d 08             	mov    0x8(%ebp),%edi
-801000e0:	8b 75 0c             	mov    0xc(%ebp),%esi
-  acquire(&bcache.lock);
-801000e3:	68 e0 c5 10 80       	push   $0x8010c5e0
-801000e8:	e8 d3 4c 00 00       	call   80104dc0 <acquire>
-  for(b = bcache.head.next; b != &bcache.head; b = b->next){
-801000ed:	8b 1d 30 0d 11 80    	mov    0x80110d30,%ebx
-801000f3:	83 c4 10             	add    $0x10,%esp
-801000f6:	81 fb dc 0c 11 80    	cmp    $0x80110cdc,%ebx
-801000fc:	75 0d                	jne    8010010b <bread+0x3b>
-801000fe:	eb 20                	jmp    80100120 <bread+0x50>
-80100100:	8b 5b 54             	mov    0x54(%ebx),%ebx
-80100103:	81 fb dc 0c 11 80    	cmp    $0x80110cdc,%ebx
-80100109:	74 15                	je     80100120 <bread+0x50>
-    if(b->dev == dev && b->blockno == blockno){
-8010010b:	3b 7b 04             	cmp    0x4(%ebx),%edi
-8010010e:	75 f0                	jne    80100100 <bread+0x30>
-80100110:	3b 73 08             	cmp    0x8(%ebx),%esi
-80100113:	75 eb                	jne    80100100 <bread+0x30>
-      b->refcnt++;
-80100115:	83 43 4c 01          	addl   $0x1,0x4c(%ebx)
-      release(&bcache.lock);
-80100119:	eb 3f                	jmp    8010015a <bread+0x8a>
-8010011b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010011f:	90                   	nop
-  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
-80100120:	8b 1d 2c 0d 11 80    	mov    0x80110d2c,%ebx
-80100126:	81 fb dc 0c 11 80    	cmp    $0x80110cdc,%ebx
-8010012c:	75 0d                	jne    8010013b <bread+0x6b>
-8010012e:	eb 70                	jmp    801001a0 <bread+0xd0>
-80100130:	8b 5b 50             	mov    0x50(%ebx),%ebx
-80100133:	81 fb dc 0c 11 80    	cmp    $0x80110cdc,%ebx
-80100139:	74 65                	je     801001a0 <bread+0xd0>
-    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
-8010013b:	8b 43 4c             	mov    0x4c(%ebx),%eax
-8010013e:	85 c0                	test   %eax,%eax
-80100140:	75 ee                	jne    80100130 <bread+0x60>
-80100142:	f6 03 04             	testb  $0x4,(%ebx)
-80100145:	75 e9                	jne    80100130 <bread+0x60>
-      b->dev = dev;
-80100147:	89 7b 04             	mov    %edi,0x4(%ebx)
-      b->blockno = blockno;
-8010014a:	89 73 08             	mov    %esi,0x8(%ebx)
-      b->flags = 0;
-8010014d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
-      b->refcnt = 1;
-80100153:	c7 43 4c 01 00 00 00 	movl   $0x1,0x4c(%ebx)
-      release(&bcache.lock);
-8010015a:	83 ec 0c             	sub    $0xc,%esp
-8010015d:	68 e0 c5 10 80       	push   $0x8010c5e0
-80100162:	e8 19 4d 00 00       	call   80104e80 <release>
-      acquiresleep(&b->lock);
-80100167:	8d 43 0c             	lea    0xc(%ebx),%eax
-8010016a:	89 04 24             	mov    %eax,(%esp)
-8010016d:	e8 ce 49 00 00       	call   80104b40 <acquiresleep>
-      return b;
-80100172:	83 c4 10             	add    $0x10,%esp
-  struct buf *b;
-
-  b = bget(dev, blockno);
-  if((b->flags & B_VALID) == 0) {
-80100175:	f6 03 02             	testb  $0x2,(%ebx)
-80100178:	74 0e                	je     80100188 <bread+0xb8>
-    iderw(b);
-  }
-  return b;
-}
-8010017a:	8d 65 f4             	lea    -0xc(%ebp),%esp
-8010017d:	89 d8                	mov    %ebx,%eax
-8010017f:	5b                   	pop    %ebx
-80100180:	5e                   	pop    %esi
-80100181:	5f                   	pop    %edi
-80100182:	5d                   	pop    %ebp
-80100183:	c3                   	ret    
-80100184:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    iderw(b);
-80100188:	83 ec 0c             	sub    $0xc,%esp
-8010018b:	53                   	push   %ebx
-8010018c:	e8 ef 20 00 00       	call   80102280 <iderw>
-80100191:	83 c4 10             	add    $0x10,%esp
-}
-80100194:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80100197:	89 d8                	mov    %ebx,%eax
-80100199:	5b                   	pop    %ebx
-8010019a:	5e                   	pop    %esi
-8010019b:	5f                   	pop    %edi
-8010019c:	5d                   	pop    %ebp
-8010019d:	c3                   	ret    
-8010019e:	66 90                	xchg   %ax,%ax
-  panic("bget: no buffers");
-801001a0:	83 ec 0c             	sub    $0xc,%esp
-801001a3:	68 8e 7c 10 80       	push   $0x80107c8e
-801001a8:	e8 e3 01 00 00       	call   80100390 <panic>
-801001ad:	8d 76 00             	lea    0x0(%esi),%esi
-
-801001b0 <bwrite>:
-
-// Write b's contents to disk.  Must be locked.
-void
-bwrite(struct buf *b)
-{
-801001b0:	f3 0f 1e fb          	endbr32 
-801001b4:	55                   	push   %ebp
-801001b5:	89 e5                	mov    %esp,%ebp
-801001b7:	53                   	push   %ebx
-801001b8:	83 ec 10             	sub    $0x10,%esp
-801001bb:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  if(!holdingsleep(&b->lock))
-801001be:	8d 43 0c             	lea    0xc(%ebx),%eax
-801001c1:	50                   	push   %eax
-801001c2:	e8 19 4a 00 00       	call   80104be0 <holdingsleep>
-801001c7:	83 c4 10             	add    $0x10,%esp
-801001ca:	85 c0                	test   %eax,%eax
-801001cc:	74 0f                	je     801001dd <bwrite+0x2d>
-    panic("bwrite");
-  b->flags |= B_DIRTY;
-801001ce:	83 0b 04             	orl    $0x4,(%ebx)
-  iderw(b);
-801001d1:	89 5d 08             	mov    %ebx,0x8(%ebp)
-}
-801001d4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-801001d7:	c9                   	leave  
-  iderw(b);
-801001d8:	e9 a3 20 00 00       	jmp    80102280 <iderw>
-    panic("bwrite");
-801001dd:	83 ec 0c             	sub    $0xc,%esp
-801001e0:	68 9f 7c 10 80       	push   $0x80107c9f
-801001e5:	e8 a6 01 00 00       	call   80100390 <panic>
-801001ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-801001f0 <brelse>:
-
-// Release a locked buffer.
-// Move to the head of the MRU list.
-void
-brelse(struct buf *b)
-{
-801001f0:	f3 0f 1e fb          	endbr32 
-801001f4:	55                   	push   %ebp
-801001f5:	89 e5                	mov    %esp,%ebp
-801001f7:	56                   	push   %esi
-801001f8:	53                   	push   %ebx
-801001f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  if(!holdingsleep(&b->lock))
-801001fc:	8d 73 0c             	lea    0xc(%ebx),%esi
-801001ff:	83 ec 0c             	sub    $0xc,%esp
-80100202:	56                   	push   %esi
-80100203:	e8 d8 49 00 00       	call   80104be0 <holdingsleep>
-80100208:	83 c4 10             	add    $0x10,%esp
-8010020b:	85 c0                	test   %eax,%eax
-8010020d:	74 66                	je     80100275 <brelse+0x85>
-    panic("brelse");
-
-  releasesleep(&b->lock);
-8010020f:	83 ec 0c             	sub    $0xc,%esp
-80100212:	56                   	push   %esi
-80100213:	e8 88 49 00 00       	call   80104ba0 <releasesleep>
-
-  acquire(&bcache.lock);
-80100218:	c7 04 24 e0 c5 10 80 	movl   $0x8010c5e0,(%esp)
-8010021f:	e8 9c 4b 00 00       	call   80104dc0 <acquire>
-  b->refcnt--;
-80100224:	8b 43 4c             	mov    0x4c(%ebx),%eax
-  if (b->refcnt == 0) {
-80100227:	83 c4 10             	add    $0x10,%esp
-  b->refcnt--;
-8010022a:	83 e8 01             	sub    $0x1,%eax
-8010022d:	89 43 4c             	mov    %eax,0x4c(%ebx)
-  if (b->refcnt == 0) {
-80100230:	85 c0                	test   %eax,%eax
-80100232:	75 2f                	jne    80100263 <brelse+0x73>
-    // no one is waiting for it.
-    b->next->prev = b->prev;
-80100234:	8b 43 54             	mov    0x54(%ebx),%eax
-80100237:	8b 53 50             	mov    0x50(%ebx),%edx
-8010023a:	89 50 50             	mov    %edx,0x50(%eax)
-    b->prev->next = b->next;
-8010023d:	8b 43 50             	mov    0x50(%ebx),%eax
-80100240:	8b 53 54             	mov    0x54(%ebx),%edx
-80100243:	89 50 54             	mov    %edx,0x54(%eax)
-    b->next = bcache.head.next;
-80100246:	a1 30 0d 11 80       	mov    0x80110d30,%eax
-    b->prev = &bcache.head;
-8010024b:	c7 43 50 dc 0c 11 80 	movl   $0x80110cdc,0x50(%ebx)
-    b->next = bcache.head.next;
-80100252:	89 43 54             	mov    %eax,0x54(%ebx)
-    bcache.head.next->prev = b;
-80100255:	a1 30 0d 11 80       	mov    0x80110d30,%eax
-8010025a:	89 58 50             	mov    %ebx,0x50(%eax)
-    bcache.head.next = b;
-8010025d:	89 1d 30 0d 11 80    	mov    %ebx,0x80110d30
-  }
-  
-  release(&bcache.lock);
-80100263:	c7 45 08 e0 c5 10 80 	movl   $0x8010c5e0,0x8(%ebp)
-}
-8010026a:	8d 65 f8             	lea    -0x8(%ebp),%esp
-8010026d:	5b                   	pop    %ebx
-8010026e:	5e                   	pop    %esi
-8010026f:	5d                   	pop    %ebp
-  release(&bcache.lock);
-80100270:	e9 0b 4c 00 00       	jmp    80104e80 <release>
-    panic("brelse");
-80100275:	83 ec 0c             	sub    $0xc,%esp
-80100278:	68 a6 7c 10 80       	push   $0x80107ca6
-8010027d:	e8 0e 01 00 00       	call   80100390 <panic>
-80100282:	66 90                	xchg   %ax,%ax
-80100284:	66 90                	xchg   %ax,%ax
-80100286:	66 90                	xchg   %ax,%ax
-80100288:	66 90                	xchg   %ax,%ax
-8010028a:	66 90                	xchg   %ax,%ax
-8010028c:	66 90                	xchg   %ax,%ax
-8010028e:	66 90                	xchg   %ax,%ax
-
-80100290 <consoleread>:
-  }
-}
-
-int
-consoleread(struct inode *ip, char *dst, int n)
-{
-80100290:	f3 0f 1e fb          	endbr32 
-80100294:	55                   	push   %ebp
-80100295:	89 e5                	mov    %esp,%ebp
-80100297:	57                   	push   %edi
-80100298:	56                   	push   %esi
-80100299:	53                   	push   %ebx
-8010029a:	83 ec 18             	sub    $0x18,%esp
-  uint target;
-  int c;
-
-  iunlock(ip);
-8010029d:	ff 75 08             	pushl  0x8(%ebp)
-{
-801002a0:	8b 5d 10             	mov    0x10(%ebp),%ebx
-  target = n;
-801002a3:	89 de                	mov    %ebx,%esi
-  iunlock(ip);
-801002a5:	e8 96 15 00 00       	call   80101840 <iunlock>
-  acquire(&cons.lock);
-801002aa:	c7 04 24 20 b5 10 80 	movl   $0x8010b520,(%esp)
-801002b1:	e8 0a 4b 00 00       	call   80104dc0 <acquire>
-        // caller gets a 0-byte result.
-        input.r--;
-      }
-      break;
-    }
-    *dst++ = c;
-801002b6:	8b 7d 0c             	mov    0xc(%ebp),%edi
-  while(n > 0){
-801002b9:	83 c4 10             	add    $0x10,%esp
-    *dst++ = c;
-801002bc:	01 df                	add    %ebx,%edi
-  while(n > 0){
-801002be:	85 db                	test   %ebx,%ebx
-801002c0:	0f 8e 97 00 00 00    	jle    8010035d <consoleread+0xcd>
-    while(input.r == input.w){
-801002c6:	a1 c0 0f 11 80       	mov    0x80110fc0,%eax
-801002cb:	3b 05 c4 0f 11 80    	cmp    0x80110fc4,%eax
-801002d1:	74 27                	je     801002fa <consoleread+0x6a>
-801002d3:	eb 5b                	jmp    80100330 <consoleread+0xa0>
-801002d5:	8d 76 00             	lea    0x0(%esi),%esi
-      sleep(&input.r, &cons.lock);
-801002d8:	83 ec 08             	sub    $0x8,%esp
-801002db:	68 20 b5 10 80       	push   $0x8010b520
-801002e0:	68 c0 0f 11 80       	push   $0x80110fc0
-801002e5:	e8 16 40 00 00       	call   80104300 <sleep>
-    while(input.r == input.w){
-801002ea:	a1 c0 0f 11 80       	mov    0x80110fc0,%eax
-801002ef:	83 c4 10             	add    $0x10,%esp
-801002f2:	3b 05 c4 0f 11 80    	cmp    0x80110fc4,%eax
-801002f8:	75 36                	jne    80100330 <consoleread+0xa0>
-      if(myproc()->killed){
-801002fa:	e8 b1 36 00 00       	call   801039b0 <myproc>
-801002ff:	8b 48 24             	mov    0x24(%eax),%ecx
-80100302:	85 c9                	test   %ecx,%ecx
-80100304:	74 d2                	je     801002d8 <consoleread+0x48>
-        release(&cons.lock);
-80100306:	83 ec 0c             	sub    $0xc,%esp
-80100309:	68 20 b5 10 80       	push   $0x8010b520
-8010030e:	e8 6d 4b 00 00       	call   80104e80 <release>
-        ilock(ip);
-80100313:	5a                   	pop    %edx
-80100314:	ff 75 08             	pushl  0x8(%ebp)
-80100317:	e8 44 14 00 00       	call   80101760 <ilock>
-        return -1;
-8010031c:	83 c4 10             	add    $0x10,%esp
-  }
-  release(&cons.lock);
-  ilock(ip);
-
-  return target - n;
-}
-8010031f:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return -1;
-80100322:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80100327:	5b                   	pop    %ebx
-80100328:	5e                   	pop    %esi
-80100329:	5f                   	pop    %edi
-8010032a:	5d                   	pop    %ebp
-8010032b:	c3                   	ret    
-8010032c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    c = input.buf[input.r++ % INPUT_BUF];
-80100330:	8d 50 01             	lea    0x1(%eax),%edx
-80100333:	89 15 c0 0f 11 80    	mov    %edx,0x80110fc0
-80100339:	89 c2                	mov    %eax,%edx
-8010033b:	83 e2 7f             	and    $0x7f,%edx
-8010033e:	0f be 8a 40 0f 11 80 	movsbl -0x7feef0c0(%edx),%ecx
-    if(c == C('D')){  // EOF
-80100345:	80 f9 04             	cmp    $0x4,%cl
-80100348:	74 38                	je     80100382 <consoleread+0xf2>
-    *dst++ = c;
-8010034a:	89 d8                	mov    %ebx,%eax
-    --n;
-8010034c:	83 eb 01             	sub    $0x1,%ebx
-    *dst++ = c;
-8010034f:	f7 d8                	neg    %eax
-80100351:	88 0c 07             	mov    %cl,(%edi,%eax,1)
-    if(c == '\n')
-80100354:	83 f9 0a             	cmp    $0xa,%ecx
-80100357:	0f 85 61 ff ff ff    	jne    801002be <consoleread+0x2e>
-  release(&cons.lock);
-8010035d:	83 ec 0c             	sub    $0xc,%esp
-80100360:	68 20 b5 10 80       	push   $0x8010b520
-80100365:	e8 16 4b 00 00       	call   80104e80 <release>
-  ilock(ip);
-8010036a:	58                   	pop    %eax
-8010036b:	ff 75 08             	pushl  0x8(%ebp)
-8010036e:	e8 ed 13 00 00       	call   80101760 <ilock>
-  return target - n;
-80100373:	89 f0                	mov    %esi,%eax
-80100375:	83 c4 10             	add    $0x10,%esp
-}
-80100378:	8d 65 f4             	lea    -0xc(%ebp),%esp
-  return target - n;
-8010037b:	29 d8                	sub    %ebx,%eax
-}
-8010037d:	5b                   	pop    %ebx
-8010037e:	5e                   	pop    %esi
-8010037f:	5f                   	pop    %edi
-80100380:	5d                   	pop    %ebp
-80100381:	c3                   	ret    
-      if(n < target){
-80100382:	39 f3                	cmp    %esi,%ebx
-80100384:	73 d7                	jae    8010035d <consoleread+0xcd>
-        input.r--;
-80100386:	a3 c0 0f 11 80       	mov    %eax,0x80110fc0
-8010038b:	eb d0                	jmp    8010035d <consoleread+0xcd>
-8010038d:	8d 76 00             	lea    0x0(%esi),%esi
-
-80100390 <panic>:
-{
-80100390:	f3 0f 1e fb          	endbr32 
-80100394:	55                   	push   %ebp
-80100395:	89 e5                	mov    %esp,%ebp
-80100397:	56                   	push   %esi
-80100398:	53                   	push   %ebx
-80100399:	83 ec 30             	sub    $0x30,%esp
-}
-
-static inline void
-cli(void)
-{
-  asm volatile("cli");
-8010039c:	fa                   	cli    
-  cons.locking = 0;
-8010039d:	c7 05 54 b5 10 80 00 	movl   $0x0,0x8010b554
-801003a4:	00 00 00 
-  getcallerpcs(&s, pcs);
-801003a7:	8d 5d d0             	lea    -0x30(%ebp),%ebx
-801003aa:	8d 75 f8             	lea    -0x8(%ebp),%esi
-  cprintf("lapicid %d: panic: ", lapicid());
-801003ad:	e8 ee 24 00 00       	call   801028a0 <lapicid>
-801003b2:	83 ec 08             	sub    $0x8,%esp
-801003b5:	50                   	push   %eax
-801003b6:	68 ad 7c 10 80       	push   $0x80107cad
-801003bb:	e8 f0 02 00 00       	call   801006b0 <cprintf>
-  cprintf(s);
-801003c0:	58                   	pop    %eax
-801003c1:	ff 75 08             	pushl  0x8(%ebp)
-801003c4:	e8 e7 02 00 00       	call   801006b0 <cprintf>
-  cprintf("\n");
-801003c9:	c7 04 24 03 86 10 80 	movl   $0x80108603,(%esp)
-801003d0:	e8 db 02 00 00       	call   801006b0 <cprintf>
-  getcallerpcs(&s, pcs);
-801003d5:	8d 45 08             	lea    0x8(%ebp),%eax
-801003d8:	5a                   	pop    %edx
-801003d9:	59                   	pop    %ecx
-801003da:	53                   	push   %ebx
-801003db:	50                   	push   %eax
-801003dc:	e8 7f 48 00 00       	call   80104c60 <getcallerpcs>
-  for(i=0; i<10; i++)
-801003e1:	83 c4 10             	add    $0x10,%esp
-    cprintf(" %p", pcs[i]);
-801003e4:	83 ec 08             	sub    $0x8,%esp
-801003e7:	ff 33                	pushl  (%ebx)
-801003e9:	83 c3 04             	add    $0x4,%ebx
-801003ec:	68 c1 7c 10 80       	push   $0x80107cc1
-801003f1:	e8 ba 02 00 00       	call   801006b0 <cprintf>
-  for(i=0; i<10; i++)
-801003f6:	83 c4 10             	add    $0x10,%esp
-801003f9:	39 f3                	cmp    %esi,%ebx
-801003fb:	75 e7                	jne    801003e4 <panic+0x54>
-  panicked = 1; // freeze other CPU
-801003fd:	c7 05 58 b5 10 80 01 	movl   $0x1,0x8010b558
-80100404:	00 00 00 
-  for(;;)
-80100407:	eb fe                	jmp    80100407 <panic+0x77>
-80100409:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-80100410 <consputc.part.0>:
-consputc(int c)
-80100410:	55                   	push   %ebp
-80100411:	89 e5                	mov    %esp,%ebp
-80100413:	57                   	push   %edi
-80100414:	56                   	push   %esi
-80100415:	53                   	push   %ebx
-80100416:	89 c3                	mov    %eax,%ebx
-80100418:	83 ec 1c             	sub    $0x1c,%esp
-  if(c == BACKSPACE){
-8010041b:	3d 00 01 00 00       	cmp    $0x100,%eax
-80100420:	0f 84 ea 00 00 00    	je     80100510 <consputc.part.0+0x100>
-    uartputc(c);
-80100426:	83 ec 0c             	sub    $0xc,%esp
-80100429:	50                   	push   %eax
-8010042a:	e8 51 64 00 00       	call   80106880 <uartputc>
-8010042f:	83 c4 10             	add    $0x10,%esp
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-80100432:	bf d4 03 00 00       	mov    $0x3d4,%edi
-80100437:	b8 0e 00 00 00       	mov    $0xe,%eax
-8010043c:	89 fa                	mov    %edi,%edx
-8010043e:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-8010043f:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
-80100444:	89 ca                	mov    %ecx,%edx
-80100446:	ec                   	in     (%dx),%al
-  pos = inb(CRTPORT+1) << 8;
-80100447:	0f b6 c0             	movzbl %al,%eax
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-8010044a:	89 fa                	mov    %edi,%edx
-8010044c:	c1 e0 08             	shl    $0x8,%eax
-8010044f:	89 c6                	mov    %eax,%esi
-80100451:	b8 0f 00 00 00       	mov    $0xf,%eax
-80100456:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80100457:	89 ca                	mov    %ecx,%edx
-80100459:	ec                   	in     (%dx),%al
-  pos |= inb(CRTPORT+1);
-8010045a:	0f b6 c0             	movzbl %al,%eax
-8010045d:	09 f0                	or     %esi,%eax
-  if(c == '\n')
-8010045f:	83 fb 0a             	cmp    $0xa,%ebx
-80100462:	0f 84 90 00 00 00    	je     801004f8 <consputc.part.0+0xe8>
-  else if(c == BACKSPACE){
-80100468:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
-8010046e:	74 70                	je     801004e0 <consputc.part.0+0xd0>
-    crt[pos++] = (c&0xff) | 0x0700;  // black on white
-80100470:	0f b6 db             	movzbl %bl,%ebx
-80100473:	8d 70 01             	lea    0x1(%eax),%esi
-80100476:	80 cf 07             	or     $0x7,%bh
-80100479:	66 89 9c 00 00 80 0b 	mov    %bx,-0x7ff48000(%eax,%eax,1)
-80100480:	80 
-  if(pos < 0 || pos > 25*80)
-80100481:	81 fe d0 07 00 00    	cmp    $0x7d0,%esi
-80100487:	0f 8f f9 00 00 00    	jg     80100586 <consputc.part.0+0x176>
-  if((pos/80) >= 24){  // Scroll up.
-8010048d:	81 fe 7f 07 00 00    	cmp    $0x77f,%esi
-80100493:	0f 8f a7 00 00 00    	jg     80100540 <consputc.part.0+0x130>
-80100499:	89 f0                	mov    %esi,%eax
-8010049b:	8d b4 36 00 80 0b 80 	lea    -0x7ff48000(%esi,%esi,1),%esi
-801004a2:	88 45 e7             	mov    %al,-0x19(%ebp)
-801004a5:	0f b6 fc             	movzbl %ah,%edi
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-801004a8:	bb d4 03 00 00       	mov    $0x3d4,%ebx
-801004ad:	b8 0e 00 00 00       	mov    $0xe,%eax
-801004b2:	89 da                	mov    %ebx,%edx
-801004b4:	ee                   	out    %al,(%dx)
-801004b5:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
-801004ba:	89 f8                	mov    %edi,%eax
-801004bc:	89 ca                	mov    %ecx,%edx
-801004be:	ee                   	out    %al,(%dx)
-801004bf:	b8 0f 00 00 00       	mov    $0xf,%eax
-801004c4:	89 da                	mov    %ebx,%edx
-801004c6:	ee                   	out    %al,(%dx)
-801004c7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
-801004cb:	89 ca                	mov    %ecx,%edx
-801004cd:	ee                   	out    %al,(%dx)
-  crt[pos] = ' ' | 0x0700;
-801004ce:	b8 20 07 00 00       	mov    $0x720,%eax
-801004d3:	66 89 06             	mov    %ax,(%esi)
-}
-801004d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801004d9:	5b                   	pop    %ebx
-801004da:	5e                   	pop    %esi
-801004db:	5f                   	pop    %edi
-801004dc:	5d                   	pop    %ebp
-801004dd:	c3                   	ret    
-801004de:	66 90                	xchg   %ax,%ax
-    if(pos > 0) --pos;
-801004e0:	8d 70 ff             	lea    -0x1(%eax),%esi
-801004e3:	85 c0                	test   %eax,%eax
-801004e5:	75 9a                	jne    80100481 <consputc.part.0+0x71>
-801004e7:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
-801004eb:	be 00 80 0b 80       	mov    $0x800b8000,%esi
-801004f0:	31 ff                	xor    %edi,%edi
-801004f2:	eb b4                	jmp    801004a8 <consputc.part.0+0x98>
-801004f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    pos += 80 - pos%80;
-801004f8:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
-801004fd:	f7 e2                	mul    %edx
-801004ff:	c1 ea 06             	shr    $0x6,%edx
-80100502:	8d 04 92             	lea    (%edx,%edx,4),%eax
-80100505:	c1 e0 04             	shl    $0x4,%eax
-80100508:	8d 70 50             	lea    0x50(%eax),%esi
-8010050b:	e9 71 ff ff ff       	jmp    80100481 <consputc.part.0+0x71>
-    uartputc('\b'); uartputc(' '); uartputc('\b');
-80100510:	83 ec 0c             	sub    $0xc,%esp
-80100513:	6a 08                	push   $0x8
-80100515:	e8 66 63 00 00       	call   80106880 <uartputc>
-8010051a:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
-80100521:	e8 5a 63 00 00       	call   80106880 <uartputc>
-80100526:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
-8010052d:	e8 4e 63 00 00       	call   80106880 <uartputc>
-80100532:	83 c4 10             	add    $0x10,%esp
-80100535:	e9 f8 fe ff ff       	jmp    80100432 <consputc.part.0+0x22>
-8010053a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    memmove(crt, crt+80, sizeof(crt[0])*23*80);
-80100540:	83 ec 04             	sub    $0x4,%esp
-    pos -= 80;
-80100543:	8d 5e b0             	lea    -0x50(%esi),%ebx
-    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
-80100546:	8d b4 36 60 7f 0b 80 	lea    -0x7ff480a0(%esi,%esi,1),%esi
-8010054d:	bf 07 00 00 00       	mov    $0x7,%edi
-    memmove(crt, crt+80, sizeof(crt[0])*23*80);
-80100552:	68 60 0e 00 00       	push   $0xe60
-80100557:	68 a0 80 0b 80       	push   $0x800b80a0
-8010055c:	68 00 80 0b 80       	push   $0x800b8000
-80100561:	e8 0a 4a 00 00       	call   80104f70 <memmove>
-    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
-80100566:	b8 80 07 00 00       	mov    $0x780,%eax
-8010056b:	83 c4 0c             	add    $0xc,%esp
-8010056e:	29 d8                	sub    %ebx,%eax
-80100570:	01 c0                	add    %eax,%eax
-80100572:	50                   	push   %eax
-80100573:	6a 00                	push   $0x0
-80100575:	56                   	push   %esi
-80100576:	e8 55 49 00 00       	call   80104ed0 <memset>
-8010057b:	88 5d e7             	mov    %bl,-0x19(%ebp)
-8010057e:	83 c4 10             	add    $0x10,%esp
-80100581:	e9 22 ff ff ff       	jmp    801004a8 <consputc.part.0+0x98>
-    panic("pos under/overflow");
-80100586:	83 ec 0c             	sub    $0xc,%esp
-80100589:	68 c5 7c 10 80       	push   $0x80107cc5
-8010058e:	e8 fd fd ff ff       	call   80100390 <panic>
-80100593:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010059a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-801005a0 <printint>:
-{
-801005a0:	55                   	push   %ebp
-801005a1:	89 e5                	mov    %esp,%ebp
-801005a3:	57                   	push   %edi
-801005a4:	56                   	push   %esi
-801005a5:	53                   	push   %ebx
-801005a6:	83 ec 2c             	sub    $0x2c,%esp
-801005a9:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-  if(sign && (sign = xx < 0))
-801005ac:	85 c9                	test   %ecx,%ecx
-801005ae:	74 04                	je     801005b4 <printint+0x14>
-801005b0:	85 c0                	test   %eax,%eax
-801005b2:	78 6d                	js     80100621 <printint+0x81>
-    x = xx;
-801005b4:	89 c1                	mov    %eax,%ecx
-801005b6:	31 f6                	xor    %esi,%esi
-  i = 0;
-801005b8:	89 75 cc             	mov    %esi,-0x34(%ebp)
-801005bb:	31 db                	xor    %ebx,%ebx
-801005bd:	8d 7d d7             	lea    -0x29(%ebp),%edi
-    buf[i++] = digits[x % base];
-801005c0:	89 c8                	mov    %ecx,%eax
-801005c2:	31 d2                	xor    %edx,%edx
-801005c4:	89 ce                	mov    %ecx,%esi
-801005c6:	f7 75 d4             	divl   -0x2c(%ebp)
-801005c9:	0f b6 92 f0 7c 10 80 	movzbl -0x7fef8310(%edx),%edx
-801005d0:	89 45 d0             	mov    %eax,-0x30(%ebp)
-801005d3:	89 d8                	mov    %ebx,%eax
-801005d5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
-801005d8:	8b 4d d0             	mov    -0x30(%ebp),%ecx
-801005db:	89 75 d0             	mov    %esi,-0x30(%ebp)
-    buf[i++] = digits[x % base];
-801005de:	88 14 1f             	mov    %dl,(%edi,%ebx,1)
-  }while((x /= base) != 0);
-801005e1:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-801005e4:	39 75 d0             	cmp    %esi,-0x30(%ebp)
-801005e7:	73 d7                	jae    801005c0 <printint+0x20>
-801005e9:	8b 75 cc             	mov    -0x34(%ebp),%esi
-  if(sign)
-801005ec:	85 f6                	test   %esi,%esi
-801005ee:	74 0c                	je     801005fc <printint+0x5c>
-    buf[i++] = '-';
-801005f0:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
-801005f5:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
-801005f7:	ba 2d 00 00 00       	mov    $0x2d,%edx
-  while(--i >= 0)
-801005fc:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
-80100600:	0f be c2             	movsbl %dl,%eax
-  if(panicked){
-80100603:	8b 15 58 b5 10 80    	mov    0x8010b558,%edx
-80100609:	85 d2                	test   %edx,%edx
-8010060b:	74 03                	je     80100610 <printint+0x70>
-  asm volatile("cli");
-8010060d:	fa                   	cli    
-    for(;;)
-8010060e:	eb fe                	jmp    8010060e <printint+0x6e>
-80100610:	e8 fb fd ff ff       	call   80100410 <consputc.part.0>
-  while(--i >= 0)
-80100615:	39 fb                	cmp    %edi,%ebx
-80100617:	74 10                	je     80100629 <printint+0x89>
-80100619:	0f be 03             	movsbl (%ebx),%eax
-8010061c:	83 eb 01             	sub    $0x1,%ebx
-8010061f:	eb e2                	jmp    80100603 <printint+0x63>
-    x = -xx;
-80100621:	f7 d8                	neg    %eax
-80100623:	89 ce                	mov    %ecx,%esi
-80100625:	89 c1                	mov    %eax,%ecx
-80100627:	eb 8f                	jmp    801005b8 <printint+0x18>
-}
-80100629:	83 c4 2c             	add    $0x2c,%esp
-8010062c:	5b                   	pop    %ebx
-8010062d:	5e                   	pop    %esi
-8010062e:	5f                   	pop    %edi
-8010062f:	5d                   	pop    %ebp
-80100630:	c3                   	ret    
-80100631:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80100638:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010063f:	90                   	nop
-
-80100640 <consolewrite>:
-
-int
-consolewrite(struct inode *ip, char *buf, int n)
-{
-80100640:	f3 0f 1e fb          	endbr32 
-80100644:	55                   	push   %ebp
-80100645:	89 e5                	mov    %esp,%ebp
-80100647:	57                   	push   %edi
-80100648:	56                   	push   %esi
-80100649:	53                   	push   %ebx
-8010064a:	83 ec 18             	sub    $0x18,%esp
-  int i;
-
-  iunlock(ip);
-8010064d:	ff 75 08             	pushl  0x8(%ebp)
-{
-80100650:	8b 5d 10             	mov    0x10(%ebp),%ebx
-  iunlock(ip);
-80100653:	e8 e8 11 00 00       	call   80101840 <iunlock>
-  acquire(&cons.lock);
-80100658:	c7 04 24 20 b5 10 80 	movl   $0x8010b520,(%esp)
-8010065f:	e8 5c 47 00 00       	call   80104dc0 <acquire>
-  for(i = 0; i < n; i++)
-80100664:	83 c4 10             	add    $0x10,%esp
-80100667:	85 db                	test   %ebx,%ebx
-80100669:	7e 24                	jle    8010068f <consolewrite+0x4f>
-8010066b:	8b 7d 0c             	mov    0xc(%ebp),%edi
-8010066e:	8d 34 1f             	lea    (%edi,%ebx,1),%esi
-  if(panicked){
-80100671:	8b 15 58 b5 10 80    	mov    0x8010b558,%edx
-80100677:	85 d2                	test   %edx,%edx
-80100679:	74 05                	je     80100680 <consolewrite+0x40>
-8010067b:	fa                   	cli    
-    for(;;)
-8010067c:	eb fe                	jmp    8010067c <consolewrite+0x3c>
-8010067e:	66 90                	xchg   %ax,%ax
-    consputc(buf[i] & 0xff);
-80100680:	0f b6 07             	movzbl (%edi),%eax
-80100683:	83 c7 01             	add    $0x1,%edi
-80100686:	e8 85 fd ff ff       	call   80100410 <consputc.part.0>
-  for(i = 0; i < n; i++)
-8010068b:	39 fe                	cmp    %edi,%esi
-8010068d:	75 e2                	jne    80100671 <consolewrite+0x31>
-  release(&cons.lock);
-8010068f:	83 ec 0c             	sub    $0xc,%esp
-80100692:	68 20 b5 10 80       	push   $0x8010b520
-80100697:	e8 e4 47 00 00       	call   80104e80 <release>
-  ilock(ip);
-8010069c:	58                   	pop    %eax
-8010069d:	ff 75 08             	pushl  0x8(%ebp)
-801006a0:	e8 bb 10 00 00       	call   80101760 <ilock>
-
-  return n;
-}
-801006a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801006a8:	89 d8                	mov    %ebx,%eax
-801006aa:	5b                   	pop    %ebx
-801006ab:	5e                   	pop    %esi
-801006ac:	5f                   	pop    %edi
-801006ad:	5d                   	pop    %ebp
-801006ae:	c3                   	ret    
-801006af:	90                   	nop
-
-801006b0 <cprintf>:
-{
-801006b0:	f3 0f 1e fb          	endbr32 
-801006b4:	55                   	push   %ebp
-801006b5:	89 e5                	mov    %esp,%ebp
-801006b7:	57                   	push   %edi
-801006b8:	56                   	push   %esi
-801006b9:	53                   	push   %ebx
-801006ba:	83 ec 1c             	sub    $0x1c,%esp
-  locking = cons.locking;
-801006bd:	a1 54 b5 10 80       	mov    0x8010b554,%eax
-801006c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
-  if(locking)
-801006c5:	85 c0                	test   %eax,%eax
-801006c7:	0f 85 e8 00 00 00    	jne    801007b5 <cprintf+0x105>
-  if (fmt == 0)
-801006cd:	8b 45 08             	mov    0x8(%ebp),%eax
-801006d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-801006d3:	85 c0                	test   %eax,%eax
-801006d5:	0f 84 5a 01 00 00    	je     80100835 <cprintf+0x185>
-  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
-801006db:	0f b6 00             	movzbl (%eax),%eax
-801006de:	85 c0                	test   %eax,%eax
-801006e0:	74 36                	je     80100718 <cprintf+0x68>
-  argp = (uint*)(void*)(&fmt + 1);
-801006e2:	8d 5d 0c             	lea    0xc(%ebp),%ebx
-  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
-801006e5:	31 f6                	xor    %esi,%esi
-    if(c != '%'){
-801006e7:	83 f8 25             	cmp    $0x25,%eax
-801006ea:	74 44                	je     80100730 <cprintf+0x80>
-  if(panicked){
-801006ec:	8b 0d 58 b5 10 80    	mov    0x8010b558,%ecx
-801006f2:	85 c9                	test   %ecx,%ecx
-801006f4:	74 0f                	je     80100705 <cprintf+0x55>
-801006f6:	fa                   	cli    
-    for(;;)
-801006f7:	eb fe                	jmp    801006f7 <cprintf+0x47>
-801006f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80100700:	b8 25 00 00 00       	mov    $0x25,%eax
-80100705:	e8 06 fd ff ff       	call   80100410 <consputc.part.0>
-  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
-8010070a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-8010070d:	83 c6 01             	add    $0x1,%esi
-80100710:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
-80100714:	85 c0                	test   %eax,%eax
-80100716:	75 cf                	jne    801006e7 <cprintf+0x37>
-  if(locking)
-80100718:	8b 45 e0             	mov    -0x20(%ebp),%eax
-8010071b:	85 c0                	test   %eax,%eax
-8010071d:	0f 85 fd 00 00 00    	jne    80100820 <cprintf+0x170>
-}
-80100723:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80100726:	5b                   	pop    %ebx
-80100727:	5e                   	pop    %esi
-80100728:	5f                   	pop    %edi
-80100729:	5d                   	pop    %ebp
-8010072a:	c3                   	ret    
-8010072b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010072f:	90                   	nop
-    c = fmt[++i] & 0xff;
-80100730:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-80100733:	83 c6 01             	add    $0x1,%esi
-80100736:	0f b6 3c 30          	movzbl (%eax,%esi,1),%edi
-    if(c == 0)
-8010073a:	85 ff                	test   %edi,%edi
-8010073c:	74 da                	je     80100718 <cprintf+0x68>
-    switch(c){
-8010073e:	83 ff 70             	cmp    $0x70,%edi
-80100741:	74 5a                	je     8010079d <cprintf+0xed>
-80100743:	7f 2a                	jg     8010076f <cprintf+0xbf>
-80100745:	83 ff 25             	cmp    $0x25,%edi
-80100748:	0f 84 92 00 00 00    	je     801007e0 <cprintf+0x130>
-8010074e:	83 ff 64             	cmp    $0x64,%edi
-80100751:	0f 85 a1 00 00 00    	jne    801007f8 <cprintf+0x148>
-      printint(*argp++, 10, 1);
-80100757:	8b 03                	mov    (%ebx),%eax
-80100759:	8d 7b 04             	lea    0x4(%ebx),%edi
-8010075c:	b9 01 00 00 00       	mov    $0x1,%ecx
-80100761:	ba 0a 00 00 00       	mov    $0xa,%edx
-80100766:	89 fb                	mov    %edi,%ebx
-80100768:	e8 33 fe ff ff       	call   801005a0 <printint>
-      break;
-8010076d:	eb 9b                	jmp    8010070a <cprintf+0x5a>
-    switch(c){
-8010076f:	83 ff 73             	cmp    $0x73,%edi
-80100772:	75 24                	jne    80100798 <cprintf+0xe8>
-      if((s = (char*)*argp++) == 0)
-80100774:	8d 7b 04             	lea    0x4(%ebx),%edi
-80100777:	8b 1b                	mov    (%ebx),%ebx
-80100779:	85 db                	test   %ebx,%ebx
-8010077b:	75 55                	jne    801007d2 <cprintf+0x122>
-        s = "(null)";
-8010077d:	bb d8 7c 10 80       	mov    $0x80107cd8,%ebx
-      for(; *s; s++)
-80100782:	b8 28 00 00 00       	mov    $0x28,%eax
-  if(panicked){
-80100787:	8b 15 58 b5 10 80    	mov    0x8010b558,%edx
-8010078d:	85 d2                	test   %edx,%edx
-8010078f:	74 39                	je     801007ca <cprintf+0x11a>
-80100791:	fa                   	cli    
-    for(;;)
-80100792:	eb fe                	jmp    80100792 <cprintf+0xe2>
-80100794:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    switch(c){
-80100798:	83 ff 78             	cmp    $0x78,%edi
-8010079b:	75 5b                	jne    801007f8 <cprintf+0x148>
-      printint(*argp++, 16, 0);
-8010079d:	8b 03                	mov    (%ebx),%eax
-8010079f:	8d 7b 04             	lea    0x4(%ebx),%edi
-801007a2:	31 c9                	xor    %ecx,%ecx
-801007a4:	ba 10 00 00 00       	mov    $0x10,%edx
-801007a9:	89 fb                	mov    %edi,%ebx
-801007ab:	e8 f0 fd ff ff       	call   801005a0 <printint>
-      break;
-801007b0:	e9 55 ff ff ff       	jmp    8010070a <cprintf+0x5a>
-    acquire(&cons.lock);
-801007b5:	83 ec 0c             	sub    $0xc,%esp
-801007b8:	68 20 b5 10 80       	push   $0x8010b520
-801007bd:	e8 fe 45 00 00       	call   80104dc0 <acquire>
-801007c2:	83 c4 10             	add    $0x10,%esp
-801007c5:	e9 03 ff ff ff       	jmp    801006cd <cprintf+0x1d>
-801007ca:	e8 41 fc ff ff       	call   80100410 <consputc.part.0>
-      for(; *s; s++)
-801007cf:	83 c3 01             	add    $0x1,%ebx
-801007d2:	0f be 03             	movsbl (%ebx),%eax
-801007d5:	84 c0                	test   %al,%al
-801007d7:	75 ae                	jne    80100787 <cprintf+0xd7>
-      if((s = (char*)*argp++) == 0)
-801007d9:	89 fb                	mov    %edi,%ebx
-801007db:	e9 2a ff ff ff       	jmp    8010070a <cprintf+0x5a>
-  if(panicked){
-801007e0:	8b 3d 58 b5 10 80    	mov    0x8010b558,%edi
-801007e6:	85 ff                	test   %edi,%edi
-801007e8:	0f 84 12 ff ff ff    	je     80100700 <cprintf+0x50>
-801007ee:	fa                   	cli    
-    for(;;)
-801007ef:	eb fe                	jmp    801007ef <cprintf+0x13f>
-801007f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  if(panicked){
-801007f8:	8b 0d 58 b5 10 80    	mov    0x8010b558,%ecx
-801007fe:	85 c9                	test   %ecx,%ecx
-80100800:	74 06                	je     80100808 <cprintf+0x158>
-80100802:	fa                   	cli    
-    for(;;)
-80100803:	eb fe                	jmp    80100803 <cprintf+0x153>
-80100805:	8d 76 00             	lea    0x0(%esi),%esi
-80100808:	b8 25 00 00 00       	mov    $0x25,%eax
-8010080d:	e8 fe fb ff ff       	call   80100410 <consputc.part.0>
-  if(panicked){
-80100812:	8b 15 58 b5 10 80    	mov    0x8010b558,%edx
-80100818:	85 d2                	test   %edx,%edx
-8010081a:	74 2c                	je     80100848 <cprintf+0x198>
-8010081c:	fa                   	cli    
-    for(;;)
-8010081d:	eb fe                	jmp    8010081d <cprintf+0x16d>
-8010081f:	90                   	nop
-    release(&cons.lock);
-80100820:	83 ec 0c             	sub    $0xc,%esp
-80100823:	68 20 b5 10 80       	push   $0x8010b520
-80100828:	e8 53 46 00 00       	call   80104e80 <release>
-8010082d:	83 c4 10             	add    $0x10,%esp
-}
-80100830:	e9 ee fe ff ff       	jmp    80100723 <cprintf+0x73>
-    panic("null fmt");
-80100835:	83 ec 0c             	sub    $0xc,%esp
-80100838:	68 df 7c 10 80       	push   $0x80107cdf
-8010083d:	e8 4e fb ff ff       	call   80100390 <panic>
-80100842:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-80100848:	89 f8                	mov    %edi,%eax
-8010084a:	e8 c1 fb ff ff       	call   80100410 <consputc.part.0>
-8010084f:	e9 b6 fe ff ff       	jmp    8010070a <cprintf+0x5a>
-80100854:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010085b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010085f:	90                   	nop
-
-80100860 <consoleintr>:
-{
-80100860:	f3 0f 1e fb          	endbr32 
-80100864:	55                   	push   %ebp
-80100865:	89 e5                	mov    %esp,%ebp
-80100867:	57                   	push   %edi
-80100868:	56                   	push   %esi
-  int c, doprocdump = 0;
-80100869:	31 f6                	xor    %esi,%esi
-{
-8010086b:	53                   	push   %ebx
-8010086c:	83 ec 18             	sub    $0x18,%esp
-8010086f:	8b 7d 08             	mov    0x8(%ebp),%edi
-  acquire(&cons.lock);
-80100872:	68 20 b5 10 80       	push   $0x8010b520
-80100877:	e8 44 45 00 00       	call   80104dc0 <acquire>
-  while((c = getc()) >= 0){
-8010087c:	83 c4 10             	add    $0x10,%esp
-8010087f:	eb 17                	jmp    80100898 <consoleintr+0x38>
-    switch(c){
-80100881:	83 fb 08             	cmp    $0x8,%ebx
-80100884:	0f 84 f6 00 00 00    	je     80100980 <consoleintr+0x120>
-8010088a:	83 fb 10             	cmp    $0x10,%ebx
-8010088d:	0f 85 15 01 00 00    	jne    801009a8 <consoleintr+0x148>
-80100893:	be 01 00 00 00       	mov    $0x1,%esi
-  while((c = getc()) >= 0){
-80100898:	ff d7                	call   *%edi
-8010089a:	89 c3                	mov    %eax,%ebx
-8010089c:	85 c0                	test   %eax,%eax
-8010089e:	0f 88 23 01 00 00    	js     801009c7 <consoleintr+0x167>
-    switch(c){
-801008a4:	83 fb 15             	cmp    $0x15,%ebx
-801008a7:	74 77                	je     80100920 <consoleintr+0xc0>
-801008a9:	7e d6                	jle    80100881 <consoleintr+0x21>
-801008ab:	83 fb 7f             	cmp    $0x7f,%ebx
-801008ae:	0f 84 cc 00 00 00    	je     80100980 <consoleintr+0x120>
-      if(c != 0 && input.e-input.r < INPUT_BUF){
-801008b4:	a1 c8 0f 11 80       	mov    0x80110fc8,%eax
-801008b9:	89 c2                	mov    %eax,%edx
-801008bb:	2b 15 c0 0f 11 80    	sub    0x80110fc0,%edx
-801008c1:	83 fa 7f             	cmp    $0x7f,%edx
-801008c4:	77 d2                	ja     80100898 <consoleintr+0x38>
-        c = (c == '\r') ? '\n' : c;
-801008c6:	8d 48 01             	lea    0x1(%eax),%ecx
-801008c9:	8b 15 58 b5 10 80    	mov    0x8010b558,%edx
-801008cf:	83 e0 7f             	and    $0x7f,%eax
-        input.buf[input.e++ % INPUT_BUF] = c;
-801008d2:	89 0d c8 0f 11 80    	mov    %ecx,0x80110fc8
-        c = (c == '\r') ? '\n' : c;
-801008d8:	83 fb 0d             	cmp    $0xd,%ebx
-801008db:	0f 84 02 01 00 00    	je     801009e3 <consoleintr+0x183>
-        input.buf[input.e++ % INPUT_BUF] = c;
-801008e1:	88 98 40 0f 11 80    	mov    %bl,-0x7feef0c0(%eax)
-  if(panicked){
-801008e7:	85 d2                	test   %edx,%edx
-801008e9:	0f 85 ff 00 00 00    	jne    801009ee <consoleintr+0x18e>
-801008ef:	89 d8                	mov    %ebx,%eax
-801008f1:	e8 1a fb ff ff       	call   80100410 <consputc.part.0>
-        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
-801008f6:	83 fb 0a             	cmp    $0xa,%ebx
-801008f9:	0f 84 0f 01 00 00    	je     80100a0e <consoleintr+0x1ae>
-801008ff:	83 fb 04             	cmp    $0x4,%ebx
-80100902:	0f 84 06 01 00 00    	je     80100a0e <consoleintr+0x1ae>
-80100908:	a1 c0 0f 11 80       	mov    0x80110fc0,%eax
-8010090d:	83 e8 80             	sub    $0xffffff80,%eax
-80100910:	39 05 c8 0f 11 80    	cmp    %eax,0x80110fc8
-80100916:	75 80                	jne    80100898 <consoleintr+0x38>
-80100918:	e9 f6 00 00 00       	jmp    80100a13 <consoleintr+0x1b3>
-8010091d:	8d 76 00             	lea    0x0(%esi),%esi
-      while(input.e != input.w &&
-80100920:	a1 c8 0f 11 80       	mov    0x80110fc8,%eax
-80100925:	39 05 c4 0f 11 80    	cmp    %eax,0x80110fc4
-8010092b:	0f 84 67 ff ff ff    	je     80100898 <consoleintr+0x38>
-            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
-80100931:	83 e8 01             	sub    $0x1,%eax
-80100934:	89 c2                	mov    %eax,%edx
-80100936:	83 e2 7f             	and    $0x7f,%edx
-      while(input.e != input.w &&
-80100939:	80 ba 40 0f 11 80 0a 	cmpb   $0xa,-0x7feef0c0(%edx)
-80100940:	0f 84 52 ff ff ff    	je     80100898 <consoleintr+0x38>
-  if(panicked){
-80100946:	8b 15 58 b5 10 80    	mov    0x8010b558,%edx
-        input.e--;
-8010094c:	a3 c8 0f 11 80       	mov    %eax,0x80110fc8
-  if(panicked){
-80100951:	85 d2                	test   %edx,%edx
-80100953:	74 0b                	je     80100960 <consoleintr+0x100>
-80100955:	fa                   	cli    
-    for(;;)
-80100956:	eb fe                	jmp    80100956 <consoleintr+0xf6>
-80100958:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010095f:	90                   	nop
-80100960:	b8 00 01 00 00       	mov    $0x100,%eax
-80100965:	e8 a6 fa ff ff       	call   80100410 <consputc.part.0>
-      while(input.e != input.w &&
-8010096a:	a1 c8 0f 11 80       	mov    0x80110fc8,%eax
-8010096f:	3b 05 c4 0f 11 80    	cmp    0x80110fc4,%eax
-80100975:	75 ba                	jne    80100931 <consoleintr+0xd1>
-80100977:	e9 1c ff ff ff       	jmp    80100898 <consoleintr+0x38>
-8010097c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-      if(input.e != input.w){
-80100980:	a1 c8 0f 11 80       	mov    0x80110fc8,%eax
-80100985:	3b 05 c4 0f 11 80    	cmp    0x80110fc4,%eax
-8010098b:	0f 84 07 ff ff ff    	je     80100898 <consoleintr+0x38>
-        input.e--;
-80100991:	83 e8 01             	sub    $0x1,%eax
-80100994:	a3 c8 0f 11 80       	mov    %eax,0x80110fc8
-  if(panicked){
-80100999:	a1 58 b5 10 80       	mov    0x8010b558,%eax
-8010099e:	85 c0                	test   %eax,%eax
-801009a0:	74 16                	je     801009b8 <consoleintr+0x158>
-801009a2:	fa                   	cli    
-    for(;;)
-801009a3:	eb fe                	jmp    801009a3 <consoleintr+0x143>
-801009a5:	8d 76 00             	lea    0x0(%esi),%esi
-      if(c != 0 && input.e-input.r < INPUT_BUF){
-801009a8:	85 db                	test   %ebx,%ebx
-801009aa:	0f 84 e8 fe ff ff    	je     80100898 <consoleintr+0x38>
-801009b0:	e9 ff fe ff ff       	jmp    801008b4 <consoleintr+0x54>
-801009b5:	8d 76 00             	lea    0x0(%esi),%esi
-801009b8:	b8 00 01 00 00       	mov    $0x100,%eax
-801009bd:	e8 4e fa ff ff       	call   80100410 <consputc.part.0>
-801009c2:	e9 d1 fe ff ff       	jmp    80100898 <consoleintr+0x38>
-  release(&cons.lock);
-801009c7:	83 ec 0c             	sub    $0xc,%esp
-801009ca:	68 20 b5 10 80       	push   $0x8010b520
-801009cf:	e8 ac 44 00 00       	call   80104e80 <release>
-  if(doprocdump) {
-801009d4:	83 c4 10             	add    $0x10,%esp
-801009d7:	85 f6                	test   %esi,%esi
-801009d9:	75 1d                	jne    801009f8 <consoleintr+0x198>
-}
-801009db:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801009de:	5b                   	pop    %ebx
-801009df:	5e                   	pop    %esi
-801009e0:	5f                   	pop    %edi
-801009e1:	5d                   	pop    %ebp
-801009e2:	c3                   	ret    
-        input.buf[input.e++ % INPUT_BUF] = c;
-801009e3:	c6 80 40 0f 11 80 0a 	movb   $0xa,-0x7feef0c0(%eax)
-  if(panicked){
-801009ea:	85 d2                	test   %edx,%edx
-801009ec:	74 16                	je     80100a04 <consoleintr+0x1a4>
-801009ee:	fa                   	cli    
-    for(;;)
-801009ef:	eb fe                	jmp    801009ef <consoleintr+0x18f>
-801009f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-}
-801009f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801009fb:	5b                   	pop    %ebx
-801009fc:	5e                   	pop    %esi
-801009fd:	5f                   	pop    %edi
-801009fe:	5d                   	pop    %ebp
-    procdump();  // now call procdump() wo. cons.lock held
-801009ff:	e9 bc 3b 00 00       	jmp    801045c0 <procdump>
-80100a04:	b8 0a 00 00 00       	mov    $0xa,%eax
-80100a09:	e8 02 fa ff ff       	call   80100410 <consputc.part.0>
-        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
-80100a0e:	a1 c8 0f 11 80       	mov    0x80110fc8,%eax
-          wakeup(&input.r);
-80100a13:	83 ec 0c             	sub    $0xc,%esp
-          input.w = input.e;
-80100a16:	a3 c4 0f 11 80       	mov    %eax,0x80110fc4
-          wakeup(&input.r);
-80100a1b:	68 c0 0f 11 80       	push   $0x80110fc0
-80100a20:	e8 9b 3a 00 00       	call   801044c0 <wakeup>
-80100a25:	83 c4 10             	add    $0x10,%esp
-80100a28:	e9 6b fe ff ff       	jmp    80100898 <consoleintr+0x38>
-80100a2d:	8d 76 00             	lea    0x0(%esi),%esi
-
-80100a30 <consoleinit>:
-
-void
-consoleinit(void)
-{
-80100a30:	f3 0f 1e fb          	endbr32 
-80100a34:	55                   	push   %ebp
-80100a35:	89 e5                	mov    %esp,%ebp
-80100a37:	83 ec 10             	sub    $0x10,%esp
-  initlock(&cons.lock, "console");
-80100a3a:	68 e8 7c 10 80       	push   $0x80107ce8
-80100a3f:	68 20 b5 10 80       	push   $0x8010b520
-80100a44:	e8 f7 41 00 00       	call   80104c40 <initlock>
-
-  devsw[CONSOLE].write = consolewrite;
-  devsw[CONSOLE].read = consoleread;
-  cons.locking = 1;
-
-  ioapicenable(IRQ_KBD, 0);
-80100a49:	58                   	pop    %eax
-80100a4a:	5a                   	pop    %edx
-80100a4b:	6a 00                	push   $0x0
-80100a4d:	6a 01                	push   $0x1
-  devsw[CONSOLE].write = consolewrite;
-80100a4f:	c7 05 8c 19 11 80 40 	movl   $0x80100640,0x8011198c
-80100a56:	06 10 80 
-  devsw[CONSOLE].read = consoleread;
-80100a59:	c7 05 88 19 11 80 90 	movl   $0x80100290,0x80111988
-80100a60:	02 10 80 
-  cons.locking = 1;
-80100a63:	c7 05 54 b5 10 80 01 	movl   $0x1,0x8010b554
-80100a6a:	00 00 00 
-  ioapicenable(IRQ_KBD, 0);
-80100a6d:	e8 be 19 00 00       	call   80102430 <ioapicenable>
-}
-80100a72:	83 c4 10             	add    $0x10,%esp
-80100a75:	c9                   	leave  
-80100a76:	c3                   	ret    
-80100a77:	66 90                	xchg   %ax,%ax
-80100a79:	66 90                	xchg   %ax,%ax
-80100a7b:	66 90                	xchg   %ax,%ax
-80100a7d:	66 90                	xchg   %ax,%ax
-80100a7f:	90                   	nop
-
-80100a80 <exec>:
-#include "x86.h"
-#include "elf.h"
-
-int
-exec(char *path, char **argv)
-{
-80100a80:	f3 0f 1e fb          	endbr32 
-80100a84:	55                   	push   %ebp
-80100a85:	89 e5                	mov    %esp,%ebp
-80100a87:	57                   	push   %edi
-80100a88:	56                   	push   %esi
-80100a89:	53                   	push   %ebx
-80100a8a:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
-  uint argc, sz, sp, ustack[3+MAXARG+1];
-  struct elfhdr elf;
-  struct inode *ip;
-  struct proghdr ph;
-  pde_t *pgdir, *oldpgdir;
-  struct proc *curproc = myproc();
-80100a90:	e8 1b 2f 00 00       	call   801039b0 <myproc>
-80100a95:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
-
-  begin_op();
-80100a9b:	e8 90 22 00 00       	call   80102d30 <begin_op>
-
-  if((ip = namei(path)) == 0){
-80100aa0:	83 ec 0c             	sub    $0xc,%esp
-80100aa3:	ff 75 08             	pushl  0x8(%ebp)
-80100aa6:	e8 85 15 00 00       	call   80102030 <namei>
-80100aab:	83 c4 10             	add    $0x10,%esp
-80100aae:	85 c0                	test   %eax,%eax
-80100ab0:	0f 84 fe 02 00 00    	je     80100db4 <exec+0x334>
-    end_op();
-    cprintf("exec: fail\n");
-    return -1;
-  }
-  ilock(ip);
-80100ab6:	83 ec 0c             	sub    $0xc,%esp
-80100ab9:	89 c3                	mov    %eax,%ebx
-80100abb:	50                   	push   %eax
-80100abc:	e8 9f 0c 00 00       	call   80101760 <ilock>
-  pgdir = 0;
-
-  // Check ELF header
-  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
-80100ac1:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
-80100ac7:	6a 34                	push   $0x34
-80100ac9:	6a 00                	push   $0x0
-80100acb:	50                   	push   %eax
-80100acc:	53                   	push   %ebx
-80100acd:	e8 8e 0f 00 00       	call   80101a60 <readi>
-80100ad2:	83 c4 20             	add    $0x20,%esp
-80100ad5:	83 f8 34             	cmp    $0x34,%eax
-80100ad8:	74 26                	je     80100b00 <exec+0x80>
-
- bad:
-  if(pgdir)
-    freevm(pgdir);
-  if(ip){
-    iunlockput(ip);
-80100ada:	83 ec 0c             	sub    $0xc,%esp
-80100add:	53                   	push   %ebx
-80100ade:	e8 1d 0f 00 00       	call   80101a00 <iunlockput>
-    end_op();
-80100ae3:	e8 b8 22 00 00       	call   80102da0 <end_op>
-80100ae8:	83 c4 10             	add    $0x10,%esp
-  }
-  return -1;
-80100aeb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80100af0:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80100af3:	5b                   	pop    %ebx
-80100af4:	5e                   	pop    %esi
-80100af5:	5f                   	pop    %edi
-80100af6:	5d                   	pop    %ebp
-80100af7:	c3                   	ret    
-80100af8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80100aff:	90                   	nop
-  if(elf.magic != ELF_MAGIC)
-80100b00:	81 bd 24 ff ff ff 7f 	cmpl   $0x464c457f,-0xdc(%ebp)
-80100b07:	45 4c 46 
-80100b0a:	75 ce                	jne    80100ada <exec+0x5a>
-  if((pgdir = setupkvm()) == 0)
-80100b0c:	e8 df 6e 00 00       	call   801079f0 <setupkvm>
-80100b11:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
-80100b17:	85 c0                	test   %eax,%eax
-80100b19:	74 bf                	je     80100ada <exec+0x5a>
-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
-80100b1b:	66 83 bd 50 ff ff ff 	cmpw   $0x0,-0xb0(%ebp)
-80100b22:	00 
-80100b23:	8b b5 40 ff ff ff    	mov    -0xc0(%ebp),%esi
-80100b29:	0f 84 a4 02 00 00    	je     80100dd3 <exec+0x353>
-  sz = 0;
-80100b2f:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
-80100b36:	00 00 00 
-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
-80100b39:	31 ff                	xor    %edi,%edi
-80100b3b:	e9 86 00 00 00       	jmp    80100bc6 <exec+0x146>
-    if(ph.type != ELF_PROG_LOAD)
-80100b40:	83 bd 04 ff ff ff 01 	cmpl   $0x1,-0xfc(%ebp)
-80100b47:	75 6c                	jne    80100bb5 <exec+0x135>
-    if(ph.memsz < ph.filesz)
-80100b49:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
-80100b4f:	3b 85 14 ff ff ff    	cmp    -0xec(%ebp),%eax
-80100b55:	0f 82 87 00 00 00    	jb     80100be2 <exec+0x162>
-    if(ph.vaddr + ph.memsz < ph.vaddr)
-80100b5b:	03 85 0c ff ff ff    	add    -0xf4(%ebp),%eax
-80100b61:	72 7f                	jb     80100be2 <exec+0x162>
-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
-80100b63:	83 ec 04             	sub    $0x4,%esp
-80100b66:	50                   	push   %eax
-80100b67:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
-80100b6d:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
-80100b73:	e8 98 6c 00 00       	call   80107810 <allocuvm>
-80100b78:	83 c4 10             	add    $0x10,%esp
-80100b7b:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
-80100b81:	85 c0                	test   %eax,%eax
-80100b83:	74 5d                	je     80100be2 <exec+0x162>
-    if(ph.vaddr % PGSIZE != 0)
-80100b85:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
-80100b8b:	a9 ff 0f 00 00       	test   $0xfff,%eax
-80100b90:	75 50                	jne    80100be2 <exec+0x162>
-    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
-80100b92:	83 ec 0c             	sub    $0xc,%esp
-80100b95:	ff b5 14 ff ff ff    	pushl  -0xec(%ebp)
-80100b9b:	ff b5 08 ff ff ff    	pushl  -0xf8(%ebp)
-80100ba1:	53                   	push   %ebx
-80100ba2:	50                   	push   %eax
-80100ba3:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
-80100ba9:	e8 92 6b 00 00       	call   80107740 <loaduvm>
-80100bae:	83 c4 20             	add    $0x20,%esp
-80100bb1:	85 c0                	test   %eax,%eax
-80100bb3:	78 2d                	js     80100be2 <exec+0x162>
-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
-80100bb5:	0f b7 85 50 ff ff ff 	movzwl -0xb0(%ebp),%eax
-80100bbc:	83 c7 01             	add    $0x1,%edi
-80100bbf:	83 c6 20             	add    $0x20,%esi
-80100bc2:	39 f8                	cmp    %edi,%eax
-80100bc4:	7e 3a                	jle    80100c00 <exec+0x180>
-    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
-80100bc6:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
-80100bcc:	6a 20                	push   $0x20
-80100bce:	56                   	push   %esi
-80100bcf:	50                   	push   %eax
-80100bd0:	53                   	push   %ebx
-80100bd1:	e8 8a 0e 00 00       	call   80101a60 <readi>
-80100bd6:	83 c4 10             	add    $0x10,%esp
-80100bd9:	83 f8 20             	cmp    $0x20,%eax
-80100bdc:	0f 84 5e ff ff ff    	je     80100b40 <exec+0xc0>
-    freevm(pgdir);
-80100be2:	83 ec 0c             	sub    $0xc,%esp
-80100be5:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
-80100beb:	e8 80 6d 00 00       	call   80107970 <freevm>
-  if(ip){
-80100bf0:	83 c4 10             	add    $0x10,%esp
-80100bf3:	e9 e2 fe ff ff       	jmp    80100ada <exec+0x5a>
-80100bf8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80100bff:	90                   	nop
-80100c00:	8b bd f0 fe ff ff    	mov    -0x110(%ebp),%edi
-80100c06:	81 c7 ff 0f 00 00    	add    $0xfff,%edi
-80100c0c:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
-80100c12:	8d b7 00 20 00 00    	lea    0x2000(%edi),%esi
-  iunlockput(ip);
-80100c18:	83 ec 0c             	sub    $0xc,%esp
-80100c1b:	53                   	push   %ebx
-80100c1c:	e8 df 0d 00 00       	call   80101a00 <iunlockput>
-  end_op();
-80100c21:	e8 7a 21 00 00       	call   80102da0 <end_op>
-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
-80100c26:	83 c4 0c             	add    $0xc,%esp
-80100c29:	56                   	push   %esi
-80100c2a:	57                   	push   %edi
-80100c2b:	8b bd f4 fe ff ff    	mov    -0x10c(%ebp),%edi
-80100c31:	57                   	push   %edi
-80100c32:	e8 d9 6b 00 00       	call   80107810 <allocuvm>
-80100c37:	83 c4 10             	add    $0x10,%esp
-80100c3a:	89 c6                	mov    %eax,%esi
-80100c3c:	85 c0                	test   %eax,%eax
-80100c3e:	0f 84 94 00 00 00    	je     80100cd8 <exec+0x258>
-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
-80100c44:	83 ec 08             	sub    $0x8,%esp
-80100c47:	8d 80 00 e0 ff ff    	lea    -0x2000(%eax),%eax
-  for(argc = 0; argv[argc]; argc++) {
-80100c4d:	89 f3                	mov    %esi,%ebx
-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
-80100c4f:	50                   	push   %eax
-80100c50:	57                   	push   %edi
-  for(argc = 0; argv[argc]; argc++) {
-80100c51:	31 ff                	xor    %edi,%edi
-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
-80100c53:	e8 38 6e 00 00       	call   80107a90 <clearpteu>
-  for(argc = 0; argv[argc]; argc++) {
-80100c58:	8b 45 0c             	mov    0xc(%ebp),%eax
-80100c5b:	83 c4 10             	add    $0x10,%esp
-80100c5e:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
-80100c64:	8b 00                	mov    (%eax),%eax
-80100c66:	85 c0                	test   %eax,%eax
-80100c68:	0f 84 8b 00 00 00    	je     80100cf9 <exec+0x279>
-80100c6e:	89 b5 f0 fe ff ff    	mov    %esi,-0x110(%ebp)
-80100c74:	8b b5 f4 fe ff ff    	mov    -0x10c(%ebp),%esi
-80100c7a:	eb 23                	jmp    80100c9f <exec+0x21f>
-80100c7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80100c80:	8b 45 0c             	mov    0xc(%ebp),%eax
-    ustack[3+argc] = sp;
-80100c83:	89 9c bd 64 ff ff ff 	mov    %ebx,-0x9c(%ebp,%edi,4)
-  for(argc = 0; argv[argc]; argc++) {
-80100c8a:	83 c7 01             	add    $0x1,%edi
-    ustack[3+argc] = sp;
-80100c8d:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
-  for(argc = 0; argv[argc]; argc++) {
-80100c93:	8b 04 b8             	mov    (%eax,%edi,4),%eax
-80100c96:	85 c0                	test   %eax,%eax
-80100c98:	74 59                	je     80100cf3 <exec+0x273>
-    if(argc >= MAXARG)
-80100c9a:	83 ff 20             	cmp    $0x20,%edi
-80100c9d:	74 39                	je     80100cd8 <exec+0x258>
-    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
-80100c9f:	83 ec 0c             	sub    $0xc,%esp
-80100ca2:	50                   	push   %eax
-80100ca3:	e8 28 44 00 00       	call   801050d0 <strlen>
-80100ca8:	f7 d0                	not    %eax
-80100caa:	01 c3                	add    %eax,%ebx
-    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
-80100cac:	58                   	pop    %eax
-80100cad:	8b 45 0c             	mov    0xc(%ebp),%eax
-    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
-80100cb0:	83 e3 fc             	and    $0xfffffffc,%ebx
-    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
-80100cb3:	ff 34 b8             	pushl  (%eax,%edi,4)
-80100cb6:	e8 15 44 00 00       	call   801050d0 <strlen>
-80100cbb:	83 c0 01             	add    $0x1,%eax
-80100cbe:	50                   	push   %eax
-80100cbf:	8b 45 0c             	mov    0xc(%ebp),%eax
-80100cc2:	ff 34 b8             	pushl  (%eax,%edi,4)
-80100cc5:	53                   	push   %ebx
-80100cc6:	56                   	push   %esi
-80100cc7:	e8 24 6f 00 00       	call   80107bf0 <copyout>
-80100ccc:	83 c4 20             	add    $0x20,%esp
-80100ccf:	85 c0                	test   %eax,%eax
-80100cd1:	79 ad                	jns    80100c80 <exec+0x200>
-80100cd3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80100cd7:	90                   	nop
-    freevm(pgdir);
-80100cd8:	83 ec 0c             	sub    $0xc,%esp
-80100cdb:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
-80100ce1:	e8 8a 6c 00 00       	call   80107970 <freevm>
-80100ce6:	83 c4 10             	add    $0x10,%esp
-  return -1;
-80100ce9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80100cee:	e9 fd fd ff ff       	jmp    80100af0 <exec+0x70>
-80100cf3:	8b b5 f0 fe ff ff    	mov    -0x110(%ebp),%esi
-  ustack[2] = sp - (argc+1)*4;  // argv pointer
-80100cf9:	8d 04 bd 04 00 00 00 	lea    0x4(,%edi,4),%eax
-80100d00:	89 d9                	mov    %ebx,%ecx
-  ustack[3+argc] = 0;
-80100d02:	c7 84 bd 64 ff ff ff 	movl   $0x0,-0x9c(%ebp,%edi,4)
-80100d09:	00 00 00 00 
-  ustack[2] = sp - (argc+1)*4;  // argv pointer
-80100d0d:	29 c1                	sub    %eax,%ecx
-  sp -= (3+argc+1) * 4;
-80100d0f:	83 c0 0c             	add    $0xc,%eax
-  ustack[1] = argc;
-80100d12:	89 bd 5c ff ff ff    	mov    %edi,-0xa4(%ebp)
-  sp -= (3+argc+1) * 4;
-80100d18:	29 c3                	sub    %eax,%ebx
-  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
-80100d1a:	50                   	push   %eax
-80100d1b:	52                   	push   %edx
-80100d1c:	53                   	push   %ebx
-80100d1d:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
-  ustack[0] = 0xffffffff;  // fake return PC
-80100d23:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
-80100d2a:	ff ff ff 
-  ustack[2] = sp - (argc+1)*4;  // argv pointer
-80100d2d:	89 8d 60 ff ff ff    	mov    %ecx,-0xa0(%ebp)
-  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
-80100d33:	e8 b8 6e 00 00       	call   80107bf0 <copyout>
-80100d38:	83 c4 10             	add    $0x10,%esp
-80100d3b:	85 c0                	test   %eax,%eax
-80100d3d:	78 99                	js     80100cd8 <exec+0x258>
-  for(last=s=path; *s; s++)
-80100d3f:	8b 45 08             	mov    0x8(%ebp),%eax
-80100d42:	8b 55 08             	mov    0x8(%ebp),%edx
-80100d45:	0f b6 00             	movzbl (%eax),%eax
-80100d48:	84 c0                	test   %al,%al
-80100d4a:	74 13                	je     80100d5f <exec+0x2df>
-80100d4c:	89 d1                	mov    %edx,%ecx
-80100d4e:	66 90                	xchg   %ax,%ax
-    if(*s == '/')
-80100d50:	83 c1 01             	add    $0x1,%ecx
-80100d53:	3c 2f                	cmp    $0x2f,%al
-  for(last=s=path; *s; s++)
-80100d55:	0f b6 01             	movzbl (%ecx),%eax
-    if(*s == '/')
-80100d58:	0f 44 d1             	cmove  %ecx,%edx
-  for(last=s=path; *s; s++)
-80100d5b:	84 c0                	test   %al,%al
-80100d5d:	75 f1                	jne    80100d50 <exec+0x2d0>
-  safestrcpy(curproc->name, last, sizeof(curproc->name));
-80100d5f:	8b bd ec fe ff ff    	mov    -0x114(%ebp),%edi
-80100d65:	83 ec 04             	sub    $0x4,%esp
-80100d68:	6a 10                	push   $0x10
-80100d6a:	89 f8                	mov    %edi,%eax
-80100d6c:	52                   	push   %edx
-80100d6d:	83 c0 6c             	add    $0x6c,%eax
-80100d70:	50                   	push   %eax
-80100d71:	e8 1a 43 00 00       	call   80105090 <safestrcpy>
-  curproc->pgdir = pgdir;
-80100d76:	8b 8d f4 fe ff ff    	mov    -0x10c(%ebp),%ecx
-  oldpgdir = curproc->pgdir;
-80100d7c:	89 f8                	mov    %edi,%eax
-80100d7e:	8b 7f 04             	mov    0x4(%edi),%edi
-  curproc->sz = sz;
-80100d81:	89 30                	mov    %esi,(%eax)
-  curproc->pgdir = pgdir;
-80100d83:	89 48 04             	mov    %ecx,0x4(%eax)
-  curproc->tf->eip = elf.entry;  // main
-80100d86:	89 c1                	mov    %eax,%ecx
-80100d88:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
-80100d8e:	8b 40 18             	mov    0x18(%eax),%eax
-80100d91:	89 50 38             	mov    %edx,0x38(%eax)
-  curproc->tf->esp = sp;
-80100d94:	8b 41 18             	mov    0x18(%ecx),%eax
-80100d97:	89 58 44             	mov    %ebx,0x44(%eax)
-  switchuvm(curproc);
-80100d9a:	89 0c 24             	mov    %ecx,(%esp)
-80100d9d:	e8 0e 68 00 00       	call   801075b0 <switchuvm>
-  freevm(oldpgdir);
-80100da2:	89 3c 24             	mov    %edi,(%esp)
-80100da5:	e8 c6 6b 00 00       	call   80107970 <freevm>
-  return 0;
-80100daa:	83 c4 10             	add    $0x10,%esp
-80100dad:	31 c0                	xor    %eax,%eax
-80100daf:	e9 3c fd ff ff       	jmp    80100af0 <exec+0x70>
-    end_op();
-80100db4:	e8 e7 1f 00 00       	call   80102da0 <end_op>
-    cprintf("exec: fail\n");
-80100db9:	83 ec 0c             	sub    $0xc,%esp
-80100dbc:	68 01 7d 10 80       	push   $0x80107d01
-80100dc1:	e8 ea f8 ff ff       	call   801006b0 <cprintf>
-    return -1;
-80100dc6:	83 c4 10             	add    $0x10,%esp
-80100dc9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80100dce:	e9 1d fd ff ff       	jmp    80100af0 <exec+0x70>
-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
-80100dd3:	31 ff                	xor    %edi,%edi
-80100dd5:	be 00 20 00 00       	mov    $0x2000,%esi
-80100dda:	e9 39 fe ff ff       	jmp    80100c18 <exec+0x198>
-80100ddf:	90                   	nop
-
-80100de0 <fileinit>:
-  struct file file[NFILE];
-} ftable;
-
-void
-fileinit(void)
-{
-80100de0:	f3 0f 1e fb          	endbr32 
-80100de4:	55                   	push   %ebp
-80100de5:	89 e5                	mov    %esp,%ebp
-80100de7:	83 ec 10             	sub    $0x10,%esp
-  initlock(&ftable.lock, "ftable");
-80100dea:	68 0d 7d 10 80       	push   $0x80107d0d
-80100def:	68 e0 0f 11 80       	push   $0x80110fe0
-80100df4:	e8 47 3e 00 00       	call   80104c40 <initlock>
-}
-80100df9:	83 c4 10             	add    $0x10,%esp
-80100dfc:	c9                   	leave  
-80100dfd:	c3                   	ret    
-80100dfe:	66 90                	xchg   %ax,%ax
-
-80100e00 <filealloc>:
-
-// Allocate a file structure.
-struct file*
-filealloc(void)
-{
-80100e00:	f3 0f 1e fb          	endbr32 
-80100e04:	55                   	push   %ebp
-80100e05:	89 e5                	mov    %esp,%ebp
-80100e07:	53                   	push   %ebx
-  struct file *f;
-
-  acquire(&ftable.lock);
-  for(f = ftable.file; f < ftable.file + NFILE; f++){
-80100e08:	bb 14 10 11 80       	mov    $0x80111014,%ebx
-{
-80100e0d:	83 ec 10             	sub    $0x10,%esp
-  acquire(&ftable.lock);
-80100e10:	68 e0 0f 11 80       	push   $0x80110fe0
-80100e15:	e8 a6 3f 00 00       	call   80104dc0 <acquire>
-80100e1a:	83 c4 10             	add    $0x10,%esp
-80100e1d:	eb 0c                	jmp    80100e2b <filealloc+0x2b>
-80100e1f:	90                   	nop
-  for(f = ftable.file; f < ftable.file + NFILE; f++){
-80100e20:	83 c3 18             	add    $0x18,%ebx
-80100e23:	81 fb 74 19 11 80    	cmp    $0x80111974,%ebx
-80100e29:	74 25                	je     80100e50 <filealloc+0x50>
-    if(f->ref == 0){
-80100e2b:	8b 43 04             	mov    0x4(%ebx),%eax
-80100e2e:	85 c0                	test   %eax,%eax
-80100e30:	75 ee                	jne    80100e20 <filealloc+0x20>
-      f->ref = 1;
-      release(&ftable.lock);
-80100e32:	83 ec 0c             	sub    $0xc,%esp
-      f->ref = 1;
-80100e35:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
-      release(&ftable.lock);
-80100e3c:	68 e0 0f 11 80       	push   $0x80110fe0
-80100e41:	e8 3a 40 00 00       	call   80104e80 <release>
-      return f;
-    }
-  }
-  release(&ftable.lock);
-  return 0;
-}
-80100e46:	89 d8                	mov    %ebx,%eax
-      return f;
-80100e48:	83 c4 10             	add    $0x10,%esp
-}
-80100e4b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80100e4e:	c9                   	leave  
-80100e4f:	c3                   	ret    
-  release(&ftable.lock);
-80100e50:	83 ec 0c             	sub    $0xc,%esp
-  return 0;
-80100e53:	31 db                	xor    %ebx,%ebx
-  release(&ftable.lock);
-80100e55:	68 e0 0f 11 80       	push   $0x80110fe0
-80100e5a:	e8 21 40 00 00       	call   80104e80 <release>
-}
-80100e5f:	89 d8                	mov    %ebx,%eax
-  return 0;
-80100e61:	83 c4 10             	add    $0x10,%esp
-}
-80100e64:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80100e67:	c9                   	leave  
-80100e68:	c3                   	ret    
-80100e69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-80100e70 <filedup>:
-
-// Increment ref count for file f.
-struct file*
-filedup(struct file *f)
-{
-80100e70:	f3 0f 1e fb          	endbr32 
-80100e74:	55                   	push   %ebp
-80100e75:	89 e5                	mov    %esp,%ebp
-80100e77:	53                   	push   %ebx
-80100e78:	83 ec 10             	sub    $0x10,%esp
-80100e7b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  acquire(&ftable.lock);
-80100e7e:	68 e0 0f 11 80       	push   $0x80110fe0
-80100e83:	e8 38 3f 00 00       	call   80104dc0 <acquire>
-  if(f->ref < 1)
-80100e88:	8b 43 04             	mov    0x4(%ebx),%eax
-80100e8b:	83 c4 10             	add    $0x10,%esp
-80100e8e:	85 c0                	test   %eax,%eax
-80100e90:	7e 1a                	jle    80100eac <filedup+0x3c>
-    panic("filedup");
-  f->ref++;
-80100e92:	83 c0 01             	add    $0x1,%eax
-  release(&ftable.lock);
-80100e95:	83 ec 0c             	sub    $0xc,%esp
-  f->ref++;
-80100e98:	89 43 04             	mov    %eax,0x4(%ebx)
-  release(&ftable.lock);
-80100e9b:	68 e0 0f 11 80       	push   $0x80110fe0
-80100ea0:	e8 db 3f 00 00       	call   80104e80 <release>
-  return f;
-}
-80100ea5:	89 d8                	mov    %ebx,%eax
-80100ea7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80100eaa:	c9                   	leave  
-80100eab:	c3                   	ret    
-    panic("filedup");
-80100eac:	83 ec 0c             	sub    $0xc,%esp
-80100eaf:	68 14 7d 10 80       	push   $0x80107d14
-80100eb4:	e8 d7 f4 ff ff       	call   80100390 <panic>
-80100eb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-80100ec0 <fileclose>:
-
-// Close file f.  (Decrement ref count, close when reaches 0.)
-void
-fileclose(struct file *f)
-{
-80100ec0:	f3 0f 1e fb          	endbr32 
-80100ec4:	55                   	push   %ebp
-80100ec5:	89 e5                	mov    %esp,%ebp
-80100ec7:	57                   	push   %edi
-80100ec8:	56                   	push   %esi
-80100ec9:	53                   	push   %ebx
-80100eca:	83 ec 28             	sub    $0x28,%esp
-80100ecd:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  struct file ff;
-
-  acquire(&ftable.lock);
-80100ed0:	68 e0 0f 11 80       	push   $0x80110fe0
-80100ed5:	e8 e6 3e 00 00       	call   80104dc0 <acquire>
-  if(f->ref < 1)
-80100eda:	8b 53 04             	mov    0x4(%ebx),%edx
-80100edd:	83 c4 10             	add    $0x10,%esp
-80100ee0:	85 d2                	test   %edx,%edx
-80100ee2:	0f 8e a1 00 00 00    	jle    80100f89 <fileclose+0xc9>
-    panic("fileclose");
-  if(--f->ref > 0){
-80100ee8:	83 ea 01             	sub    $0x1,%edx
-80100eeb:	89 53 04             	mov    %edx,0x4(%ebx)
-80100eee:	75 40                	jne    80100f30 <fileclose+0x70>
-    release(&ftable.lock);
-    return;
-  }
-  ff = *f;
-80100ef0:	0f b6 43 09          	movzbl 0x9(%ebx),%eax
-  f->ref = 0;
-  f->type = FD_NONE;
-  release(&ftable.lock);
-80100ef4:	83 ec 0c             	sub    $0xc,%esp
-  ff = *f;
-80100ef7:	8b 3b                	mov    (%ebx),%edi
-  f->type = FD_NONE;
-80100ef9:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
-  ff = *f;
-80100eff:	8b 73 0c             	mov    0xc(%ebx),%esi
-80100f02:	88 45 e7             	mov    %al,-0x19(%ebp)
-80100f05:	8b 43 10             	mov    0x10(%ebx),%eax
-  release(&ftable.lock);
-80100f08:	68 e0 0f 11 80       	push   $0x80110fe0
-  ff = *f;
-80100f0d:	89 45 e0             	mov    %eax,-0x20(%ebp)
-  release(&ftable.lock);
-80100f10:	e8 6b 3f 00 00       	call   80104e80 <release>
-
-  if(ff.type == FD_PIPE)
-80100f15:	83 c4 10             	add    $0x10,%esp
-80100f18:	83 ff 01             	cmp    $0x1,%edi
-80100f1b:	74 53                	je     80100f70 <fileclose+0xb0>
-    pipeclose(ff.pipe, ff.writable);
-  else if(ff.type == FD_INODE){
-80100f1d:	83 ff 02             	cmp    $0x2,%edi
-80100f20:	74 26                	je     80100f48 <fileclose+0x88>
-    begin_op();
-    iput(ff.ip);
-    end_op();
-  }
-}
-80100f22:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80100f25:	5b                   	pop    %ebx
-80100f26:	5e                   	pop    %esi
-80100f27:	5f                   	pop    %edi
-80100f28:	5d                   	pop    %ebp
-80100f29:	c3                   	ret    
-80100f2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    release(&ftable.lock);
-80100f30:	c7 45 08 e0 0f 11 80 	movl   $0x80110fe0,0x8(%ebp)
-}
-80100f37:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80100f3a:	5b                   	pop    %ebx
-80100f3b:	5e                   	pop    %esi
-80100f3c:	5f                   	pop    %edi
-80100f3d:	5d                   	pop    %ebp
-    release(&ftable.lock);
-80100f3e:	e9 3d 3f 00 00       	jmp    80104e80 <release>
-80100f43:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80100f47:	90                   	nop
-    begin_op();
-80100f48:	e8 e3 1d 00 00       	call   80102d30 <begin_op>
-    iput(ff.ip);
-80100f4d:	83 ec 0c             	sub    $0xc,%esp
-80100f50:	ff 75 e0             	pushl  -0x20(%ebp)
-80100f53:	e8 38 09 00 00       	call   80101890 <iput>
-    end_op();
-80100f58:	83 c4 10             	add    $0x10,%esp
-}
-80100f5b:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80100f5e:	5b                   	pop    %ebx
-80100f5f:	5e                   	pop    %esi
-80100f60:	5f                   	pop    %edi
-80100f61:	5d                   	pop    %ebp
-    end_op();
-80100f62:	e9 39 1e 00 00       	jmp    80102da0 <end_op>
-80100f67:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80100f6e:	66 90                	xchg   %ax,%ax
-    pipeclose(ff.pipe, ff.writable);
-80100f70:	0f be 5d e7          	movsbl -0x19(%ebp),%ebx
-80100f74:	83 ec 08             	sub    $0x8,%esp
-80100f77:	53                   	push   %ebx
-80100f78:	56                   	push   %esi
-80100f79:	e8 82 25 00 00       	call   80103500 <pipeclose>
-80100f7e:	83 c4 10             	add    $0x10,%esp
-}
-80100f81:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80100f84:	5b                   	pop    %ebx
-80100f85:	5e                   	pop    %esi
-80100f86:	5f                   	pop    %edi
-80100f87:	5d                   	pop    %ebp
-80100f88:	c3                   	ret    
-    panic("fileclose");
-80100f89:	83 ec 0c             	sub    $0xc,%esp
-80100f8c:	68 1c 7d 10 80       	push   $0x80107d1c
-80100f91:	e8 fa f3 ff ff       	call   80100390 <panic>
-80100f96:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80100f9d:	8d 76 00             	lea    0x0(%esi),%esi
-
-80100fa0 <filestat>:
-
-// Get metadata about file f.
-int
-filestat(struct file *f, struct stat *st)
-{
-80100fa0:	f3 0f 1e fb          	endbr32 
-80100fa4:	55                   	push   %ebp
-80100fa5:	89 e5                	mov    %esp,%ebp
-80100fa7:	53                   	push   %ebx
-80100fa8:	83 ec 04             	sub    $0x4,%esp
-80100fab:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  if(f->type == FD_INODE){
-80100fae:	83 3b 02             	cmpl   $0x2,(%ebx)
-80100fb1:	75 2d                	jne    80100fe0 <filestat+0x40>
-    ilock(f->ip);
-80100fb3:	83 ec 0c             	sub    $0xc,%esp
-80100fb6:	ff 73 10             	pushl  0x10(%ebx)
-80100fb9:	e8 a2 07 00 00       	call   80101760 <ilock>
-    stati(f->ip, st);
-80100fbe:	58                   	pop    %eax
-80100fbf:	5a                   	pop    %edx
-80100fc0:	ff 75 0c             	pushl  0xc(%ebp)
-80100fc3:	ff 73 10             	pushl  0x10(%ebx)
-80100fc6:	e8 65 0a 00 00       	call   80101a30 <stati>
-    iunlock(f->ip);
-80100fcb:	59                   	pop    %ecx
-80100fcc:	ff 73 10             	pushl  0x10(%ebx)
-80100fcf:	e8 6c 08 00 00       	call   80101840 <iunlock>
-    return 0;
-  }
-  return -1;
-}
-80100fd4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-    return 0;
-80100fd7:	83 c4 10             	add    $0x10,%esp
-80100fda:	31 c0                	xor    %eax,%eax
-}
-80100fdc:	c9                   	leave  
-80100fdd:	c3                   	ret    
-80100fde:	66 90                	xchg   %ax,%ax
-80100fe0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-  return -1;
-80100fe3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80100fe8:	c9                   	leave  
-80100fe9:	c3                   	ret    
-80100fea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80100ff0 <fileread>:
-
-// Read from file f.
-int
-fileread(struct file *f, char *addr, int n)
-{
-80100ff0:	f3 0f 1e fb          	endbr32 
-80100ff4:	55                   	push   %ebp
-80100ff5:	89 e5                	mov    %esp,%ebp
-80100ff7:	57                   	push   %edi
-80100ff8:	56                   	push   %esi
-80100ff9:	53                   	push   %ebx
-80100ffa:	83 ec 0c             	sub    $0xc,%esp
-80100ffd:	8b 5d 08             	mov    0x8(%ebp),%ebx
-80101000:	8b 75 0c             	mov    0xc(%ebp),%esi
-80101003:	8b 7d 10             	mov    0x10(%ebp),%edi
-  int r;
-
-  if(f->readable == 0)
-80101006:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
-8010100a:	74 64                	je     80101070 <fileread+0x80>
-    return -1;
-  if(f->type == FD_PIPE)
-8010100c:	8b 03                	mov    (%ebx),%eax
-8010100e:	83 f8 01             	cmp    $0x1,%eax
-80101011:	74 45                	je     80101058 <fileread+0x68>
-    return piperead(f->pipe, addr, n);
-  if(f->type == FD_INODE){
-80101013:	83 f8 02             	cmp    $0x2,%eax
-80101016:	75 5f                	jne    80101077 <fileread+0x87>
-    ilock(f->ip);
-80101018:	83 ec 0c             	sub    $0xc,%esp
-8010101b:	ff 73 10             	pushl  0x10(%ebx)
-8010101e:	e8 3d 07 00 00       	call   80101760 <ilock>
-    if((r = readi(f->ip, addr, f->off, n)) > 0)
-80101023:	57                   	push   %edi
-80101024:	ff 73 14             	pushl  0x14(%ebx)
-80101027:	56                   	push   %esi
-80101028:	ff 73 10             	pushl  0x10(%ebx)
-8010102b:	e8 30 0a 00 00       	call   80101a60 <readi>
-80101030:	83 c4 20             	add    $0x20,%esp
-80101033:	89 c6                	mov    %eax,%esi
-80101035:	85 c0                	test   %eax,%eax
-80101037:	7e 03                	jle    8010103c <fileread+0x4c>
-      f->off += r;
-80101039:	01 43 14             	add    %eax,0x14(%ebx)
-    iunlock(f->ip);
-8010103c:	83 ec 0c             	sub    $0xc,%esp
-8010103f:	ff 73 10             	pushl  0x10(%ebx)
-80101042:	e8 f9 07 00 00       	call   80101840 <iunlock>
-    return r;
-80101047:	83 c4 10             	add    $0x10,%esp
-  }
-  panic("fileread");
-}
-8010104a:	8d 65 f4             	lea    -0xc(%ebp),%esp
-8010104d:	89 f0                	mov    %esi,%eax
-8010104f:	5b                   	pop    %ebx
-80101050:	5e                   	pop    %esi
-80101051:	5f                   	pop    %edi
-80101052:	5d                   	pop    %ebp
-80101053:	c3                   	ret    
-80101054:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    return piperead(f->pipe, addr, n);
-80101058:	8b 43 0c             	mov    0xc(%ebx),%eax
-8010105b:	89 45 08             	mov    %eax,0x8(%ebp)
-}
-8010105e:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80101061:	5b                   	pop    %ebx
-80101062:	5e                   	pop    %esi
-80101063:	5f                   	pop    %edi
-80101064:	5d                   	pop    %ebp
-    return piperead(f->pipe, addr, n);
-80101065:	e9 36 26 00 00       	jmp    801036a0 <piperead>
-8010106a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    return -1;
-80101070:	be ff ff ff ff       	mov    $0xffffffff,%esi
-80101075:	eb d3                	jmp    8010104a <fileread+0x5a>
-  panic("fileread");
-80101077:	83 ec 0c             	sub    $0xc,%esp
-8010107a:	68 26 7d 10 80       	push   $0x80107d26
-8010107f:	e8 0c f3 ff ff       	call   80100390 <panic>
-80101084:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010108b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010108f:	90                   	nop
-
-80101090 <filewrite>:
-
-//PAGEBREAK!
-// Write to file f.
-int
-filewrite(struct file *f, char *addr, int n)
-{
-80101090:	f3 0f 1e fb          	endbr32 
-80101094:	55                   	push   %ebp
-80101095:	89 e5                	mov    %esp,%ebp
-80101097:	57                   	push   %edi
-80101098:	56                   	push   %esi
-80101099:	53                   	push   %ebx
-8010109a:	83 ec 1c             	sub    $0x1c,%esp
-8010109d:	8b 45 0c             	mov    0xc(%ebp),%eax
-801010a0:	8b 75 08             	mov    0x8(%ebp),%esi
-801010a3:	89 45 dc             	mov    %eax,-0x24(%ebp)
-801010a6:	8b 45 10             	mov    0x10(%ebp),%eax
-  int r;
-
-  if(f->writable == 0)
-801010a9:	80 7e 09 00          	cmpb   $0x0,0x9(%esi)
-{
-801010ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-  if(f->writable == 0)
-801010b0:	0f 84 c1 00 00 00    	je     80101177 <filewrite+0xe7>
-    return -1;
-  if(f->type == FD_PIPE)
-801010b6:	8b 06                	mov    (%esi),%eax
-801010b8:	83 f8 01             	cmp    $0x1,%eax
-801010bb:	0f 84 c3 00 00 00    	je     80101184 <filewrite+0xf4>
-    return pipewrite(f->pipe, addr, n);
-  if(f->type == FD_INODE){
-801010c1:	83 f8 02             	cmp    $0x2,%eax
-801010c4:	0f 85 cc 00 00 00    	jne    80101196 <filewrite+0x106>
-    // and 2 blocks of slop for non-aligned writes.
-    // this really belongs lower down, since writei()
-    // might be writing a device like the console.
-    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
-    int i = 0;
-    while(i < n){
-801010ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-    int i = 0;
-801010cd:	31 ff                	xor    %edi,%edi
-    while(i < n){
-801010cf:	85 c0                	test   %eax,%eax
-801010d1:	7f 34                	jg     80101107 <filewrite+0x77>
-801010d3:	e9 98 00 00 00       	jmp    80101170 <filewrite+0xe0>
-801010d8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801010df:	90                   	nop
-        n1 = max;
-
-      begin_op();
-      ilock(f->ip);
-      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
-        f->off += r;
-801010e0:	01 46 14             	add    %eax,0x14(%esi)
-      iunlock(f->ip);
-801010e3:	83 ec 0c             	sub    $0xc,%esp
-801010e6:	ff 76 10             	pushl  0x10(%esi)
-        f->off += r;
-801010e9:	89 45 e0             	mov    %eax,-0x20(%ebp)
-      iunlock(f->ip);
-801010ec:	e8 4f 07 00 00       	call   80101840 <iunlock>
-      end_op();
-801010f1:	e8 aa 1c 00 00       	call   80102da0 <end_op>
-
-      if(r < 0)
-        break;
-      if(r != n1)
-801010f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
-801010f9:	83 c4 10             	add    $0x10,%esp
-801010fc:	39 c3                	cmp    %eax,%ebx
-801010fe:	75 60                	jne    80101160 <filewrite+0xd0>
-        panic("short filewrite");
-      i += r;
-80101100:	01 df                	add    %ebx,%edi
-    while(i < n){
-80101102:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
-80101105:	7e 69                	jle    80101170 <filewrite+0xe0>
-      int n1 = n - i;
-80101107:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
-8010110a:	b8 00 06 00 00       	mov    $0x600,%eax
-8010110f:	29 fb                	sub    %edi,%ebx
-      if(n1 > max)
-80101111:	81 fb 00 06 00 00    	cmp    $0x600,%ebx
-80101117:	0f 4f d8             	cmovg  %eax,%ebx
-      begin_op();
-8010111a:	e8 11 1c 00 00       	call   80102d30 <begin_op>
-      ilock(f->ip);
-8010111f:	83 ec 0c             	sub    $0xc,%esp
-80101122:	ff 76 10             	pushl  0x10(%esi)
-80101125:	e8 36 06 00 00       	call   80101760 <ilock>
-      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
-8010112a:	8b 45 dc             	mov    -0x24(%ebp),%eax
-8010112d:	53                   	push   %ebx
-8010112e:	ff 76 14             	pushl  0x14(%esi)
-80101131:	01 f8                	add    %edi,%eax
-80101133:	50                   	push   %eax
-80101134:	ff 76 10             	pushl  0x10(%esi)
-80101137:	e8 24 0a 00 00       	call   80101b60 <writei>
-8010113c:	83 c4 20             	add    $0x20,%esp
-8010113f:	85 c0                	test   %eax,%eax
-80101141:	7f 9d                	jg     801010e0 <filewrite+0x50>
-      iunlock(f->ip);
-80101143:	83 ec 0c             	sub    $0xc,%esp
-80101146:	ff 76 10             	pushl  0x10(%esi)
-80101149:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-8010114c:	e8 ef 06 00 00       	call   80101840 <iunlock>
-      end_op();
-80101151:	e8 4a 1c 00 00       	call   80102da0 <end_op>
-      if(r < 0)
-80101156:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-80101159:	83 c4 10             	add    $0x10,%esp
-8010115c:	85 c0                	test   %eax,%eax
-8010115e:	75 17                	jne    80101177 <filewrite+0xe7>
-        panic("short filewrite");
-80101160:	83 ec 0c             	sub    $0xc,%esp
-80101163:	68 2f 7d 10 80       	push   $0x80107d2f
-80101168:	e8 23 f2 ff ff       	call   80100390 <panic>
-8010116d:	8d 76 00             	lea    0x0(%esi),%esi
-    }
-    return i == n ? n : -1;
-80101170:	89 f8                	mov    %edi,%eax
-80101172:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
-80101175:	74 05                	je     8010117c <filewrite+0xec>
-80101177:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-  }
-  panic("filewrite");
-}
-8010117c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-8010117f:	5b                   	pop    %ebx
-80101180:	5e                   	pop    %esi
-80101181:	5f                   	pop    %edi
-80101182:	5d                   	pop    %ebp
-80101183:	c3                   	ret    
-    return pipewrite(f->pipe, addr, n);
-80101184:	8b 46 0c             	mov    0xc(%esi),%eax
-80101187:	89 45 08             	mov    %eax,0x8(%ebp)
-}
-8010118a:	8d 65 f4             	lea    -0xc(%ebp),%esp
-8010118d:	5b                   	pop    %ebx
-8010118e:	5e                   	pop    %esi
-8010118f:	5f                   	pop    %edi
-80101190:	5d                   	pop    %ebp
-    return pipewrite(f->pipe, addr, n);
-80101191:	e9 0a 24 00 00       	jmp    801035a0 <pipewrite>
-  panic("filewrite");
-80101196:	83 ec 0c             	sub    $0xc,%esp
-80101199:	68 35 7d 10 80       	push   $0x80107d35
-8010119e:	e8 ed f1 ff ff       	call   80100390 <panic>
-801011a3:	66 90                	xchg   %ax,%ax
-801011a5:	66 90                	xchg   %ax,%ax
-801011a7:	66 90                	xchg   %ax,%ax
-801011a9:	66 90                	xchg   %ax,%ax
-801011ab:	66 90                	xchg   %ax,%ax
-801011ad:	66 90                	xchg   %ax,%ax
-801011af:	90                   	nop
-
-801011b0 <bfree>:
-}
-
-// Free a disk block.
-static void
-bfree(int dev, uint b)
-{
-801011b0:	55                   	push   %ebp
-801011b1:	89 c1                	mov    %eax,%ecx
-  struct buf *bp;
-  int bi, m;
-
-  bp = bread(dev, BBLOCK(b, sb));
-801011b3:	89 d0                	mov    %edx,%eax
-801011b5:	c1 e8 0c             	shr    $0xc,%eax
-801011b8:	03 05 f8 19 11 80    	add    0x801119f8,%eax
-{
-801011be:	89 e5                	mov    %esp,%ebp
-801011c0:	56                   	push   %esi
-801011c1:	53                   	push   %ebx
-801011c2:	89 d3                	mov    %edx,%ebx
-  bp = bread(dev, BBLOCK(b, sb));
-801011c4:	83 ec 08             	sub    $0x8,%esp
-801011c7:	50                   	push   %eax
-801011c8:	51                   	push   %ecx
-801011c9:	e8 02 ef ff ff       	call   801000d0 <bread>
-  bi = b % BPB;
-  m = 1 << (bi % 8);
-801011ce:	89 d9                	mov    %ebx,%ecx
-  if((bp->data[bi/8] & m) == 0)
-801011d0:	c1 fb 03             	sar    $0x3,%ebx
-  m = 1 << (bi % 8);
-801011d3:	ba 01 00 00 00       	mov    $0x1,%edx
-801011d8:	83 e1 07             	and    $0x7,%ecx
-  if((bp->data[bi/8] & m) == 0)
-801011db:	81 e3 ff 01 00 00    	and    $0x1ff,%ebx
-801011e1:	83 c4 10             	add    $0x10,%esp
-  m = 1 << (bi % 8);
-801011e4:	d3 e2                	shl    %cl,%edx
-  if((bp->data[bi/8] & m) == 0)
-801011e6:	0f b6 4c 18 5c       	movzbl 0x5c(%eax,%ebx,1),%ecx
-801011eb:	85 d1                	test   %edx,%ecx
-801011ed:	74 25                	je     80101214 <bfree+0x64>
-    panic("freeing free block");
-  bp->data[bi/8] &= ~m;
-801011ef:	f7 d2                	not    %edx
-  log_write(bp);
-801011f1:	83 ec 0c             	sub    $0xc,%esp
-801011f4:	89 c6                	mov    %eax,%esi
-  bp->data[bi/8] &= ~m;
-801011f6:	21 ca                	and    %ecx,%edx
-801011f8:	88 54 18 5c          	mov    %dl,0x5c(%eax,%ebx,1)
-  log_write(bp);
-801011fc:	50                   	push   %eax
-801011fd:	e8 0e 1d 00 00       	call   80102f10 <log_write>
-  brelse(bp);
-80101202:	89 34 24             	mov    %esi,(%esp)
-80101205:	e8 e6 ef ff ff       	call   801001f0 <brelse>
-}
-8010120a:	83 c4 10             	add    $0x10,%esp
-8010120d:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80101210:	5b                   	pop    %ebx
-80101211:	5e                   	pop    %esi
-80101212:	5d                   	pop    %ebp
-80101213:	c3                   	ret    
-    panic("freeing free block");
-80101214:	83 ec 0c             	sub    $0xc,%esp
-80101217:	68 3f 7d 10 80       	push   $0x80107d3f
-8010121c:	e8 6f f1 ff ff       	call   80100390 <panic>
-80101221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101228:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010122f:	90                   	nop
-
-80101230 <balloc>:
-{
-80101230:	55                   	push   %ebp
-80101231:	89 e5                	mov    %esp,%ebp
-80101233:	57                   	push   %edi
-80101234:	56                   	push   %esi
-80101235:	53                   	push   %ebx
-80101236:	83 ec 1c             	sub    $0x1c,%esp
-  for(b = 0; b < sb.size; b += BPB){
-80101239:	8b 0d e0 19 11 80    	mov    0x801119e0,%ecx
-{
-8010123f:	89 45 d8             	mov    %eax,-0x28(%ebp)
-  for(b = 0; b < sb.size; b += BPB){
-80101242:	85 c9                	test   %ecx,%ecx
-80101244:	0f 84 87 00 00 00    	je     801012d1 <balloc+0xa1>
-8010124a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
-    bp = bread(dev, BBLOCK(b, sb));
-80101251:	8b 75 dc             	mov    -0x24(%ebp),%esi
-80101254:	83 ec 08             	sub    $0x8,%esp
-80101257:	89 f0                	mov    %esi,%eax
-80101259:	c1 f8 0c             	sar    $0xc,%eax
-8010125c:	03 05 f8 19 11 80    	add    0x801119f8,%eax
-80101262:	50                   	push   %eax
-80101263:	ff 75 d8             	pushl  -0x28(%ebp)
-80101266:	e8 65 ee ff ff       	call   801000d0 <bread>
-8010126b:	83 c4 10             	add    $0x10,%esp
-8010126e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
-80101271:	a1 e0 19 11 80       	mov    0x801119e0,%eax
-80101276:	89 45 e0             	mov    %eax,-0x20(%ebp)
-80101279:	31 c0                	xor    %eax,%eax
-8010127b:	eb 2f                	jmp    801012ac <balloc+0x7c>
-8010127d:	8d 76 00             	lea    0x0(%esi),%esi
-      m = 1 << (bi % 8);
-80101280:	89 c1                	mov    %eax,%ecx
-80101282:	bb 01 00 00 00       	mov    $0x1,%ebx
-      if((bp->data[bi/8] & m) == 0){  // Is block free?
-80101287:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-      m = 1 << (bi % 8);
-8010128a:	83 e1 07             	and    $0x7,%ecx
-8010128d:	d3 e3                	shl    %cl,%ebx
-      if((bp->data[bi/8] & m) == 0){  // Is block free?
-8010128f:	89 c1                	mov    %eax,%ecx
-80101291:	c1 f9 03             	sar    $0x3,%ecx
-80101294:	0f b6 7c 0a 5c       	movzbl 0x5c(%edx,%ecx,1),%edi
-80101299:	89 fa                	mov    %edi,%edx
-8010129b:	85 df                	test   %ebx,%edi
-8010129d:	74 41                	je     801012e0 <balloc+0xb0>
-    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
-8010129f:	83 c0 01             	add    $0x1,%eax
-801012a2:	83 c6 01             	add    $0x1,%esi
-801012a5:	3d 00 10 00 00       	cmp    $0x1000,%eax
-801012aa:	74 05                	je     801012b1 <balloc+0x81>
-801012ac:	39 75 e0             	cmp    %esi,-0x20(%ebp)
-801012af:	77 cf                	ja     80101280 <balloc+0x50>
-    brelse(bp);
-801012b1:	83 ec 0c             	sub    $0xc,%esp
-801012b4:	ff 75 e4             	pushl  -0x1c(%ebp)
-801012b7:	e8 34 ef ff ff       	call   801001f0 <brelse>
-  for(b = 0; b < sb.size; b += BPB){
-801012bc:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
-801012c3:	83 c4 10             	add    $0x10,%esp
-801012c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
-801012c9:	39 05 e0 19 11 80    	cmp    %eax,0x801119e0
-801012cf:	77 80                	ja     80101251 <balloc+0x21>
-  panic("balloc: out of blocks");
-801012d1:	83 ec 0c             	sub    $0xc,%esp
-801012d4:	68 52 7d 10 80       	push   $0x80107d52
-801012d9:	e8 b2 f0 ff ff       	call   80100390 <panic>
-801012de:	66 90                	xchg   %ax,%ax
-        bp->data[bi/8] |= m;  // Mark block in use.
-801012e0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
-        log_write(bp);
-801012e3:	83 ec 0c             	sub    $0xc,%esp
-        bp->data[bi/8] |= m;  // Mark block in use.
-801012e6:	09 da                	or     %ebx,%edx
-801012e8:	88 54 0f 5c          	mov    %dl,0x5c(%edi,%ecx,1)
-        log_write(bp);
-801012ec:	57                   	push   %edi
-801012ed:	e8 1e 1c 00 00       	call   80102f10 <log_write>
-        brelse(bp);
-801012f2:	89 3c 24             	mov    %edi,(%esp)
-801012f5:	e8 f6 ee ff ff       	call   801001f0 <brelse>
-  bp = bread(dev, bno);
-801012fa:	58                   	pop    %eax
-801012fb:	5a                   	pop    %edx
-801012fc:	56                   	push   %esi
-801012fd:	ff 75 d8             	pushl  -0x28(%ebp)
-80101300:	e8 cb ed ff ff       	call   801000d0 <bread>
-  memset(bp->data, 0, BSIZE);
-80101305:	83 c4 0c             	add    $0xc,%esp
-  bp = bread(dev, bno);
-80101308:	89 c3                	mov    %eax,%ebx
-  memset(bp->data, 0, BSIZE);
-8010130a:	8d 40 5c             	lea    0x5c(%eax),%eax
-8010130d:	68 00 02 00 00       	push   $0x200
-80101312:	6a 00                	push   $0x0
-80101314:	50                   	push   %eax
-80101315:	e8 b6 3b 00 00       	call   80104ed0 <memset>
-  log_write(bp);
-8010131a:	89 1c 24             	mov    %ebx,(%esp)
-8010131d:	e8 ee 1b 00 00       	call   80102f10 <log_write>
-  brelse(bp);
-80101322:	89 1c 24             	mov    %ebx,(%esp)
-80101325:	e8 c6 ee ff ff       	call   801001f0 <brelse>
-}
-8010132a:	8d 65 f4             	lea    -0xc(%ebp),%esp
-8010132d:	89 f0                	mov    %esi,%eax
-8010132f:	5b                   	pop    %ebx
-80101330:	5e                   	pop    %esi
-80101331:	5f                   	pop    %edi
-80101332:	5d                   	pop    %ebp
-80101333:	c3                   	ret    
-80101334:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010133b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010133f:	90                   	nop
-
-80101340 <iget>:
-// Find the inode with number inum on device dev
-// and return the in-memory copy. Does not lock
-// the inode and does not read it from disk.
-static struct inode*
-iget(uint dev, uint inum)
-{
-80101340:	55                   	push   %ebp
-80101341:	89 e5                	mov    %esp,%ebp
-80101343:	57                   	push   %edi
-80101344:	89 c7                	mov    %eax,%edi
-80101346:	56                   	push   %esi
-  struct inode *ip, *empty;
-
-  acquire(&icache.lock);
-
-  // Is the inode already cached?
-  empty = 0;
-80101347:	31 f6                	xor    %esi,%esi
-{
-80101349:	53                   	push   %ebx
-  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
-8010134a:	bb 34 1a 11 80       	mov    $0x80111a34,%ebx
-{
-8010134f:	83 ec 28             	sub    $0x28,%esp
-80101352:	89 55 e4             	mov    %edx,-0x1c(%ebp)
-  acquire(&icache.lock);
-80101355:	68 00 1a 11 80       	push   $0x80111a00
-8010135a:	e8 61 3a 00 00       	call   80104dc0 <acquire>
-  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
-8010135f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-  acquire(&icache.lock);
-80101362:	83 c4 10             	add    $0x10,%esp
-80101365:	eb 1b                	jmp    80101382 <iget+0x42>
-80101367:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010136e:	66 90                	xchg   %ax,%ax
-    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
-80101370:	39 3b                	cmp    %edi,(%ebx)
-80101372:	74 6c                	je     801013e0 <iget+0xa0>
-80101374:	81 c3 90 00 00 00    	add    $0x90,%ebx
-  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
-8010137a:	81 fb 54 36 11 80    	cmp    $0x80113654,%ebx
-80101380:	73 26                	jae    801013a8 <iget+0x68>
-    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
-80101382:	8b 4b 08             	mov    0x8(%ebx),%ecx
-80101385:	85 c9                	test   %ecx,%ecx
-80101387:	7f e7                	jg     80101370 <iget+0x30>
-      ip->ref++;
-      release(&icache.lock);
-      return ip;
-    }
-    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
-80101389:	85 f6                	test   %esi,%esi
-8010138b:	75 e7                	jne    80101374 <iget+0x34>
-8010138d:	89 d8                	mov    %ebx,%eax
-8010138f:	81 c3 90 00 00 00    	add    $0x90,%ebx
-80101395:	85 c9                	test   %ecx,%ecx
-80101397:	75 6e                	jne    80101407 <iget+0xc7>
-80101399:	89 c6                	mov    %eax,%esi
-  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
-8010139b:	81 fb 54 36 11 80    	cmp    $0x80113654,%ebx
-801013a1:	72 df                	jb     80101382 <iget+0x42>
-801013a3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801013a7:	90                   	nop
-      empty = ip;
-  }
-
-  // Recycle an inode cache entry.
-  if(empty == 0)
-801013a8:	85 f6                	test   %esi,%esi
-801013aa:	74 73                	je     8010141f <iget+0xdf>
-  ip = empty;
-  ip->dev = dev;
-  ip->inum = inum;
-  ip->ref = 1;
-  ip->valid = 0;
-  release(&icache.lock);
-801013ac:	83 ec 0c             	sub    $0xc,%esp
-  ip->dev = dev;
-801013af:	89 3e                	mov    %edi,(%esi)
-  ip->inum = inum;
-801013b1:	89 56 04             	mov    %edx,0x4(%esi)
-  ip->ref = 1;
-801013b4:	c7 46 08 01 00 00 00 	movl   $0x1,0x8(%esi)
-  ip->valid = 0;
-801013bb:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
-  release(&icache.lock);
-801013c2:	68 00 1a 11 80       	push   $0x80111a00
-801013c7:	e8 b4 3a 00 00       	call   80104e80 <release>
-
-  return ip;
-801013cc:	83 c4 10             	add    $0x10,%esp
-}
-801013cf:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801013d2:	89 f0                	mov    %esi,%eax
-801013d4:	5b                   	pop    %ebx
-801013d5:	5e                   	pop    %esi
-801013d6:	5f                   	pop    %edi
-801013d7:	5d                   	pop    %ebp
-801013d8:	c3                   	ret    
-801013d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
-801013e0:	39 53 04             	cmp    %edx,0x4(%ebx)
-801013e3:	75 8f                	jne    80101374 <iget+0x34>
-      release(&icache.lock);
-801013e5:	83 ec 0c             	sub    $0xc,%esp
-      ip->ref++;
-801013e8:	83 c1 01             	add    $0x1,%ecx
-      return ip;
-801013eb:	89 de                	mov    %ebx,%esi
-      release(&icache.lock);
-801013ed:	68 00 1a 11 80       	push   $0x80111a00
-      ip->ref++;
-801013f2:	89 4b 08             	mov    %ecx,0x8(%ebx)
-      release(&icache.lock);
-801013f5:	e8 86 3a 00 00       	call   80104e80 <release>
-      return ip;
-801013fa:	83 c4 10             	add    $0x10,%esp
-}
-801013fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80101400:	89 f0                	mov    %esi,%eax
-80101402:	5b                   	pop    %ebx
-80101403:	5e                   	pop    %esi
-80101404:	5f                   	pop    %edi
-80101405:	5d                   	pop    %ebp
-80101406:	c3                   	ret    
-  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
-80101407:	81 fb 54 36 11 80    	cmp    $0x80113654,%ebx
-8010140d:	73 10                	jae    8010141f <iget+0xdf>
-    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
-8010140f:	8b 4b 08             	mov    0x8(%ebx),%ecx
-80101412:	85 c9                	test   %ecx,%ecx
-80101414:	0f 8f 56 ff ff ff    	jg     80101370 <iget+0x30>
-8010141a:	e9 6e ff ff ff       	jmp    8010138d <iget+0x4d>
-    panic("iget: no inodes");
-8010141f:	83 ec 0c             	sub    $0xc,%esp
-80101422:	68 68 7d 10 80       	push   $0x80107d68
-80101427:	e8 64 ef ff ff       	call   80100390 <panic>
-8010142c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-80101430 <bmap>:
-
-// Return the disk block address of the nth block in inode ip.
-// If there is no such block, bmap allocates one.
-static uint
-bmap(struct inode *ip, uint bn)
-{
-80101430:	55                   	push   %ebp
-80101431:	89 e5                	mov    %esp,%ebp
-80101433:	57                   	push   %edi
-80101434:	56                   	push   %esi
-80101435:	89 c6                	mov    %eax,%esi
-80101437:	53                   	push   %ebx
-80101438:	83 ec 1c             	sub    $0x1c,%esp
-  uint addr, *a;
-  struct buf *bp;
-
-  if(bn < NDIRECT){
-8010143b:	83 fa 0b             	cmp    $0xb,%edx
-8010143e:	0f 86 84 00 00 00    	jbe    801014c8 <bmap+0x98>
-    if((addr = ip->addrs[bn]) == 0)
-      ip->addrs[bn] = addr = balloc(ip->dev);
-    return addr;
-  }
-  bn -= NDIRECT;
-80101444:	8d 5a f4             	lea    -0xc(%edx),%ebx
-
-  if(bn < NINDIRECT){
-80101447:	83 fb 7f             	cmp    $0x7f,%ebx
-8010144a:	0f 87 98 00 00 00    	ja     801014e8 <bmap+0xb8>
-    // Load indirect block, allocating if necessary.
-    if((addr = ip->addrs[NDIRECT]) == 0)
-80101450:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
-80101456:	8b 16                	mov    (%esi),%edx
-80101458:	85 c0                	test   %eax,%eax
-8010145a:	74 54                	je     801014b0 <bmap+0x80>
-      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
-    bp = bread(ip->dev, addr);
-8010145c:	83 ec 08             	sub    $0x8,%esp
-8010145f:	50                   	push   %eax
-80101460:	52                   	push   %edx
-80101461:	e8 6a ec ff ff       	call   801000d0 <bread>
-    a = (uint*)bp->data;
-    if((addr = a[bn]) == 0){
-80101466:	83 c4 10             	add    $0x10,%esp
-80101469:	8d 54 98 5c          	lea    0x5c(%eax,%ebx,4),%edx
-    bp = bread(ip->dev, addr);
-8010146d:	89 c7                	mov    %eax,%edi
-    if((addr = a[bn]) == 0){
-8010146f:	8b 1a                	mov    (%edx),%ebx
-80101471:	85 db                	test   %ebx,%ebx
-80101473:	74 1b                	je     80101490 <bmap+0x60>
-      a[bn] = addr = balloc(ip->dev);
-      log_write(bp);
-    }
-    brelse(bp);
-80101475:	83 ec 0c             	sub    $0xc,%esp
-80101478:	57                   	push   %edi
-80101479:	e8 72 ed ff ff       	call   801001f0 <brelse>
-    return addr;
-8010147e:	83 c4 10             	add    $0x10,%esp
-  }
-
-  panic("bmap: out of range");
-}
-80101481:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80101484:	89 d8                	mov    %ebx,%eax
-80101486:	5b                   	pop    %ebx
-80101487:	5e                   	pop    %esi
-80101488:	5f                   	pop    %edi
-80101489:	5d                   	pop    %ebp
-8010148a:	c3                   	ret    
-8010148b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010148f:	90                   	nop
-      a[bn] = addr = balloc(ip->dev);
-80101490:	8b 06                	mov    (%esi),%eax
-80101492:	89 55 e4             	mov    %edx,-0x1c(%ebp)
-80101495:	e8 96 fd ff ff       	call   80101230 <balloc>
-8010149a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-      log_write(bp);
-8010149d:	83 ec 0c             	sub    $0xc,%esp
-      a[bn] = addr = balloc(ip->dev);
-801014a0:	89 c3                	mov    %eax,%ebx
-801014a2:	89 02                	mov    %eax,(%edx)
-      log_write(bp);
-801014a4:	57                   	push   %edi
-801014a5:	e8 66 1a 00 00       	call   80102f10 <log_write>
-801014aa:	83 c4 10             	add    $0x10,%esp
-801014ad:	eb c6                	jmp    80101475 <bmap+0x45>
-801014af:	90                   	nop
-      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
-801014b0:	89 d0                	mov    %edx,%eax
-801014b2:	e8 79 fd ff ff       	call   80101230 <balloc>
-801014b7:	8b 16                	mov    (%esi),%edx
-801014b9:	89 86 8c 00 00 00    	mov    %eax,0x8c(%esi)
-801014bf:	eb 9b                	jmp    8010145c <bmap+0x2c>
-801014c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    if((addr = ip->addrs[bn]) == 0)
-801014c8:	8d 3c 90             	lea    (%eax,%edx,4),%edi
-801014cb:	8b 5f 5c             	mov    0x5c(%edi),%ebx
-801014ce:	85 db                	test   %ebx,%ebx
-801014d0:	75 af                	jne    80101481 <bmap+0x51>
-      ip->addrs[bn] = addr = balloc(ip->dev);
-801014d2:	8b 00                	mov    (%eax),%eax
-801014d4:	e8 57 fd ff ff       	call   80101230 <balloc>
-801014d9:	89 47 5c             	mov    %eax,0x5c(%edi)
-801014dc:	89 c3                	mov    %eax,%ebx
-}
-801014de:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801014e1:	89 d8                	mov    %ebx,%eax
-801014e3:	5b                   	pop    %ebx
-801014e4:	5e                   	pop    %esi
-801014e5:	5f                   	pop    %edi
-801014e6:	5d                   	pop    %ebp
-801014e7:	c3                   	ret    
-  panic("bmap: out of range");
-801014e8:	83 ec 0c             	sub    $0xc,%esp
-801014eb:	68 78 7d 10 80       	push   $0x80107d78
-801014f0:	e8 9b ee ff ff       	call   80100390 <panic>
-801014f5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801014fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-80101500 <readsb>:
-{
-80101500:	f3 0f 1e fb          	endbr32 
-80101504:	55                   	push   %ebp
-80101505:	89 e5                	mov    %esp,%ebp
-80101507:	56                   	push   %esi
-80101508:	53                   	push   %ebx
-80101509:	8b 75 0c             	mov    0xc(%ebp),%esi
-  bp = bread(dev, 1);
-8010150c:	83 ec 08             	sub    $0x8,%esp
-8010150f:	6a 01                	push   $0x1
-80101511:	ff 75 08             	pushl  0x8(%ebp)
-80101514:	e8 b7 eb ff ff       	call   801000d0 <bread>
-  memmove(sb, bp->data, sizeof(*sb));
-80101519:	83 c4 0c             	add    $0xc,%esp
-  bp = bread(dev, 1);
-8010151c:	89 c3                	mov    %eax,%ebx
-  memmove(sb, bp->data, sizeof(*sb));
-8010151e:	8d 40 5c             	lea    0x5c(%eax),%eax
-80101521:	6a 1c                	push   $0x1c
-80101523:	50                   	push   %eax
-80101524:	56                   	push   %esi
-80101525:	e8 46 3a 00 00       	call   80104f70 <memmove>
-  brelse(bp);
-8010152a:	89 5d 08             	mov    %ebx,0x8(%ebp)
-8010152d:	83 c4 10             	add    $0x10,%esp
-}
-80101530:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80101533:	5b                   	pop    %ebx
-80101534:	5e                   	pop    %esi
-80101535:	5d                   	pop    %ebp
-  brelse(bp);
-80101536:	e9 b5 ec ff ff       	jmp    801001f0 <brelse>
-8010153b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010153f:	90                   	nop
-
-80101540 <iinit>:
-{
-80101540:	f3 0f 1e fb          	endbr32 
-80101544:	55                   	push   %ebp
-80101545:	89 e5                	mov    %esp,%ebp
-80101547:	53                   	push   %ebx
-80101548:	bb 40 1a 11 80       	mov    $0x80111a40,%ebx
-8010154d:	83 ec 0c             	sub    $0xc,%esp
-  initlock(&icache.lock, "icache");
-80101550:	68 8b 7d 10 80       	push   $0x80107d8b
-80101555:	68 00 1a 11 80       	push   $0x80111a00
-8010155a:	e8 e1 36 00 00       	call   80104c40 <initlock>
-  for(i = 0; i < NINODE; i++) {
-8010155f:	83 c4 10             	add    $0x10,%esp
-80101562:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    initsleeplock(&icache.inode[i].lock, "inode");
-80101568:	83 ec 08             	sub    $0x8,%esp
-8010156b:	68 92 7d 10 80       	push   $0x80107d92
-80101570:	53                   	push   %ebx
-80101571:	81 c3 90 00 00 00    	add    $0x90,%ebx
-80101577:	e8 84 35 00 00       	call   80104b00 <initsleeplock>
-  for(i = 0; i < NINODE; i++) {
-8010157c:	83 c4 10             	add    $0x10,%esp
-8010157f:	81 fb 60 36 11 80    	cmp    $0x80113660,%ebx
-80101585:	75 e1                	jne    80101568 <iinit+0x28>
-  readsb(dev, &sb);
-80101587:	83 ec 08             	sub    $0x8,%esp
-8010158a:	68 e0 19 11 80       	push   $0x801119e0
-8010158f:	ff 75 08             	pushl  0x8(%ebp)
-80101592:	e8 69 ff ff ff       	call   80101500 <readsb>
-  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
-80101597:	ff 35 f8 19 11 80    	pushl  0x801119f8
-8010159d:	ff 35 f4 19 11 80    	pushl  0x801119f4
-801015a3:	ff 35 f0 19 11 80    	pushl  0x801119f0
-801015a9:	ff 35 ec 19 11 80    	pushl  0x801119ec
-801015af:	ff 35 e8 19 11 80    	pushl  0x801119e8
-801015b5:	ff 35 e4 19 11 80    	pushl  0x801119e4
-801015bb:	ff 35 e0 19 11 80    	pushl  0x801119e0
-801015c1:	68 f8 7d 10 80       	push   $0x80107df8
-801015c6:	e8 e5 f0 ff ff       	call   801006b0 <cprintf>
-}
-801015cb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-801015ce:	83 c4 30             	add    $0x30,%esp
-801015d1:	c9                   	leave  
-801015d2:	c3                   	ret    
-801015d3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801015da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-801015e0 <ialloc>:
-{
-801015e0:	f3 0f 1e fb          	endbr32 
-801015e4:	55                   	push   %ebp
-801015e5:	89 e5                	mov    %esp,%ebp
-801015e7:	57                   	push   %edi
-801015e8:	56                   	push   %esi
-801015e9:	53                   	push   %ebx
-801015ea:	83 ec 1c             	sub    $0x1c,%esp
-801015ed:	8b 45 0c             	mov    0xc(%ebp),%eax
-  for(inum = 1; inum < sb.ninodes; inum++){
-801015f0:	83 3d e8 19 11 80 01 	cmpl   $0x1,0x801119e8
-{
-801015f7:	8b 75 08             	mov    0x8(%ebp),%esi
-801015fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-  for(inum = 1; inum < sb.ninodes; inum++){
-801015fd:	0f 86 8d 00 00 00    	jbe    80101690 <ialloc+0xb0>
-80101603:	bf 01 00 00 00       	mov    $0x1,%edi
-80101608:	eb 1d                	jmp    80101627 <ialloc+0x47>
-8010160a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    brelse(bp);
-80101610:	83 ec 0c             	sub    $0xc,%esp
-  for(inum = 1; inum < sb.ninodes; inum++){
-80101613:	83 c7 01             	add    $0x1,%edi
-    brelse(bp);
-80101616:	53                   	push   %ebx
-80101617:	e8 d4 eb ff ff       	call   801001f0 <brelse>
-  for(inum = 1; inum < sb.ninodes; inum++){
-8010161c:	83 c4 10             	add    $0x10,%esp
-8010161f:	3b 3d e8 19 11 80    	cmp    0x801119e8,%edi
-80101625:	73 69                	jae    80101690 <ialloc+0xb0>
-    bp = bread(dev, IBLOCK(inum, sb));
-80101627:	89 f8                	mov    %edi,%eax
-80101629:	83 ec 08             	sub    $0x8,%esp
-8010162c:	c1 e8 03             	shr    $0x3,%eax
-8010162f:	03 05 f4 19 11 80    	add    0x801119f4,%eax
-80101635:	50                   	push   %eax
-80101636:	56                   	push   %esi
-80101637:	e8 94 ea ff ff       	call   801000d0 <bread>
-    if(dip->type == 0){  // a free inode
-8010163c:	83 c4 10             	add    $0x10,%esp
-    bp = bread(dev, IBLOCK(inum, sb));
-8010163f:	89 c3                	mov    %eax,%ebx
-    dip = (struct dinode*)bp->data + inum%IPB;
-80101641:	89 f8                	mov    %edi,%eax
-80101643:	83 e0 07             	and    $0x7,%eax
-80101646:	c1 e0 06             	shl    $0x6,%eax
-80101649:	8d 4c 03 5c          	lea    0x5c(%ebx,%eax,1),%ecx
-    if(dip->type == 0){  // a free inode
-8010164d:	66 83 39 00          	cmpw   $0x0,(%ecx)
-80101651:	75 bd                	jne    80101610 <ialloc+0x30>
-      memset(dip, 0, sizeof(*dip));
-80101653:	83 ec 04             	sub    $0x4,%esp
-80101656:	89 4d e0             	mov    %ecx,-0x20(%ebp)
-80101659:	6a 40                	push   $0x40
-8010165b:	6a 00                	push   $0x0
-8010165d:	51                   	push   %ecx
-8010165e:	e8 6d 38 00 00       	call   80104ed0 <memset>
-      dip->type = type;
-80101663:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
-80101667:	8b 4d e0             	mov    -0x20(%ebp),%ecx
-8010166a:	66 89 01             	mov    %ax,(%ecx)
-      log_write(bp);   // mark it allocated on the disk
-8010166d:	89 1c 24             	mov    %ebx,(%esp)
-80101670:	e8 9b 18 00 00       	call   80102f10 <log_write>
-      brelse(bp);
-80101675:	89 1c 24             	mov    %ebx,(%esp)
-80101678:	e8 73 eb ff ff       	call   801001f0 <brelse>
-      return iget(dev, inum);
-8010167d:	83 c4 10             	add    $0x10,%esp
-}
-80101680:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return iget(dev, inum);
-80101683:	89 fa                	mov    %edi,%edx
-}
-80101685:	5b                   	pop    %ebx
-      return iget(dev, inum);
-80101686:	89 f0                	mov    %esi,%eax
-}
-80101688:	5e                   	pop    %esi
-80101689:	5f                   	pop    %edi
-8010168a:	5d                   	pop    %ebp
-      return iget(dev, inum);
-8010168b:	e9 b0 fc ff ff       	jmp    80101340 <iget>
-  panic("ialloc: no inodes");
-80101690:	83 ec 0c             	sub    $0xc,%esp
-80101693:	68 98 7d 10 80       	push   $0x80107d98
-80101698:	e8 f3 ec ff ff       	call   80100390 <panic>
-8010169d:	8d 76 00             	lea    0x0(%esi),%esi
-
-801016a0 <iupdate>:
-{
-801016a0:	f3 0f 1e fb          	endbr32 
-801016a4:	55                   	push   %ebp
-801016a5:	89 e5                	mov    %esp,%ebp
-801016a7:	56                   	push   %esi
-801016a8:	53                   	push   %ebx
-801016a9:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
-801016ac:	8b 43 04             	mov    0x4(%ebx),%eax
-  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
-801016af:	83 c3 5c             	add    $0x5c,%ebx
-  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
-801016b2:	83 ec 08             	sub    $0x8,%esp
-801016b5:	c1 e8 03             	shr    $0x3,%eax
-801016b8:	03 05 f4 19 11 80    	add    0x801119f4,%eax
-801016be:	50                   	push   %eax
-801016bf:	ff 73 a4             	pushl  -0x5c(%ebx)
-801016c2:	e8 09 ea ff ff       	call   801000d0 <bread>
-  dip->type = ip->type;
-801016c7:	0f b7 53 f4          	movzwl -0xc(%ebx),%edx
-  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
-801016cb:	83 c4 0c             	add    $0xc,%esp
-  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
-801016ce:	89 c6                	mov    %eax,%esi
-  dip = (struct dinode*)bp->data + ip->inum%IPB;
-801016d0:	8b 43 a8             	mov    -0x58(%ebx),%eax
-801016d3:	83 e0 07             	and    $0x7,%eax
-801016d6:	c1 e0 06             	shl    $0x6,%eax
-801016d9:	8d 44 06 5c          	lea    0x5c(%esi,%eax,1),%eax
-  dip->type = ip->type;
-801016dd:	66 89 10             	mov    %dx,(%eax)
-  dip->major = ip->major;
-801016e0:	0f b7 53 f6          	movzwl -0xa(%ebx),%edx
-  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
-801016e4:	83 c0 0c             	add    $0xc,%eax
-  dip->major = ip->major;
-801016e7:	66 89 50 f6          	mov    %dx,-0xa(%eax)
-  dip->minor = ip->minor;
-801016eb:	0f b7 53 f8          	movzwl -0x8(%ebx),%edx
-801016ef:	66 89 50 f8          	mov    %dx,-0x8(%eax)
-  dip->nlink = ip->nlink;
-801016f3:	0f b7 53 fa          	movzwl -0x6(%ebx),%edx
-801016f7:	66 89 50 fa          	mov    %dx,-0x6(%eax)
-  dip->size = ip->size;
-801016fb:	8b 53 fc             	mov    -0x4(%ebx),%edx
-801016fe:	89 50 fc             	mov    %edx,-0x4(%eax)
-  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
-80101701:	6a 34                	push   $0x34
-80101703:	53                   	push   %ebx
-80101704:	50                   	push   %eax
-80101705:	e8 66 38 00 00       	call   80104f70 <memmove>
-  log_write(bp);
-8010170a:	89 34 24             	mov    %esi,(%esp)
-8010170d:	e8 fe 17 00 00       	call   80102f10 <log_write>
-  brelse(bp);
-80101712:	89 75 08             	mov    %esi,0x8(%ebp)
-80101715:	83 c4 10             	add    $0x10,%esp
-}
-80101718:	8d 65 f8             	lea    -0x8(%ebp),%esp
-8010171b:	5b                   	pop    %ebx
-8010171c:	5e                   	pop    %esi
-8010171d:	5d                   	pop    %ebp
-  brelse(bp);
-8010171e:	e9 cd ea ff ff       	jmp    801001f0 <brelse>
-80101723:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010172a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80101730 <idup>:
-{
-80101730:	f3 0f 1e fb          	endbr32 
-80101734:	55                   	push   %ebp
-80101735:	89 e5                	mov    %esp,%ebp
-80101737:	53                   	push   %ebx
-80101738:	83 ec 10             	sub    $0x10,%esp
-8010173b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  acquire(&icache.lock);
-8010173e:	68 00 1a 11 80       	push   $0x80111a00
-80101743:	e8 78 36 00 00       	call   80104dc0 <acquire>
-  ip->ref++;
-80101748:	83 43 08 01          	addl   $0x1,0x8(%ebx)
-  release(&icache.lock);
-8010174c:	c7 04 24 00 1a 11 80 	movl   $0x80111a00,(%esp)
-80101753:	e8 28 37 00 00       	call   80104e80 <release>
-}
-80101758:	89 d8                	mov    %ebx,%eax
-8010175a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-8010175d:	c9                   	leave  
-8010175e:	c3                   	ret    
-8010175f:	90                   	nop
-
-80101760 <ilock>:
-{
-80101760:	f3 0f 1e fb          	endbr32 
-80101764:	55                   	push   %ebp
-80101765:	89 e5                	mov    %esp,%ebp
-80101767:	56                   	push   %esi
-80101768:	53                   	push   %ebx
-80101769:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  if(ip == 0 || ip->ref < 1)
-8010176c:	85 db                	test   %ebx,%ebx
-8010176e:	0f 84 b3 00 00 00    	je     80101827 <ilock+0xc7>
-80101774:	8b 53 08             	mov    0x8(%ebx),%edx
-80101777:	85 d2                	test   %edx,%edx
-80101779:	0f 8e a8 00 00 00    	jle    80101827 <ilock+0xc7>
-  acquiresleep(&ip->lock);
-8010177f:	83 ec 0c             	sub    $0xc,%esp
-80101782:	8d 43 0c             	lea    0xc(%ebx),%eax
-80101785:	50                   	push   %eax
-80101786:	e8 b5 33 00 00       	call   80104b40 <acquiresleep>
-  if(ip->valid == 0){
-8010178b:	8b 43 4c             	mov    0x4c(%ebx),%eax
-8010178e:	83 c4 10             	add    $0x10,%esp
-80101791:	85 c0                	test   %eax,%eax
-80101793:	74 0b                	je     801017a0 <ilock+0x40>
-}
-80101795:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80101798:	5b                   	pop    %ebx
-80101799:	5e                   	pop    %esi
-8010179a:	5d                   	pop    %ebp
-8010179b:	c3                   	ret    
-8010179c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
-801017a0:	8b 43 04             	mov    0x4(%ebx),%eax
-801017a3:	83 ec 08             	sub    $0x8,%esp
-801017a6:	c1 e8 03             	shr    $0x3,%eax
-801017a9:	03 05 f4 19 11 80    	add    0x801119f4,%eax
-801017af:	50                   	push   %eax
-801017b0:	ff 33                	pushl  (%ebx)
-801017b2:	e8 19 e9 ff ff       	call   801000d0 <bread>
-    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
-801017b7:	83 c4 0c             	add    $0xc,%esp
-    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
-801017ba:	89 c6                	mov    %eax,%esi
-    dip = (struct dinode*)bp->data + ip->inum%IPB;
-801017bc:	8b 43 04             	mov    0x4(%ebx),%eax
-801017bf:	83 e0 07             	and    $0x7,%eax
-801017c2:	c1 e0 06             	shl    $0x6,%eax
-801017c5:	8d 44 06 5c          	lea    0x5c(%esi,%eax,1),%eax
-    ip->type = dip->type;
-801017c9:	0f b7 10             	movzwl (%eax),%edx
-    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
-801017cc:	83 c0 0c             	add    $0xc,%eax
-    ip->type = dip->type;
-801017cf:	66 89 53 50          	mov    %dx,0x50(%ebx)
-    ip->major = dip->major;
-801017d3:	0f b7 50 f6          	movzwl -0xa(%eax),%edx
-801017d7:	66 89 53 52          	mov    %dx,0x52(%ebx)
-    ip->minor = dip->minor;
-801017db:	0f b7 50 f8          	movzwl -0x8(%eax),%edx
-801017df:	66 89 53 54          	mov    %dx,0x54(%ebx)
-    ip->nlink = dip->nlink;
-801017e3:	0f b7 50 fa          	movzwl -0x6(%eax),%edx
-801017e7:	66 89 53 56          	mov    %dx,0x56(%ebx)
-    ip->size = dip->size;
-801017eb:	8b 50 fc             	mov    -0x4(%eax),%edx
-801017ee:	89 53 58             	mov    %edx,0x58(%ebx)
-    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
-801017f1:	6a 34                	push   $0x34
-801017f3:	50                   	push   %eax
-801017f4:	8d 43 5c             	lea    0x5c(%ebx),%eax
-801017f7:	50                   	push   %eax
-801017f8:	e8 73 37 00 00       	call   80104f70 <memmove>
-    brelse(bp);
-801017fd:	89 34 24             	mov    %esi,(%esp)
-80101800:	e8 eb e9 ff ff       	call   801001f0 <brelse>
-    if(ip->type == 0)
-80101805:	83 c4 10             	add    $0x10,%esp
-80101808:	66 83 7b 50 00       	cmpw   $0x0,0x50(%ebx)
-    ip->valid = 1;
-8010180d:	c7 43 4c 01 00 00 00 	movl   $0x1,0x4c(%ebx)
-    if(ip->type == 0)
-80101814:	0f 85 7b ff ff ff    	jne    80101795 <ilock+0x35>
-      panic("ilock: no type");
-8010181a:	83 ec 0c             	sub    $0xc,%esp
-8010181d:	68 b0 7d 10 80       	push   $0x80107db0
-80101822:	e8 69 eb ff ff       	call   80100390 <panic>
-    panic("ilock");
-80101827:	83 ec 0c             	sub    $0xc,%esp
-8010182a:	68 aa 7d 10 80       	push   $0x80107daa
-8010182f:	e8 5c eb ff ff       	call   80100390 <panic>
-80101834:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010183b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010183f:	90                   	nop
-
-80101840 <iunlock>:
-{
-80101840:	f3 0f 1e fb          	endbr32 
-80101844:	55                   	push   %ebp
-80101845:	89 e5                	mov    %esp,%ebp
-80101847:	56                   	push   %esi
-80101848:	53                   	push   %ebx
-80101849:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
-8010184c:	85 db                	test   %ebx,%ebx
-8010184e:	74 28                	je     80101878 <iunlock+0x38>
-80101850:	83 ec 0c             	sub    $0xc,%esp
-80101853:	8d 73 0c             	lea    0xc(%ebx),%esi
-80101856:	56                   	push   %esi
-80101857:	e8 84 33 00 00       	call   80104be0 <holdingsleep>
-8010185c:	83 c4 10             	add    $0x10,%esp
-8010185f:	85 c0                	test   %eax,%eax
-80101861:	74 15                	je     80101878 <iunlock+0x38>
-80101863:	8b 43 08             	mov    0x8(%ebx),%eax
-80101866:	85 c0                	test   %eax,%eax
-80101868:	7e 0e                	jle    80101878 <iunlock+0x38>
-  releasesleep(&ip->lock);
-8010186a:	89 75 08             	mov    %esi,0x8(%ebp)
-}
-8010186d:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80101870:	5b                   	pop    %ebx
-80101871:	5e                   	pop    %esi
-80101872:	5d                   	pop    %ebp
-  releasesleep(&ip->lock);
-80101873:	e9 28 33 00 00       	jmp    80104ba0 <releasesleep>
-    panic("iunlock");
-80101878:	83 ec 0c             	sub    $0xc,%esp
-8010187b:	68 bf 7d 10 80       	push   $0x80107dbf
-80101880:	e8 0b eb ff ff       	call   80100390 <panic>
-80101885:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010188c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-80101890 <iput>:
-{
-80101890:	f3 0f 1e fb          	endbr32 
-80101894:	55                   	push   %ebp
-80101895:	89 e5                	mov    %esp,%ebp
-80101897:	57                   	push   %edi
-80101898:	56                   	push   %esi
-80101899:	53                   	push   %ebx
-8010189a:	83 ec 28             	sub    $0x28,%esp
-8010189d:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  acquiresleep(&ip->lock);
-801018a0:	8d 7b 0c             	lea    0xc(%ebx),%edi
-801018a3:	57                   	push   %edi
-801018a4:	e8 97 32 00 00       	call   80104b40 <acquiresleep>
-  if(ip->valid && ip->nlink == 0){
-801018a9:	8b 53 4c             	mov    0x4c(%ebx),%edx
-801018ac:	83 c4 10             	add    $0x10,%esp
-801018af:	85 d2                	test   %edx,%edx
-801018b1:	74 07                	je     801018ba <iput+0x2a>
-801018b3:	66 83 7b 56 00       	cmpw   $0x0,0x56(%ebx)
-801018b8:	74 36                	je     801018f0 <iput+0x60>
-  releasesleep(&ip->lock);
-801018ba:	83 ec 0c             	sub    $0xc,%esp
-801018bd:	57                   	push   %edi
-801018be:	e8 dd 32 00 00       	call   80104ba0 <releasesleep>
-  acquire(&icache.lock);
-801018c3:	c7 04 24 00 1a 11 80 	movl   $0x80111a00,(%esp)
-801018ca:	e8 f1 34 00 00       	call   80104dc0 <acquire>
-  ip->ref--;
-801018cf:	83 6b 08 01          	subl   $0x1,0x8(%ebx)
-  release(&icache.lock);
-801018d3:	83 c4 10             	add    $0x10,%esp
-801018d6:	c7 45 08 00 1a 11 80 	movl   $0x80111a00,0x8(%ebp)
-}
-801018dd:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801018e0:	5b                   	pop    %ebx
-801018e1:	5e                   	pop    %esi
-801018e2:	5f                   	pop    %edi
-801018e3:	5d                   	pop    %ebp
-  release(&icache.lock);
-801018e4:	e9 97 35 00 00       	jmp    80104e80 <release>
-801018e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    acquire(&icache.lock);
-801018f0:	83 ec 0c             	sub    $0xc,%esp
-801018f3:	68 00 1a 11 80       	push   $0x80111a00
-801018f8:	e8 c3 34 00 00       	call   80104dc0 <acquire>
-    int r = ip->ref;
-801018fd:	8b 73 08             	mov    0x8(%ebx),%esi
-    release(&icache.lock);
-80101900:	c7 04 24 00 1a 11 80 	movl   $0x80111a00,(%esp)
-80101907:	e8 74 35 00 00       	call   80104e80 <release>
-    if(r == 1){
-8010190c:	83 c4 10             	add    $0x10,%esp
-8010190f:	83 fe 01             	cmp    $0x1,%esi
-80101912:	75 a6                	jne    801018ba <iput+0x2a>
-80101914:	8d 8b 8c 00 00 00    	lea    0x8c(%ebx),%ecx
-8010191a:	89 7d e4             	mov    %edi,-0x1c(%ebp)
-8010191d:	8d 73 5c             	lea    0x5c(%ebx),%esi
-80101920:	89 cf                	mov    %ecx,%edi
-80101922:	eb 0b                	jmp    8010192f <iput+0x9f>
-80101924:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-{
-  int i, j;
-  struct buf *bp;
-  uint *a;
-
-  for(i = 0; i < NDIRECT; i++){
-80101928:	83 c6 04             	add    $0x4,%esi
-8010192b:	39 fe                	cmp    %edi,%esi
-8010192d:	74 19                	je     80101948 <iput+0xb8>
-    if(ip->addrs[i]){
-8010192f:	8b 16                	mov    (%esi),%edx
-80101931:	85 d2                	test   %edx,%edx
-80101933:	74 f3                	je     80101928 <iput+0x98>
-      bfree(ip->dev, ip->addrs[i]);
-80101935:	8b 03                	mov    (%ebx),%eax
-80101937:	e8 74 f8 ff ff       	call   801011b0 <bfree>
-      ip->addrs[i] = 0;
-8010193c:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
-80101942:	eb e4                	jmp    80101928 <iput+0x98>
-80101944:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    }
-  }
-
-  if(ip->addrs[NDIRECT]){
-80101948:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
-8010194e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
-80101951:	85 c0                	test   %eax,%eax
-80101953:	75 33                	jne    80101988 <iput+0xf8>
-    bfree(ip->dev, ip->addrs[NDIRECT]);
-    ip->addrs[NDIRECT] = 0;
-  }
-
-  ip->size = 0;
-  iupdate(ip);
-80101955:	83 ec 0c             	sub    $0xc,%esp
-  ip->size = 0;
-80101958:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
-  iupdate(ip);
-8010195f:	53                   	push   %ebx
-80101960:	e8 3b fd ff ff       	call   801016a0 <iupdate>
-      ip->type = 0;
-80101965:	31 c0                	xor    %eax,%eax
-80101967:	66 89 43 50          	mov    %ax,0x50(%ebx)
-      iupdate(ip);
-8010196b:	89 1c 24             	mov    %ebx,(%esp)
-8010196e:	e8 2d fd ff ff       	call   801016a0 <iupdate>
-      ip->valid = 0;
-80101973:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
-8010197a:	83 c4 10             	add    $0x10,%esp
-8010197d:	e9 38 ff ff ff       	jmp    801018ba <iput+0x2a>
-80101982:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    bp = bread(ip->dev, ip->addrs[NDIRECT]);
-80101988:	83 ec 08             	sub    $0x8,%esp
-8010198b:	50                   	push   %eax
-8010198c:	ff 33                	pushl  (%ebx)
-8010198e:	e8 3d e7 ff ff       	call   801000d0 <bread>
-80101993:	89 7d e0             	mov    %edi,-0x20(%ebp)
-80101996:	83 c4 10             	add    $0x10,%esp
-80101999:	8d 88 5c 02 00 00    	lea    0x25c(%eax),%ecx
-8010199f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-    for(j = 0; j < NINDIRECT; j++){
-801019a2:	8d 70 5c             	lea    0x5c(%eax),%esi
-801019a5:	89 cf                	mov    %ecx,%edi
-801019a7:	eb 0e                	jmp    801019b7 <iput+0x127>
-801019a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801019b0:	83 c6 04             	add    $0x4,%esi
-801019b3:	39 f7                	cmp    %esi,%edi
-801019b5:	74 19                	je     801019d0 <iput+0x140>
-      if(a[j])
-801019b7:	8b 16                	mov    (%esi),%edx
-801019b9:	85 d2                	test   %edx,%edx
-801019bb:	74 f3                	je     801019b0 <iput+0x120>
-        bfree(ip->dev, a[j]);
-801019bd:	8b 03                	mov    (%ebx),%eax
-801019bf:	e8 ec f7 ff ff       	call   801011b0 <bfree>
-801019c4:	eb ea                	jmp    801019b0 <iput+0x120>
-801019c6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801019cd:	8d 76 00             	lea    0x0(%esi),%esi
-    brelse(bp);
-801019d0:	83 ec 0c             	sub    $0xc,%esp
-801019d3:	ff 75 e4             	pushl  -0x1c(%ebp)
-801019d6:	8b 7d e0             	mov    -0x20(%ebp),%edi
-801019d9:	e8 12 e8 ff ff       	call   801001f0 <brelse>
-    bfree(ip->dev, ip->addrs[NDIRECT]);
-801019de:	8b 93 8c 00 00 00    	mov    0x8c(%ebx),%edx
-801019e4:	8b 03                	mov    (%ebx),%eax
-801019e6:	e8 c5 f7 ff ff       	call   801011b0 <bfree>
-    ip->addrs[NDIRECT] = 0;
-801019eb:	83 c4 10             	add    $0x10,%esp
-801019ee:	c7 83 8c 00 00 00 00 	movl   $0x0,0x8c(%ebx)
-801019f5:	00 00 00 
-801019f8:	e9 58 ff ff ff       	jmp    80101955 <iput+0xc5>
-801019fd:	8d 76 00             	lea    0x0(%esi),%esi
-
-80101a00 <iunlockput>:
-{
-80101a00:	f3 0f 1e fb          	endbr32 
-80101a04:	55                   	push   %ebp
-80101a05:	89 e5                	mov    %esp,%ebp
-80101a07:	53                   	push   %ebx
-80101a08:	83 ec 10             	sub    $0x10,%esp
-80101a0b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  iunlock(ip);
-80101a0e:	53                   	push   %ebx
-80101a0f:	e8 2c fe ff ff       	call   80101840 <iunlock>
-  iput(ip);
-80101a14:	89 5d 08             	mov    %ebx,0x8(%ebp)
-80101a17:	83 c4 10             	add    $0x10,%esp
-}
-80101a1a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80101a1d:	c9                   	leave  
-  iput(ip);
-80101a1e:	e9 6d fe ff ff       	jmp    80101890 <iput>
-80101a23:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101a2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80101a30 <stati>:
-
-// Copy stat information from inode.
-// Caller must hold ip->lock.
-void
-stati(struct inode *ip, struct stat *st)
-{
-80101a30:	f3 0f 1e fb          	endbr32 
-80101a34:	55                   	push   %ebp
-80101a35:	89 e5                	mov    %esp,%ebp
-80101a37:	8b 55 08             	mov    0x8(%ebp),%edx
-80101a3a:	8b 45 0c             	mov    0xc(%ebp),%eax
-  st->dev = ip->dev;
-80101a3d:	8b 0a                	mov    (%edx),%ecx
-80101a3f:	89 48 04             	mov    %ecx,0x4(%eax)
-  st->ino = ip->inum;
-80101a42:	8b 4a 04             	mov    0x4(%edx),%ecx
-80101a45:	89 48 08             	mov    %ecx,0x8(%eax)
-  st->type = ip->type;
-80101a48:	0f b7 4a 50          	movzwl 0x50(%edx),%ecx
-80101a4c:	66 89 08             	mov    %cx,(%eax)
-  st->nlink = ip->nlink;
-80101a4f:	0f b7 4a 56          	movzwl 0x56(%edx),%ecx
-80101a53:	66 89 48 0c          	mov    %cx,0xc(%eax)
-  st->size = ip->size;
-80101a57:	8b 52 58             	mov    0x58(%edx),%edx
-80101a5a:	89 50 10             	mov    %edx,0x10(%eax)
-}
-80101a5d:	5d                   	pop    %ebp
-80101a5e:	c3                   	ret    
-80101a5f:	90                   	nop
-
-80101a60 <readi>:
-//PAGEBREAK!
-// Read data from inode.
-// Caller must hold ip->lock.
-int
-readi(struct inode *ip, char *dst, uint off, uint n)
-{
-80101a60:	f3 0f 1e fb          	endbr32 
-80101a64:	55                   	push   %ebp
-80101a65:	89 e5                	mov    %esp,%ebp
-80101a67:	57                   	push   %edi
-80101a68:	56                   	push   %esi
-80101a69:	53                   	push   %ebx
-80101a6a:	83 ec 1c             	sub    $0x1c,%esp
-80101a6d:	8b 7d 0c             	mov    0xc(%ebp),%edi
-80101a70:	8b 45 08             	mov    0x8(%ebp),%eax
-80101a73:	8b 75 10             	mov    0x10(%ebp),%esi
-80101a76:	89 7d e0             	mov    %edi,-0x20(%ebp)
-80101a79:	8b 7d 14             	mov    0x14(%ebp),%edi
-  uint tot, m;
-  struct buf *bp;
-
-  if(ip->type == T_DEV){
-80101a7c:	66 83 78 50 03       	cmpw   $0x3,0x50(%eax)
-{
-80101a81:	89 45 d8             	mov    %eax,-0x28(%ebp)
-80101a84:	89 7d e4             	mov    %edi,-0x1c(%ebp)
-  if(ip->type == T_DEV){
-80101a87:	0f 84 a3 00 00 00    	je     80101b30 <readi+0xd0>
-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
-      return -1;
-    return devsw[ip->major].read(ip, dst, n);
-  }
-
-  if(off > ip->size || off + n < off)
-80101a8d:	8b 45 d8             	mov    -0x28(%ebp),%eax
-80101a90:	8b 40 58             	mov    0x58(%eax),%eax
-80101a93:	39 c6                	cmp    %eax,%esi
-80101a95:	0f 87 b6 00 00 00    	ja     80101b51 <readi+0xf1>
-80101a9b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
-80101a9e:	31 c9                	xor    %ecx,%ecx
-80101aa0:	89 da                	mov    %ebx,%edx
-80101aa2:	01 f2                	add    %esi,%edx
-80101aa4:	0f 92 c1             	setb   %cl
-80101aa7:	89 cf                	mov    %ecx,%edi
-80101aa9:	0f 82 a2 00 00 00    	jb     80101b51 <readi+0xf1>
-    return -1;
-  if(off + n > ip->size)
-    n = ip->size - off;
-80101aaf:	89 c1                	mov    %eax,%ecx
-80101ab1:	29 f1                	sub    %esi,%ecx
-80101ab3:	39 d0                	cmp    %edx,%eax
-80101ab5:	0f 43 cb             	cmovae %ebx,%ecx
-80101ab8:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
-
-  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
-80101abb:	85 c9                	test   %ecx,%ecx
-80101abd:	74 63                	je     80101b22 <readi+0xc2>
-80101abf:	90                   	nop
-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
-80101ac0:	8b 5d d8             	mov    -0x28(%ebp),%ebx
-80101ac3:	89 f2                	mov    %esi,%edx
-80101ac5:	c1 ea 09             	shr    $0x9,%edx
-80101ac8:	89 d8                	mov    %ebx,%eax
-80101aca:	e8 61 f9 ff ff       	call   80101430 <bmap>
-80101acf:	83 ec 08             	sub    $0x8,%esp
-80101ad2:	50                   	push   %eax
-80101ad3:	ff 33                	pushl  (%ebx)
-80101ad5:	e8 f6 e5 ff ff       	call   801000d0 <bread>
-    m = min(n - tot, BSIZE - off%BSIZE);
-80101ada:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
-80101add:	b9 00 02 00 00       	mov    $0x200,%ecx
-80101ae2:	83 c4 0c             	add    $0xc,%esp
-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
-80101ae5:	89 c2                	mov    %eax,%edx
-    m = min(n - tot, BSIZE - off%BSIZE);
-80101ae7:	89 f0                	mov    %esi,%eax
-80101ae9:	25 ff 01 00 00       	and    $0x1ff,%eax
-80101aee:	29 fb                	sub    %edi,%ebx
-    memmove(dst, bp->data + off%BSIZE, m);
-80101af0:	89 55 dc             	mov    %edx,-0x24(%ebp)
-    m = min(n - tot, BSIZE - off%BSIZE);
-80101af3:	29 c1                	sub    %eax,%ecx
-    memmove(dst, bp->data + off%BSIZE, m);
-80101af5:	8d 44 02 5c          	lea    0x5c(%edx,%eax,1),%eax
-    m = min(n - tot, BSIZE - off%BSIZE);
-80101af9:	39 d9                	cmp    %ebx,%ecx
-80101afb:	0f 46 d9             	cmovbe %ecx,%ebx
-    memmove(dst, bp->data + off%BSIZE, m);
-80101afe:	53                   	push   %ebx
-  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
-80101aff:	01 df                	add    %ebx,%edi
-80101b01:	01 de                	add    %ebx,%esi
-    memmove(dst, bp->data + off%BSIZE, m);
-80101b03:	50                   	push   %eax
-80101b04:	ff 75 e0             	pushl  -0x20(%ebp)
-80101b07:	e8 64 34 00 00       	call   80104f70 <memmove>
-    brelse(bp);
-80101b0c:	8b 55 dc             	mov    -0x24(%ebp),%edx
-80101b0f:	89 14 24             	mov    %edx,(%esp)
-80101b12:	e8 d9 e6 ff ff       	call   801001f0 <brelse>
-  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
-80101b17:	01 5d e0             	add    %ebx,-0x20(%ebp)
-80101b1a:	83 c4 10             	add    $0x10,%esp
-80101b1d:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
-80101b20:	77 9e                	ja     80101ac0 <readi+0x60>
-  }
-  return n;
-80101b22:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-}
-80101b25:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80101b28:	5b                   	pop    %ebx
-80101b29:	5e                   	pop    %esi
-80101b2a:	5f                   	pop    %edi
-80101b2b:	5d                   	pop    %ebp
-80101b2c:	c3                   	ret    
-80101b2d:	8d 76 00             	lea    0x0(%esi),%esi
-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
-80101b30:	0f bf 40 52          	movswl 0x52(%eax),%eax
-80101b34:	66 83 f8 09          	cmp    $0x9,%ax
-80101b38:	77 17                	ja     80101b51 <readi+0xf1>
-80101b3a:	8b 04 c5 80 19 11 80 	mov    -0x7feee680(,%eax,8),%eax
-80101b41:	85 c0                	test   %eax,%eax
-80101b43:	74 0c                	je     80101b51 <readi+0xf1>
-    return devsw[ip->major].read(ip, dst, n);
-80101b45:	89 7d 10             	mov    %edi,0x10(%ebp)
-}
-80101b48:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80101b4b:	5b                   	pop    %ebx
-80101b4c:	5e                   	pop    %esi
-80101b4d:	5f                   	pop    %edi
-80101b4e:	5d                   	pop    %ebp
-    return devsw[ip->major].read(ip, dst, n);
-80101b4f:	ff e0                	jmp    *%eax
-      return -1;
-80101b51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80101b56:	eb cd                	jmp    80101b25 <readi+0xc5>
-80101b58:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101b5f:	90                   	nop
-
-80101b60 <writei>:
-// PAGEBREAK!
-// Write data to inode.
-// Caller must hold ip->lock.
-int
-writei(struct inode *ip, char *src, uint off, uint n)
-{
-80101b60:	f3 0f 1e fb          	endbr32 
-80101b64:	55                   	push   %ebp
-80101b65:	89 e5                	mov    %esp,%ebp
-80101b67:	57                   	push   %edi
-80101b68:	56                   	push   %esi
-80101b69:	53                   	push   %ebx
-80101b6a:	83 ec 1c             	sub    $0x1c,%esp
-80101b6d:	8b 45 08             	mov    0x8(%ebp),%eax
-80101b70:	8b 75 0c             	mov    0xc(%ebp),%esi
-80101b73:	8b 7d 14             	mov    0x14(%ebp),%edi
-  uint tot, m;
-  struct buf *bp;
-
-  if(ip->type == T_DEV){
-80101b76:	66 83 78 50 03       	cmpw   $0x3,0x50(%eax)
-{
-80101b7b:	89 75 dc             	mov    %esi,-0x24(%ebp)
-80101b7e:	89 45 d8             	mov    %eax,-0x28(%ebp)
-80101b81:	8b 75 10             	mov    0x10(%ebp),%esi
-80101b84:	89 7d e0             	mov    %edi,-0x20(%ebp)
-  if(ip->type == T_DEV){
-80101b87:	0f 84 b3 00 00 00    	je     80101c40 <writei+0xe0>
-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
-      return -1;
-    return devsw[ip->major].write(ip, src, n);
-  }
-
-  if(off > ip->size || off + n < off)
-80101b8d:	8b 45 d8             	mov    -0x28(%ebp),%eax
-80101b90:	39 70 58             	cmp    %esi,0x58(%eax)
-80101b93:	0f 82 e3 00 00 00    	jb     80101c7c <writei+0x11c>
-    return -1;
-  if(off + n > MAXFILE*BSIZE)
-80101b99:	8b 7d e0             	mov    -0x20(%ebp),%edi
-80101b9c:	89 f8                	mov    %edi,%eax
-80101b9e:	01 f0                	add    %esi,%eax
-80101ba0:	0f 82 d6 00 00 00    	jb     80101c7c <writei+0x11c>
-80101ba6:	3d 00 18 01 00       	cmp    $0x11800,%eax
-80101bab:	0f 87 cb 00 00 00    	ja     80101c7c <writei+0x11c>
-    return -1;
-
-  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
-80101bb1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
-80101bb8:	85 ff                	test   %edi,%edi
-80101bba:	74 75                	je     80101c31 <writei+0xd1>
-80101bbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
-80101bc0:	8b 7d d8             	mov    -0x28(%ebp),%edi
-80101bc3:	89 f2                	mov    %esi,%edx
-80101bc5:	c1 ea 09             	shr    $0x9,%edx
-80101bc8:	89 f8                	mov    %edi,%eax
-80101bca:	e8 61 f8 ff ff       	call   80101430 <bmap>
-80101bcf:	83 ec 08             	sub    $0x8,%esp
-80101bd2:	50                   	push   %eax
-80101bd3:	ff 37                	pushl  (%edi)
-80101bd5:	e8 f6 e4 ff ff       	call   801000d0 <bread>
-    m = min(n - tot, BSIZE - off%BSIZE);
-80101bda:	b9 00 02 00 00       	mov    $0x200,%ecx
-80101bdf:	8b 5d e0             	mov    -0x20(%ebp),%ebx
-80101be2:	2b 5d e4             	sub    -0x1c(%ebp),%ebx
-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
-80101be5:	89 c7                	mov    %eax,%edi
-    m = min(n - tot, BSIZE - off%BSIZE);
-80101be7:	89 f0                	mov    %esi,%eax
-80101be9:	83 c4 0c             	add    $0xc,%esp
-80101bec:	25 ff 01 00 00       	and    $0x1ff,%eax
-80101bf1:	29 c1                	sub    %eax,%ecx
-    memmove(bp->data + off%BSIZE, src, m);
-80101bf3:	8d 44 07 5c          	lea    0x5c(%edi,%eax,1),%eax
-    m = min(n - tot, BSIZE - off%BSIZE);
-80101bf7:	39 d9                	cmp    %ebx,%ecx
-80101bf9:	0f 46 d9             	cmovbe %ecx,%ebx
-    memmove(bp->data + off%BSIZE, src, m);
-80101bfc:	53                   	push   %ebx
-  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
-80101bfd:	01 de                	add    %ebx,%esi
-    memmove(bp->data + off%BSIZE, src, m);
-80101bff:	ff 75 dc             	pushl  -0x24(%ebp)
-80101c02:	50                   	push   %eax
-80101c03:	e8 68 33 00 00       	call   80104f70 <memmove>
-    log_write(bp);
-80101c08:	89 3c 24             	mov    %edi,(%esp)
-80101c0b:	e8 00 13 00 00       	call   80102f10 <log_write>
-    brelse(bp);
-80101c10:	89 3c 24             	mov    %edi,(%esp)
-80101c13:	e8 d8 e5 ff ff       	call   801001f0 <brelse>
-  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
-80101c18:	01 5d e4             	add    %ebx,-0x1c(%ebp)
-80101c1b:	83 c4 10             	add    $0x10,%esp
-80101c1e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-80101c21:	01 5d dc             	add    %ebx,-0x24(%ebp)
-80101c24:	39 45 e0             	cmp    %eax,-0x20(%ebp)
-80101c27:	77 97                	ja     80101bc0 <writei+0x60>
-  }
-
-  if(n > 0 && off > ip->size){
-80101c29:	8b 45 d8             	mov    -0x28(%ebp),%eax
-80101c2c:	3b 70 58             	cmp    0x58(%eax),%esi
-80101c2f:	77 37                	ja     80101c68 <writei+0x108>
-    ip->size = off;
-    iupdate(ip);
-  }
-  return n;
-80101c31:	8b 45 e0             	mov    -0x20(%ebp),%eax
-}
-80101c34:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80101c37:	5b                   	pop    %ebx
-80101c38:	5e                   	pop    %esi
-80101c39:	5f                   	pop    %edi
-80101c3a:	5d                   	pop    %ebp
-80101c3b:	c3                   	ret    
-80101c3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
-80101c40:	0f bf 40 52          	movswl 0x52(%eax),%eax
-80101c44:	66 83 f8 09          	cmp    $0x9,%ax
-80101c48:	77 32                	ja     80101c7c <writei+0x11c>
-80101c4a:	8b 04 c5 84 19 11 80 	mov    -0x7feee67c(,%eax,8),%eax
-80101c51:	85 c0                	test   %eax,%eax
-80101c53:	74 27                	je     80101c7c <writei+0x11c>
-    return devsw[ip->major].write(ip, src, n);
-80101c55:	89 7d 10             	mov    %edi,0x10(%ebp)
-}
-80101c58:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80101c5b:	5b                   	pop    %ebx
-80101c5c:	5e                   	pop    %esi
-80101c5d:	5f                   	pop    %edi
-80101c5e:	5d                   	pop    %ebp
-    return devsw[ip->major].write(ip, src, n);
-80101c5f:	ff e0                	jmp    *%eax
-80101c61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    ip->size = off;
-80101c68:	8b 45 d8             	mov    -0x28(%ebp),%eax
-    iupdate(ip);
-80101c6b:	83 ec 0c             	sub    $0xc,%esp
-    ip->size = off;
-80101c6e:	89 70 58             	mov    %esi,0x58(%eax)
-    iupdate(ip);
-80101c71:	50                   	push   %eax
-80101c72:	e8 29 fa ff ff       	call   801016a0 <iupdate>
-80101c77:	83 c4 10             	add    $0x10,%esp
-80101c7a:	eb b5                	jmp    80101c31 <writei+0xd1>
-      return -1;
-80101c7c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80101c81:	eb b1                	jmp    80101c34 <writei+0xd4>
-80101c83:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101c8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80101c90 <namecmp>:
-//PAGEBREAK!
-// Directories
-
-int
-namecmp(const char *s, const char *t)
-{
-80101c90:	f3 0f 1e fb          	endbr32 
-80101c94:	55                   	push   %ebp
-80101c95:	89 e5                	mov    %esp,%ebp
-80101c97:	83 ec 0c             	sub    $0xc,%esp
-  return strncmp(s, t, DIRSIZ);
-80101c9a:	6a 0e                	push   $0xe
-80101c9c:	ff 75 0c             	pushl  0xc(%ebp)
-80101c9f:	ff 75 08             	pushl  0x8(%ebp)
-80101ca2:	e8 39 33 00 00       	call   80104fe0 <strncmp>
-}
-80101ca7:	c9                   	leave  
-80101ca8:	c3                   	ret    
-80101ca9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-80101cb0 <dirlookup>:
-
-// Look for a directory entry in a directory.
-// If found, set *poff to byte offset of entry.
-struct inode*
-dirlookup(struct inode *dp, char *name, uint *poff)
-{
-80101cb0:	f3 0f 1e fb          	endbr32 
-80101cb4:	55                   	push   %ebp
-80101cb5:	89 e5                	mov    %esp,%ebp
-80101cb7:	57                   	push   %edi
-80101cb8:	56                   	push   %esi
-80101cb9:	53                   	push   %ebx
-80101cba:	83 ec 1c             	sub    $0x1c,%esp
-80101cbd:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  uint off, inum;
-  struct dirent de;
-
-  if(dp->type != T_DIR)
-80101cc0:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
-80101cc5:	0f 85 89 00 00 00    	jne    80101d54 <dirlookup+0xa4>
-    panic("dirlookup not DIR");
-
-  for(off = 0; off < dp->size; off += sizeof(de)){
-80101ccb:	8b 53 58             	mov    0x58(%ebx),%edx
-80101cce:	31 ff                	xor    %edi,%edi
-80101cd0:	8d 75 d8             	lea    -0x28(%ebp),%esi
-80101cd3:	85 d2                	test   %edx,%edx
-80101cd5:	74 42                	je     80101d19 <dirlookup+0x69>
-80101cd7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101cde:	66 90                	xchg   %ax,%ax
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-80101ce0:	6a 10                	push   $0x10
-80101ce2:	57                   	push   %edi
-80101ce3:	56                   	push   %esi
-80101ce4:	53                   	push   %ebx
-80101ce5:	e8 76 fd ff ff       	call   80101a60 <readi>
-80101cea:	83 c4 10             	add    $0x10,%esp
-80101ced:	83 f8 10             	cmp    $0x10,%eax
-80101cf0:	75 55                	jne    80101d47 <dirlookup+0x97>
-      panic("dirlookup read");
-    if(de.inum == 0)
-80101cf2:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
-80101cf7:	74 18                	je     80101d11 <dirlookup+0x61>
-  return strncmp(s, t, DIRSIZ);
-80101cf9:	83 ec 04             	sub    $0x4,%esp
-80101cfc:	8d 45 da             	lea    -0x26(%ebp),%eax
-80101cff:	6a 0e                	push   $0xe
-80101d01:	50                   	push   %eax
-80101d02:	ff 75 0c             	pushl  0xc(%ebp)
-80101d05:	e8 d6 32 00 00       	call   80104fe0 <strncmp>
-      continue;
-    if(namecmp(name, de.name) == 0){
-80101d0a:	83 c4 10             	add    $0x10,%esp
-80101d0d:	85 c0                	test   %eax,%eax
-80101d0f:	74 17                	je     80101d28 <dirlookup+0x78>
-  for(off = 0; off < dp->size; off += sizeof(de)){
-80101d11:	83 c7 10             	add    $0x10,%edi
-80101d14:	3b 7b 58             	cmp    0x58(%ebx),%edi
-80101d17:	72 c7                	jb     80101ce0 <dirlookup+0x30>
-      return iget(dp->dev, inum);
-    }
-  }
-
-  return 0;
-}
-80101d19:	8d 65 f4             	lea    -0xc(%ebp),%esp
-  return 0;
-80101d1c:	31 c0                	xor    %eax,%eax
-}
-80101d1e:	5b                   	pop    %ebx
-80101d1f:	5e                   	pop    %esi
-80101d20:	5f                   	pop    %edi
-80101d21:	5d                   	pop    %ebp
-80101d22:	c3                   	ret    
-80101d23:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80101d27:	90                   	nop
-      if(poff)
-80101d28:	8b 45 10             	mov    0x10(%ebp),%eax
-80101d2b:	85 c0                	test   %eax,%eax
-80101d2d:	74 05                	je     80101d34 <dirlookup+0x84>
-        *poff = off;
-80101d2f:	8b 45 10             	mov    0x10(%ebp),%eax
-80101d32:	89 38                	mov    %edi,(%eax)
-      inum = de.inum;
-80101d34:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
-      return iget(dp->dev, inum);
-80101d38:	8b 03                	mov    (%ebx),%eax
-80101d3a:	e8 01 f6 ff ff       	call   80101340 <iget>
-}
-80101d3f:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80101d42:	5b                   	pop    %ebx
-80101d43:	5e                   	pop    %esi
-80101d44:	5f                   	pop    %edi
-80101d45:	5d                   	pop    %ebp
-80101d46:	c3                   	ret    
-      panic("dirlookup read");
-80101d47:	83 ec 0c             	sub    $0xc,%esp
-80101d4a:	68 d9 7d 10 80       	push   $0x80107dd9
-80101d4f:	e8 3c e6 ff ff       	call   80100390 <panic>
-    panic("dirlookup not DIR");
-80101d54:	83 ec 0c             	sub    $0xc,%esp
-80101d57:	68 c7 7d 10 80       	push   $0x80107dc7
-80101d5c:	e8 2f e6 ff ff       	call   80100390 <panic>
-80101d61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101d68:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101d6f:	90                   	nop
-
-80101d70 <namex>:
-// If parent != 0, return the inode for the parent and copy the final
-// path element into name, which must have room for DIRSIZ bytes.
-// Must be called inside a transaction since it calls iput().
-static struct inode*
-namex(char *path, int nameiparent, char *name)
-{
-80101d70:	55                   	push   %ebp
-80101d71:	89 e5                	mov    %esp,%ebp
-80101d73:	57                   	push   %edi
-80101d74:	56                   	push   %esi
-80101d75:	53                   	push   %ebx
-80101d76:	89 c3                	mov    %eax,%ebx
-80101d78:	83 ec 1c             	sub    $0x1c,%esp
-  struct inode *ip, *next;
-
-  if(*path == '/')
-80101d7b:	80 38 2f             	cmpb   $0x2f,(%eax)
-{
-80101d7e:	89 55 e0             	mov    %edx,-0x20(%ebp)
-80101d81:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
-  if(*path == '/')
-80101d84:	0f 84 86 01 00 00    	je     80101f10 <namex+0x1a0>
-    ip = iget(ROOTDEV, ROOTINO);
-  else
-    ip = idup(myproc()->cwd);
-80101d8a:	e8 21 1c 00 00       	call   801039b0 <myproc>
-  acquire(&icache.lock);
-80101d8f:	83 ec 0c             	sub    $0xc,%esp
-80101d92:	89 df                	mov    %ebx,%edi
-    ip = idup(myproc()->cwd);
-80101d94:	8b 70 68             	mov    0x68(%eax),%esi
-  acquire(&icache.lock);
-80101d97:	68 00 1a 11 80       	push   $0x80111a00
-80101d9c:	e8 1f 30 00 00       	call   80104dc0 <acquire>
-  ip->ref++;
-80101da1:	83 46 08 01          	addl   $0x1,0x8(%esi)
-  release(&icache.lock);
-80101da5:	c7 04 24 00 1a 11 80 	movl   $0x80111a00,(%esp)
-80101dac:	e8 cf 30 00 00       	call   80104e80 <release>
-80101db1:	83 c4 10             	add    $0x10,%esp
-80101db4:	eb 0d                	jmp    80101dc3 <namex+0x53>
-80101db6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101dbd:	8d 76 00             	lea    0x0(%esi),%esi
-    path++;
-80101dc0:	83 c7 01             	add    $0x1,%edi
-  while(*path == '/')
-80101dc3:	0f b6 07             	movzbl (%edi),%eax
-80101dc6:	3c 2f                	cmp    $0x2f,%al
-80101dc8:	74 f6                	je     80101dc0 <namex+0x50>
-  if(*path == 0)
-80101dca:	84 c0                	test   %al,%al
-80101dcc:	0f 84 ee 00 00 00    	je     80101ec0 <namex+0x150>
-  while(*path != '/' && *path != 0)
-80101dd2:	0f b6 07             	movzbl (%edi),%eax
-80101dd5:	84 c0                	test   %al,%al
-80101dd7:	0f 84 fb 00 00 00    	je     80101ed8 <namex+0x168>
-80101ddd:	89 fb                	mov    %edi,%ebx
-80101ddf:	3c 2f                	cmp    $0x2f,%al
-80101de1:	0f 84 f1 00 00 00    	je     80101ed8 <namex+0x168>
-80101de7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101dee:	66 90                	xchg   %ax,%ax
-80101df0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
-    path++;
-80101df4:	83 c3 01             	add    $0x1,%ebx
-  while(*path != '/' && *path != 0)
-80101df7:	3c 2f                	cmp    $0x2f,%al
-80101df9:	74 04                	je     80101dff <namex+0x8f>
-80101dfb:	84 c0                	test   %al,%al
-80101dfd:	75 f1                	jne    80101df0 <namex+0x80>
-  len = path - s;
-80101dff:	89 d8                	mov    %ebx,%eax
-80101e01:	29 f8                	sub    %edi,%eax
-  if(len >= DIRSIZ)
-80101e03:	83 f8 0d             	cmp    $0xd,%eax
-80101e06:	0f 8e 84 00 00 00    	jle    80101e90 <namex+0x120>
-    memmove(name, s, DIRSIZ);
-80101e0c:	83 ec 04             	sub    $0x4,%esp
-80101e0f:	6a 0e                	push   $0xe
-80101e11:	57                   	push   %edi
-    path++;
-80101e12:	89 df                	mov    %ebx,%edi
-    memmove(name, s, DIRSIZ);
-80101e14:	ff 75 e4             	pushl  -0x1c(%ebp)
-80101e17:	e8 54 31 00 00       	call   80104f70 <memmove>
-80101e1c:	83 c4 10             	add    $0x10,%esp
-  while(*path == '/')
-80101e1f:	80 3b 2f             	cmpb   $0x2f,(%ebx)
-80101e22:	75 0c                	jne    80101e30 <namex+0xc0>
-80101e24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    path++;
-80101e28:	83 c7 01             	add    $0x1,%edi
-  while(*path == '/')
-80101e2b:	80 3f 2f             	cmpb   $0x2f,(%edi)
-80101e2e:	74 f8                	je     80101e28 <namex+0xb8>
-
-  while((path = skipelem(path, name)) != 0){
-    ilock(ip);
-80101e30:	83 ec 0c             	sub    $0xc,%esp
-80101e33:	56                   	push   %esi
-80101e34:	e8 27 f9 ff ff       	call   80101760 <ilock>
-    if(ip->type != T_DIR){
-80101e39:	83 c4 10             	add    $0x10,%esp
-80101e3c:	66 83 7e 50 01       	cmpw   $0x1,0x50(%esi)
-80101e41:	0f 85 a1 00 00 00    	jne    80101ee8 <namex+0x178>
-      iunlockput(ip);
-      return 0;
-    }
-    if(nameiparent && *path == '\0'){
-80101e47:	8b 55 e0             	mov    -0x20(%ebp),%edx
-80101e4a:	85 d2                	test   %edx,%edx
-80101e4c:	74 09                	je     80101e57 <namex+0xe7>
-80101e4e:	80 3f 00             	cmpb   $0x0,(%edi)
-80101e51:	0f 84 d9 00 00 00    	je     80101f30 <namex+0x1c0>
-      // Stop one level early.
-      iunlock(ip);
-      return ip;
-    }
-    if((next = dirlookup(ip, name, 0)) == 0){
-80101e57:	83 ec 04             	sub    $0x4,%esp
-80101e5a:	6a 00                	push   $0x0
-80101e5c:	ff 75 e4             	pushl  -0x1c(%ebp)
-80101e5f:	56                   	push   %esi
-80101e60:	e8 4b fe ff ff       	call   80101cb0 <dirlookup>
-80101e65:	83 c4 10             	add    $0x10,%esp
-80101e68:	89 c3                	mov    %eax,%ebx
-80101e6a:	85 c0                	test   %eax,%eax
-80101e6c:	74 7a                	je     80101ee8 <namex+0x178>
-  iunlock(ip);
-80101e6e:	83 ec 0c             	sub    $0xc,%esp
-80101e71:	56                   	push   %esi
-80101e72:	e8 c9 f9 ff ff       	call   80101840 <iunlock>
-  iput(ip);
-80101e77:	89 34 24             	mov    %esi,(%esp)
-80101e7a:	89 de                	mov    %ebx,%esi
-80101e7c:	e8 0f fa ff ff       	call   80101890 <iput>
-80101e81:	83 c4 10             	add    $0x10,%esp
-80101e84:	e9 3a ff ff ff       	jmp    80101dc3 <namex+0x53>
-80101e89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101e90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-80101e93:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
-80101e96:	89 4d dc             	mov    %ecx,-0x24(%ebp)
-    memmove(name, s, len);
-80101e99:	83 ec 04             	sub    $0x4,%esp
-80101e9c:	50                   	push   %eax
-80101e9d:	57                   	push   %edi
-    name[len] = 0;
-80101e9e:	89 df                	mov    %ebx,%edi
-    memmove(name, s, len);
-80101ea0:	ff 75 e4             	pushl  -0x1c(%ebp)
-80101ea3:	e8 c8 30 00 00       	call   80104f70 <memmove>
-    name[len] = 0;
-80101ea8:	8b 45 dc             	mov    -0x24(%ebp),%eax
-80101eab:	83 c4 10             	add    $0x10,%esp
-80101eae:	c6 00 00             	movb   $0x0,(%eax)
-80101eb1:	e9 69 ff ff ff       	jmp    80101e1f <namex+0xaf>
-80101eb6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101ebd:	8d 76 00             	lea    0x0(%esi),%esi
-      return 0;
-    }
-    iunlockput(ip);
-    ip = next;
-  }
-  if(nameiparent){
-80101ec0:	8b 45 e0             	mov    -0x20(%ebp),%eax
-80101ec3:	85 c0                	test   %eax,%eax
-80101ec5:	0f 85 85 00 00 00    	jne    80101f50 <namex+0x1e0>
-    iput(ip);
-    return 0;
-  }
-  return ip;
-}
-80101ecb:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80101ece:	89 f0                	mov    %esi,%eax
-80101ed0:	5b                   	pop    %ebx
-80101ed1:	5e                   	pop    %esi
-80101ed2:	5f                   	pop    %edi
-80101ed3:	5d                   	pop    %ebp
-80101ed4:	c3                   	ret    
-80101ed5:	8d 76 00             	lea    0x0(%esi),%esi
-  while(*path != '/' && *path != 0)
-80101ed8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-80101edb:	89 fb                	mov    %edi,%ebx
-80101edd:	89 45 dc             	mov    %eax,-0x24(%ebp)
-80101ee0:	31 c0                	xor    %eax,%eax
-80101ee2:	eb b5                	jmp    80101e99 <namex+0x129>
-80101ee4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  iunlock(ip);
-80101ee8:	83 ec 0c             	sub    $0xc,%esp
-80101eeb:	56                   	push   %esi
-80101eec:	e8 4f f9 ff ff       	call   80101840 <iunlock>
-  iput(ip);
-80101ef1:	89 34 24             	mov    %esi,(%esp)
-      return 0;
-80101ef4:	31 f6                	xor    %esi,%esi
-  iput(ip);
-80101ef6:	e8 95 f9 ff ff       	call   80101890 <iput>
-      return 0;
-80101efb:	83 c4 10             	add    $0x10,%esp
-}
-80101efe:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80101f01:	89 f0                	mov    %esi,%eax
-80101f03:	5b                   	pop    %ebx
-80101f04:	5e                   	pop    %esi
-80101f05:	5f                   	pop    %edi
-80101f06:	5d                   	pop    %ebp
-80101f07:	c3                   	ret    
-80101f08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101f0f:	90                   	nop
-    ip = iget(ROOTDEV, ROOTINO);
-80101f10:	ba 01 00 00 00       	mov    $0x1,%edx
-80101f15:	b8 01 00 00 00       	mov    $0x1,%eax
-80101f1a:	89 df                	mov    %ebx,%edi
-80101f1c:	e8 1f f4 ff ff       	call   80101340 <iget>
-80101f21:	89 c6                	mov    %eax,%esi
-80101f23:	e9 9b fe ff ff       	jmp    80101dc3 <namex+0x53>
-80101f28:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101f2f:	90                   	nop
-      iunlock(ip);
-80101f30:	83 ec 0c             	sub    $0xc,%esp
-80101f33:	56                   	push   %esi
-80101f34:	e8 07 f9 ff ff       	call   80101840 <iunlock>
-      return ip;
-80101f39:	83 c4 10             	add    $0x10,%esp
-}
-80101f3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80101f3f:	89 f0                	mov    %esi,%eax
-80101f41:	5b                   	pop    %ebx
-80101f42:	5e                   	pop    %esi
-80101f43:	5f                   	pop    %edi
-80101f44:	5d                   	pop    %ebp
-80101f45:	c3                   	ret    
-80101f46:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101f4d:	8d 76 00             	lea    0x0(%esi),%esi
-    iput(ip);
-80101f50:	83 ec 0c             	sub    $0xc,%esp
-80101f53:	56                   	push   %esi
-    return 0;
-80101f54:	31 f6                	xor    %esi,%esi
-    iput(ip);
-80101f56:	e8 35 f9 ff ff       	call   80101890 <iput>
-    return 0;
-80101f5b:	83 c4 10             	add    $0x10,%esp
-80101f5e:	e9 68 ff ff ff       	jmp    80101ecb <namex+0x15b>
-80101f63:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80101f6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80101f70 <dirlink>:
-{
-80101f70:	f3 0f 1e fb          	endbr32 
-80101f74:	55                   	push   %ebp
-80101f75:	89 e5                	mov    %esp,%ebp
-80101f77:	57                   	push   %edi
-80101f78:	56                   	push   %esi
-80101f79:	53                   	push   %ebx
-80101f7a:	83 ec 20             	sub    $0x20,%esp
-80101f7d:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  if((ip = dirlookup(dp, name, 0)) != 0){
-80101f80:	6a 00                	push   $0x0
-80101f82:	ff 75 0c             	pushl  0xc(%ebp)
-80101f85:	53                   	push   %ebx
-80101f86:	e8 25 fd ff ff       	call   80101cb0 <dirlookup>
-80101f8b:	83 c4 10             	add    $0x10,%esp
-80101f8e:	85 c0                	test   %eax,%eax
-80101f90:	75 6b                	jne    80101ffd <dirlink+0x8d>
-  for(off = 0; off < dp->size; off += sizeof(de)){
-80101f92:	8b 7b 58             	mov    0x58(%ebx),%edi
-80101f95:	8d 75 d8             	lea    -0x28(%ebp),%esi
-80101f98:	85 ff                	test   %edi,%edi
-80101f9a:	74 2d                	je     80101fc9 <dirlink+0x59>
-80101f9c:	31 ff                	xor    %edi,%edi
-80101f9e:	8d 75 d8             	lea    -0x28(%ebp),%esi
-80101fa1:	eb 0d                	jmp    80101fb0 <dirlink+0x40>
-80101fa3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80101fa7:	90                   	nop
-80101fa8:	83 c7 10             	add    $0x10,%edi
-80101fab:	3b 7b 58             	cmp    0x58(%ebx),%edi
-80101fae:	73 19                	jae    80101fc9 <dirlink+0x59>
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-80101fb0:	6a 10                	push   $0x10
-80101fb2:	57                   	push   %edi
-80101fb3:	56                   	push   %esi
-80101fb4:	53                   	push   %ebx
-80101fb5:	e8 a6 fa ff ff       	call   80101a60 <readi>
-80101fba:	83 c4 10             	add    $0x10,%esp
-80101fbd:	83 f8 10             	cmp    $0x10,%eax
-80101fc0:	75 4e                	jne    80102010 <dirlink+0xa0>
-    if(de.inum == 0)
-80101fc2:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
-80101fc7:	75 df                	jne    80101fa8 <dirlink+0x38>
-  strncpy(de.name, name, DIRSIZ);
-80101fc9:	83 ec 04             	sub    $0x4,%esp
-80101fcc:	8d 45 da             	lea    -0x26(%ebp),%eax
-80101fcf:	6a 0e                	push   $0xe
-80101fd1:	ff 75 0c             	pushl  0xc(%ebp)
-80101fd4:	50                   	push   %eax
-80101fd5:	e8 56 30 00 00       	call   80105030 <strncpy>
-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-80101fda:	6a 10                	push   $0x10
-  de.inum = inum;
-80101fdc:	8b 45 10             	mov    0x10(%ebp),%eax
-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-80101fdf:	57                   	push   %edi
-80101fe0:	56                   	push   %esi
-80101fe1:	53                   	push   %ebx
-  de.inum = inum;
-80101fe2:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-80101fe6:	e8 75 fb ff ff       	call   80101b60 <writei>
-80101feb:	83 c4 20             	add    $0x20,%esp
-80101fee:	83 f8 10             	cmp    $0x10,%eax
-80101ff1:	75 2a                	jne    8010201d <dirlink+0xad>
-  return 0;
-80101ff3:	31 c0                	xor    %eax,%eax
-}
-80101ff5:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80101ff8:	5b                   	pop    %ebx
-80101ff9:	5e                   	pop    %esi
-80101ffa:	5f                   	pop    %edi
-80101ffb:	5d                   	pop    %ebp
-80101ffc:	c3                   	ret    
-    iput(ip);
-80101ffd:	83 ec 0c             	sub    $0xc,%esp
-80102000:	50                   	push   %eax
-80102001:	e8 8a f8 ff ff       	call   80101890 <iput>
-    return -1;
-80102006:	83 c4 10             	add    $0x10,%esp
-80102009:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-8010200e:	eb e5                	jmp    80101ff5 <dirlink+0x85>
-      panic("dirlink read");
-80102010:	83 ec 0c             	sub    $0xc,%esp
-80102013:	68 e8 7d 10 80       	push   $0x80107de8
-80102018:	e8 73 e3 ff ff       	call   80100390 <panic>
-    panic("dirlink");
-8010201d:	83 ec 0c             	sub    $0xc,%esp
-80102020:	68 ea 83 10 80       	push   $0x801083ea
-80102025:	e8 66 e3 ff ff       	call   80100390 <panic>
-8010202a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80102030 <namei>:
-
-struct inode*
-namei(char *path)
-{
-80102030:	f3 0f 1e fb          	endbr32 
-80102034:	55                   	push   %ebp
-  char name[DIRSIZ];
-  return namex(path, 0, name);
-80102035:	31 d2                	xor    %edx,%edx
-{
-80102037:	89 e5                	mov    %esp,%ebp
-80102039:	83 ec 18             	sub    $0x18,%esp
-  return namex(path, 0, name);
-8010203c:	8b 45 08             	mov    0x8(%ebp),%eax
-8010203f:	8d 4d ea             	lea    -0x16(%ebp),%ecx
-80102042:	e8 29 fd ff ff       	call   80101d70 <namex>
-}
-80102047:	c9                   	leave  
-80102048:	c3                   	ret    
-80102049:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-80102050 <nameiparent>:
-
-struct inode*
-nameiparent(char *path, char *name)
-{
-80102050:	f3 0f 1e fb          	endbr32 
-80102054:	55                   	push   %ebp
-  return namex(path, 1, name);
-80102055:	ba 01 00 00 00       	mov    $0x1,%edx
-{
-8010205a:	89 e5                	mov    %esp,%ebp
-  return namex(path, 1, name);
-8010205c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
-8010205f:	8b 45 08             	mov    0x8(%ebp),%eax
-}
-80102062:	5d                   	pop    %ebp
-  return namex(path, 1, name);
-80102063:	e9 08 fd ff ff       	jmp    80101d70 <namex>
-80102068:	66 90                	xchg   %ax,%ax
-8010206a:	66 90                	xchg   %ax,%ax
-8010206c:	66 90                	xchg   %ax,%ax
-8010206e:	66 90                	xchg   %ax,%ax
-
-80102070 <idestart>:
-}
-
-// Start the request for b.  Caller must hold idelock.
-static void
-idestart(struct buf *b)
-{
-80102070:	55                   	push   %ebp
-80102071:	89 e5                	mov    %esp,%ebp
-80102073:	57                   	push   %edi
-80102074:	56                   	push   %esi
-80102075:	53                   	push   %ebx
-80102076:	83 ec 0c             	sub    $0xc,%esp
-  if(b == 0)
-80102079:	85 c0                	test   %eax,%eax
-8010207b:	0f 84 b4 00 00 00    	je     80102135 <idestart+0xc5>
-    panic("idestart");
-  if(b->blockno >= FSSIZE)
-80102081:	8b 70 08             	mov    0x8(%eax),%esi
-80102084:	89 c3                	mov    %eax,%ebx
-80102086:	81 fe e7 03 00 00    	cmp    $0x3e7,%esi
-8010208c:	0f 87 96 00 00 00    	ja     80102128 <idestart+0xb8>
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80102092:	b9 f7 01 00 00       	mov    $0x1f7,%ecx
-80102097:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010209e:	66 90                	xchg   %ax,%ax
-801020a0:	89 ca                	mov    %ecx,%edx
-801020a2:	ec                   	in     (%dx),%al
-  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
-801020a3:	83 e0 c0             	and    $0xffffffc0,%eax
-801020a6:	3c 40                	cmp    $0x40,%al
-801020a8:	75 f6                	jne    801020a0 <idestart+0x30>
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-801020aa:	31 ff                	xor    %edi,%edi
-801020ac:	ba f6 03 00 00       	mov    $0x3f6,%edx
-801020b1:	89 f8                	mov    %edi,%eax
-801020b3:	ee                   	out    %al,(%dx)
-801020b4:	b8 01 00 00 00       	mov    $0x1,%eax
-801020b9:	ba f2 01 00 00       	mov    $0x1f2,%edx
-801020be:	ee                   	out    %al,(%dx)
-801020bf:	ba f3 01 00 00       	mov    $0x1f3,%edx
-801020c4:	89 f0                	mov    %esi,%eax
-801020c6:	ee                   	out    %al,(%dx)
-
-  idewait(0);
-  outb(0x3f6, 0);  // generate interrupt
-  outb(0x1f2, sector_per_block);  // number of sectors
-  outb(0x1f3, sector & 0xff);
-  outb(0x1f4, (sector >> 8) & 0xff);
-801020c7:	89 f0                	mov    %esi,%eax
-801020c9:	ba f4 01 00 00       	mov    $0x1f4,%edx
-801020ce:	c1 f8 08             	sar    $0x8,%eax
-801020d1:	ee                   	out    %al,(%dx)
-801020d2:	ba f5 01 00 00       	mov    $0x1f5,%edx
-801020d7:	89 f8                	mov    %edi,%eax
-801020d9:	ee                   	out    %al,(%dx)
-  outb(0x1f5, (sector >> 16) & 0xff);
-  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
-801020da:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
-801020de:	ba f6 01 00 00       	mov    $0x1f6,%edx
-801020e3:	c1 e0 04             	shl    $0x4,%eax
-801020e6:	83 e0 10             	and    $0x10,%eax
-801020e9:	83 c8 e0             	or     $0xffffffe0,%eax
-801020ec:	ee                   	out    %al,(%dx)
-  if(b->flags & B_DIRTY){
-801020ed:	f6 03 04             	testb  $0x4,(%ebx)
-801020f0:	75 16                	jne    80102108 <idestart+0x98>
-801020f2:	b8 20 00 00 00       	mov    $0x20,%eax
-801020f7:	89 ca                	mov    %ecx,%edx
-801020f9:	ee                   	out    %al,(%dx)
-    outb(0x1f7, write_cmd);
-    outsl(0x1f0, b->data, BSIZE/4);
-  } else {
-    outb(0x1f7, read_cmd);
-  }
-}
-801020fa:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801020fd:	5b                   	pop    %ebx
-801020fe:	5e                   	pop    %esi
-801020ff:	5f                   	pop    %edi
-80102100:	5d                   	pop    %ebp
-80102101:	c3                   	ret    
-80102102:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-80102108:	b8 30 00 00 00       	mov    $0x30,%eax
-8010210d:	89 ca                	mov    %ecx,%edx
-8010210f:	ee                   	out    %al,(%dx)
-  asm volatile("cld; rep outsl" :
-80102110:	b9 80 00 00 00       	mov    $0x80,%ecx
-    outsl(0x1f0, b->data, BSIZE/4);
-80102115:	8d 73 5c             	lea    0x5c(%ebx),%esi
-80102118:	ba f0 01 00 00       	mov    $0x1f0,%edx
-8010211d:	fc                   	cld    
-8010211e:	f3 6f                	rep outsl %ds:(%esi),(%dx)
-}
-80102120:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80102123:	5b                   	pop    %ebx
-80102124:	5e                   	pop    %esi
-80102125:	5f                   	pop    %edi
-80102126:	5d                   	pop    %ebp
-80102127:	c3                   	ret    
-    panic("incorrect blockno");
-80102128:	83 ec 0c             	sub    $0xc,%esp
-8010212b:	68 54 7e 10 80       	push   $0x80107e54
-80102130:	e8 5b e2 ff ff       	call   80100390 <panic>
-    panic("idestart");
-80102135:	83 ec 0c             	sub    $0xc,%esp
-80102138:	68 4b 7e 10 80       	push   $0x80107e4b
-8010213d:	e8 4e e2 ff ff       	call   80100390 <panic>
-80102142:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80102149:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-80102150 <ideinit>:
-{
-80102150:	f3 0f 1e fb          	endbr32 
-80102154:	55                   	push   %ebp
-80102155:	89 e5                	mov    %esp,%ebp
-80102157:	83 ec 10             	sub    $0x10,%esp
-  initlock(&idelock, "ide");
-8010215a:	68 66 7e 10 80       	push   $0x80107e66
-8010215f:	68 80 b5 10 80       	push   $0x8010b580
-80102164:	e8 d7 2a 00 00       	call   80104c40 <initlock>
-  ioapicenable(IRQ_IDE, ncpu - 1);
-80102169:	58                   	pop    %eax
-8010216a:	a1 20 3d 11 80       	mov    0x80113d20,%eax
-8010216f:	5a                   	pop    %edx
-80102170:	83 e8 01             	sub    $0x1,%eax
-80102173:	50                   	push   %eax
-80102174:	6a 0e                	push   $0xe
-80102176:	e8 b5 02 00 00       	call   80102430 <ioapicenable>
-  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
-8010217b:	83 c4 10             	add    $0x10,%esp
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-8010217e:	ba f7 01 00 00       	mov    $0x1f7,%edx
-80102183:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80102187:	90                   	nop
-80102188:	ec                   	in     (%dx),%al
-80102189:	83 e0 c0             	and    $0xffffffc0,%eax
-8010218c:	3c 40                	cmp    $0x40,%al
-8010218e:	75 f8                	jne    80102188 <ideinit+0x38>
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-80102190:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
-80102195:	ba f6 01 00 00       	mov    $0x1f6,%edx
-8010219a:	ee                   	out    %al,(%dx)
-8010219b:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-801021a0:	ba f7 01 00 00       	mov    $0x1f7,%edx
-801021a5:	eb 0e                	jmp    801021b5 <ideinit+0x65>
-801021a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801021ae:	66 90                	xchg   %ax,%ax
-  for(i=0; i<1000; i++){
-801021b0:	83 e9 01             	sub    $0x1,%ecx
-801021b3:	74 0f                	je     801021c4 <ideinit+0x74>
-801021b5:	ec                   	in     (%dx),%al
-    if(inb(0x1f7) != 0){
-801021b6:	84 c0                	test   %al,%al
-801021b8:	74 f6                	je     801021b0 <ideinit+0x60>
-      havedisk1 = 1;
-801021ba:	c7 05 60 b5 10 80 01 	movl   $0x1,0x8010b560
-801021c1:	00 00 00 
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-801021c4:	b8 e0 ff ff ff       	mov    $0xffffffe0,%eax
-801021c9:	ba f6 01 00 00       	mov    $0x1f6,%edx
-801021ce:	ee                   	out    %al,(%dx)
-}
-801021cf:	c9                   	leave  
-801021d0:	c3                   	ret    
-801021d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801021d8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801021df:	90                   	nop
-
-801021e0 <ideintr>:
-
-// Interrupt handler.
-void
-ideintr(void)
-{
-801021e0:	f3 0f 1e fb          	endbr32 
-801021e4:	55                   	push   %ebp
-801021e5:	89 e5                	mov    %esp,%ebp
-801021e7:	57                   	push   %edi
-801021e8:	56                   	push   %esi
-801021e9:	53                   	push   %ebx
-801021ea:	83 ec 18             	sub    $0x18,%esp
-  struct buf *b;
-
-  // First queued buffer is the active request.
-  acquire(&idelock);
-801021ed:	68 80 b5 10 80       	push   $0x8010b580
-801021f2:	e8 c9 2b 00 00       	call   80104dc0 <acquire>
-
-  if((b = idequeue) == 0){
-801021f7:	8b 1d 64 b5 10 80    	mov    0x8010b564,%ebx
-801021fd:	83 c4 10             	add    $0x10,%esp
-80102200:	85 db                	test   %ebx,%ebx
-80102202:	74 5f                	je     80102263 <ideintr+0x83>
-    release(&idelock);
-    return;
-  }
-  idequeue = b->qnext;
-80102204:	8b 43 58             	mov    0x58(%ebx),%eax
-80102207:	a3 64 b5 10 80       	mov    %eax,0x8010b564
-
-  // Read data if needed.
-  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
-8010220c:	8b 33                	mov    (%ebx),%esi
-8010220e:	f7 c6 04 00 00 00    	test   $0x4,%esi
-80102214:	75 2b                	jne    80102241 <ideintr+0x61>
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80102216:	ba f7 01 00 00       	mov    $0x1f7,%edx
-8010221b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010221f:	90                   	nop
-80102220:	ec                   	in     (%dx),%al
-  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
-80102221:	89 c1                	mov    %eax,%ecx
-80102223:	83 e1 c0             	and    $0xffffffc0,%ecx
-80102226:	80 f9 40             	cmp    $0x40,%cl
-80102229:	75 f5                	jne    80102220 <ideintr+0x40>
-  if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
-8010222b:	a8 21                	test   $0x21,%al
-8010222d:	75 12                	jne    80102241 <ideintr+0x61>
-    insl(0x1f0, b->data, BSIZE/4);
-8010222f:	8d 7b 5c             	lea    0x5c(%ebx),%edi
-  asm volatile("cld; rep insl" :
-80102232:	b9 80 00 00 00       	mov    $0x80,%ecx
-80102237:	ba f0 01 00 00       	mov    $0x1f0,%edx
-8010223c:	fc                   	cld    
-8010223d:	f3 6d                	rep insl (%dx),%es:(%edi)
-8010223f:	8b 33                	mov    (%ebx),%esi
-
-  // Wake process waiting for this buf.
-  b->flags |= B_VALID;
-  b->flags &= ~B_DIRTY;
-80102241:	83 e6 fb             	and    $0xfffffffb,%esi
-  wakeup(b);
-80102244:	83 ec 0c             	sub    $0xc,%esp
-  b->flags &= ~B_DIRTY;
-80102247:	83 ce 02             	or     $0x2,%esi
-8010224a:	89 33                	mov    %esi,(%ebx)
-  wakeup(b);
-8010224c:	53                   	push   %ebx
-8010224d:	e8 6e 22 00 00       	call   801044c0 <wakeup>
-
-  // Start disk on next buf in queue.
-  if(idequeue != 0)
-80102252:	a1 64 b5 10 80       	mov    0x8010b564,%eax
-80102257:	83 c4 10             	add    $0x10,%esp
-8010225a:	85 c0                	test   %eax,%eax
-8010225c:	74 05                	je     80102263 <ideintr+0x83>
-    idestart(idequeue);
-8010225e:	e8 0d fe ff ff       	call   80102070 <idestart>
-    release(&idelock);
-80102263:	83 ec 0c             	sub    $0xc,%esp
-80102266:	68 80 b5 10 80       	push   $0x8010b580
-8010226b:	e8 10 2c 00 00       	call   80104e80 <release>
-
-  release(&idelock);
-}
-80102270:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80102273:	5b                   	pop    %ebx
-80102274:	5e                   	pop    %esi
-80102275:	5f                   	pop    %edi
-80102276:	5d                   	pop    %ebp
-80102277:	c3                   	ret    
-80102278:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010227f:	90                   	nop
-
-80102280 <iderw>:
-// Sync buf with disk.
-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
-// Else if B_VALID is not set, read buf from disk, set B_VALID.
-void
-iderw(struct buf *b)
-{
-80102280:	f3 0f 1e fb          	endbr32 
-80102284:	55                   	push   %ebp
-80102285:	89 e5                	mov    %esp,%ebp
-80102287:	53                   	push   %ebx
-80102288:	83 ec 10             	sub    $0x10,%esp
-8010228b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  struct buf **pp;
-
-  if(!holdingsleep(&b->lock))
-8010228e:	8d 43 0c             	lea    0xc(%ebx),%eax
-80102291:	50                   	push   %eax
-80102292:	e8 49 29 00 00       	call   80104be0 <holdingsleep>
-80102297:	83 c4 10             	add    $0x10,%esp
-8010229a:	85 c0                	test   %eax,%eax
-8010229c:	0f 84 cf 00 00 00    	je     80102371 <iderw+0xf1>
-    panic("iderw: buf not locked");
-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
-801022a2:	8b 03                	mov    (%ebx),%eax
-801022a4:	83 e0 06             	and    $0x6,%eax
-801022a7:	83 f8 02             	cmp    $0x2,%eax
-801022aa:	0f 84 b4 00 00 00    	je     80102364 <iderw+0xe4>
-    panic("iderw: nothing to do");
-  if(b->dev != 0 && !havedisk1)
-801022b0:	8b 53 04             	mov    0x4(%ebx),%edx
-801022b3:	85 d2                	test   %edx,%edx
-801022b5:	74 0d                	je     801022c4 <iderw+0x44>
-801022b7:	a1 60 b5 10 80       	mov    0x8010b560,%eax
-801022bc:	85 c0                	test   %eax,%eax
-801022be:	0f 84 93 00 00 00    	je     80102357 <iderw+0xd7>
-    panic("iderw: ide disk 1 not present");
-
-  acquire(&idelock);  //DOC:acquire-lock
-801022c4:	83 ec 0c             	sub    $0xc,%esp
-801022c7:	68 80 b5 10 80       	push   $0x8010b580
-801022cc:	e8 ef 2a 00 00       	call   80104dc0 <acquire>
-
-  // Append b to idequeue.
-  b->qnext = 0;
-  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
-801022d1:	a1 64 b5 10 80       	mov    0x8010b564,%eax
-  b->qnext = 0;
-801022d6:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
-  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
-801022dd:	83 c4 10             	add    $0x10,%esp
-801022e0:	85 c0                	test   %eax,%eax
-801022e2:	74 6c                	je     80102350 <iderw+0xd0>
-801022e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801022e8:	89 c2                	mov    %eax,%edx
-801022ea:	8b 40 58             	mov    0x58(%eax),%eax
-801022ed:	85 c0                	test   %eax,%eax
-801022ef:	75 f7                	jne    801022e8 <iderw+0x68>
-801022f1:	83 c2 58             	add    $0x58,%edx
-    ;
-  *pp = b;
-801022f4:	89 1a                	mov    %ebx,(%edx)
-
-  // Start disk if necessary.
-  if(idequeue == b)
-801022f6:	39 1d 64 b5 10 80    	cmp    %ebx,0x8010b564
-801022fc:	74 42                	je     80102340 <iderw+0xc0>
-    idestart(b);
-
-  // Wait for request to finish.
-  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
-801022fe:	8b 03                	mov    (%ebx),%eax
-80102300:	83 e0 06             	and    $0x6,%eax
-80102303:	83 f8 02             	cmp    $0x2,%eax
-80102306:	74 23                	je     8010232b <iderw+0xab>
-80102308:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010230f:	90                   	nop
-    sleep(b, &idelock);
-80102310:	83 ec 08             	sub    $0x8,%esp
-80102313:	68 80 b5 10 80       	push   $0x8010b580
-80102318:	53                   	push   %ebx
-80102319:	e8 e2 1f 00 00       	call   80104300 <sleep>
-  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
-8010231e:	8b 03                	mov    (%ebx),%eax
-80102320:	83 c4 10             	add    $0x10,%esp
-80102323:	83 e0 06             	and    $0x6,%eax
-80102326:	83 f8 02             	cmp    $0x2,%eax
-80102329:	75 e5                	jne    80102310 <iderw+0x90>
-  }
-
-
-  release(&idelock);
-8010232b:	c7 45 08 80 b5 10 80 	movl   $0x8010b580,0x8(%ebp)
-}
-80102332:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80102335:	c9                   	leave  
-  release(&idelock);
-80102336:	e9 45 2b 00 00       	jmp    80104e80 <release>
-8010233b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010233f:	90                   	nop
-    idestart(b);
-80102340:	89 d8                	mov    %ebx,%eax
-80102342:	e8 29 fd ff ff       	call   80102070 <idestart>
-80102347:	eb b5                	jmp    801022fe <iderw+0x7e>
-80102349:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
-80102350:	ba 64 b5 10 80       	mov    $0x8010b564,%edx
-80102355:	eb 9d                	jmp    801022f4 <iderw+0x74>
-    panic("iderw: ide disk 1 not present");
-80102357:	83 ec 0c             	sub    $0xc,%esp
-8010235a:	68 95 7e 10 80       	push   $0x80107e95
-8010235f:	e8 2c e0 ff ff       	call   80100390 <panic>
-    panic("iderw: nothing to do");
-80102364:	83 ec 0c             	sub    $0xc,%esp
-80102367:	68 80 7e 10 80       	push   $0x80107e80
-8010236c:	e8 1f e0 ff ff       	call   80100390 <panic>
-    panic("iderw: buf not locked");
-80102371:	83 ec 0c             	sub    $0xc,%esp
-80102374:	68 6a 7e 10 80       	push   $0x80107e6a
-80102379:	e8 12 e0 ff ff       	call   80100390 <panic>
-8010237e:	66 90                	xchg   %ax,%ax
-
-80102380 <ioapicinit>:
-  ioapic->data = data;
-}
-
-void
-ioapicinit(void)
-{
-80102380:	f3 0f 1e fb          	endbr32 
-80102384:	55                   	push   %ebp
-  int i, id, maxintr;
-
-  ioapic = (volatile struct ioapic*)IOAPIC;
-80102385:	c7 05 54 36 11 80 00 	movl   $0xfec00000,0x80113654
-8010238c:	00 c0 fe 
-{
-8010238f:	89 e5                	mov    %esp,%ebp
-80102391:	56                   	push   %esi
-80102392:	53                   	push   %ebx
-  ioapic->reg = reg;
-80102393:	c7 05 00 00 c0 fe 01 	movl   $0x1,0xfec00000
-8010239a:	00 00 00 
-  return ioapic->data;
-8010239d:	8b 15 54 36 11 80    	mov    0x80113654,%edx
-801023a3:	8b 72 10             	mov    0x10(%edx),%esi
-  ioapic->reg = reg;
-801023a6:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
-  return ioapic->data;
-801023ac:	8b 0d 54 36 11 80    	mov    0x80113654,%ecx
-  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
-  id = ioapicread(REG_ID) >> 24;
-  if(id != ioapicid)
-801023b2:	0f b6 15 80 37 11 80 	movzbl 0x80113780,%edx
-  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
-801023b9:	c1 ee 10             	shr    $0x10,%esi
-801023bc:	89 f0                	mov    %esi,%eax
-801023be:	0f b6 f0             	movzbl %al,%esi
-  return ioapic->data;
-801023c1:	8b 41 10             	mov    0x10(%ecx),%eax
-  id = ioapicread(REG_ID) >> 24;
-801023c4:	c1 e8 18             	shr    $0x18,%eax
-  if(id != ioapicid)
-801023c7:	39 c2                	cmp    %eax,%edx
-801023c9:	74 16                	je     801023e1 <ioapicinit+0x61>
-    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
-801023cb:	83 ec 0c             	sub    $0xc,%esp
-801023ce:	68 b4 7e 10 80       	push   $0x80107eb4
-801023d3:	e8 d8 e2 ff ff       	call   801006b0 <cprintf>
-801023d8:	8b 0d 54 36 11 80    	mov    0x80113654,%ecx
-801023de:	83 c4 10             	add    $0x10,%esp
-801023e1:	83 c6 21             	add    $0x21,%esi
-{
-801023e4:	ba 10 00 00 00       	mov    $0x10,%edx
-801023e9:	b8 20 00 00 00       	mov    $0x20,%eax
-801023ee:	66 90                	xchg   %ax,%ax
-  ioapic->reg = reg;
-801023f0:	89 11                	mov    %edx,(%ecx)
-
-  // Mark all interrupts edge-triggered, active high, disabled,
-  // and not routed to any CPUs.
-  for(i = 0; i <= maxintr; i++){
-    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
-801023f2:	89 c3                	mov    %eax,%ebx
-  ioapic->data = data;
-801023f4:	8b 0d 54 36 11 80    	mov    0x80113654,%ecx
-801023fa:	83 c0 01             	add    $0x1,%eax
-    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
-801023fd:	81 cb 00 00 01 00    	or     $0x10000,%ebx
-  ioapic->data = data;
-80102403:	89 59 10             	mov    %ebx,0x10(%ecx)
-  ioapic->reg = reg;
-80102406:	8d 5a 01             	lea    0x1(%edx),%ebx
-80102409:	83 c2 02             	add    $0x2,%edx
-8010240c:	89 19                	mov    %ebx,(%ecx)
-  ioapic->data = data;
-8010240e:	8b 0d 54 36 11 80    	mov    0x80113654,%ecx
-80102414:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
-  for(i = 0; i <= maxintr; i++){
-8010241b:	39 f0                	cmp    %esi,%eax
-8010241d:	75 d1                	jne    801023f0 <ioapicinit+0x70>
-    ioapicwrite(REG_TABLE+2*i+1, 0);
-  }
-}
-8010241f:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80102422:	5b                   	pop    %ebx
-80102423:	5e                   	pop    %esi
-80102424:	5d                   	pop    %ebp
-80102425:	c3                   	ret    
-80102426:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010242d:	8d 76 00             	lea    0x0(%esi),%esi
-
-80102430 <ioapicenable>:
-
-void
-ioapicenable(int irq, int cpunum)
-{
-80102430:	f3 0f 1e fb          	endbr32 
-80102434:	55                   	push   %ebp
-  ioapic->reg = reg;
-80102435:	8b 0d 54 36 11 80    	mov    0x80113654,%ecx
-{
-8010243b:	89 e5                	mov    %esp,%ebp
-8010243d:	8b 45 08             	mov    0x8(%ebp),%eax
-  // Mark interrupt edge-triggered, active high,
-  // enabled, and routed to the given cpunum,
-  // which happens to be that cpu's APIC ID.
-  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
-80102440:	8d 50 20             	lea    0x20(%eax),%edx
-80102443:	8d 44 00 10          	lea    0x10(%eax,%eax,1),%eax
-  ioapic->reg = reg;
-80102447:	89 01                	mov    %eax,(%ecx)
-  ioapic->data = data;
-80102449:	8b 0d 54 36 11 80    	mov    0x80113654,%ecx
-  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
-8010244f:	83 c0 01             	add    $0x1,%eax
-  ioapic->data = data;
-80102452:	89 51 10             	mov    %edx,0x10(%ecx)
-  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
-80102455:	8b 55 0c             	mov    0xc(%ebp),%edx
-  ioapic->reg = reg;
-80102458:	89 01                	mov    %eax,(%ecx)
-  ioapic->data = data;
-8010245a:	a1 54 36 11 80       	mov    0x80113654,%eax
-  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
-8010245f:	c1 e2 18             	shl    $0x18,%edx
-  ioapic->data = data;
-80102462:	89 50 10             	mov    %edx,0x10(%eax)
-}
-80102465:	5d                   	pop    %ebp
-80102466:	c3                   	ret    
-80102467:	66 90                	xchg   %ax,%ax
-80102469:	66 90                	xchg   %ax,%ax
-8010246b:	66 90                	xchg   %ax,%ax
-8010246d:	66 90                	xchg   %ax,%ax
-8010246f:	90                   	nop
-
-80102470 <kfree>:
-// which normally should have been returned by a
-// call to kalloc().  (The exception is when
-// initializing the allocator; see kinit above.)
-void
-kfree(char *v)
-{
-80102470:	f3 0f 1e fb          	endbr32 
-80102474:	55                   	push   %ebp
-80102475:	89 e5                	mov    %esp,%ebp
-80102477:	53                   	push   %ebx
-80102478:	83 ec 04             	sub    $0x4,%esp
-8010247b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  struct run *r;
-
-  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
-8010247e:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
-80102484:	75 7a                	jne    80102500 <kfree+0x90>
-80102486:	81 fb e8 89 11 80    	cmp    $0x801189e8,%ebx
-8010248c:	72 72                	jb     80102500 <kfree+0x90>
-8010248e:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
-80102494:	3d ff ff ff 0d       	cmp    $0xdffffff,%eax
-80102499:	77 65                	ja     80102500 <kfree+0x90>
-    panic("kfree");
-
-  // Fill with junk to catch dangling refs.
-  memset(v, 1, PGSIZE);
-8010249b:	83 ec 04             	sub    $0x4,%esp
-8010249e:	68 00 10 00 00       	push   $0x1000
-801024a3:	6a 01                	push   $0x1
-801024a5:	53                   	push   %ebx
-801024a6:	e8 25 2a 00 00       	call   80104ed0 <memset>
-
-  if(kmem.use_lock)
-801024ab:	8b 15 94 36 11 80    	mov    0x80113694,%edx
-801024b1:	83 c4 10             	add    $0x10,%esp
-801024b4:	85 d2                	test   %edx,%edx
-801024b6:	75 20                	jne    801024d8 <kfree+0x68>
-    acquire(&kmem.lock);
-  r = (struct run*)v;
-  r->next = kmem.freelist;
-801024b8:	a1 98 36 11 80       	mov    0x80113698,%eax
-801024bd:	89 03                	mov    %eax,(%ebx)
-  kmem.freelist = r;
-  if(kmem.use_lock)
-801024bf:	a1 94 36 11 80       	mov    0x80113694,%eax
-  kmem.freelist = r;
-801024c4:	89 1d 98 36 11 80    	mov    %ebx,0x80113698
-  if(kmem.use_lock)
-801024ca:	85 c0                	test   %eax,%eax
-801024cc:	75 22                	jne    801024f0 <kfree+0x80>
-    release(&kmem.lock);
-}
-801024ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-801024d1:	c9                   	leave  
-801024d2:	c3                   	ret    
-801024d3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801024d7:	90                   	nop
-    acquire(&kmem.lock);
-801024d8:	83 ec 0c             	sub    $0xc,%esp
-801024db:	68 60 36 11 80       	push   $0x80113660
-801024e0:	e8 db 28 00 00       	call   80104dc0 <acquire>
-801024e5:	83 c4 10             	add    $0x10,%esp
-801024e8:	eb ce                	jmp    801024b8 <kfree+0x48>
-801024ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    release(&kmem.lock);
-801024f0:	c7 45 08 60 36 11 80 	movl   $0x80113660,0x8(%ebp)
-}
-801024f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-801024fa:	c9                   	leave  
-    release(&kmem.lock);
-801024fb:	e9 80 29 00 00       	jmp    80104e80 <release>
-    panic("kfree");
-80102500:	83 ec 0c             	sub    $0xc,%esp
-80102503:	68 e6 7e 10 80       	push   $0x80107ee6
-80102508:	e8 83 de ff ff       	call   80100390 <panic>
-8010250d:	8d 76 00             	lea    0x0(%esi),%esi
-
-80102510 <freerange>:
-{
-80102510:	f3 0f 1e fb          	endbr32 
-80102514:	55                   	push   %ebp
-80102515:	89 e5                	mov    %esp,%ebp
-80102517:	56                   	push   %esi
-  p = (char*)PGROUNDUP((uint)vstart);
-80102518:	8b 45 08             	mov    0x8(%ebp),%eax
-{
-8010251b:	8b 75 0c             	mov    0xc(%ebp),%esi
-8010251e:	53                   	push   %ebx
-  p = (char*)PGROUNDUP((uint)vstart);
-8010251f:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
-80102525:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
-8010252b:	81 c3 00 10 00 00    	add    $0x1000,%ebx
-80102531:	39 de                	cmp    %ebx,%esi
-80102533:	72 1f                	jb     80102554 <freerange+0x44>
-80102535:	8d 76 00             	lea    0x0(%esi),%esi
-    kfree(p);
-80102538:	83 ec 0c             	sub    $0xc,%esp
-8010253b:	8d 83 00 f0 ff ff    	lea    -0x1000(%ebx),%eax
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
-80102541:	81 c3 00 10 00 00    	add    $0x1000,%ebx
-    kfree(p);
-80102547:	50                   	push   %eax
-80102548:	e8 23 ff ff ff       	call   80102470 <kfree>
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
-8010254d:	83 c4 10             	add    $0x10,%esp
-80102550:	39 f3                	cmp    %esi,%ebx
-80102552:	76 e4                	jbe    80102538 <freerange+0x28>
-}
-80102554:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80102557:	5b                   	pop    %ebx
-80102558:	5e                   	pop    %esi
-80102559:	5d                   	pop    %ebp
-8010255a:	c3                   	ret    
-8010255b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010255f:	90                   	nop
-
-80102560 <kinit1>:
-{
-80102560:	f3 0f 1e fb          	endbr32 
-80102564:	55                   	push   %ebp
-80102565:	89 e5                	mov    %esp,%ebp
-80102567:	56                   	push   %esi
-80102568:	53                   	push   %ebx
-80102569:	8b 75 0c             	mov    0xc(%ebp),%esi
-  initlock(&kmem.lock, "kmem");
-8010256c:	83 ec 08             	sub    $0x8,%esp
-8010256f:	68 ec 7e 10 80       	push   $0x80107eec
-80102574:	68 60 36 11 80       	push   $0x80113660
-80102579:	e8 c2 26 00 00       	call   80104c40 <initlock>
-  p = (char*)PGROUNDUP((uint)vstart);
-8010257e:	8b 45 08             	mov    0x8(%ebp),%eax
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
-80102581:	83 c4 10             	add    $0x10,%esp
-  kmem.use_lock = 0;
-80102584:	c7 05 94 36 11 80 00 	movl   $0x0,0x80113694
-8010258b:	00 00 00 
-  p = (char*)PGROUNDUP((uint)vstart);
-8010258e:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
-80102594:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
-8010259a:	81 c3 00 10 00 00    	add    $0x1000,%ebx
-801025a0:	39 de                	cmp    %ebx,%esi
-801025a2:	72 20                	jb     801025c4 <kinit1+0x64>
-801025a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    kfree(p);
-801025a8:	83 ec 0c             	sub    $0xc,%esp
-801025ab:	8d 83 00 f0 ff ff    	lea    -0x1000(%ebx),%eax
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
-801025b1:	81 c3 00 10 00 00    	add    $0x1000,%ebx
-    kfree(p);
-801025b7:	50                   	push   %eax
-801025b8:	e8 b3 fe ff ff       	call   80102470 <kfree>
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
-801025bd:	83 c4 10             	add    $0x10,%esp
-801025c0:	39 de                	cmp    %ebx,%esi
-801025c2:	73 e4                	jae    801025a8 <kinit1+0x48>
-}
-801025c4:	8d 65 f8             	lea    -0x8(%ebp),%esp
-801025c7:	5b                   	pop    %ebx
-801025c8:	5e                   	pop    %esi
-801025c9:	5d                   	pop    %ebp
-801025ca:	c3                   	ret    
-801025cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801025cf:	90                   	nop
-
-801025d0 <kinit2>:
-{
-801025d0:	f3 0f 1e fb          	endbr32 
-801025d4:	55                   	push   %ebp
-801025d5:	89 e5                	mov    %esp,%ebp
-801025d7:	56                   	push   %esi
-  p = (char*)PGROUNDUP((uint)vstart);
-801025d8:	8b 45 08             	mov    0x8(%ebp),%eax
-{
-801025db:	8b 75 0c             	mov    0xc(%ebp),%esi
-801025de:	53                   	push   %ebx
-  p = (char*)PGROUNDUP((uint)vstart);
-801025df:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
-801025e5:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
-801025eb:	81 c3 00 10 00 00    	add    $0x1000,%ebx
-801025f1:	39 de                	cmp    %ebx,%esi
-801025f3:	72 1f                	jb     80102614 <kinit2+0x44>
-801025f5:	8d 76 00             	lea    0x0(%esi),%esi
-    kfree(p);
-801025f8:	83 ec 0c             	sub    $0xc,%esp
-801025fb:	8d 83 00 f0 ff ff    	lea    -0x1000(%ebx),%eax
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
-80102601:	81 c3 00 10 00 00    	add    $0x1000,%ebx
-    kfree(p);
-80102607:	50                   	push   %eax
-80102608:	e8 63 fe ff ff       	call   80102470 <kfree>
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
-8010260d:	83 c4 10             	add    $0x10,%esp
-80102610:	39 de                	cmp    %ebx,%esi
-80102612:	73 e4                	jae    801025f8 <kinit2+0x28>
-  kmem.use_lock = 1;
-80102614:	c7 05 94 36 11 80 01 	movl   $0x1,0x80113694
-8010261b:	00 00 00 
-}
-8010261e:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80102621:	5b                   	pop    %ebx
-80102622:	5e                   	pop    %esi
-80102623:	5d                   	pop    %ebp
-80102624:	c3                   	ret    
-80102625:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010262c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-80102630 <kalloc>:
-// Allocate one 4096-byte page of physical memory.
-// Returns a pointer that the kernel can use.
-// Returns 0 if the memory cannot be allocated.
-char*
-kalloc(void)
-{
-80102630:	f3 0f 1e fb          	endbr32 
-  struct run *r;
-
-  if(kmem.use_lock)
-80102634:	a1 94 36 11 80       	mov    0x80113694,%eax
-80102639:	85 c0                	test   %eax,%eax
-8010263b:	75 1b                	jne    80102658 <kalloc+0x28>
-    acquire(&kmem.lock);
-  r = kmem.freelist;
-8010263d:	a1 98 36 11 80       	mov    0x80113698,%eax
-  if(r)
-80102642:	85 c0                	test   %eax,%eax
-80102644:	74 0a                	je     80102650 <kalloc+0x20>
-    kmem.freelist = r->next;
-80102646:	8b 10                	mov    (%eax),%edx
-80102648:	89 15 98 36 11 80    	mov    %edx,0x80113698
-  if(kmem.use_lock)
-8010264e:	c3                   	ret    
-8010264f:	90                   	nop
-    release(&kmem.lock);
-  return (char*)r;
-}
-80102650:	c3                   	ret    
-80102651:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-{
-80102658:	55                   	push   %ebp
-80102659:	89 e5                	mov    %esp,%ebp
-8010265b:	83 ec 24             	sub    $0x24,%esp
-    acquire(&kmem.lock);
-8010265e:	68 60 36 11 80       	push   $0x80113660
-80102663:	e8 58 27 00 00       	call   80104dc0 <acquire>
-  r = kmem.freelist;
-80102668:	a1 98 36 11 80       	mov    0x80113698,%eax
-  if(r)
-8010266d:	8b 15 94 36 11 80    	mov    0x80113694,%edx
-80102673:	83 c4 10             	add    $0x10,%esp
-80102676:	85 c0                	test   %eax,%eax
-80102678:	74 08                	je     80102682 <kalloc+0x52>
-    kmem.freelist = r->next;
-8010267a:	8b 08                	mov    (%eax),%ecx
-8010267c:	89 0d 98 36 11 80    	mov    %ecx,0x80113698
-  if(kmem.use_lock)
-80102682:	85 d2                	test   %edx,%edx
-80102684:	74 16                	je     8010269c <kalloc+0x6c>
-    release(&kmem.lock);
-80102686:	83 ec 0c             	sub    $0xc,%esp
-80102689:	89 45 f4             	mov    %eax,-0xc(%ebp)
-8010268c:	68 60 36 11 80       	push   $0x80113660
-80102691:	e8 ea 27 00 00       	call   80104e80 <release>
-  return (char*)r;
-80102696:	8b 45 f4             	mov    -0xc(%ebp),%eax
-    release(&kmem.lock);
-80102699:	83 c4 10             	add    $0x10,%esp
-}
-8010269c:	c9                   	leave  
-8010269d:	c3                   	ret    
-8010269e:	66 90                	xchg   %ax,%ax
-
-801026a0 <kbdgetc>:
-#include "defs.h"
-#include "kbd.h"
-
-int
-kbdgetc(void)
-{
-801026a0:	f3 0f 1e fb          	endbr32 
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-801026a4:	ba 64 00 00 00       	mov    $0x64,%edx
-801026a9:	ec                   	in     (%dx),%al
-    normalmap, shiftmap, ctlmap, ctlmap
-  };
-  uint st, data, c;
-
-  st = inb(KBSTATP);
-  if((st & KBS_DIB) == 0)
-801026aa:	a8 01                	test   $0x1,%al
-801026ac:	0f 84 be 00 00 00    	je     80102770 <kbdgetc+0xd0>
-{
-801026b2:	55                   	push   %ebp
-801026b3:	ba 60 00 00 00       	mov    $0x60,%edx
-801026b8:	89 e5                	mov    %esp,%ebp
-801026ba:	53                   	push   %ebx
-801026bb:	ec                   	in     (%dx),%al
-  return data;
-801026bc:	8b 1d b4 b5 10 80    	mov    0x8010b5b4,%ebx
-    return -1;
-  data = inb(KBDATAP);
-801026c2:	0f b6 d0             	movzbl %al,%edx
-
-  if(data == 0xE0){
-801026c5:	3c e0                	cmp    $0xe0,%al
-801026c7:	74 57                	je     80102720 <kbdgetc+0x80>
-    shift |= E0ESC;
-    return 0;
-  } else if(data & 0x80){
-801026c9:	89 d9                	mov    %ebx,%ecx
-801026cb:	83 e1 40             	and    $0x40,%ecx
-801026ce:	84 c0                	test   %al,%al
-801026d0:	78 5e                	js     80102730 <kbdgetc+0x90>
-    // Key released
-    data = (shift & E0ESC ? data : data & 0x7F);
-    shift &= ~(shiftcode[data] | E0ESC);
-    return 0;
-  } else if(shift & E0ESC){
-801026d2:	85 c9                	test   %ecx,%ecx
-801026d4:	74 09                	je     801026df <kbdgetc+0x3f>
-    // Last character was an E0 escape; or with 0x80
-    data |= 0x80;
-801026d6:	83 c8 80             	or     $0xffffff80,%eax
-    shift &= ~E0ESC;
-801026d9:	83 e3 bf             	and    $0xffffffbf,%ebx
-    data |= 0x80;
-801026dc:	0f b6 d0             	movzbl %al,%edx
-  }
-
-  shift |= shiftcode[data];
-801026df:	0f b6 8a 20 80 10 80 	movzbl -0x7fef7fe0(%edx),%ecx
-  shift ^= togglecode[data];
-801026e6:	0f b6 82 20 7f 10 80 	movzbl -0x7fef80e0(%edx),%eax
-  shift |= shiftcode[data];
-801026ed:	09 d9                	or     %ebx,%ecx
-  shift ^= togglecode[data];
-801026ef:	31 c1                	xor    %eax,%ecx
-  c = charcode[shift & (CTL | SHIFT)][data];
-801026f1:	89 c8                	mov    %ecx,%eax
-  shift ^= togglecode[data];
-801026f3:	89 0d b4 b5 10 80    	mov    %ecx,0x8010b5b4
-  c = charcode[shift & (CTL | SHIFT)][data];
-801026f9:	83 e0 03             	and    $0x3,%eax
-  if(shift & CAPSLOCK){
-801026fc:	83 e1 08             	and    $0x8,%ecx
-  c = charcode[shift & (CTL | SHIFT)][data];
-801026ff:	8b 04 85 00 7f 10 80 	mov    -0x7fef8100(,%eax,4),%eax
-80102706:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
-  if(shift & CAPSLOCK){
-8010270a:	74 0b                	je     80102717 <kbdgetc+0x77>
-    if('a' <= c && c <= 'z')
-8010270c:	8d 50 9f             	lea    -0x61(%eax),%edx
-8010270f:	83 fa 19             	cmp    $0x19,%edx
-80102712:	77 44                	ja     80102758 <kbdgetc+0xb8>
-      c += 'A' - 'a';
-80102714:	83 e8 20             	sub    $0x20,%eax
-    else if('A' <= c && c <= 'Z')
-      c += 'a' - 'A';
-  }
-  return c;
-}
-80102717:	5b                   	pop    %ebx
-80102718:	5d                   	pop    %ebp
-80102719:	c3                   	ret    
-8010271a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    shift |= E0ESC;
-80102720:	83 cb 40             	or     $0x40,%ebx
-    return 0;
-80102723:	31 c0                	xor    %eax,%eax
-    shift |= E0ESC;
-80102725:	89 1d b4 b5 10 80    	mov    %ebx,0x8010b5b4
-}
-8010272b:	5b                   	pop    %ebx
-8010272c:	5d                   	pop    %ebp
-8010272d:	c3                   	ret    
-8010272e:	66 90                	xchg   %ax,%ax
-    data = (shift & E0ESC ? data : data & 0x7F);
-80102730:	83 e0 7f             	and    $0x7f,%eax
-80102733:	85 c9                	test   %ecx,%ecx
-80102735:	0f 44 d0             	cmove  %eax,%edx
-    return 0;
-80102738:	31 c0                	xor    %eax,%eax
-    shift &= ~(shiftcode[data] | E0ESC);
-8010273a:	0f b6 8a 20 80 10 80 	movzbl -0x7fef7fe0(%edx),%ecx
-80102741:	83 c9 40             	or     $0x40,%ecx
-80102744:	0f b6 c9             	movzbl %cl,%ecx
-80102747:	f7 d1                	not    %ecx
-80102749:	21 d9                	and    %ebx,%ecx
-}
-8010274b:	5b                   	pop    %ebx
-8010274c:	5d                   	pop    %ebp
-    shift &= ~(shiftcode[data] | E0ESC);
-8010274d:	89 0d b4 b5 10 80    	mov    %ecx,0x8010b5b4
-}
-80102753:	c3                   	ret    
-80102754:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    else if('A' <= c && c <= 'Z')
-80102758:	8d 48 bf             	lea    -0x41(%eax),%ecx
-      c += 'a' - 'A';
-8010275b:	8d 50 20             	lea    0x20(%eax),%edx
-}
-8010275e:	5b                   	pop    %ebx
-8010275f:	5d                   	pop    %ebp
-      c += 'a' - 'A';
-80102760:	83 f9 1a             	cmp    $0x1a,%ecx
-80102763:	0f 42 c2             	cmovb  %edx,%eax
-}
-80102766:	c3                   	ret    
-80102767:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010276e:	66 90                	xchg   %ax,%ax
-    return -1;
-80102770:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80102775:	c3                   	ret    
-80102776:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010277d:	8d 76 00             	lea    0x0(%esi),%esi
-
-80102780 <kbdintr>:
-
-void
-kbdintr(void)
-{
-80102780:	f3 0f 1e fb          	endbr32 
-80102784:	55                   	push   %ebp
-80102785:	89 e5                	mov    %esp,%ebp
-80102787:	83 ec 14             	sub    $0x14,%esp
-  consoleintr(kbdgetc);
-8010278a:	68 a0 26 10 80       	push   $0x801026a0
-8010278f:	e8 cc e0 ff ff       	call   80100860 <consoleintr>
-}
-80102794:	83 c4 10             	add    $0x10,%esp
-80102797:	c9                   	leave  
-80102798:	c3                   	ret    
-80102799:	66 90                	xchg   %ax,%ax
-8010279b:	66 90                	xchg   %ax,%ax
-8010279d:	66 90                	xchg   %ax,%ax
-8010279f:	90                   	nop
-
-801027a0 <lapicinit>:
-  lapic[ID];  // wait for write to finish, by reading
-}
-
-void
-lapicinit(void)
-{
-801027a0:	f3 0f 1e fb          	endbr32 
-  if(!lapic)
-801027a4:	a1 9c 36 11 80       	mov    0x8011369c,%eax
-801027a9:	85 c0                	test   %eax,%eax
-801027ab:	0f 84 c7 00 00 00    	je     80102878 <lapicinit+0xd8>
-  lapic[index] = value;
-801027b1:	c7 80 f0 00 00 00 3f 	movl   $0x13f,0xf0(%eax)
-801027b8:	01 00 00 
-  lapic[ID];  // wait for write to finish, by reading
-801027bb:	8b 50 20             	mov    0x20(%eax),%edx
-  lapic[index] = value;
-801027be:	c7 80 e0 03 00 00 0b 	movl   $0xb,0x3e0(%eax)
-801027c5:	00 00 00 
-  lapic[ID];  // wait for write to finish, by reading
-801027c8:	8b 50 20             	mov    0x20(%eax),%edx
-  lapic[index] = value;
-801027cb:	c7 80 20 03 00 00 20 	movl   $0x20020,0x320(%eax)
-801027d2:	00 02 00 
-  lapic[ID];  // wait for write to finish, by reading
-801027d5:	8b 50 20             	mov    0x20(%eax),%edx
-  lapic[index] = value;
-801027d8:	c7 80 80 03 00 00 80 	movl   $0x989680,0x380(%eax)
-801027df:	96 98 00 
-  lapic[ID];  // wait for write to finish, by reading
-801027e2:	8b 50 20             	mov    0x20(%eax),%edx
-  lapic[index] = value;
-801027e5:	c7 80 50 03 00 00 00 	movl   $0x10000,0x350(%eax)
-801027ec:	00 01 00 
-  lapic[ID];  // wait for write to finish, by reading
-801027ef:	8b 50 20             	mov    0x20(%eax),%edx
-  lapic[index] = value;
-801027f2:	c7 80 60 03 00 00 00 	movl   $0x10000,0x360(%eax)
-801027f9:	00 01 00 
-  lapic[ID];  // wait for write to finish, by reading
-801027fc:	8b 50 20             	mov    0x20(%eax),%edx
-  lapicw(LINT0, MASKED);
-  lapicw(LINT1, MASKED);
-
-  // Disable performance counter overflow interrupts
-  // on machines that provide that interrupt entry.
-  if(((lapic[VER]>>16) & 0xFF) >= 4)
-801027ff:	8b 50 30             	mov    0x30(%eax),%edx
-80102802:	c1 ea 10             	shr    $0x10,%edx
-80102805:	81 e2 fc 00 00 00    	and    $0xfc,%edx
-8010280b:	75 73                	jne    80102880 <lapicinit+0xe0>
-  lapic[index] = value;
-8010280d:	c7 80 70 03 00 00 33 	movl   $0x33,0x370(%eax)
-80102814:	00 00 00 
-  lapic[ID];  // wait for write to finish, by reading
-80102817:	8b 50 20             	mov    0x20(%eax),%edx
-  lapic[index] = value;
-8010281a:	c7 80 80 02 00 00 00 	movl   $0x0,0x280(%eax)
-80102821:	00 00 00 
-  lapic[ID];  // wait for write to finish, by reading
-80102824:	8b 50 20             	mov    0x20(%eax),%edx
-  lapic[index] = value;
-80102827:	c7 80 80 02 00 00 00 	movl   $0x0,0x280(%eax)
-8010282e:	00 00 00 
-  lapic[ID];  // wait for write to finish, by reading
-80102831:	8b 50 20             	mov    0x20(%eax),%edx
-  lapic[index] = value;
-80102834:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
-8010283b:	00 00 00 
-  lapic[ID];  // wait for write to finish, by reading
-8010283e:	8b 50 20             	mov    0x20(%eax),%edx
-  lapic[index] = value;
-80102841:	c7 80 10 03 00 00 00 	movl   $0x0,0x310(%eax)
-80102848:	00 00 00 
-  lapic[ID];  // wait for write to finish, by reading
-8010284b:	8b 50 20             	mov    0x20(%eax),%edx
-  lapic[index] = value;
-8010284e:	c7 80 00 03 00 00 00 	movl   $0x88500,0x300(%eax)
-80102855:	85 08 00 
-  lapic[ID];  // wait for write to finish, by reading
-80102858:	8b 50 20             	mov    0x20(%eax),%edx
-8010285b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010285f:	90                   	nop
-  lapicw(EOI, 0);
-
-  // Send an Init Level De-Assert to synchronise arbitration ID's.
-  lapicw(ICRHI, 0);
-  lapicw(ICRLO, BCAST | INIT | LEVEL);
-  while(lapic[ICRLO] & DELIVS)
-80102860:	8b 90 00 03 00 00    	mov    0x300(%eax),%edx
-80102866:	80 e6 10             	and    $0x10,%dh
-80102869:	75 f5                	jne    80102860 <lapicinit+0xc0>
-  lapic[index] = value;
-8010286b:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
-80102872:	00 00 00 
-  lapic[ID];  // wait for write to finish, by reading
-80102875:	8b 40 20             	mov    0x20(%eax),%eax
-    ;
-
-  // Enable interrupts on the APIC (but not on the processor).
-  lapicw(TPR, 0);
-}
-80102878:	c3                   	ret    
-80102879:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  lapic[index] = value;
-80102880:	c7 80 40 03 00 00 00 	movl   $0x10000,0x340(%eax)
-80102887:	00 01 00 
-  lapic[ID];  // wait for write to finish, by reading
-8010288a:	8b 50 20             	mov    0x20(%eax),%edx
-}
-8010288d:	e9 7b ff ff ff       	jmp    8010280d <lapicinit+0x6d>
-80102892:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80102899:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-801028a0 <lapicid>:
-
-int
-lapicid(void)
-{
-801028a0:	f3 0f 1e fb          	endbr32 
-  if (!lapic)
-801028a4:	a1 9c 36 11 80       	mov    0x8011369c,%eax
-801028a9:	85 c0                	test   %eax,%eax
-801028ab:	74 0b                	je     801028b8 <lapicid+0x18>
-    return 0;
-  return lapic[ID] >> 24;
-801028ad:	8b 40 20             	mov    0x20(%eax),%eax
-801028b0:	c1 e8 18             	shr    $0x18,%eax
-801028b3:	c3                   	ret    
-801028b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    return 0;
-801028b8:	31 c0                	xor    %eax,%eax
-}
-801028ba:	c3                   	ret    
-801028bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801028bf:	90                   	nop
-
-801028c0 <lapiceoi>:
-
-// Acknowledge interrupt.
-void
-lapiceoi(void)
-{
-801028c0:	f3 0f 1e fb          	endbr32 
-  if(lapic)
-801028c4:	a1 9c 36 11 80       	mov    0x8011369c,%eax
-801028c9:	85 c0                	test   %eax,%eax
-801028cb:	74 0d                	je     801028da <lapiceoi+0x1a>
-  lapic[index] = value;
-801028cd:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
-801028d4:	00 00 00 
-  lapic[ID];  // wait for write to finish, by reading
-801028d7:	8b 40 20             	mov    0x20(%eax),%eax
-    lapicw(EOI, 0);
-}
-801028da:	c3                   	ret    
-801028db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801028df:	90                   	nop
-
-801028e0 <microdelay>:
-
-// Spin for a given number of microseconds.
-// On real hardware would want to tune this dynamically.
-void
-microdelay(int us)
-{
-801028e0:	f3 0f 1e fb          	endbr32 
-}
-801028e4:	c3                   	ret    
-801028e5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801028ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-801028f0 <lapicstartap>:
-
-// Start additional processor running entry code at addr.
-// See Appendix B of MultiProcessor Specification.
-void
-lapicstartap(uchar apicid, uint addr)
-{
-801028f0:	f3 0f 1e fb          	endbr32 
-801028f4:	55                   	push   %ebp
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-801028f5:	b8 0f 00 00 00       	mov    $0xf,%eax
-801028fa:	ba 70 00 00 00       	mov    $0x70,%edx
-801028ff:	89 e5                	mov    %esp,%ebp
-80102901:	53                   	push   %ebx
-80102902:	8b 4d 0c             	mov    0xc(%ebp),%ecx
-80102905:	8b 5d 08             	mov    0x8(%ebp),%ebx
-80102908:	ee                   	out    %al,(%dx)
-80102909:	b8 0a 00 00 00       	mov    $0xa,%eax
-8010290e:	ba 71 00 00 00       	mov    $0x71,%edx
-80102913:	ee                   	out    %al,(%dx)
-  // and the warm reset vector (DWORD based at 40:67) to point at
-  // the AP startup code prior to the [universal startup algorithm]."
-  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
-  outb(CMOS_PORT+1, 0x0A);
-  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
-  wrv[0] = 0;
-80102914:	31 c0                	xor    %eax,%eax
-  wrv[1] = addr >> 4;
-
-  // "Universal startup algorithm."
-  // Send INIT (level-triggered) interrupt to reset other CPU.
-  lapicw(ICRHI, apicid<<24);
-80102916:	c1 e3 18             	shl    $0x18,%ebx
-  wrv[0] = 0;
-80102919:	66 a3 67 04 00 80    	mov    %ax,0x80000467
-  wrv[1] = addr >> 4;
-8010291f:	89 c8                	mov    %ecx,%eax
-  // when it is in the halted state due to an INIT.  So the second
-  // should be ignored, but it is part of the official Intel algorithm.
-  // Bochs complains about the second one.  Too bad for Bochs.
-  for(i = 0; i < 2; i++){
-    lapicw(ICRHI, apicid<<24);
-    lapicw(ICRLO, STARTUP | (addr>>12));
-80102921:	c1 e9 0c             	shr    $0xc,%ecx
-  lapicw(ICRHI, apicid<<24);
-80102924:	89 da                	mov    %ebx,%edx
-  wrv[1] = addr >> 4;
-80102926:	c1 e8 04             	shr    $0x4,%eax
-    lapicw(ICRLO, STARTUP | (addr>>12));
-80102929:	80 cd 06             	or     $0x6,%ch
-  wrv[1] = addr >> 4;
-8010292c:	66 a3 69 04 00 80    	mov    %ax,0x80000469
-  lapic[index] = value;
-80102932:	a1 9c 36 11 80       	mov    0x8011369c,%eax
-80102937:	89 98 10 03 00 00    	mov    %ebx,0x310(%eax)
-  lapic[ID];  // wait for write to finish, by reading
-8010293d:	8b 58 20             	mov    0x20(%eax),%ebx
-  lapic[index] = value;
-80102940:	c7 80 00 03 00 00 00 	movl   $0xc500,0x300(%eax)
-80102947:	c5 00 00 
-  lapic[ID];  // wait for write to finish, by reading
-8010294a:	8b 58 20             	mov    0x20(%eax),%ebx
-  lapic[index] = value;
-8010294d:	c7 80 00 03 00 00 00 	movl   $0x8500,0x300(%eax)
-80102954:	85 00 00 
-  lapic[ID];  // wait for write to finish, by reading
-80102957:	8b 58 20             	mov    0x20(%eax),%ebx
-  lapic[index] = value;
-8010295a:	89 90 10 03 00 00    	mov    %edx,0x310(%eax)
-  lapic[ID];  // wait for write to finish, by reading
-80102960:	8b 58 20             	mov    0x20(%eax),%ebx
-  lapic[index] = value;
-80102963:	89 88 00 03 00 00    	mov    %ecx,0x300(%eax)
-  lapic[ID];  // wait for write to finish, by reading
-80102969:	8b 58 20             	mov    0x20(%eax),%ebx
-  lapic[index] = value;
-8010296c:	89 90 10 03 00 00    	mov    %edx,0x310(%eax)
-  lapic[ID];  // wait for write to finish, by reading
-80102972:	8b 50 20             	mov    0x20(%eax),%edx
-  lapic[index] = value;
-80102975:	89 88 00 03 00 00    	mov    %ecx,0x300(%eax)
-    microdelay(200);
-  }
-}
-8010297b:	5b                   	pop    %ebx
-  lapic[ID];  // wait for write to finish, by reading
-8010297c:	8b 40 20             	mov    0x20(%eax),%eax
-}
-8010297f:	5d                   	pop    %ebp
-80102980:	c3                   	ret    
-80102981:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80102988:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010298f:	90                   	nop
-
-80102990 <cmostime>:
-}
-
-// qemu seems to use 24-hour GWT and the values are BCD encoded
-void
-cmostime(struct rtcdate *r)
-{
-80102990:	f3 0f 1e fb          	endbr32 
-80102994:	55                   	push   %ebp
-80102995:	b8 0b 00 00 00       	mov    $0xb,%eax
-8010299a:	ba 70 00 00 00       	mov    $0x70,%edx
-8010299f:	89 e5                	mov    %esp,%ebp
-801029a1:	57                   	push   %edi
-801029a2:	56                   	push   %esi
-801029a3:	53                   	push   %ebx
-801029a4:	83 ec 4c             	sub    $0x4c,%esp
-801029a7:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-801029a8:	ba 71 00 00 00       	mov    $0x71,%edx
-801029ad:	ec                   	in     (%dx),%al
-  struct rtcdate t1, t2;
-  int sb, bcd;
-
-  sb = cmos_read(CMOS_STATB);
-
-  bcd = (sb & (1 << 2)) == 0;
-801029ae:	83 e0 04             	and    $0x4,%eax
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-801029b1:	bb 70 00 00 00       	mov    $0x70,%ebx
-801029b6:	88 45 b3             	mov    %al,-0x4d(%ebp)
-801029b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801029c0:	31 c0                	xor    %eax,%eax
-801029c2:	89 da                	mov    %ebx,%edx
-801029c4:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-801029c5:	b9 71 00 00 00       	mov    $0x71,%ecx
-801029ca:	89 ca                	mov    %ecx,%edx
-801029cc:	ec                   	in     (%dx),%al
-801029cd:	88 45 b7             	mov    %al,-0x49(%ebp)
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-801029d0:	89 da                	mov    %ebx,%edx
-801029d2:	b8 02 00 00 00       	mov    $0x2,%eax
-801029d7:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-801029d8:	89 ca                	mov    %ecx,%edx
-801029da:	ec                   	in     (%dx),%al
-801029db:	88 45 b6             	mov    %al,-0x4a(%ebp)
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-801029de:	89 da                	mov    %ebx,%edx
-801029e0:	b8 04 00 00 00       	mov    $0x4,%eax
-801029e5:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-801029e6:	89 ca                	mov    %ecx,%edx
-801029e8:	ec                   	in     (%dx),%al
-801029e9:	88 45 b5             	mov    %al,-0x4b(%ebp)
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-801029ec:	89 da                	mov    %ebx,%edx
-801029ee:	b8 07 00 00 00       	mov    $0x7,%eax
-801029f3:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-801029f4:	89 ca                	mov    %ecx,%edx
-801029f6:	ec                   	in     (%dx),%al
-801029f7:	88 45 b4             	mov    %al,-0x4c(%ebp)
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-801029fa:	89 da                	mov    %ebx,%edx
-801029fc:	b8 08 00 00 00       	mov    $0x8,%eax
-80102a01:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80102a02:	89 ca                	mov    %ecx,%edx
-80102a04:	ec                   	in     (%dx),%al
-80102a05:	89 c7                	mov    %eax,%edi
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-80102a07:	89 da                	mov    %ebx,%edx
-80102a09:	b8 09 00 00 00       	mov    $0x9,%eax
-80102a0e:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80102a0f:	89 ca                	mov    %ecx,%edx
-80102a11:	ec                   	in     (%dx),%al
-80102a12:	89 c6                	mov    %eax,%esi
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-80102a14:	89 da                	mov    %ebx,%edx
-80102a16:	b8 0a 00 00 00       	mov    $0xa,%eax
-80102a1b:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80102a1c:	89 ca                	mov    %ecx,%edx
-80102a1e:	ec                   	in     (%dx),%al
-
-  // make sure CMOS doesn't modify time while we read it
-  for(;;) {
-    fill_rtcdate(&t1);
-    if(cmos_read(CMOS_STATA) & CMOS_UIP)
-80102a1f:	84 c0                	test   %al,%al
-80102a21:	78 9d                	js     801029c0 <cmostime+0x30>
-  return inb(CMOS_RETURN);
-80102a23:	0f b6 45 b7          	movzbl -0x49(%ebp),%eax
-80102a27:	89 fa                	mov    %edi,%edx
-80102a29:	0f b6 fa             	movzbl %dl,%edi
-80102a2c:	89 f2                	mov    %esi,%edx
-80102a2e:	89 45 b8             	mov    %eax,-0x48(%ebp)
-80102a31:	0f b6 45 b6          	movzbl -0x4a(%ebp),%eax
-80102a35:	0f b6 f2             	movzbl %dl,%esi
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-80102a38:	89 da                	mov    %ebx,%edx
-80102a3a:	89 7d c8             	mov    %edi,-0x38(%ebp)
-80102a3d:	89 45 bc             	mov    %eax,-0x44(%ebp)
-80102a40:	0f b6 45 b5          	movzbl -0x4b(%ebp),%eax
-80102a44:	89 75 cc             	mov    %esi,-0x34(%ebp)
-80102a47:	89 45 c0             	mov    %eax,-0x40(%ebp)
-80102a4a:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
-80102a4e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
-80102a51:	31 c0                	xor    %eax,%eax
-80102a53:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80102a54:	89 ca                	mov    %ecx,%edx
-80102a56:	ec                   	in     (%dx),%al
-80102a57:	0f b6 c0             	movzbl %al,%eax
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-80102a5a:	89 da                	mov    %ebx,%edx
-80102a5c:	89 45 d0             	mov    %eax,-0x30(%ebp)
-80102a5f:	b8 02 00 00 00       	mov    $0x2,%eax
-80102a64:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80102a65:	89 ca                	mov    %ecx,%edx
-80102a67:	ec                   	in     (%dx),%al
-80102a68:	0f b6 c0             	movzbl %al,%eax
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-80102a6b:	89 da                	mov    %ebx,%edx
-80102a6d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
-80102a70:	b8 04 00 00 00       	mov    $0x4,%eax
-80102a75:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80102a76:	89 ca                	mov    %ecx,%edx
-80102a78:	ec                   	in     (%dx),%al
-80102a79:	0f b6 c0             	movzbl %al,%eax
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-80102a7c:	89 da                	mov    %ebx,%edx
-80102a7e:	89 45 d8             	mov    %eax,-0x28(%ebp)
-80102a81:	b8 07 00 00 00       	mov    $0x7,%eax
-80102a86:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80102a87:	89 ca                	mov    %ecx,%edx
-80102a89:	ec                   	in     (%dx),%al
-80102a8a:	0f b6 c0             	movzbl %al,%eax
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-80102a8d:	89 da                	mov    %ebx,%edx
-80102a8f:	89 45 dc             	mov    %eax,-0x24(%ebp)
-80102a92:	b8 08 00 00 00       	mov    $0x8,%eax
-80102a97:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80102a98:	89 ca                	mov    %ecx,%edx
-80102a9a:	ec                   	in     (%dx),%al
-80102a9b:	0f b6 c0             	movzbl %al,%eax
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-80102a9e:	89 da                	mov    %ebx,%edx
-80102aa0:	89 45 e0             	mov    %eax,-0x20(%ebp)
-80102aa3:	b8 09 00 00 00       	mov    $0x9,%eax
-80102aa8:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80102aa9:	89 ca                	mov    %ecx,%edx
-80102aab:	ec                   	in     (%dx),%al
-80102aac:	0f b6 c0             	movzbl %al,%eax
-        continue;
-    fill_rtcdate(&t2);
-    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
-80102aaf:	83 ec 04             	sub    $0x4,%esp
-  return inb(CMOS_RETURN);
-80102ab2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
-80102ab5:	8d 45 d0             	lea    -0x30(%ebp),%eax
-80102ab8:	6a 18                	push   $0x18
-80102aba:	50                   	push   %eax
-80102abb:	8d 45 b8             	lea    -0x48(%ebp),%eax
-80102abe:	50                   	push   %eax
-80102abf:	e8 5c 24 00 00       	call   80104f20 <memcmp>
-80102ac4:	83 c4 10             	add    $0x10,%esp
-80102ac7:	85 c0                	test   %eax,%eax
-80102ac9:	0f 85 f1 fe ff ff    	jne    801029c0 <cmostime+0x30>
-      break;
-  }
-
-  // convert
-  if(bcd) {
-80102acf:	80 7d b3 00          	cmpb   $0x0,-0x4d(%ebp)
-80102ad3:	75 78                	jne    80102b4d <cmostime+0x1bd>
-#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
-    CONV(second);
-80102ad5:	8b 45 b8             	mov    -0x48(%ebp),%eax
-80102ad8:	89 c2                	mov    %eax,%edx
-80102ada:	83 e0 0f             	and    $0xf,%eax
-80102add:	c1 ea 04             	shr    $0x4,%edx
-80102ae0:	8d 14 92             	lea    (%edx,%edx,4),%edx
-80102ae3:	8d 04 50             	lea    (%eax,%edx,2),%eax
-80102ae6:	89 45 b8             	mov    %eax,-0x48(%ebp)
-    CONV(minute);
-80102ae9:	8b 45 bc             	mov    -0x44(%ebp),%eax
-80102aec:	89 c2                	mov    %eax,%edx
-80102aee:	83 e0 0f             	and    $0xf,%eax
-80102af1:	c1 ea 04             	shr    $0x4,%edx
-80102af4:	8d 14 92             	lea    (%edx,%edx,4),%edx
-80102af7:	8d 04 50             	lea    (%eax,%edx,2),%eax
-80102afa:	89 45 bc             	mov    %eax,-0x44(%ebp)
-    CONV(hour  );
-80102afd:	8b 45 c0             	mov    -0x40(%ebp),%eax
-80102b00:	89 c2                	mov    %eax,%edx
-80102b02:	83 e0 0f             	and    $0xf,%eax
-80102b05:	c1 ea 04             	shr    $0x4,%edx
-80102b08:	8d 14 92             	lea    (%edx,%edx,4),%edx
-80102b0b:	8d 04 50             	lea    (%eax,%edx,2),%eax
-80102b0e:	89 45 c0             	mov    %eax,-0x40(%ebp)
-    CONV(day   );
-80102b11:	8b 45 c4             	mov    -0x3c(%ebp),%eax
-80102b14:	89 c2                	mov    %eax,%edx
-80102b16:	83 e0 0f             	and    $0xf,%eax
-80102b19:	c1 ea 04             	shr    $0x4,%edx
-80102b1c:	8d 14 92             	lea    (%edx,%edx,4),%edx
-80102b1f:	8d 04 50             	lea    (%eax,%edx,2),%eax
-80102b22:	89 45 c4             	mov    %eax,-0x3c(%ebp)
-    CONV(month );
-80102b25:	8b 45 c8             	mov    -0x38(%ebp),%eax
-80102b28:	89 c2                	mov    %eax,%edx
-80102b2a:	83 e0 0f             	and    $0xf,%eax
-80102b2d:	c1 ea 04             	shr    $0x4,%edx
-80102b30:	8d 14 92             	lea    (%edx,%edx,4),%edx
-80102b33:	8d 04 50             	lea    (%eax,%edx,2),%eax
-80102b36:	89 45 c8             	mov    %eax,-0x38(%ebp)
-    CONV(year  );
-80102b39:	8b 45 cc             	mov    -0x34(%ebp),%eax
-80102b3c:	89 c2                	mov    %eax,%edx
-80102b3e:	83 e0 0f             	and    $0xf,%eax
-80102b41:	c1 ea 04             	shr    $0x4,%edx
-80102b44:	8d 14 92             	lea    (%edx,%edx,4),%edx
-80102b47:	8d 04 50             	lea    (%eax,%edx,2),%eax
-80102b4a:	89 45 cc             	mov    %eax,-0x34(%ebp)
-#undef     CONV
-  }
-
-  *r = t1;
-80102b4d:	8b 75 08             	mov    0x8(%ebp),%esi
-80102b50:	8b 45 b8             	mov    -0x48(%ebp),%eax
-80102b53:	89 06                	mov    %eax,(%esi)
-80102b55:	8b 45 bc             	mov    -0x44(%ebp),%eax
-80102b58:	89 46 04             	mov    %eax,0x4(%esi)
-80102b5b:	8b 45 c0             	mov    -0x40(%ebp),%eax
-80102b5e:	89 46 08             	mov    %eax,0x8(%esi)
-80102b61:	8b 45 c4             	mov    -0x3c(%ebp),%eax
-80102b64:	89 46 0c             	mov    %eax,0xc(%esi)
-80102b67:	8b 45 c8             	mov    -0x38(%ebp),%eax
-80102b6a:	89 46 10             	mov    %eax,0x10(%esi)
-80102b6d:	8b 45 cc             	mov    -0x34(%ebp),%eax
-80102b70:	89 46 14             	mov    %eax,0x14(%esi)
-  r->year += 2000;
-80102b73:	81 46 14 d0 07 00 00 	addl   $0x7d0,0x14(%esi)
-}
-80102b7a:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80102b7d:	5b                   	pop    %ebx
-80102b7e:	5e                   	pop    %esi
-80102b7f:	5f                   	pop    %edi
-80102b80:	5d                   	pop    %ebp
-80102b81:	c3                   	ret    
-80102b82:	66 90                	xchg   %ax,%ax
-80102b84:	66 90                	xchg   %ax,%ax
-80102b86:	66 90                	xchg   %ax,%ax
-80102b88:	66 90                	xchg   %ax,%ax
-80102b8a:	66 90                	xchg   %ax,%ax
-80102b8c:	66 90                	xchg   %ax,%ax
-80102b8e:	66 90                	xchg   %ax,%ax
-
-80102b90 <install_trans>:
-static void
-install_trans(void)
-{
-  int tail;
-
-  for (tail = 0; tail < log.lh.n; tail++) {
-80102b90:	8b 0d e8 36 11 80    	mov    0x801136e8,%ecx
-80102b96:	85 c9                	test   %ecx,%ecx
-80102b98:	0f 8e 8a 00 00 00    	jle    80102c28 <install_trans+0x98>
-{
-80102b9e:	55                   	push   %ebp
-80102b9f:	89 e5                	mov    %esp,%ebp
-80102ba1:	57                   	push   %edi
-  for (tail = 0; tail < log.lh.n; tail++) {
-80102ba2:	31 ff                	xor    %edi,%edi
-{
-80102ba4:	56                   	push   %esi
-80102ba5:	53                   	push   %ebx
-80102ba6:	83 ec 0c             	sub    $0xc,%esp
-80102ba9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
-80102bb0:	a1 d4 36 11 80       	mov    0x801136d4,%eax
-80102bb5:	83 ec 08             	sub    $0x8,%esp
-80102bb8:	01 f8                	add    %edi,%eax
-80102bba:	83 c0 01             	add    $0x1,%eax
-80102bbd:	50                   	push   %eax
-80102bbe:	ff 35 e4 36 11 80    	pushl  0x801136e4
-80102bc4:	e8 07 d5 ff ff       	call   801000d0 <bread>
-80102bc9:	89 c6                	mov    %eax,%esi
-    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
-80102bcb:	58                   	pop    %eax
-80102bcc:	5a                   	pop    %edx
-80102bcd:	ff 34 bd ec 36 11 80 	pushl  -0x7feec914(,%edi,4)
-80102bd4:	ff 35 e4 36 11 80    	pushl  0x801136e4
-  for (tail = 0; tail < log.lh.n; tail++) {
-80102bda:	83 c7 01             	add    $0x1,%edi
-    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
-80102bdd:	e8 ee d4 ff ff       	call   801000d0 <bread>
-    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
-80102be2:	83 c4 0c             	add    $0xc,%esp
-    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
-80102be5:	89 c3                	mov    %eax,%ebx
-    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
-80102be7:	8d 46 5c             	lea    0x5c(%esi),%eax
-80102bea:	68 00 02 00 00       	push   $0x200
-80102bef:	50                   	push   %eax
-80102bf0:	8d 43 5c             	lea    0x5c(%ebx),%eax
-80102bf3:	50                   	push   %eax
-80102bf4:	e8 77 23 00 00       	call   80104f70 <memmove>
-    bwrite(dbuf);  // write dst to disk
-80102bf9:	89 1c 24             	mov    %ebx,(%esp)
-80102bfc:	e8 af d5 ff ff       	call   801001b0 <bwrite>
-    brelse(lbuf);
-80102c01:	89 34 24             	mov    %esi,(%esp)
-80102c04:	e8 e7 d5 ff ff       	call   801001f0 <brelse>
-    brelse(dbuf);
-80102c09:	89 1c 24             	mov    %ebx,(%esp)
-80102c0c:	e8 df d5 ff ff       	call   801001f0 <brelse>
-  for (tail = 0; tail < log.lh.n; tail++) {
-80102c11:	83 c4 10             	add    $0x10,%esp
-80102c14:	39 3d e8 36 11 80    	cmp    %edi,0x801136e8
-80102c1a:	7f 94                	jg     80102bb0 <install_trans+0x20>
-  }
-}
-80102c1c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80102c1f:	5b                   	pop    %ebx
-80102c20:	5e                   	pop    %esi
-80102c21:	5f                   	pop    %edi
-80102c22:	5d                   	pop    %ebp
-80102c23:	c3                   	ret    
-80102c24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80102c28:	c3                   	ret    
-80102c29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-80102c30 <write_head>:
-// Write in-memory log header to disk.
-// This is the true point at which the
-// current transaction commits.
-static void
-write_head(void)
-{
-80102c30:	55                   	push   %ebp
-80102c31:	89 e5                	mov    %esp,%ebp
-80102c33:	53                   	push   %ebx
-80102c34:	83 ec 0c             	sub    $0xc,%esp
-  struct buf *buf = bread(log.dev, log.start);
-80102c37:	ff 35 d4 36 11 80    	pushl  0x801136d4
-80102c3d:	ff 35 e4 36 11 80    	pushl  0x801136e4
-80102c43:	e8 88 d4 ff ff       	call   801000d0 <bread>
-  struct logheader *hb = (struct logheader *) (buf->data);
-  int i;
-  hb->n = log.lh.n;
-  for (i = 0; i < log.lh.n; i++) {
-80102c48:	83 c4 10             	add    $0x10,%esp
-  struct buf *buf = bread(log.dev, log.start);
-80102c4b:	89 c3                	mov    %eax,%ebx
-  hb->n = log.lh.n;
-80102c4d:	a1 e8 36 11 80       	mov    0x801136e8,%eax
-80102c52:	89 43 5c             	mov    %eax,0x5c(%ebx)
-  for (i = 0; i < log.lh.n; i++) {
-80102c55:	85 c0                	test   %eax,%eax
-80102c57:	7e 19                	jle    80102c72 <write_head+0x42>
-80102c59:	31 d2                	xor    %edx,%edx
-80102c5b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80102c5f:	90                   	nop
-    hb->block[i] = log.lh.block[i];
-80102c60:	8b 0c 95 ec 36 11 80 	mov    -0x7feec914(,%edx,4),%ecx
-80102c67:	89 4c 93 60          	mov    %ecx,0x60(%ebx,%edx,4)
-  for (i = 0; i < log.lh.n; i++) {
-80102c6b:	83 c2 01             	add    $0x1,%edx
-80102c6e:	39 d0                	cmp    %edx,%eax
-80102c70:	75 ee                	jne    80102c60 <write_head+0x30>
-  }
-  bwrite(buf);
-80102c72:	83 ec 0c             	sub    $0xc,%esp
-80102c75:	53                   	push   %ebx
-80102c76:	e8 35 d5 ff ff       	call   801001b0 <bwrite>
-  brelse(buf);
-80102c7b:	89 1c 24             	mov    %ebx,(%esp)
-80102c7e:	e8 6d d5 ff ff       	call   801001f0 <brelse>
-}
-80102c83:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80102c86:	83 c4 10             	add    $0x10,%esp
-80102c89:	c9                   	leave  
-80102c8a:	c3                   	ret    
-80102c8b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80102c8f:	90                   	nop
-
-80102c90 <initlog>:
-{
-80102c90:	f3 0f 1e fb          	endbr32 
-80102c94:	55                   	push   %ebp
-80102c95:	89 e5                	mov    %esp,%ebp
-80102c97:	53                   	push   %ebx
-80102c98:	83 ec 2c             	sub    $0x2c,%esp
-80102c9b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  initlock(&log.lock, "log");
-80102c9e:	68 20 81 10 80       	push   $0x80108120
-80102ca3:	68 a0 36 11 80       	push   $0x801136a0
-80102ca8:	e8 93 1f 00 00       	call   80104c40 <initlock>
-  readsb(dev, &sb);
-80102cad:	58                   	pop    %eax
-80102cae:	8d 45 dc             	lea    -0x24(%ebp),%eax
-80102cb1:	5a                   	pop    %edx
-80102cb2:	50                   	push   %eax
-80102cb3:	53                   	push   %ebx
-80102cb4:	e8 47 e8 ff ff       	call   80101500 <readsb>
-  log.start = sb.logstart;
-80102cb9:	8b 45 ec             	mov    -0x14(%ebp),%eax
-  struct buf *buf = bread(log.dev, log.start);
-80102cbc:	59                   	pop    %ecx
-  log.dev = dev;
-80102cbd:	89 1d e4 36 11 80    	mov    %ebx,0x801136e4
-  log.size = sb.nlog;
-80102cc3:	8b 55 e8             	mov    -0x18(%ebp),%edx
-  log.start = sb.logstart;
-80102cc6:	a3 d4 36 11 80       	mov    %eax,0x801136d4
-  log.size = sb.nlog;
-80102ccb:	89 15 d8 36 11 80    	mov    %edx,0x801136d8
-  struct buf *buf = bread(log.dev, log.start);
-80102cd1:	5a                   	pop    %edx
-80102cd2:	50                   	push   %eax
-80102cd3:	53                   	push   %ebx
-80102cd4:	e8 f7 d3 ff ff       	call   801000d0 <bread>
-  for (i = 0; i < log.lh.n; i++) {
-80102cd9:	83 c4 10             	add    $0x10,%esp
-  log.lh.n = lh->n;
-80102cdc:	8b 48 5c             	mov    0x5c(%eax),%ecx
-80102cdf:	89 0d e8 36 11 80    	mov    %ecx,0x801136e8
-  for (i = 0; i < log.lh.n; i++) {
-80102ce5:	85 c9                	test   %ecx,%ecx
-80102ce7:	7e 19                	jle    80102d02 <initlog+0x72>
-80102ce9:	31 d2                	xor    %edx,%edx
-80102ceb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80102cef:	90                   	nop
-    log.lh.block[i] = lh->block[i];
-80102cf0:	8b 5c 90 60          	mov    0x60(%eax,%edx,4),%ebx
-80102cf4:	89 1c 95 ec 36 11 80 	mov    %ebx,-0x7feec914(,%edx,4)
-  for (i = 0; i < log.lh.n; i++) {
-80102cfb:	83 c2 01             	add    $0x1,%edx
-80102cfe:	39 d1                	cmp    %edx,%ecx
-80102d00:	75 ee                	jne    80102cf0 <initlog+0x60>
-  brelse(buf);
-80102d02:	83 ec 0c             	sub    $0xc,%esp
-80102d05:	50                   	push   %eax
-80102d06:	e8 e5 d4 ff ff       	call   801001f0 <brelse>
-
-static void
-recover_from_log(void)
-{
-  read_head();
-  install_trans(); // if committed, copy from log to disk
-80102d0b:	e8 80 fe ff ff       	call   80102b90 <install_trans>
-  log.lh.n = 0;
-80102d10:	c7 05 e8 36 11 80 00 	movl   $0x0,0x801136e8
-80102d17:	00 00 00 
-  write_head(); // clear the log
-80102d1a:	e8 11 ff ff ff       	call   80102c30 <write_head>
-}
-80102d1f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80102d22:	83 c4 10             	add    $0x10,%esp
-80102d25:	c9                   	leave  
-80102d26:	c3                   	ret    
-80102d27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80102d2e:	66 90                	xchg   %ax,%ax
-
-80102d30 <begin_op>:
-}
-
-// called at the start of each FS system call.
-void
-begin_op(void)
-{
-80102d30:	f3 0f 1e fb          	endbr32 
-80102d34:	55                   	push   %ebp
-80102d35:	89 e5                	mov    %esp,%ebp
-80102d37:	83 ec 14             	sub    $0x14,%esp
-  acquire(&log.lock);
-80102d3a:	68 a0 36 11 80       	push   $0x801136a0
-80102d3f:	e8 7c 20 00 00       	call   80104dc0 <acquire>
-80102d44:	83 c4 10             	add    $0x10,%esp
-80102d47:	eb 1c                	jmp    80102d65 <begin_op+0x35>
-80102d49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  while(1){
-    if(log.committing){
-      sleep(&log, &log.lock);
-80102d50:	83 ec 08             	sub    $0x8,%esp
-80102d53:	68 a0 36 11 80       	push   $0x801136a0
-80102d58:	68 a0 36 11 80       	push   $0x801136a0
-80102d5d:	e8 9e 15 00 00       	call   80104300 <sleep>
-80102d62:	83 c4 10             	add    $0x10,%esp
-    if(log.committing){
-80102d65:	a1 e0 36 11 80       	mov    0x801136e0,%eax
-80102d6a:	85 c0                	test   %eax,%eax
-80102d6c:	75 e2                	jne    80102d50 <begin_op+0x20>
-    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
-80102d6e:	a1 dc 36 11 80       	mov    0x801136dc,%eax
-80102d73:	8b 15 e8 36 11 80    	mov    0x801136e8,%edx
-80102d79:	83 c0 01             	add    $0x1,%eax
-80102d7c:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
-80102d7f:	8d 14 4a             	lea    (%edx,%ecx,2),%edx
-80102d82:	83 fa 1e             	cmp    $0x1e,%edx
-80102d85:	7f c9                	jg     80102d50 <begin_op+0x20>
-      // this op might exhaust log space; wait for commit.
-      sleep(&log, &log.lock);
-    } else {
-      log.outstanding += 1;
-      release(&log.lock);
-80102d87:	83 ec 0c             	sub    $0xc,%esp
-      log.outstanding += 1;
-80102d8a:	a3 dc 36 11 80       	mov    %eax,0x801136dc
-      release(&log.lock);
-80102d8f:	68 a0 36 11 80       	push   $0x801136a0
-80102d94:	e8 e7 20 00 00       	call   80104e80 <release>
-      break;
-    }
-  }
-}
-80102d99:	83 c4 10             	add    $0x10,%esp
-80102d9c:	c9                   	leave  
-80102d9d:	c3                   	ret    
-80102d9e:	66 90                	xchg   %ax,%ax
-
-80102da0 <end_op>:
-
-// called at the end of each FS system call.
-// commits if this was the last outstanding operation.
-void
-end_op(void)
-{
-80102da0:	f3 0f 1e fb          	endbr32 
-80102da4:	55                   	push   %ebp
-80102da5:	89 e5                	mov    %esp,%ebp
-80102da7:	57                   	push   %edi
-80102da8:	56                   	push   %esi
-80102da9:	53                   	push   %ebx
-80102daa:	83 ec 18             	sub    $0x18,%esp
-  int do_commit = 0;
-
-  acquire(&log.lock);
-80102dad:	68 a0 36 11 80       	push   $0x801136a0
-80102db2:	e8 09 20 00 00       	call   80104dc0 <acquire>
-  log.outstanding -= 1;
-80102db7:	a1 dc 36 11 80       	mov    0x801136dc,%eax
-  if(log.committing)
-80102dbc:	8b 35 e0 36 11 80    	mov    0x801136e0,%esi
-80102dc2:	83 c4 10             	add    $0x10,%esp
-  log.outstanding -= 1;
-80102dc5:	8d 58 ff             	lea    -0x1(%eax),%ebx
-80102dc8:	89 1d dc 36 11 80    	mov    %ebx,0x801136dc
-  if(log.committing)
-80102dce:	85 f6                	test   %esi,%esi
-80102dd0:	0f 85 1e 01 00 00    	jne    80102ef4 <end_op+0x154>
-    panic("log.committing");
-  if(log.outstanding == 0){
-80102dd6:	85 db                	test   %ebx,%ebx
-80102dd8:	0f 85 f2 00 00 00    	jne    80102ed0 <end_op+0x130>
-    do_commit = 1;
-    log.committing = 1;
-80102dde:	c7 05 e0 36 11 80 01 	movl   $0x1,0x801136e0
-80102de5:	00 00 00 
-    // begin_op() may be waiting for log space,
-    // and decrementing log.outstanding has decreased
-    // the amount of reserved space.
-    wakeup(&log);
-  }
-  release(&log.lock);
-80102de8:	83 ec 0c             	sub    $0xc,%esp
-80102deb:	68 a0 36 11 80       	push   $0x801136a0
-80102df0:	e8 8b 20 00 00       	call   80104e80 <release>
-}
-
-static void
-commit()
-{
-  if (log.lh.n > 0) {
-80102df5:	8b 0d e8 36 11 80    	mov    0x801136e8,%ecx
-80102dfb:	83 c4 10             	add    $0x10,%esp
-80102dfe:	85 c9                	test   %ecx,%ecx
-80102e00:	7f 3e                	jg     80102e40 <end_op+0xa0>
-    acquire(&log.lock);
-80102e02:	83 ec 0c             	sub    $0xc,%esp
-80102e05:	68 a0 36 11 80       	push   $0x801136a0
-80102e0a:	e8 b1 1f 00 00       	call   80104dc0 <acquire>
-    wakeup(&log);
-80102e0f:	c7 04 24 a0 36 11 80 	movl   $0x801136a0,(%esp)
-    log.committing = 0;
-80102e16:	c7 05 e0 36 11 80 00 	movl   $0x0,0x801136e0
-80102e1d:	00 00 00 
-    wakeup(&log);
-80102e20:	e8 9b 16 00 00       	call   801044c0 <wakeup>
-    release(&log.lock);
-80102e25:	c7 04 24 a0 36 11 80 	movl   $0x801136a0,(%esp)
-80102e2c:	e8 4f 20 00 00       	call   80104e80 <release>
-80102e31:	83 c4 10             	add    $0x10,%esp
-}
-80102e34:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80102e37:	5b                   	pop    %ebx
-80102e38:	5e                   	pop    %esi
-80102e39:	5f                   	pop    %edi
-80102e3a:	5d                   	pop    %ebp
-80102e3b:	c3                   	ret    
-80102e3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    struct buf *to = bread(log.dev, log.start+tail+1); // log block
-80102e40:	a1 d4 36 11 80       	mov    0x801136d4,%eax
-80102e45:	83 ec 08             	sub    $0x8,%esp
-80102e48:	01 d8                	add    %ebx,%eax
-80102e4a:	83 c0 01             	add    $0x1,%eax
-80102e4d:	50                   	push   %eax
-80102e4e:	ff 35 e4 36 11 80    	pushl  0x801136e4
-80102e54:	e8 77 d2 ff ff       	call   801000d0 <bread>
-80102e59:	89 c6                	mov    %eax,%esi
-    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
-80102e5b:	58                   	pop    %eax
-80102e5c:	5a                   	pop    %edx
-80102e5d:	ff 34 9d ec 36 11 80 	pushl  -0x7feec914(,%ebx,4)
-80102e64:	ff 35 e4 36 11 80    	pushl  0x801136e4
-  for (tail = 0; tail < log.lh.n; tail++) {
-80102e6a:	83 c3 01             	add    $0x1,%ebx
-    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
-80102e6d:	e8 5e d2 ff ff       	call   801000d0 <bread>
-    memmove(to->data, from->data, BSIZE);
-80102e72:	83 c4 0c             	add    $0xc,%esp
-    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
-80102e75:	89 c7                	mov    %eax,%edi
-    memmove(to->data, from->data, BSIZE);
-80102e77:	8d 40 5c             	lea    0x5c(%eax),%eax
-80102e7a:	68 00 02 00 00       	push   $0x200
-80102e7f:	50                   	push   %eax
-80102e80:	8d 46 5c             	lea    0x5c(%esi),%eax
-80102e83:	50                   	push   %eax
-80102e84:	e8 e7 20 00 00       	call   80104f70 <memmove>
-    bwrite(to);  // write the log
-80102e89:	89 34 24             	mov    %esi,(%esp)
-80102e8c:	e8 1f d3 ff ff       	call   801001b0 <bwrite>
-    brelse(from);
-80102e91:	89 3c 24             	mov    %edi,(%esp)
-80102e94:	e8 57 d3 ff ff       	call   801001f0 <brelse>
-    brelse(to);
-80102e99:	89 34 24             	mov    %esi,(%esp)
-80102e9c:	e8 4f d3 ff ff       	call   801001f0 <brelse>
-  for (tail = 0; tail < log.lh.n; tail++) {
-80102ea1:	83 c4 10             	add    $0x10,%esp
-80102ea4:	3b 1d e8 36 11 80    	cmp    0x801136e8,%ebx
-80102eaa:	7c 94                	jl     80102e40 <end_op+0xa0>
-    write_log();     // Write modified blocks from cache to log
-    write_head();    // Write header to disk -- the real commit
-80102eac:	e8 7f fd ff ff       	call   80102c30 <write_head>
-    install_trans(); // Now install writes to home locations
-80102eb1:	e8 da fc ff ff       	call   80102b90 <install_trans>
-    log.lh.n = 0;
-80102eb6:	c7 05 e8 36 11 80 00 	movl   $0x0,0x801136e8
-80102ebd:	00 00 00 
-    write_head();    // Erase the transaction from the log
-80102ec0:	e8 6b fd ff ff       	call   80102c30 <write_head>
-80102ec5:	e9 38 ff ff ff       	jmp    80102e02 <end_op+0x62>
-80102eca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    wakeup(&log);
-80102ed0:	83 ec 0c             	sub    $0xc,%esp
-80102ed3:	68 a0 36 11 80       	push   $0x801136a0
-80102ed8:	e8 e3 15 00 00       	call   801044c0 <wakeup>
-  release(&log.lock);
-80102edd:	c7 04 24 a0 36 11 80 	movl   $0x801136a0,(%esp)
-80102ee4:	e8 97 1f 00 00       	call   80104e80 <release>
-80102ee9:	83 c4 10             	add    $0x10,%esp
-}
-80102eec:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80102eef:	5b                   	pop    %ebx
-80102ef0:	5e                   	pop    %esi
-80102ef1:	5f                   	pop    %edi
-80102ef2:	5d                   	pop    %ebp
-80102ef3:	c3                   	ret    
-    panic("log.committing");
-80102ef4:	83 ec 0c             	sub    $0xc,%esp
-80102ef7:	68 24 81 10 80       	push   $0x80108124
-80102efc:	e8 8f d4 ff ff       	call   80100390 <panic>
-80102f01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80102f08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80102f0f:	90                   	nop
-
-80102f10 <log_write>:
-//   modify bp->data[]
-//   log_write(bp)
-//   brelse(bp)
-void
-log_write(struct buf *b)
-{
-80102f10:	f3 0f 1e fb          	endbr32 
-80102f14:	55                   	push   %ebp
-80102f15:	89 e5                	mov    %esp,%ebp
-80102f17:	53                   	push   %ebx
-80102f18:	83 ec 04             	sub    $0x4,%esp
-  int i;
-
-  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
-80102f1b:	8b 15 e8 36 11 80    	mov    0x801136e8,%edx
-{
-80102f21:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
-80102f24:	83 fa 1d             	cmp    $0x1d,%edx
-80102f27:	0f 8f 91 00 00 00    	jg     80102fbe <log_write+0xae>
-80102f2d:	a1 d8 36 11 80       	mov    0x801136d8,%eax
-80102f32:	83 e8 01             	sub    $0x1,%eax
-80102f35:	39 c2                	cmp    %eax,%edx
-80102f37:	0f 8d 81 00 00 00    	jge    80102fbe <log_write+0xae>
-    panic("too big a transaction");
-  if (log.outstanding < 1)
-80102f3d:	a1 dc 36 11 80       	mov    0x801136dc,%eax
-80102f42:	85 c0                	test   %eax,%eax
-80102f44:	0f 8e 81 00 00 00    	jle    80102fcb <log_write+0xbb>
-    panic("log_write outside of trans");
-
-  acquire(&log.lock);
-80102f4a:	83 ec 0c             	sub    $0xc,%esp
-80102f4d:	68 a0 36 11 80       	push   $0x801136a0
-80102f52:	e8 69 1e 00 00       	call   80104dc0 <acquire>
-  for (i = 0; i < log.lh.n; i++) {
-80102f57:	8b 15 e8 36 11 80    	mov    0x801136e8,%edx
-80102f5d:	83 c4 10             	add    $0x10,%esp
-80102f60:	85 d2                	test   %edx,%edx
-80102f62:	7e 4e                	jle    80102fb2 <log_write+0xa2>
-    if (log.lh.block[i] == b->blockno)   // log absorbtion
-80102f64:	8b 4b 08             	mov    0x8(%ebx),%ecx
-  for (i = 0; i < log.lh.n; i++) {
-80102f67:	31 c0                	xor    %eax,%eax
-80102f69:	eb 0c                	jmp    80102f77 <log_write+0x67>
-80102f6b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80102f6f:	90                   	nop
-80102f70:	83 c0 01             	add    $0x1,%eax
-80102f73:	39 c2                	cmp    %eax,%edx
-80102f75:	74 29                	je     80102fa0 <log_write+0x90>
-    if (log.lh.block[i] == b->blockno)   // log absorbtion
-80102f77:	39 0c 85 ec 36 11 80 	cmp    %ecx,-0x7feec914(,%eax,4)
-80102f7e:	75 f0                	jne    80102f70 <log_write+0x60>
-      break;
-  }
-  log.lh.block[i] = b->blockno;
-80102f80:	89 0c 85 ec 36 11 80 	mov    %ecx,-0x7feec914(,%eax,4)
-  if (i == log.lh.n)
-    log.lh.n++;
-  b->flags |= B_DIRTY; // prevent eviction
-80102f87:	83 0b 04             	orl    $0x4,(%ebx)
-  release(&log.lock);
-}
-80102f8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-  release(&log.lock);
-80102f8d:	c7 45 08 a0 36 11 80 	movl   $0x801136a0,0x8(%ebp)
-}
-80102f94:	c9                   	leave  
-  release(&log.lock);
-80102f95:	e9 e6 1e 00 00       	jmp    80104e80 <release>
-80102f9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  log.lh.block[i] = b->blockno;
-80102fa0:	89 0c 95 ec 36 11 80 	mov    %ecx,-0x7feec914(,%edx,4)
-    log.lh.n++;
-80102fa7:	83 c2 01             	add    $0x1,%edx
-80102faa:	89 15 e8 36 11 80    	mov    %edx,0x801136e8
-80102fb0:	eb d5                	jmp    80102f87 <log_write+0x77>
-  log.lh.block[i] = b->blockno;
-80102fb2:	8b 43 08             	mov    0x8(%ebx),%eax
-80102fb5:	a3 ec 36 11 80       	mov    %eax,0x801136ec
-  if (i == log.lh.n)
-80102fba:	75 cb                	jne    80102f87 <log_write+0x77>
-80102fbc:	eb e9                	jmp    80102fa7 <log_write+0x97>
-    panic("too big a transaction");
-80102fbe:	83 ec 0c             	sub    $0xc,%esp
-80102fc1:	68 33 81 10 80       	push   $0x80108133
-80102fc6:	e8 c5 d3 ff ff       	call   80100390 <panic>
-    panic("log_write outside of trans");
-80102fcb:	83 ec 0c             	sub    $0xc,%esp
-80102fce:	68 49 81 10 80       	push   $0x80108149
-80102fd3:	e8 b8 d3 ff ff       	call   80100390 <panic>
-80102fd8:	66 90                	xchg   %ax,%ax
-80102fda:	66 90                	xchg   %ax,%ax
-80102fdc:	66 90                	xchg   %ax,%ax
-80102fde:	66 90                	xchg   %ax,%ax
-
-80102fe0 <mpmain>:
-}
-
-// Common CPU setup code.
-static void
-mpmain(void)
-{
-80102fe0:	55                   	push   %ebp
-80102fe1:	89 e5                	mov    %esp,%ebp
-80102fe3:	53                   	push   %ebx
-80102fe4:	83 ec 04             	sub    $0x4,%esp
-  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
-80102fe7:	e8 a4 09 00 00       	call   80103990 <cpuid>
-80102fec:	89 c3                	mov    %eax,%ebx
-80102fee:	e8 9d 09 00 00       	call   80103990 <cpuid>
-80102ff3:	83 ec 04             	sub    $0x4,%esp
-80102ff6:	53                   	push   %ebx
-80102ff7:	50                   	push   %eax
-80102ff8:	68 64 81 10 80       	push   $0x80108164
-80102ffd:	e8 ae d6 ff ff       	call   801006b0 <cprintf>
-  idtinit();       // load idt register
-80103002:	e8 39 34 00 00       	call   80106440 <idtinit>
-  xchg(&(mycpu()->started), 1); // tell startothers() we're up
-80103007:	e8 14 09 00 00       	call   80103920 <mycpu>
-8010300c:	89 c2                	mov    %eax,%edx
-xchg(volatile uint *addr, uint newval)
-{
-  uint result;
-
-  // The + in "+m" denotes a read-modify-write operand.
-  asm volatile("lock; xchgl %0, %1" :
-8010300e:	b8 01 00 00 00       	mov    $0x1,%eax
-80103013:	f0 87 82 a0 00 00 00 	lock xchg %eax,0xa0(%edx)
-  scheduler();     // start running processes
-8010301a:	e8 11 0e 00 00       	call   80103e30 <scheduler>
-8010301f:	90                   	nop
-
-80103020 <mpenter>:
-{
-80103020:	f3 0f 1e fb          	endbr32 
-80103024:	55                   	push   %ebp
-80103025:	89 e5                	mov    %esp,%ebp
-80103027:	83 ec 08             	sub    $0x8,%esp
-  switchkvm();
-8010302a:	e8 61 45 00 00       	call   80107590 <switchkvm>
-  seginit();
-8010302f:	e8 cc 44 00 00       	call   80107500 <seginit>
-  lapicinit();
-80103034:	e8 67 f7 ff ff       	call   801027a0 <lapicinit>
-  mpmain();
-80103039:	e8 a2 ff ff ff       	call   80102fe0 <mpmain>
-8010303e:	66 90                	xchg   %ax,%ax
-
-80103040 <main>:
-{
-80103040:	f3 0f 1e fb          	endbr32 
-80103044:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-80103048:	83 e4 f0             	and    $0xfffffff0,%esp
-8010304b:	ff 71 fc             	pushl  -0x4(%ecx)
-8010304e:	55                   	push   %ebp
-8010304f:	89 e5                	mov    %esp,%ebp
-80103051:	53                   	push   %ebx
-80103052:	51                   	push   %ecx
-  kinit1(end, P2V(4*1024*1024)); // phys page allocator
-80103053:	83 ec 08             	sub    $0x8,%esp
-80103056:	68 00 00 40 80       	push   $0x80400000
-8010305b:	68 e8 89 11 80       	push   $0x801189e8
-80103060:	e8 fb f4 ff ff       	call   80102560 <kinit1>
-  kvmalloc();      // kernel page table
-80103065:	e8 06 4a 00 00       	call   80107a70 <kvmalloc>
-  mpinit();        // detect other processors
-8010306a:	e8 81 01 00 00       	call   801031f0 <mpinit>
-  lapicinit();     // interrupt controller
-8010306f:	e8 2c f7 ff ff       	call   801027a0 <lapicinit>
-  seginit();       // segment descriptors
-80103074:	e8 87 44 00 00       	call   80107500 <seginit>
-  picinit();       // disable pic
-80103079:	e8 52 03 00 00       	call   801033d0 <picinit>
-  ioapicinit();    // another interrupt controller
-8010307e:	e8 fd f2 ff ff       	call   80102380 <ioapicinit>
-  consoleinit();   // console hardware
-80103083:	e8 a8 d9 ff ff       	call   80100a30 <consoleinit>
-  uartinit();      // serial port
-80103088:	e8 33 37 00 00       	call   801067c0 <uartinit>
-  pinit();         // process table
-8010308d:	e8 6e 08 00 00       	call   80103900 <pinit>
-  tvinit();        // trap vectors
-80103092:	e8 29 33 00 00       	call   801063c0 <tvinit>
-  binit();         // buffer cache
-80103097:	e8 a4 cf ff ff       	call   80100040 <binit>
-  fileinit();      // file table
-8010309c:	e8 3f dd ff ff       	call   80100de0 <fileinit>
-  ideinit();       // disk 
-801030a1:	e8 aa f0 ff ff       	call   80102150 <ideinit>
-
-  // Write entry code to unused memory at 0x7000.
-  // The linker has placed the image of entryother.S in
-  // _binary_entryother_start.
-  code = P2V(0x7000);
-  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
-801030a6:	83 c4 0c             	add    $0xc,%esp
-801030a9:	68 8a 00 00 00       	push   $0x8a
-801030ae:	68 8c b4 10 80       	push   $0x8010b48c
-801030b3:	68 00 70 00 80       	push   $0x80007000
-801030b8:	e8 b3 1e 00 00       	call   80104f70 <memmove>
-
-  for(c = cpus; c < cpus+ncpu; c++){
-801030bd:	83 c4 10             	add    $0x10,%esp
-801030c0:	69 05 20 3d 11 80 b0 	imul   $0xb0,0x80113d20,%eax
-801030c7:	00 00 00 
-801030ca:	05 a0 37 11 80       	add    $0x801137a0,%eax
-801030cf:	3d a0 37 11 80       	cmp    $0x801137a0,%eax
-801030d4:	76 7a                	jbe    80103150 <main+0x110>
-801030d6:	bb a0 37 11 80       	mov    $0x801137a0,%ebx
-801030db:	eb 1c                	jmp    801030f9 <main+0xb9>
-801030dd:	8d 76 00             	lea    0x0(%esi),%esi
-801030e0:	69 05 20 3d 11 80 b0 	imul   $0xb0,0x80113d20,%eax
-801030e7:	00 00 00 
-801030ea:	81 c3 b0 00 00 00    	add    $0xb0,%ebx
-801030f0:	05 a0 37 11 80       	add    $0x801137a0,%eax
-801030f5:	39 c3                	cmp    %eax,%ebx
-801030f7:	73 57                	jae    80103150 <main+0x110>
-    if(c == mycpu())  // We've started already.
-801030f9:	e8 22 08 00 00       	call   80103920 <mycpu>
-801030fe:	39 c3                	cmp    %eax,%ebx
-80103100:	74 de                	je     801030e0 <main+0xa0>
-      continue;
-
-    // Tell entryother.S what stack to use, where to enter, and what
-    // pgdir to use. We cannot use kpgdir yet, because the AP processor
-    // is running in low  memory, so we use entrypgdir for the APs too.
-    stack = kalloc();
-80103102:	e8 29 f5 ff ff       	call   80102630 <kalloc>
-    *(void**)(code-4) = stack + KSTACKSIZE;
-    *(void(**)(void))(code-8) = mpenter;
-    *(int**)(code-12) = (void *) V2P(entrypgdir);
-
-    lapicstartap(c->apicid, V2P(code));
-80103107:	83 ec 08             	sub    $0x8,%esp
-    *(void(**)(void))(code-8) = mpenter;
-8010310a:	c7 05 f8 6f 00 80 20 	movl   $0x80103020,0x80006ff8
-80103111:	30 10 80 
-    *(int**)(code-12) = (void *) V2P(entrypgdir);
-80103114:	c7 05 f4 6f 00 80 00 	movl   $0x10a000,0x80006ff4
-8010311b:	a0 10 00 
-    *(void**)(code-4) = stack + KSTACKSIZE;
-8010311e:	05 00 10 00 00       	add    $0x1000,%eax
-80103123:	a3 fc 6f 00 80       	mov    %eax,0x80006ffc
-    lapicstartap(c->apicid, V2P(code));
-80103128:	0f b6 03             	movzbl (%ebx),%eax
-8010312b:	68 00 70 00 00       	push   $0x7000
-80103130:	50                   	push   %eax
-80103131:	e8 ba f7 ff ff       	call   801028f0 <lapicstartap>
-
-    // wait for cpu to finish mpmain()
-    while(c->started == 0)
-80103136:	83 c4 10             	add    $0x10,%esp
-80103139:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80103140:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
-80103146:	85 c0                	test   %eax,%eax
-80103148:	74 f6                	je     80103140 <main+0x100>
-8010314a:	eb 94                	jmp    801030e0 <main+0xa0>
-8010314c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
-80103150:	83 ec 08             	sub    $0x8,%esp
-80103153:	68 00 00 00 8e       	push   $0x8e000000
-80103158:	68 00 00 40 80       	push   $0x80400000
-8010315d:	e8 6e f4 ff ff       	call   801025d0 <kinit2>
-  userinit();      // first user process
-80103162:	e8 79 08 00 00       	call   801039e0 <userinit>
-  mpmain();        // finish this processor's setup
-80103167:	e8 74 fe ff ff       	call   80102fe0 <mpmain>
-8010316c:	66 90                	xchg   %ax,%ax
-8010316e:	66 90                	xchg   %ax,%ax
-
-80103170 <mpsearch1>:
-}
-
-// Look for an MP structure in the len bytes at addr.
-static struct mp*
-mpsearch1(uint a, int len)
-{
-80103170:	55                   	push   %ebp
-80103171:	89 e5                	mov    %esp,%ebp
-80103173:	57                   	push   %edi
-80103174:	56                   	push   %esi
-  uchar *e, *p, *addr;
-
-  addr = P2V(a);
-80103175:	8d b0 00 00 00 80    	lea    -0x80000000(%eax),%esi
-{
-8010317b:	53                   	push   %ebx
-  e = addr+len;
-8010317c:	8d 1c 16             	lea    (%esi,%edx,1),%ebx
-{
-8010317f:	83 ec 0c             	sub    $0xc,%esp
-  for(p = addr; p < e; p += sizeof(struct mp))
-80103182:	39 de                	cmp    %ebx,%esi
-80103184:	72 10                	jb     80103196 <mpsearch1+0x26>
-80103186:	eb 50                	jmp    801031d8 <mpsearch1+0x68>
-80103188:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010318f:	90                   	nop
-80103190:	89 fe                	mov    %edi,%esi
-80103192:	39 fb                	cmp    %edi,%ebx
-80103194:	76 42                	jbe    801031d8 <mpsearch1+0x68>
-    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
-80103196:	83 ec 04             	sub    $0x4,%esp
-80103199:	8d 7e 10             	lea    0x10(%esi),%edi
-8010319c:	6a 04                	push   $0x4
-8010319e:	68 78 81 10 80       	push   $0x80108178
-801031a3:	56                   	push   %esi
-801031a4:	e8 77 1d 00 00       	call   80104f20 <memcmp>
-801031a9:	83 c4 10             	add    $0x10,%esp
-801031ac:	85 c0                	test   %eax,%eax
-801031ae:	75 e0                	jne    80103190 <mpsearch1+0x20>
-801031b0:	89 f2                	mov    %esi,%edx
-801031b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    sum += addr[i];
-801031b8:	0f b6 0a             	movzbl (%edx),%ecx
-801031bb:	83 c2 01             	add    $0x1,%edx
-801031be:	01 c8                	add    %ecx,%eax
-  for(i=0; i<len; i++)
-801031c0:	39 fa                	cmp    %edi,%edx
-801031c2:	75 f4                	jne    801031b8 <mpsearch1+0x48>
-    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
-801031c4:	84 c0                	test   %al,%al
-801031c6:	75 c8                	jne    80103190 <mpsearch1+0x20>
-      return (struct mp*)p;
-  return 0;
-}
-801031c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801031cb:	89 f0                	mov    %esi,%eax
-801031cd:	5b                   	pop    %ebx
-801031ce:	5e                   	pop    %esi
-801031cf:	5f                   	pop    %edi
-801031d0:	5d                   	pop    %ebp
-801031d1:	c3                   	ret    
-801031d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-801031d8:	8d 65 f4             	lea    -0xc(%ebp),%esp
-  return 0;
-801031db:	31 f6                	xor    %esi,%esi
-}
-801031dd:	5b                   	pop    %ebx
-801031de:	89 f0                	mov    %esi,%eax
-801031e0:	5e                   	pop    %esi
-801031e1:	5f                   	pop    %edi
-801031e2:	5d                   	pop    %ebp
-801031e3:	c3                   	ret    
-801031e4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801031eb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801031ef:	90                   	nop
-
-801031f0 <mpinit>:
-  return conf;
-}
-
-void
-mpinit(void)
-{
-801031f0:	f3 0f 1e fb          	endbr32 
-801031f4:	55                   	push   %ebp
-801031f5:	89 e5                	mov    %esp,%ebp
-801031f7:	57                   	push   %edi
-801031f8:	56                   	push   %esi
-801031f9:	53                   	push   %ebx
-801031fa:	83 ec 1c             	sub    $0x1c,%esp
-  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
-801031fd:	0f b6 05 0f 04 00 80 	movzbl 0x8000040f,%eax
-80103204:	0f b6 15 0e 04 00 80 	movzbl 0x8000040e,%edx
-8010320b:	c1 e0 08             	shl    $0x8,%eax
-8010320e:	09 d0                	or     %edx,%eax
-80103210:	c1 e0 04             	shl    $0x4,%eax
-80103213:	75 1b                	jne    80103230 <mpinit+0x40>
-    p = ((bda[0x14]<<8)|bda[0x13])*1024;
-80103215:	0f b6 05 14 04 00 80 	movzbl 0x80000414,%eax
-8010321c:	0f b6 15 13 04 00 80 	movzbl 0x80000413,%edx
-80103223:	c1 e0 08             	shl    $0x8,%eax
-80103226:	09 d0                	or     %edx,%eax
-80103228:	c1 e0 0a             	shl    $0xa,%eax
-    if((mp = mpsearch1(p-1024, 1024)))
-8010322b:	2d 00 04 00 00       	sub    $0x400,%eax
-    if((mp = mpsearch1(p, 1024)))
-80103230:	ba 00 04 00 00       	mov    $0x400,%edx
-80103235:	e8 36 ff ff ff       	call   80103170 <mpsearch1>
-8010323a:	89 c6                	mov    %eax,%esi
-8010323c:	85 c0                	test   %eax,%eax
-8010323e:	0f 84 4c 01 00 00    	je     80103390 <mpinit+0x1a0>
-  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
-80103244:	8b 5e 04             	mov    0x4(%esi),%ebx
-80103247:	85 db                	test   %ebx,%ebx
-80103249:	0f 84 61 01 00 00    	je     801033b0 <mpinit+0x1c0>
-  if(memcmp(conf, "PCMP", 4) != 0)
-8010324f:	83 ec 04             	sub    $0x4,%esp
-  conf = (struct mpconf*) P2V((uint) mp->physaddr);
-80103252:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
-  if(memcmp(conf, "PCMP", 4) != 0)
-80103258:	6a 04                	push   $0x4
-8010325a:	68 7d 81 10 80       	push   $0x8010817d
-8010325f:	50                   	push   %eax
-  conf = (struct mpconf*) P2V((uint) mp->physaddr);
-80103260:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-  if(memcmp(conf, "PCMP", 4) != 0)
-80103263:	e8 b8 1c 00 00       	call   80104f20 <memcmp>
-80103268:	83 c4 10             	add    $0x10,%esp
-8010326b:	85 c0                	test   %eax,%eax
-8010326d:	0f 85 3d 01 00 00    	jne    801033b0 <mpinit+0x1c0>
-  if(conf->version != 1 && conf->version != 4)
-80103273:	0f b6 83 06 00 00 80 	movzbl -0x7ffffffa(%ebx),%eax
-8010327a:	3c 01                	cmp    $0x1,%al
-8010327c:	74 08                	je     80103286 <mpinit+0x96>
-8010327e:	3c 04                	cmp    $0x4,%al
-80103280:	0f 85 2a 01 00 00    	jne    801033b0 <mpinit+0x1c0>
-  if(sum((uchar*)conf, conf->length) != 0)
-80103286:	0f b7 93 04 00 00 80 	movzwl -0x7ffffffc(%ebx),%edx
-  for(i=0; i<len; i++)
-8010328d:	66 85 d2             	test   %dx,%dx
-80103290:	74 26                	je     801032b8 <mpinit+0xc8>
-80103292:	8d 3c 1a             	lea    (%edx,%ebx,1),%edi
-80103295:	89 d8                	mov    %ebx,%eax
-  sum = 0;
-80103297:	31 d2                	xor    %edx,%edx
-80103299:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    sum += addr[i];
-801032a0:	0f b6 88 00 00 00 80 	movzbl -0x80000000(%eax),%ecx
-801032a7:	83 c0 01             	add    $0x1,%eax
-801032aa:	01 ca                	add    %ecx,%edx
-  for(i=0; i<len; i++)
-801032ac:	39 f8                	cmp    %edi,%eax
-801032ae:	75 f0                	jne    801032a0 <mpinit+0xb0>
-  if(sum((uchar*)conf, conf->length) != 0)
-801032b0:	84 d2                	test   %dl,%dl
-801032b2:	0f 85 f8 00 00 00    	jne    801033b0 <mpinit+0x1c0>
-  struct mpioapic *ioapic;
-
-  if((conf = mpconfig(&mp)) == 0)
-    panic("Expect to run on an SMP");
-  ismp = 1;
-  lapic = (uint*)conf->lapicaddr;
-801032b8:	8b 83 24 00 00 80    	mov    -0x7fffffdc(%ebx),%eax
-801032be:	a3 9c 36 11 80       	mov    %eax,0x8011369c
-  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
-801032c3:	8d 83 2c 00 00 80    	lea    -0x7fffffd4(%ebx),%eax
-801032c9:	0f b7 93 04 00 00 80 	movzwl -0x7ffffffc(%ebx),%edx
-  ismp = 1;
-801032d0:	bb 01 00 00 00       	mov    $0x1,%ebx
-  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
-801032d5:	03 55 e4             	add    -0x1c(%ebp),%edx
-801032d8:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
-801032db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801032df:	90                   	nop
-801032e0:	39 c2                	cmp    %eax,%edx
-801032e2:	76 15                	jbe    801032f9 <mpinit+0x109>
-    switch(*p){
-801032e4:	0f b6 08             	movzbl (%eax),%ecx
-801032e7:	80 f9 02             	cmp    $0x2,%cl
-801032ea:	74 5c                	je     80103348 <mpinit+0x158>
-801032ec:	77 42                	ja     80103330 <mpinit+0x140>
-801032ee:	84 c9                	test   %cl,%cl
-801032f0:	74 6e                	je     80103360 <mpinit+0x170>
-      p += sizeof(struct mpioapic);
-      continue;
-    case MPBUS:
-    case MPIOINTR:
-    case MPLINTR:
-      p += 8;
-801032f2:	83 c0 08             	add    $0x8,%eax
-  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
-801032f5:	39 c2                	cmp    %eax,%edx
-801032f7:	77 eb                	ja     801032e4 <mpinit+0xf4>
-801032f9:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
-    default:
-      ismp = 0;
-      break;
-    }
-  }
-  if(!ismp)
-801032fc:	85 db                	test   %ebx,%ebx
-801032fe:	0f 84 b9 00 00 00    	je     801033bd <mpinit+0x1cd>
-    panic("Didn't find a suitable machine");
-
-  if(mp->imcrp){
-80103304:	80 7e 0c 00          	cmpb   $0x0,0xc(%esi)
-80103308:	74 15                	je     8010331f <mpinit+0x12f>
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-8010330a:	b8 70 00 00 00       	mov    $0x70,%eax
-8010330f:	ba 22 00 00 00       	mov    $0x22,%edx
-80103314:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80103315:	ba 23 00 00 00       	mov    $0x23,%edx
-8010331a:	ec                   	in     (%dx),%al
-    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
-    // But it would on real hardware.
-    outb(0x22, 0x70);   // Select IMCR
-    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
-8010331b:	83 c8 01             	or     $0x1,%eax
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-8010331e:	ee                   	out    %al,(%dx)
-  }
-}
-8010331f:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80103322:	5b                   	pop    %ebx
-80103323:	5e                   	pop    %esi
-80103324:	5f                   	pop    %edi
-80103325:	5d                   	pop    %ebp
-80103326:	c3                   	ret    
-80103327:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010332e:	66 90                	xchg   %ax,%ax
-    switch(*p){
-80103330:	83 e9 03             	sub    $0x3,%ecx
-80103333:	80 f9 01             	cmp    $0x1,%cl
-80103336:	76 ba                	jbe    801032f2 <mpinit+0x102>
-80103338:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
-8010333f:	eb 9f                	jmp    801032e0 <mpinit+0xf0>
-80103341:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      ioapicid = ioapic->apicno;
-80103348:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
-      p += sizeof(struct mpioapic);
-8010334c:	83 c0 08             	add    $0x8,%eax
-      ioapicid = ioapic->apicno;
-8010334f:	88 0d 80 37 11 80    	mov    %cl,0x80113780
-      continue;
-80103355:	eb 89                	jmp    801032e0 <mpinit+0xf0>
-80103357:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010335e:	66 90                	xchg   %ax,%ax
-      if(ncpu < NCPU) {
-80103360:	8b 0d 20 3d 11 80    	mov    0x80113d20,%ecx
-80103366:	83 f9 07             	cmp    $0x7,%ecx
-80103369:	7f 19                	jg     80103384 <mpinit+0x194>
-        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
-8010336b:	69 f9 b0 00 00 00    	imul   $0xb0,%ecx,%edi
-80103371:	0f b6 58 01          	movzbl 0x1(%eax),%ebx
-        ncpu++;
-80103375:	83 c1 01             	add    $0x1,%ecx
-80103378:	89 0d 20 3d 11 80    	mov    %ecx,0x80113d20
-        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
-8010337e:	88 9f a0 37 11 80    	mov    %bl,-0x7feec860(%edi)
-      p += sizeof(struct mpproc);
-80103384:	83 c0 14             	add    $0x14,%eax
-      continue;
-80103387:	e9 54 ff ff ff       	jmp    801032e0 <mpinit+0xf0>
-8010338c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  return mpsearch1(0xF0000, 0x10000);
-80103390:	ba 00 00 01 00       	mov    $0x10000,%edx
-80103395:	b8 00 00 0f 00       	mov    $0xf0000,%eax
-8010339a:	e8 d1 fd ff ff       	call   80103170 <mpsearch1>
-8010339f:	89 c6                	mov    %eax,%esi
-  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
-801033a1:	85 c0                	test   %eax,%eax
-801033a3:	0f 85 9b fe ff ff    	jne    80103244 <mpinit+0x54>
-801033a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    panic("Expect to run on an SMP");
-801033b0:	83 ec 0c             	sub    $0xc,%esp
-801033b3:	68 82 81 10 80       	push   $0x80108182
-801033b8:	e8 d3 cf ff ff       	call   80100390 <panic>
-    panic("Didn't find a suitable machine");
-801033bd:	83 ec 0c             	sub    $0xc,%esp
-801033c0:	68 9c 81 10 80       	push   $0x8010819c
-801033c5:	e8 c6 cf ff ff       	call   80100390 <panic>
-801033ca:	66 90                	xchg   %ax,%ax
-801033cc:	66 90                	xchg   %ax,%ax
-801033ce:	66 90                	xchg   %ax,%ax
-
-801033d0 <picinit>:
-#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
-
-// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
-void
-picinit(void)
-{
-801033d0:	f3 0f 1e fb          	endbr32 
-801033d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-801033d9:	ba 21 00 00 00       	mov    $0x21,%edx
-801033de:	ee                   	out    %al,(%dx)
-801033df:	ba a1 00 00 00       	mov    $0xa1,%edx
-801033e4:	ee                   	out    %al,(%dx)
-  // mask all interrupts
-  outb(IO_PIC1+1, 0xFF);
-  outb(IO_PIC2+1, 0xFF);
-}
-801033e5:	c3                   	ret    
-801033e6:	66 90                	xchg   %ax,%ax
-801033e8:	66 90                	xchg   %ax,%ax
-801033ea:	66 90                	xchg   %ax,%ax
-801033ec:	66 90                	xchg   %ax,%ax
-801033ee:	66 90                	xchg   %ax,%ax
-
-801033f0 <pipealloc>:
-  int writeopen;  // write fd is still open
-};
-
-int
-pipealloc(struct file **f0, struct file **f1)
-{
-801033f0:	f3 0f 1e fb          	endbr32 
-801033f4:	55                   	push   %ebp
-801033f5:	89 e5                	mov    %esp,%ebp
-801033f7:	57                   	push   %edi
-801033f8:	56                   	push   %esi
-801033f9:	53                   	push   %ebx
-801033fa:	83 ec 0c             	sub    $0xc,%esp
-801033fd:	8b 5d 08             	mov    0x8(%ebp),%ebx
-80103400:	8b 75 0c             	mov    0xc(%ebp),%esi
-  struct pipe *p;
-
-  p = 0;
-  *f0 = *f1 = 0;
-80103403:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
-80103409:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
-  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
-8010340f:	e8 ec d9 ff ff       	call   80100e00 <filealloc>
-80103414:	89 03                	mov    %eax,(%ebx)
-80103416:	85 c0                	test   %eax,%eax
-80103418:	0f 84 ac 00 00 00    	je     801034ca <pipealloc+0xda>
-8010341e:	e8 dd d9 ff ff       	call   80100e00 <filealloc>
-80103423:	89 06                	mov    %eax,(%esi)
-80103425:	85 c0                	test   %eax,%eax
-80103427:	0f 84 8b 00 00 00    	je     801034b8 <pipealloc+0xc8>
-    goto bad;
-  if((p = (struct pipe*)kalloc()) == 0)
-8010342d:	e8 fe f1 ff ff       	call   80102630 <kalloc>
-80103432:	89 c7                	mov    %eax,%edi
-80103434:	85 c0                	test   %eax,%eax
-80103436:	0f 84 b4 00 00 00    	je     801034f0 <pipealloc+0x100>
-    goto bad;
-  p->readopen = 1;
-8010343c:	c7 80 3c 02 00 00 01 	movl   $0x1,0x23c(%eax)
-80103443:	00 00 00 
-  p->writeopen = 1;
-  p->nwrite = 0;
-  p->nread = 0;
-  initlock(&p->lock, "pipe");
-80103446:	83 ec 08             	sub    $0x8,%esp
-  p->writeopen = 1;
-80103449:	c7 80 40 02 00 00 01 	movl   $0x1,0x240(%eax)
-80103450:	00 00 00 
-  p->nwrite = 0;
-80103453:	c7 80 38 02 00 00 00 	movl   $0x0,0x238(%eax)
-8010345a:	00 00 00 
-  p->nread = 0;
-8010345d:	c7 80 34 02 00 00 00 	movl   $0x0,0x234(%eax)
-80103464:	00 00 00 
-  initlock(&p->lock, "pipe");
-80103467:	68 bb 81 10 80       	push   $0x801081bb
-8010346c:	50                   	push   %eax
-8010346d:	e8 ce 17 00 00       	call   80104c40 <initlock>
-  (*f0)->type = FD_PIPE;
-80103472:	8b 03                	mov    (%ebx),%eax
-  (*f0)->pipe = p;
-  (*f1)->type = FD_PIPE;
-  (*f1)->readable = 0;
-  (*f1)->writable = 1;
-  (*f1)->pipe = p;
-  return 0;
-80103474:	83 c4 10             	add    $0x10,%esp
-  (*f0)->type = FD_PIPE;
-80103477:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
-  (*f0)->readable = 1;
-8010347d:	8b 03                	mov    (%ebx),%eax
-8010347f:	c6 40 08 01          	movb   $0x1,0x8(%eax)
-  (*f0)->writable = 0;
-80103483:	8b 03                	mov    (%ebx),%eax
-80103485:	c6 40 09 00          	movb   $0x0,0x9(%eax)
-  (*f0)->pipe = p;
-80103489:	8b 03                	mov    (%ebx),%eax
-8010348b:	89 78 0c             	mov    %edi,0xc(%eax)
-  (*f1)->type = FD_PIPE;
-8010348e:	8b 06                	mov    (%esi),%eax
-80103490:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
-  (*f1)->readable = 0;
-80103496:	8b 06                	mov    (%esi),%eax
-80103498:	c6 40 08 00          	movb   $0x0,0x8(%eax)
-  (*f1)->writable = 1;
-8010349c:	8b 06                	mov    (%esi),%eax
-8010349e:	c6 40 09 01          	movb   $0x1,0x9(%eax)
-  (*f1)->pipe = p;
-801034a2:	8b 06                	mov    (%esi),%eax
-801034a4:	89 78 0c             	mov    %edi,0xc(%eax)
-  if(*f0)
-    fileclose(*f0);
-  if(*f1)
-    fileclose(*f1);
-  return -1;
-}
-801034a7:	8d 65 f4             	lea    -0xc(%ebp),%esp
-  return 0;
-801034aa:	31 c0                	xor    %eax,%eax
-}
-801034ac:	5b                   	pop    %ebx
-801034ad:	5e                   	pop    %esi
-801034ae:	5f                   	pop    %edi
-801034af:	5d                   	pop    %ebp
-801034b0:	c3                   	ret    
-801034b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  if(*f0)
-801034b8:	8b 03                	mov    (%ebx),%eax
-801034ba:	85 c0                	test   %eax,%eax
-801034bc:	74 1e                	je     801034dc <pipealloc+0xec>
-    fileclose(*f0);
-801034be:	83 ec 0c             	sub    $0xc,%esp
-801034c1:	50                   	push   %eax
-801034c2:	e8 f9 d9 ff ff       	call   80100ec0 <fileclose>
-801034c7:	83 c4 10             	add    $0x10,%esp
-  if(*f1)
-801034ca:	8b 06                	mov    (%esi),%eax
-801034cc:	85 c0                	test   %eax,%eax
-801034ce:	74 0c                	je     801034dc <pipealloc+0xec>
-    fileclose(*f1);
-801034d0:	83 ec 0c             	sub    $0xc,%esp
-801034d3:	50                   	push   %eax
-801034d4:	e8 e7 d9 ff ff       	call   80100ec0 <fileclose>
-801034d9:	83 c4 10             	add    $0x10,%esp
-}
-801034dc:	8d 65 f4             	lea    -0xc(%ebp),%esp
-  return -1;
-801034df:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-801034e4:	5b                   	pop    %ebx
-801034e5:	5e                   	pop    %esi
-801034e6:	5f                   	pop    %edi
-801034e7:	5d                   	pop    %ebp
-801034e8:	c3                   	ret    
-801034e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  if(*f0)
-801034f0:	8b 03                	mov    (%ebx),%eax
-801034f2:	85 c0                	test   %eax,%eax
-801034f4:	75 c8                	jne    801034be <pipealloc+0xce>
-801034f6:	eb d2                	jmp    801034ca <pipealloc+0xda>
-801034f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801034ff:	90                   	nop
-
-80103500 <pipeclose>:
-
-void
-pipeclose(struct pipe *p, int writable)
-{
-80103500:	f3 0f 1e fb          	endbr32 
-80103504:	55                   	push   %ebp
-80103505:	89 e5                	mov    %esp,%ebp
-80103507:	56                   	push   %esi
-80103508:	53                   	push   %ebx
-80103509:	8b 5d 08             	mov    0x8(%ebp),%ebx
-8010350c:	8b 75 0c             	mov    0xc(%ebp),%esi
-  acquire(&p->lock);
-8010350f:	83 ec 0c             	sub    $0xc,%esp
-80103512:	53                   	push   %ebx
-80103513:	e8 a8 18 00 00       	call   80104dc0 <acquire>
-  if(writable){
-80103518:	83 c4 10             	add    $0x10,%esp
-8010351b:	85 f6                	test   %esi,%esi
-8010351d:	74 41                	je     80103560 <pipeclose+0x60>
-    p->writeopen = 0;
-    wakeup(&p->nread);
-8010351f:	83 ec 0c             	sub    $0xc,%esp
-80103522:	8d 83 34 02 00 00    	lea    0x234(%ebx),%eax
-    p->writeopen = 0;
-80103528:	c7 83 40 02 00 00 00 	movl   $0x0,0x240(%ebx)
-8010352f:	00 00 00 
-    wakeup(&p->nread);
-80103532:	50                   	push   %eax
-80103533:	e8 88 0f 00 00       	call   801044c0 <wakeup>
-80103538:	83 c4 10             	add    $0x10,%esp
-  } else {
-    p->readopen = 0;
-    wakeup(&p->nwrite);
-  }
-  if(p->readopen == 0 && p->writeopen == 0){
-8010353b:	8b 93 3c 02 00 00    	mov    0x23c(%ebx),%edx
-80103541:	85 d2                	test   %edx,%edx
-80103543:	75 0a                	jne    8010354f <pipeclose+0x4f>
-80103545:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
-8010354b:	85 c0                	test   %eax,%eax
-8010354d:	74 31                	je     80103580 <pipeclose+0x80>
-    release(&p->lock);
-    kfree((char*)p);
-  } else
-    release(&p->lock);
-8010354f:	89 5d 08             	mov    %ebx,0x8(%ebp)
-}
-80103552:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80103555:	5b                   	pop    %ebx
-80103556:	5e                   	pop    %esi
-80103557:	5d                   	pop    %ebp
-    release(&p->lock);
-80103558:	e9 23 19 00 00       	jmp    80104e80 <release>
-8010355d:	8d 76 00             	lea    0x0(%esi),%esi
-    wakeup(&p->nwrite);
-80103560:	83 ec 0c             	sub    $0xc,%esp
-80103563:	8d 83 38 02 00 00    	lea    0x238(%ebx),%eax
-    p->readopen = 0;
-80103569:	c7 83 3c 02 00 00 00 	movl   $0x0,0x23c(%ebx)
-80103570:	00 00 00 
-    wakeup(&p->nwrite);
-80103573:	50                   	push   %eax
-80103574:	e8 47 0f 00 00       	call   801044c0 <wakeup>
-80103579:	83 c4 10             	add    $0x10,%esp
-8010357c:	eb bd                	jmp    8010353b <pipeclose+0x3b>
-8010357e:	66 90                	xchg   %ax,%ax
-    release(&p->lock);
-80103580:	83 ec 0c             	sub    $0xc,%esp
-80103583:	53                   	push   %ebx
-80103584:	e8 f7 18 00 00       	call   80104e80 <release>
-    kfree((char*)p);
-80103589:	89 5d 08             	mov    %ebx,0x8(%ebp)
-8010358c:	83 c4 10             	add    $0x10,%esp
-}
-8010358f:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80103592:	5b                   	pop    %ebx
-80103593:	5e                   	pop    %esi
-80103594:	5d                   	pop    %ebp
-    kfree((char*)p);
-80103595:	e9 d6 ee ff ff       	jmp    80102470 <kfree>
-8010359a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-801035a0 <pipewrite>:
-
-//PAGEBREAK: 40
-int
-pipewrite(struct pipe *p, char *addr, int n)
-{
-801035a0:	f3 0f 1e fb          	endbr32 
-801035a4:	55                   	push   %ebp
-801035a5:	89 e5                	mov    %esp,%ebp
-801035a7:	57                   	push   %edi
-801035a8:	56                   	push   %esi
-801035a9:	53                   	push   %ebx
-801035aa:	83 ec 28             	sub    $0x28,%esp
-801035ad:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  int i;
-
-  acquire(&p->lock);
-801035b0:	53                   	push   %ebx
-801035b1:	e8 0a 18 00 00       	call   80104dc0 <acquire>
-  for(i = 0; i < n; i++){
-801035b6:	8b 45 10             	mov    0x10(%ebp),%eax
-801035b9:	83 c4 10             	add    $0x10,%esp
-801035bc:	85 c0                	test   %eax,%eax
-801035be:	0f 8e bc 00 00 00    	jle    80103680 <pipewrite+0xe0>
-801035c4:	8b 45 0c             	mov    0xc(%ebp),%eax
-801035c7:	8b 8b 38 02 00 00    	mov    0x238(%ebx),%ecx
-    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
-      if(p->readopen == 0 || myproc()->killed){
-        release(&p->lock);
-        return -1;
-      }
-      wakeup(&p->nread);
-801035cd:	8d bb 34 02 00 00    	lea    0x234(%ebx),%edi
-801035d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-801035d6:	03 45 10             	add    0x10(%ebp),%eax
-801035d9:	89 45 e0             	mov    %eax,-0x20(%ebp)
-    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
-801035dc:	8b 83 34 02 00 00    	mov    0x234(%ebx),%eax
-      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
-801035e2:	8d b3 38 02 00 00    	lea    0x238(%ebx),%esi
-    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
-801035e8:	89 ca                	mov    %ecx,%edx
-801035ea:	05 00 02 00 00       	add    $0x200,%eax
-801035ef:	39 c1                	cmp    %eax,%ecx
-801035f1:	74 3b                	je     8010362e <pipewrite+0x8e>
-801035f3:	eb 63                	jmp    80103658 <pipewrite+0xb8>
-801035f5:	8d 76 00             	lea    0x0(%esi),%esi
-      if(p->readopen == 0 || myproc()->killed){
-801035f8:	e8 b3 03 00 00       	call   801039b0 <myproc>
-801035fd:	8b 48 24             	mov    0x24(%eax),%ecx
-80103600:	85 c9                	test   %ecx,%ecx
-80103602:	75 34                	jne    80103638 <pipewrite+0x98>
-      wakeup(&p->nread);
-80103604:	83 ec 0c             	sub    $0xc,%esp
-80103607:	57                   	push   %edi
-80103608:	e8 b3 0e 00 00       	call   801044c0 <wakeup>
-      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
-8010360d:	58                   	pop    %eax
-8010360e:	5a                   	pop    %edx
-8010360f:	53                   	push   %ebx
-80103610:	56                   	push   %esi
-80103611:	e8 ea 0c 00 00       	call   80104300 <sleep>
-    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
-80103616:	8b 83 34 02 00 00    	mov    0x234(%ebx),%eax
-8010361c:	8b 93 38 02 00 00    	mov    0x238(%ebx),%edx
-80103622:	83 c4 10             	add    $0x10,%esp
-80103625:	05 00 02 00 00       	add    $0x200,%eax
-8010362a:	39 c2                	cmp    %eax,%edx
-8010362c:	75 2a                	jne    80103658 <pipewrite+0xb8>
-      if(p->readopen == 0 || myproc()->killed){
-8010362e:	8b 83 3c 02 00 00    	mov    0x23c(%ebx),%eax
-80103634:	85 c0                	test   %eax,%eax
-80103636:	75 c0                	jne    801035f8 <pipewrite+0x58>
-        release(&p->lock);
-80103638:	83 ec 0c             	sub    $0xc,%esp
-8010363b:	53                   	push   %ebx
-8010363c:	e8 3f 18 00 00       	call   80104e80 <release>
-        return -1;
-80103641:	83 c4 10             	add    $0x10,%esp
-80103644:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-    p->data[p->nwrite++ % PIPESIZE] = addr[i];
-  }
-  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
-  release(&p->lock);
-  return n;
-}
-80103649:	8d 65 f4             	lea    -0xc(%ebp),%esp
-8010364c:	5b                   	pop    %ebx
-8010364d:	5e                   	pop    %esi
-8010364e:	5f                   	pop    %edi
-8010364f:	5d                   	pop    %ebp
-80103650:	c3                   	ret    
-80103651:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    p->data[p->nwrite++ % PIPESIZE] = addr[i];
-80103658:	8b 75 e4             	mov    -0x1c(%ebp),%esi
-8010365b:	8d 4a 01             	lea    0x1(%edx),%ecx
-8010365e:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
-80103664:	89 8b 38 02 00 00    	mov    %ecx,0x238(%ebx)
-8010366a:	0f b6 06             	movzbl (%esi),%eax
-8010366d:	83 c6 01             	add    $0x1,%esi
-80103670:	89 75 e4             	mov    %esi,-0x1c(%ebp)
-80103673:	88 44 13 34          	mov    %al,0x34(%ebx,%edx,1)
-  for(i = 0; i < n; i++){
-80103677:	3b 75 e0             	cmp    -0x20(%ebp),%esi
-8010367a:	0f 85 5c ff ff ff    	jne    801035dc <pipewrite+0x3c>
-  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
-80103680:	83 ec 0c             	sub    $0xc,%esp
-80103683:	8d 83 34 02 00 00    	lea    0x234(%ebx),%eax
-80103689:	50                   	push   %eax
-8010368a:	e8 31 0e 00 00       	call   801044c0 <wakeup>
-  release(&p->lock);
-8010368f:	89 1c 24             	mov    %ebx,(%esp)
-80103692:	e8 e9 17 00 00       	call   80104e80 <release>
-  return n;
-80103697:	8b 45 10             	mov    0x10(%ebp),%eax
-8010369a:	83 c4 10             	add    $0x10,%esp
-8010369d:	eb aa                	jmp    80103649 <pipewrite+0xa9>
-8010369f:	90                   	nop
-
-801036a0 <piperead>:
-
-int
-piperead(struct pipe *p, char *addr, int n)
-{
-801036a0:	f3 0f 1e fb          	endbr32 
-801036a4:	55                   	push   %ebp
-801036a5:	89 e5                	mov    %esp,%ebp
-801036a7:	57                   	push   %edi
-801036a8:	56                   	push   %esi
-801036a9:	53                   	push   %ebx
-801036aa:	83 ec 18             	sub    $0x18,%esp
-801036ad:	8b 75 08             	mov    0x8(%ebp),%esi
-801036b0:	8b 7d 0c             	mov    0xc(%ebp),%edi
-  int i;
-
-  acquire(&p->lock);
-801036b3:	56                   	push   %esi
-801036b4:	8d 9e 34 02 00 00    	lea    0x234(%esi),%ebx
-801036ba:	e8 01 17 00 00       	call   80104dc0 <acquire>
-  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
-801036bf:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
-801036c5:	83 c4 10             	add    $0x10,%esp
-801036c8:	39 86 38 02 00 00    	cmp    %eax,0x238(%esi)
-801036ce:	74 33                	je     80103703 <piperead+0x63>
-801036d0:	eb 3b                	jmp    8010370d <piperead+0x6d>
-801036d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    if(myproc()->killed){
-801036d8:	e8 d3 02 00 00       	call   801039b0 <myproc>
-801036dd:	8b 48 24             	mov    0x24(%eax),%ecx
-801036e0:	85 c9                	test   %ecx,%ecx
-801036e2:	0f 85 88 00 00 00    	jne    80103770 <piperead+0xd0>
-      release(&p->lock);
-      return -1;
-    }
-    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
-801036e8:	83 ec 08             	sub    $0x8,%esp
-801036eb:	56                   	push   %esi
-801036ec:	53                   	push   %ebx
-801036ed:	e8 0e 0c 00 00       	call   80104300 <sleep>
-  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
-801036f2:	8b 86 38 02 00 00    	mov    0x238(%esi),%eax
-801036f8:	83 c4 10             	add    $0x10,%esp
-801036fb:	39 86 34 02 00 00    	cmp    %eax,0x234(%esi)
-80103701:	75 0a                	jne    8010370d <piperead+0x6d>
-80103703:	8b 86 40 02 00 00    	mov    0x240(%esi),%eax
-80103709:	85 c0                	test   %eax,%eax
-8010370b:	75 cb                	jne    801036d8 <piperead+0x38>
-  }
-  for(i = 0; i < n; i++){  //DOC: piperead-copy
-8010370d:	8b 55 10             	mov    0x10(%ebp),%edx
-80103710:	31 db                	xor    %ebx,%ebx
-80103712:	85 d2                	test   %edx,%edx
-80103714:	7f 28                	jg     8010373e <piperead+0x9e>
-80103716:	eb 34                	jmp    8010374c <piperead+0xac>
-80103718:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010371f:	90                   	nop
-    if(p->nread == p->nwrite)
-      break;
-    addr[i] = p->data[p->nread++ % PIPESIZE];
-80103720:	8d 48 01             	lea    0x1(%eax),%ecx
-80103723:	25 ff 01 00 00       	and    $0x1ff,%eax
-80103728:	89 8e 34 02 00 00    	mov    %ecx,0x234(%esi)
-8010372e:	0f b6 44 06 34       	movzbl 0x34(%esi,%eax,1),%eax
-80103733:	88 04 1f             	mov    %al,(%edi,%ebx,1)
-  for(i = 0; i < n; i++){  //DOC: piperead-copy
-80103736:	83 c3 01             	add    $0x1,%ebx
-80103739:	39 5d 10             	cmp    %ebx,0x10(%ebp)
-8010373c:	74 0e                	je     8010374c <piperead+0xac>
-    if(p->nread == p->nwrite)
-8010373e:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
-80103744:	3b 86 38 02 00 00    	cmp    0x238(%esi),%eax
-8010374a:	75 d4                	jne    80103720 <piperead+0x80>
-  }
-  wakeup(&p->nwrite);  //DOC: piperead-wakeup
-8010374c:	83 ec 0c             	sub    $0xc,%esp
-8010374f:	8d 86 38 02 00 00    	lea    0x238(%esi),%eax
-80103755:	50                   	push   %eax
-80103756:	e8 65 0d 00 00       	call   801044c0 <wakeup>
-  release(&p->lock);
-8010375b:	89 34 24             	mov    %esi,(%esp)
-8010375e:	e8 1d 17 00 00       	call   80104e80 <release>
-  return i;
-80103763:	83 c4 10             	add    $0x10,%esp
-}
-80103766:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80103769:	89 d8                	mov    %ebx,%eax
-8010376b:	5b                   	pop    %ebx
-8010376c:	5e                   	pop    %esi
-8010376d:	5f                   	pop    %edi
-8010376e:	5d                   	pop    %ebp
-8010376f:	c3                   	ret    
-      release(&p->lock);
-80103770:	83 ec 0c             	sub    $0xc,%esp
-      return -1;
-80103773:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
-      release(&p->lock);
-80103778:	56                   	push   %esi
-80103779:	e8 02 17 00 00       	call   80104e80 <release>
-      return -1;
-8010377e:	83 c4 10             	add    $0x10,%esp
-}
-80103781:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80103784:	89 d8                	mov    %ebx,%eax
-80103786:	5b                   	pop    %ebx
-80103787:	5e                   	pop    %esi
-80103788:	5f                   	pop    %edi
-80103789:	5d                   	pop    %ebp
-8010378a:	c3                   	ret    
-8010378b:	66 90                	xchg   %ax,%ax
-8010378d:	66 90                	xchg   %ax,%ax
-8010378f:	90                   	nop
-
-80103790 <allocproc>:
-// state required to run in the kernel.
-// Otherwise return 0.
-int total_t = 0;
-static struct proc *
-allocproc(void)
-{
-80103790:	55                   	push   %ebp
-80103791:	89 e5                	mov    %esp,%ebp
-80103793:	53                   	push   %ebx
-  struct proc *p;
-  char *sp;
-
-  acquire(&ptable.lock);
-
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80103794:	bb 94 3d 11 80       	mov    $0x80113d94,%ebx
-{
-80103799:	83 ec 10             	sub    $0x10,%esp
-  acquire(&ptable.lock);
-8010379c:	68 60 3d 11 80       	push   $0x80113d60
-801037a1:	e8 1a 16 00 00       	call   80104dc0 <acquire>
-801037a6:	83 c4 10             	add    $0x10,%esp
-801037a9:	eb 17                	jmp    801037c2 <allocproc+0x32>
-801037ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801037af:	90                   	nop
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-801037b0:	81 c3 10 01 00 00    	add    $0x110,%ebx
-801037b6:	81 fb 94 81 11 80    	cmp    $0x80118194,%ebx
-801037bc:	0f 84 be 00 00 00    	je     80103880 <allocproc+0xf0>
-    if (p->state == UNUSED)
-801037c2:	8b 43 0c             	mov    0xc(%ebx),%eax
-801037c5:	85 c0                	test   %eax,%eax
-801037c7:	75 e7                	jne    801037b0 <allocproc+0x20>
-  release(&ptable.lock);
-  return 0;
-
-found:
-  p->state = EMBRYO;
-  p->pid = nextpid++;
-801037c9:	a1 04 b0 10 80       	mov    0x8010b004,%eax
-
-  release(&ptable.lock);
-801037ce:	83 ec 0c             	sub    $0xc,%esp
-  p->state = EMBRYO;
-801037d1:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
-  p->pid = nextpid++;
-801037d8:	89 43 10             	mov    %eax,0x10(%ebx)
-801037db:	8d 50 01             	lea    0x1(%eax),%edx
-  release(&ptable.lock);
-801037de:	68 60 3d 11 80       	push   $0x80113d60
-  p->pid = nextpid++;
-801037e3:	89 15 04 b0 10 80    	mov    %edx,0x8010b004
-  release(&ptable.lock);
-801037e9:	e8 92 16 00 00       	call   80104e80 <release>
-
-  // Allocate kernel stack.
-  if ((p->kstack = kalloc()) == 0)
-801037ee:	e8 3d ee ff ff       	call   80102630 <kalloc>
-801037f3:	83 c4 10             	add    $0x10,%esp
-801037f6:	89 43 08             	mov    %eax,0x8(%ebx)
-801037f9:	85 c0                	test   %eax,%eax
-801037fb:	0f 84 98 00 00 00    	je     80103899 <allocproc+0x109>
-    return 0;
-  }
-  sp = p->kstack + KSTACKSIZE;
-
-  // Leave room for trap frame.
-  sp -= sizeof *p->tf;
-80103801:	8d 90 b4 0f 00 00    	lea    0xfb4(%eax),%edx
-  sp -= 4;
-  *(uint *)sp = (uint)trapret;
-
-  sp -= sizeof *p->context;
-  p->context = (struct context *)sp;
-  memset(p->context, 0, sizeof *p->context);
-80103807:	83 ec 04             	sub    $0x4,%esp
-  sp -= sizeof *p->context;
-8010380a:	05 9c 0f 00 00       	add    $0xf9c,%eax
-  sp -= sizeof *p->tf;
-8010380f:	89 53 18             	mov    %edx,0x18(%ebx)
-  *(uint *)sp = (uint)trapret;
-80103812:	c7 40 14 af 63 10 80 	movl   $0x801063af,0x14(%eax)
-  p->context = (struct context *)sp;
-80103819:	89 43 1c             	mov    %eax,0x1c(%ebx)
-  memset(p->context, 0, sizeof *p->context);
-8010381c:	6a 14                	push   $0x14
-8010381e:	6a 00                	push   $0x0
-80103820:	50                   	push   %eax
-80103821:	e8 aa 16 00 00       	call   80104ed0 <memset>
-  p->context->eip = (uint)forkret;
-80103826:	8b 43 1c             	mov    0x1c(%ebx),%eax
-  p->state = EMBRYO;
-  p->priority = DEFAULT_PRIORITY;
-  //p->creation_t= total_t;
-
-
-  return p;
-80103829:	83 c4 10             	add    $0x10,%esp
-  p->context->eip = (uint)forkret;
-8010382c:	c7 40 10 b0 38 10 80 	movl   $0x801038b0,0x10(%eax)
-}
-80103833:	89 d8                	mov    %ebx,%eax
-  p->sleeping_t = 0;
-80103835:	c7 83 00 01 00 00 00 	movl   $0x0,0x100(%ebx)
-8010383c:	00 00 00 
-  p->runnable_t = 0;
-8010383f:	c7 83 04 01 00 00 00 	movl   $0x0,0x104(%ebx)
-80103846:	00 00 00 
-  p->running_t = 0;
-80103849:	c7 83 08 01 00 00 00 	movl   $0x0,0x108(%ebx)
-80103850:	00 00 00 
-  p->queue = 0; // by default each process is in the 0 queue
-80103853:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
-  p->rr_remaining_t = QUANTUM;
-8010385a:	c7 83 f4 00 00 00 64 	movl   $0x64,0xf4(%ebx)
-80103861:	00 00 00 
-  p->state = EMBRYO;
-80103864:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
-  p->priority = DEFAULT_PRIORITY;
-8010386b:	c7 83 f8 00 00 00 03 	movl   $0x3,0xf8(%ebx)
-80103872:	00 00 00 
-}
-80103875:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80103878:	c9                   	leave  
-80103879:	c3                   	ret    
-8010387a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  release(&ptable.lock);
-80103880:	83 ec 0c             	sub    $0xc,%esp
-  return 0;
-80103883:	31 db                	xor    %ebx,%ebx
-  release(&ptable.lock);
-80103885:	68 60 3d 11 80       	push   $0x80113d60
-8010388a:	e8 f1 15 00 00       	call   80104e80 <release>
-}
-8010388f:	89 d8                	mov    %ebx,%eax
-  return 0;
-80103891:	83 c4 10             	add    $0x10,%esp
-}
-80103894:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80103897:	c9                   	leave  
-80103898:	c3                   	ret    
-    p->state = UNUSED;
-80103899:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
-    return 0;
-801038a0:	31 db                	xor    %ebx,%ebx
-}
-801038a2:	89 d8                	mov    %ebx,%eax
-801038a4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-801038a7:	c9                   	leave  
-801038a8:	c3                   	ret    
-801038a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-801038b0 <forkret>:
-}
-
-// A fork child's very first scheduling by scheduler()
-// will swtch here.  "Return" to user space.
-void forkret(void)
-{
-801038b0:	f3 0f 1e fb          	endbr32 
-801038b4:	55                   	push   %ebp
-801038b5:	89 e5                	mov    %esp,%ebp
-801038b7:	83 ec 14             	sub    $0x14,%esp
-  static int first = 1;
-  // Still holding ptable.lock from scheduler.
-  release(&ptable.lock);
-801038ba:	68 60 3d 11 80       	push   $0x80113d60
-801038bf:	e8 bc 15 00 00       	call   80104e80 <release>
-
-  if (first)
-801038c4:	a1 00 b0 10 80       	mov    0x8010b000,%eax
-801038c9:	83 c4 10             	add    $0x10,%esp
-801038cc:	85 c0                	test   %eax,%eax
-801038ce:	75 08                	jne    801038d8 <forkret+0x28>
-    iinit(ROOTDEV);
-    initlog(ROOTDEV);
-  }
-
-  // Return to "caller", actually trapret (see allocproc).
-}
-801038d0:	c9                   	leave  
-801038d1:	c3                   	ret    
-801038d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    first = 0;
-801038d8:	c7 05 00 b0 10 80 00 	movl   $0x0,0x8010b000
-801038df:	00 00 00 
-    iinit(ROOTDEV);
-801038e2:	83 ec 0c             	sub    $0xc,%esp
-801038e5:	6a 01                	push   $0x1
-801038e7:	e8 54 dc ff ff       	call   80101540 <iinit>
-    initlog(ROOTDEV);
-801038ec:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
-801038f3:	e8 98 f3 ff ff       	call   80102c90 <initlog>
-}
-801038f8:	83 c4 10             	add    $0x10,%esp
-801038fb:	c9                   	leave  
-801038fc:	c3                   	ret    
-801038fd:	8d 76 00             	lea    0x0(%esi),%esi
-
-80103900 <pinit>:
-{
-80103900:	f3 0f 1e fb          	endbr32 
-80103904:	55                   	push   %ebp
-80103905:	89 e5                	mov    %esp,%ebp
-80103907:	83 ec 10             	sub    $0x10,%esp
-  initlock(&ptable.lock, "ptable");
-8010390a:	68 c0 81 10 80       	push   $0x801081c0
-8010390f:	68 60 3d 11 80       	push   $0x80113d60
-80103914:	e8 27 13 00 00       	call   80104c40 <initlock>
-}
-80103919:	83 c4 10             	add    $0x10,%esp
-8010391c:	c9                   	leave  
-8010391d:	c3                   	ret    
-8010391e:	66 90                	xchg   %ax,%ax
-
-80103920 <mycpu>:
-{
-80103920:	f3 0f 1e fb          	endbr32 
-80103924:	55                   	push   %ebp
-80103925:	89 e5                	mov    %esp,%ebp
-80103927:	56                   	push   %esi
-80103928:	53                   	push   %ebx
-  asm volatile("pushfl; popl %0" : "=r" (eflags));
-80103929:	9c                   	pushf  
-8010392a:	58                   	pop    %eax
-  if (readeflags() & FL_IF)
-8010392b:	f6 c4 02             	test   $0x2,%ah
-8010392e:	75 4a                	jne    8010397a <mycpu+0x5a>
-  apicid = lapicid();
-80103930:	e8 6b ef ff ff       	call   801028a0 <lapicid>
-  for (i = 0; i < ncpu; ++i)
-80103935:	8b 35 20 3d 11 80    	mov    0x80113d20,%esi
-  apicid = lapicid();
-8010393b:	89 c3                	mov    %eax,%ebx
-  for (i = 0; i < ncpu; ++i)
-8010393d:	85 f6                	test   %esi,%esi
-8010393f:	7e 2c                	jle    8010396d <mycpu+0x4d>
-80103941:	31 d2                	xor    %edx,%edx
-80103943:	eb 0a                	jmp    8010394f <mycpu+0x2f>
-80103945:	8d 76 00             	lea    0x0(%esi),%esi
-80103948:	83 c2 01             	add    $0x1,%edx
-8010394b:	39 f2                	cmp    %esi,%edx
-8010394d:	74 1e                	je     8010396d <mycpu+0x4d>
-    if (cpus[i].apicid == apicid)
-8010394f:	69 ca b0 00 00 00    	imul   $0xb0,%edx,%ecx
-80103955:	0f b6 81 a0 37 11 80 	movzbl -0x7feec860(%ecx),%eax
-8010395c:	39 d8                	cmp    %ebx,%eax
-8010395e:	75 e8                	jne    80103948 <mycpu+0x28>
-}
-80103960:	8d 65 f8             	lea    -0x8(%ebp),%esp
-      return &cpus[i];
-80103963:	8d 81 a0 37 11 80    	lea    -0x7feec860(%ecx),%eax
-}
-80103969:	5b                   	pop    %ebx
-8010396a:	5e                   	pop    %esi
-8010396b:	5d                   	pop    %ebp
-8010396c:	c3                   	ret    
-  panic("unknown apicid\n");
-8010396d:	83 ec 0c             	sub    $0xc,%esp
-80103970:	68 c7 81 10 80       	push   $0x801081c7
-80103975:	e8 16 ca ff ff       	call   80100390 <panic>
-    panic("mycpu called with interrupts enabled\n");
-8010397a:	83 ec 0c             	sub    $0xc,%esp
-8010397d:	68 a4 82 10 80       	push   $0x801082a4
-80103982:	e8 09 ca ff ff       	call   80100390 <panic>
-80103987:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010398e:	66 90                	xchg   %ax,%ax
-
-80103990 <cpuid>:
-{
-80103990:	f3 0f 1e fb          	endbr32 
-80103994:	55                   	push   %ebp
-80103995:	89 e5                	mov    %esp,%ebp
-80103997:	83 ec 08             	sub    $0x8,%esp
-  return mycpu() - cpus;
-8010399a:	e8 81 ff ff ff       	call   80103920 <mycpu>
-}
-8010399f:	c9                   	leave  
-  return mycpu() - cpus;
-801039a0:	2d a0 37 11 80       	sub    $0x801137a0,%eax
-801039a5:	c1 f8 04             	sar    $0x4,%eax
-801039a8:	69 c0 a3 8b 2e ba    	imul   $0xba2e8ba3,%eax,%eax
-}
-801039ae:	c3                   	ret    
-801039af:	90                   	nop
-
-801039b0 <myproc>:
-{
-801039b0:	f3 0f 1e fb          	endbr32 
-801039b4:	55                   	push   %ebp
-801039b5:	89 e5                	mov    %esp,%ebp
-801039b7:	53                   	push   %ebx
-801039b8:	83 ec 04             	sub    $0x4,%esp
-  pushcli();
-801039bb:	e8 00 13 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-801039c0:	e8 5b ff ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-801039c5:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
-  popcli();
-801039cb:	e8 40 13 00 00       	call   80104d10 <popcli>
-}
-801039d0:	83 c4 04             	add    $0x4,%esp
-801039d3:	89 d8                	mov    %ebx,%eax
-801039d5:	5b                   	pop    %ebx
-801039d6:	5d                   	pop    %ebp
-801039d7:	c3                   	ret    
-801039d8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801039df:	90                   	nop
-
-801039e0 <userinit>:
-{
-801039e0:	f3 0f 1e fb          	endbr32 
-801039e4:	55                   	push   %ebp
-801039e5:	89 e5                	mov    %esp,%ebp
-801039e7:	53                   	push   %ebx
-801039e8:	83 ec 04             	sub    $0x4,%esp
-  p = allocproc();
-801039eb:	e8 a0 fd ff ff       	call   80103790 <allocproc>
-801039f0:	89 c3                	mov    %eax,%ebx
-  initproc = p;
-801039f2:	a3 c4 b5 10 80       	mov    %eax,0x8010b5c4
-  if ((p->pgdir = setupkvm()) == 0)
-801039f7:	e8 f4 3f 00 00       	call   801079f0 <setupkvm>
-801039fc:	89 43 04             	mov    %eax,0x4(%ebx)
-801039ff:	85 c0                	test   %eax,%eax
-80103a01:	0f 84 bd 00 00 00    	je     80103ac4 <userinit+0xe4>
-  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
-80103a07:	83 ec 04             	sub    $0x4,%esp
-80103a0a:	68 2c 00 00 00       	push   $0x2c
-80103a0f:	68 60 b4 10 80       	push   $0x8010b460
-80103a14:	50                   	push   %eax
-80103a15:	e8 a6 3c 00 00       	call   801076c0 <inituvm>
-  memset(p->tf, 0, sizeof(*p->tf));
-80103a1a:	83 c4 0c             	add    $0xc,%esp
-  p->sz = PGSIZE;
-80103a1d:	c7 03 00 10 00 00    	movl   $0x1000,(%ebx)
-  memset(p->tf, 0, sizeof(*p->tf));
-80103a23:	6a 4c                	push   $0x4c
-80103a25:	6a 00                	push   $0x0
-80103a27:	ff 73 18             	pushl  0x18(%ebx)
-80103a2a:	e8 a1 14 00 00       	call   80104ed0 <memset>
-  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
-80103a2f:	8b 43 18             	mov    0x18(%ebx),%eax
-80103a32:	ba 1b 00 00 00       	mov    $0x1b,%edx
-  safestrcpy(p->name, "initcode", sizeof(p->name));
-80103a37:	83 c4 0c             	add    $0xc,%esp
-  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
-80103a3a:	b9 23 00 00 00       	mov    $0x23,%ecx
-  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
-80103a3f:	66 89 50 3c          	mov    %dx,0x3c(%eax)
-  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
-80103a43:	8b 43 18             	mov    0x18(%ebx),%eax
-80103a46:	66 89 48 2c          	mov    %cx,0x2c(%eax)
-  p->tf->es = p->tf->ds;
-80103a4a:	8b 43 18             	mov    0x18(%ebx),%eax
-80103a4d:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
-80103a51:	66 89 50 28          	mov    %dx,0x28(%eax)
-  p->tf->ss = p->tf->ds;
-80103a55:	8b 43 18             	mov    0x18(%ebx),%eax
-80103a58:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
-80103a5c:	66 89 50 48          	mov    %dx,0x48(%eax)
-  p->tf->eflags = FL_IF;
-80103a60:	8b 43 18             	mov    0x18(%ebx),%eax
-80103a63:	c7 40 40 00 02 00 00 	movl   $0x200,0x40(%eax)
-  p->tf->esp = PGSIZE;
-80103a6a:	8b 43 18             	mov    0x18(%ebx),%eax
-80103a6d:	c7 40 44 00 10 00 00 	movl   $0x1000,0x44(%eax)
-  p->tf->eip = 0; // beginning of initcode.S
-80103a74:	8b 43 18             	mov    0x18(%ebx),%eax
-80103a77:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
-  safestrcpy(p->name, "initcode", sizeof(p->name));
-80103a7e:	8d 43 6c             	lea    0x6c(%ebx),%eax
-80103a81:	6a 10                	push   $0x10
-80103a83:	68 f0 81 10 80       	push   $0x801081f0
-80103a88:	50                   	push   %eax
-80103a89:	e8 02 16 00 00       	call   80105090 <safestrcpy>
-  p->cwd = namei("/");
-80103a8e:	c7 04 24 f9 81 10 80 	movl   $0x801081f9,(%esp)
-80103a95:	e8 96 e5 ff ff       	call   80102030 <namei>
-80103a9a:	89 43 68             	mov    %eax,0x68(%ebx)
-  acquire(&ptable.lock);
-80103a9d:	c7 04 24 60 3d 11 80 	movl   $0x80113d60,(%esp)
-80103aa4:	e8 17 13 00 00       	call   80104dc0 <acquire>
-  p->state = RUNNABLE;
-80103aa9:	c7 43 0c 03 00 00 00 	movl   $0x3,0xc(%ebx)
-  release(&ptable.lock);
-80103ab0:	c7 04 24 60 3d 11 80 	movl   $0x80113d60,(%esp)
-80103ab7:	e8 c4 13 00 00       	call   80104e80 <release>
-}
-80103abc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80103abf:	83 c4 10             	add    $0x10,%esp
-80103ac2:	c9                   	leave  
-80103ac3:	c3                   	ret    
-    panic("userinit: out of memory?");
-80103ac4:	83 ec 0c             	sub    $0xc,%esp
-80103ac7:	68 d7 81 10 80       	push   $0x801081d7
-80103acc:	e8 bf c8 ff ff       	call   80100390 <panic>
-80103ad1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80103ad8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80103adf:	90                   	nop
-
-80103ae0 <growproc>:
-{
-80103ae0:	f3 0f 1e fb          	endbr32 
-80103ae4:	55                   	push   %ebp
-80103ae5:	89 e5                	mov    %esp,%ebp
-80103ae7:	56                   	push   %esi
-80103ae8:	53                   	push   %ebx
-80103ae9:	8b 75 08             	mov    0x8(%ebp),%esi
-  pushcli();
-80103aec:	e8 cf 11 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-80103af1:	e8 2a fe ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-80103af6:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
-  popcli();
-80103afc:	e8 0f 12 00 00       	call   80104d10 <popcli>
-  sz = curproc->sz;
-80103b01:	8b 03                	mov    (%ebx),%eax
-  if (n > 0)
-80103b03:	85 f6                	test   %esi,%esi
-80103b05:	7f 19                	jg     80103b20 <growproc+0x40>
-  else if (n < 0)
-80103b07:	75 37                	jne    80103b40 <growproc+0x60>
-  switchuvm(curproc);
-80103b09:	83 ec 0c             	sub    $0xc,%esp
-  curproc->sz = sz;
-80103b0c:	89 03                	mov    %eax,(%ebx)
-  switchuvm(curproc);
-80103b0e:	53                   	push   %ebx
-80103b0f:	e8 9c 3a 00 00       	call   801075b0 <switchuvm>
-  return 0;
-80103b14:	83 c4 10             	add    $0x10,%esp
-80103b17:	31 c0                	xor    %eax,%eax
-}
-80103b19:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80103b1c:	5b                   	pop    %ebx
-80103b1d:	5e                   	pop    %esi
-80103b1e:	5d                   	pop    %ebp
-80103b1f:	c3                   	ret    
-    if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
-80103b20:	83 ec 04             	sub    $0x4,%esp
-80103b23:	01 c6                	add    %eax,%esi
-80103b25:	56                   	push   %esi
-80103b26:	50                   	push   %eax
-80103b27:	ff 73 04             	pushl  0x4(%ebx)
-80103b2a:	e8 e1 3c 00 00       	call   80107810 <allocuvm>
-80103b2f:	83 c4 10             	add    $0x10,%esp
-80103b32:	85 c0                	test   %eax,%eax
-80103b34:	75 d3                	jne    80103b09 <growproc+0x29>
-      return -1;
-80103b36:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80103b3b:	eb dc                	jmp    80103b19 <growproc+0x39>
-80103b3d:	8d 76 00             	lea    0x0(%esi),%esi
-    if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
-80103b40:	83 ec 04             	sub    $0x4,%esp
-80103b43:	01 c6                	add    %eax,%esi
-80103b45:	56                   	push   %esi
-80103b46:	50                   	push   %eax
-80103b47:	ff 73 04             	pushl  0x4(%ebx)
-80103b4a:	e8 f1 3d 00 00       	call   80107940 <deallocuvm>
-80103b4f:	83 c4 10             	add    $0x10,%esp
-80103b52:	85 c0                	test   %eax,%eax
-80103b54:	75 b3                	jne    80103b09 <growproc+0x29>
-80103b56:	eb de                	jmp    80103b36 <growproc+0x56>
-80103b58:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80103b5f:	90                   	nop
-
-80103b60 <fork>:
-{
-80103b60:	f3 0f 1e fb          	endbr32 
-80103b64:	55                   	push   %ebp
-80103b65:	89 e5                	mov    %esp,%ebp
-80103b67:	57                   	push   %edi
-80103b68:	56                   	push   %esi
-80103b69:	53                   	push   %ebx
-80103b6a:	83 ec 1c             	sub    $0x1c,%esp
-  pushcli();
-80103b6d:	e8 4e 11 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-80103b72:	e8 a9 fd ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-80103b77:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
-  popcli();
-80103b7d:	e8 8e 11 00 00       	call   80104d10 <popcli>
-  if ((np = allocproc()) == 0)
-80103b82:	e8 09 fc ff ff       	call   80103790 <allocproc>
-80103b87:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-80103b8a:	85 c0                	test   %eax,%eax
-80103b8c:	0f 84 bb 00 00 00    	je     80103c4d <fork+0xed>
-  if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0)
-80103b92:	83 ec 08             	sub    $0x8,%esp
-80103b95:	ff 33                	pushl  (%ebx)
-80103b97:	89 c7                	mov    %eax,%edi
-80103b99:	ff 73 04             	pushl  0x4(%ebx)
-80103b9c:	e8 1f 3f 00 00       	call   80107ac0 <copyuvm>
-80103ba1:	83 c4 10             	add    $0x10,%esp
-80103ba4:	89 47 04             	mov    %eax,0x4(%edi)
-80103ba7:	85 c0                	test   %eax,%eax
-80103ba9:	0f 84 a5 00 00 00    	je     80103c54 <fork+0xf4>
-  np->sz = curproc->sz;
-80103baf:	8b 03                	mov    (%ebx),%eax
-80103bb1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
-80103bb4:	89 01                	mov    %eax,(%ecx)
-  *np->tf = *curproc->tf;
-80103bb6:	8b 79 18             	mov    0x18(%ecx),%edi
-  np->parent = curproc;
-80103bb9:	89 c8                	mov    %ecx,%eax
-80103bbb:	89 59 14             	mov    %ebx,0x14(%ecx)
-  *np->tf = *curproc->tf;
-80103bbe:	b9 13 00 00 00       	mov    $0x13,%ecx
-80103bc3:	8b 73 18             	mov    0x18(%ebx),%esi
-80103bc6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
-  for (i = 0; i < NOFILE; i++)
-80103bc8:	31 f6                	xor    %esi,%esi
-  np->tf->eax = 0;
-80103bca:	8b 40 18             	mov    0x18(%eax),%eax
-80103bcd:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
-  for (i = 0; i < NOFILE; i++)
-80103bd4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    if (curproc->ofile[i])
-80103bd8:	8b 44 b3 28          	mov    0x28(%ebx,%esi,4),%eax
-80103bdc:	85 c0                	test   %eax,%eax
-80103bde:	74 13                	je     80103bf3 <fork+0x93>
-      np->ofile[i] = filedup(curproc->ofile[i]);
-80103be0:	83 ec 0c             	sub    $0xc,%esp
-80103be3:	50                   	push   %eax
-80103be4:	e8 87 d2 ff ff       	call   80100e70 <filedup>
-80103be9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-80103bec:	83 c4 10             	add    $0x10,%esp
-80103bef:	89 44 b2 28          	mov    %eax,0x28(%edx,%esi,4)
-  for (i = 0; i < NOFILE; i++)
-80103bf3:	83 c6 01             	add    $0x1,%esi
-80103bf6:	83 fe 10             	cmp    $0x10,%esi
-80103bf9:	75 dd                	jne    80103bd8 <fork+0x78>
-  np->cwd = idup(curproc->cwd);
-80103bfb:	83 ec 0c             	sub    $0xc,%esp
-80103bfe:	ff 73 68             	pushl  0x68(%ebx)
-  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
-80103c01:	83 c3 6c             	add    $0x6c,%ebx
-  np->cwd = idup(curproc->cwd);
-80103c04:	e8 27 db ff ff       	call   80101730 <idup>
-80103c09:	8b 7d e4             	mov    -0x1c(%ebp),%edi
-  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
-80103c0c:	83 c4 0c             	add    $0xc,%esp
-  np->cwd = idup(curproc->cwd);
-80103c0f:	89 47 68             	mov    %eax,0x68(%edi)
-  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
-80103c12:	8d 47 6c             	lea    0x6c(%edi),%eax
-80103c15:	6a 10                	push   $0x10
-80103c17:	53                   	push   %ebx
-80103c18:	50                   	push   %eax
-80103c19:	e8 72 14 00 00       	call   80105090 <safestrcpy>
-  pid = np->pid;
-80103c1e:	8b 5f 10             	mov    0x10(%edi),%ebx
-  acquire(&ptable.lock);
-80103c21:	c7 04 24 60 3d 11 80 	movl   $0x80113d60,(%esp)
-80103c28:	e8 93 11 00 00       	call   80104dc0 <acquire>
-  np->state = RUNNABLE;
-80103c2d:	c7 47 0c 03 00 00 00 	movl   $0x3,0xc(%edi)
-  release(&ptable.lock);
-80103c34:	c7 04 24 60 3d 11 80 	movl   $0x80113d60,(%esp)
-80103c3b:	e8 40 12 00 00       	call   80104e80 <release>
-  return pid;
-80103c40:	83 c4 10             	add    $0x10,%esp
-}
-80103c43:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80103c46:	89 d8                	mov    %ebx,%eax
-80103c48:	5b                   	pop    %ebx
-80103c49:	5e                   	pop    %esi
-80103c4a:	5f                   	pop    %edi
-80103c4b:	5d                   	pop    %ebp
-80103c4c:	c3                   	ret    
-    return -1;
-80103c4d:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
-80103c52:	eb ef                	jmp    80103c43 <fork+0xe3>
-    kfree(np->kstack);
-80103c54:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
-80103c57:	83 ec 0c             	sub    $0xc,%esp
-80103c5a:	ff 73 08             	pushl  0x8(%ebx)
-80103c5d:	e8 0e e8 ff ff       	call   80102470 <kfree>
-    np->kstack = 0;
-80103c62:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
-    return -1;
-80103c69:	83 c4 10             	add    $0x10,%esp
-    np->state = UNUSED;
-80103c6c:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
-    return -1;
-80103c73:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
-80103c78:	eb c9                	jmp    80103c43 <fork+0xe3>
-80103c7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80103c80 <switch_process>:
-{
-80103c80:	f3 0f 1e fb          	endbr32 
-80103c84:	55                   	push   %ebp
-80103c85:	89 e5                	mov    %esp,%ebp
-80103c87:	56                   	push   %esi
-80103c88:	53                   	push   %ebx
-80103c89:	8b 75 08             	mov    0x8(%ebp),%esi
-80103c8c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  switchuvm(p);
-80103c8f:	83 ec 0c             	sub    $0xc,%esp
-  c->proc = p;
-80103c92:	89 9e ac 00 00 00    	mov    %ebx,0xac(%esi)
-  switchuvm(p);
-80103c98:	53                   	push   %ebx
-80103c99:	e8 12 39 00 00       	call   801075b0 <switchuvm>
-  p->state = RUNNING;
-80103c9e:	c7 43 0c 04 00 00 00 	movl   $0x4,0xc(%ebx)
-  swtch(&(c->scheduler), p->context);
-80103ca5:	58                   	pop    %eax
-80103ca6:	8d 46 04             	lea    0x4(%esi),%eax
-80103ca9:	5a                   	pop    %edx
-80103caa:	ff 73 1c             	pushl  0x1c(%ebx)
-80103cad:	50                   	push   %eax
-80103cae:	e8 40 14 00 00       	call   801050f3 <swtch>
-  switchkvm();
-80103cb3:	e8 d8 38 00 00       	call   80107590 <switchkvm>
-}
-80103cb8:	83 c4 10             	add    $0x10,%esp
-  c->proc = 0;
-80103cbb:	c7 86 ac 00 00 00 00 	movl   $0x0,0xac(%esi)
-80103cc2:	00 00 00 
-}
-80103cc5:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80103cc8:	5b                   	pop    %ebx
-80103cc9:	5e                   	pop    %esi
-80103cca:	5d                   	pop    %ebp
-80103ccb:	c3                   	ret    
-80103ccc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-80103cd0 <findHighestInQueue>:
-{
-80103cd0:	f3 0f 1e fb          	endbr32 
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80103cd4:	ba 94 3d 11 80       	mov    $0x80113d94,%edx
-80103cd9:	eb 17                	jmp    80103cf2 <findHighestInQueue+0x22>
-80103cdb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80103cdf:	90                   	nop
-80103ce0:	81 c2 10 01 00 00    	add    $0x110,%edx
-80103ce6:	81 fa 94 81 11 80    	cmp    $0x80118194,%edx
-80103cec:	0f 84 8f 00 00 00    	je     80103d81 <findHighestInQueue+0xb1>
-    if (p->state == RUNNABLE && p->queue == 2)
-80103cf2:	83 7a 0c 03          	cmpl   $0x3,0xc(%edx)
-80103cf6:	75 e8                	jne    80103ce0 <findHighestInQueue+0x10>
-80103cf8:	83 7a 7c 02          	cmpl   $0x2,0x7c(%edx)
-80103cfc:	75 e2                	jne    80103ce0 <findHighestInQueue+0x10>
-      hasRunnable = 1;
-80103cfe:	b9 01 00 00 00       	mov    $0x1,%ecx
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with highest priority
-80103d03:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-80103d08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80103d0f:	90                   	nop
-    if (p->state != RUNNABLE || p->queue != 2)
-80103d10:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
-80103d14:	75 52                	jne    80103d68 <findHighestInQueue+0x98>
-80103d16:	83 78 7c 02          	cmpl   $0x2,0x7c(%eax)
-80103d1a:	75 4c                	jne    80103d68 <findHighestInQueue+0x98>
-{
-80103d1c:	55                   	push   %ebp
-80103d1d:	89 e5                	mov    %esp,%ebp
-80103d1f:	53                   	push   %ebx
-    if (p->priority < highest_p->priority)
-80103d20:	8b 9a f8 00 00 00    	mov    0xf8(%edx),%ebx
-80103d26:	39 98 f8 00 00 00    	cmp    %ebx,0xf8(%eax)
-80103d2c:	0f 4c d0             	cmovl  %eax,%edx
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with highest priority
-80103d2f:	05 10 01 00 00       	add    $0x110,%eax
-80103d34:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80103d39:	74 18                	je     80103d53 <findHighestInQueue+0x83>
-    if (p->state != RUNNABLE || p->queue != 2)
-80103d3b:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
-80103d3f:	75 ee                	jne    80103d2f <findHighestInQueue+0x5f>
-80103d41:	83 78 7c 02          	cmpl   $0x2,0x7c(%eax)
-80103d45:	74 d9                	je     80103d20 <findHighestInQueue+0x50>
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with highest priority
-80103d47:	05 10 01 00 00       	add    $0x110,%eax
-80103d4c:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80103d51:	75 e8                	jne    80103d3b <findHighestInQueue+0x6b>
-    return (void *)-1;
-80103d53:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80103d58:	85 c9                	test   %ecx,%ecx
-}
-80103d5a:	5b                   	pop    %ebx
-80103d5b:	5d                   	pop    %ebp
-    return (void *)-1;
-80103d5c:	0f 44 d0             	cmove  %eax,%edx
-}
-80103d5f:	89 d0                	mov    %edx,%eax
-80103d61:	c3                   	ret    
-80103d62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with highest priority
-80103d68:	05 10 01 00 00       	add    $0x110,%eax
-80103d6d:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80103d72:	75 9c                	jne    80103d10 <findHighestInQueue+0x40>
-    return (void *)-1;
-80103d74:	85 c9                	test   %ecx,%ecx
-80103d76:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80103d7b:	0f 44 d0             	cmove  %eax,%edx
-}
-80103d7e:	89 d0                	mov    %edx,%eax
-80103d80:	c3                   	ret    
-  int hasRunnable = 0;
-80103d81:	31 c9                	xor    %ecx,%ecx
-  struct proc *highest_p = 0;
-80103d83:	31 d2                	xor    %edx,%edx
-80103d85:	e9 79 ff ff ff       	jmp    80103d03 <findHighestInQueue+0x33>
-80103d8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80103d90 <findLowestInQueue>:
-{
-80103d90:	f3 0f 1e fb          	endbr32 
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80103d94:	ba 94 3d 11 80       	mov    $0x80113d94,%edx
-80103d99:	eb 13                	jmp    80103dae <findLowestInQueue+0x1e>
-80103d9b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80103d9f:	90                   	nop
-80103da0:	81 c2 10 01 00 00    	add    $0x110,%edx
-80103da6:	81 fa 94 81 11 80    	cmp    $0x80118194,%edx
-80103dac:	74 7b                	je     80103e29 <findLowestInQueue+0x99>
-    if (p->state == RUNNABLE && p->state == 3)
-80103dae:	83 7a 0c 03          	cmpl   $0x3,0xc(%edx)
-80103db2:	75 ec                	jne    80103da0 <findLowestInQueue+0x10>
-      hasRunnable = 1;
-80103db4:	b9 01 00 00 00       	mov    $0x1,%ecx
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with lowest priority
-80103db9:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-80103dbe:	66 90                	xchg   %ax,%ax
-    if (p->state != RUNNABLE || p->state != 3)
-80103dc0:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
-80103dc4:	75 4a                	jne    80103e10 <findLowestInQueue+0x80>
-{
-80103dc6:	55                   	push   %ebp
-80103dc7:	89 e5                	mov    %esp,%ebp
-80103dc9:	53                   	push   %ebx
-    if (p->priority > lowest_p->priority)
-80103dca:	8b 9a f8 00 00 00    	mov    0xf8(%edx),%ebx
-80103dd0:	39 98 f8 00 00 00    	cmp    %ebx,0xf8(%eax)
-80103dd6:	0f 4f d0             	cmovg  %eax,%edx
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with lowest priority
-80103dd9:	05 10 01 00 00       	add    $0x110,%eax
-80103dde:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80103de3:	74 12                	je     80103df7 <findLowestInQueue+0x67>
-    if (p->state != RUNNABLE || p->state != 3)
-80103de5:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
-80103de9:	74 df                	je     80103dca <findLowestInQueue+0x3a>
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with lowest priority
-80103deb:	05 10 01 00 00       	add    $0x110,%eax
-80103df0:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80103df5:	75 ee                	jne    80103de5 <findLowestInQueue+0x55>
-    return (void *)-1;
-80103df7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80103dfc:	85 c9                	test   %ecx,%ecx
-}
-80103dfe:	5b                   	pop    %ebx
-80103dff:	5d                   	pop    %ebp
-    return (void *)-1;
-80103e00:	0f 44 d0             	cmove  %eax,%edx
-}
-80103e03:	89 d0                	mov    %edx,%eax
-80103e05:	c3                   	ret    
-80103e06:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80103e0d:	8d 76 00             	lea    0x0(%esi),%esi
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with lowest priority
-80103e10:	05 10 01 00 00       	add    $0x110,%eax
-80103e15:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80103e1a:	75 a4                	jne    80103dc0 <findLowestInQueue+0x30>
-    return (void *)-1;
-80103e1c:	85 c9                	test   %ecx,%ecx
-80103e1e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80103e23:	0f 44 d0             	cmove  %eax,%edx
-}
-80103e26:	89 d0                	mov    %edx,%eax
-80103e28:	c3                   	ret    
-  int hasRunnable = 0;
-80103e29:	31 c9                	xor    %ecx,%ecx
-  struct proc *lowest_p = 0;
-80103e2b:	31 d2                	xor    %edx,%edx
-80103e2d:	eb 8a                	jmp    80103db9 <findLowestInQueue+0x29>
-80103e2f:	90                   	nop
-
-80103e30 <scheduler>:
-{
-80103e30:	f3 0f 1e fb          	endbr32 
-80103e34:	55                   	push   %ebp
-80103e35:	89 e5                	mov    %esp,%ebp
-80103e37:	57                   	push   %edi
-80103e38:	56                   	push   %esi
-  struct proc *lowest_p = 0;  // runnable process with lowest priority
-80103e39:	31 f6                	xor    %esi,%esi
-{
-80103e3b:	53                   	push   %ebx
-  struct proc *highest_p = 0; // runnable process with highest priority
-80103e3c:	31 db                	xor    %ebx,%ebx
-{
-80103e3e:	83 ec 1c             	sub    $0x1c,%esp
-  struct cpu *c = mycpu();
-80103e41:	e8 da fa ff ff       	call   80103920 <mycpu>
-80103e46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-  c->proc = 0;
-80103e49:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
-80103e50:	00 00 00 
-80103e53:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80103e57:	90                   	nop
-  asm volatile("sti");
-80103e58:	fb                   	sti    
-    acquire(&ptable.lock);
-80103e59:	83 ec 0c             	sub    $0xc,%esp
-80103e5c:	68 60 3d 11 80       	push   $0x80113d60
-80103e61:	e8 5a 0f 00 00       	call   80104dc0 <acquire>
-    switch (policy)
-80103e66:	8b 0d 40 3d 11 80    	mov    0x80113d40,%ecx
-80103e6c:	83 c4 10             	add    $0x10,%esp
-80103e6f:	83 f9 03             	cmp    $0x3,%ecx
-80103e72:	0f 84 98 01 00 00    	je     80104010 <scheduler+0x1e0>
-80103e78:	0f 87 da 00 00 00    	ja     80103f58 <scheduler+0x128>
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80103e7e:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80103e83:	89 c7                	mov    %eax,%edi
-    switch (policy)
-80103e85:	83 f9 02             	cmp    $0x2,%ecx
-80103e88:	74 16                	je     80103ea0 <scheduler+0x70>
-80103e8a:	eb 6c                	jmp    80103ef8 <scheduler+0xc8>
-80103e8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80103e90:	05 10 01 00 00       	add    $0x110,%eax
-80103e95:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80103e9a:	0f 84 ed 01 00 00    	je     8010408d <scheduler+0x25d>
-        if (p->state == RUNNABLE)
-80103ea0:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
-80103ea4:	75 ea                	jne    80103e90 <scheduler+0x60>
-          hasRunnable = 1;
-80103ea6:	b9 01 00 00 00       	mov    $0x1,%ecx
-      hasRunnable = 0;
-80103eab:	89 c3                	mov    %eax,%ebx
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with highest priority
-80103ead:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-80103eb2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        if (p->state != RUNNABLE)
-80103eb8:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
-80103ebc:	75 0f                	jne    80103ecd <scheduler+0x9d>
-        if ((p->running_t < highest_p->running_t )){
-80103ebe:	8b 93 08 01 00 00    	mov    0x108(%ebx),%edx
-80103ec4:	39 90 08 01 00 00    	cmp    %edx,0x108(%eax)
-80103eca:	0f 4c d8             	cmovl  %eax,%ebx
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with highest priority
-80103ecd:	05 10 01 00 00       	add    $0x110,%eax
-80103ed2:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80103ed7:	75 df                	jne    80103eb8 <scheduler+0x88>
-      if (hasRunnable)
-80103ed9:	85 c9                	test   %ecx,%ecx
-80103edb:	75 53                	jne    80103f30 <scheduler+0x100>
-    release(&ptable.lock);
-80103edd:	83 ec 0c             	sub    $0xc,%esp
-80103ee0:	68 60 3d 11 80       	push   $0x80113d60
-80103ee5:	e8 96 0f 00 00       	call   80104e80 <release>
-    sti();
-80103eea:	83 c4 10             	add    $0x10,%esp
-80103eed:	e9 66 ff ff ff       	jmp    80103e58 <scheduler+0x28>
-80103ef2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        if (p->state != RUNNABLE)
-80103ef8:	83 7f 0c 03          	cmpl   $0x3,0xc(%edi)
-80103efc:	75 0f                	jne    80103f0d <scheduler+0xdd>
-        switch_process(c, p);
-80103efe:	83 ec 08             	sub    $0x8,%esp
-80103f01:	57                   	push   %edi
-80103f02:	ff 75 e4             	pushl  -0x1c(%ebp)
-80103f05:	e8 76 fd ff ff       	call   80103c80 <switch_process>
-80103f0a:	83 c4 10             	add    $0x10,%esp
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80103f0d:	81 c7 10 01 00 00    	add    $0x110,%edi
-80103f13:	81 ff 94 81 11 80    	cmp    $0x80118194,%edi
-80103f19:	75 dd                	jne    80103ef8 <scheduler+0xc8>
-    release(&ptable.lock);
-80103f1b:	83 ec 0c             	sub    $0xc,%esp
-80103f1e:	68 60 3d 11 80       	push   $0x80113d60
-80103f23:	e8 58 0f 00 00       	call   80104e80 <release>
-    sti();
-80103f28:	83 c4 10             	add    $0x10,%esp
-80103f2b:	e9 28 ff ff ff       	jmp    80103e58 <scheduler+0x28>
-        switch_process(c, highest_p);
-80103f30:	83 ec 08             	sub    $0x8,%esp
-80103f33:	53                   	push   %ebx
-80103f34:	ff 75 e4             	pushl  -0x1c(%ebp)
-80103f37:	e8 44 fd ff ff       	call   80103c80 <switch_process>
-80103f3c:	83 c4 10             	add    $0x10,%esp
-    release(&ptable.lock);
-80103f3f:	83 ec 0c             	sub    $0xc,%esp
-80103f42:	68 60 3d 11 80       	push   $0x80113d60
-80103f47:	e8 34 0f 00 00       	call   80104e80 <release>
-    sti();
-80103f4c:	83 c4 10             	add    $0x10,%esp
-80103f4f:	e9 04 ff ff ff       	jmp    80103e58 <scheduler+0x28>
-80103f54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    switch (policy)
-80103f58:	bf 01 00 00 00       	mov    $0x1,%edi
-80103f5d:	83 f9 04             	cmp    $0x4,%ecx
-80103f60:	0f 85 77 ff ff ff    	jne    80103edd <scheduler+0xad>
-          switch (currentQueue)
-80103f66:	83 ff 02             	cmp    $0x2,%edi
-80103f69:	74 64                	je     80103fcf <scheduler+0x19f>
-            for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80103f6b:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-80103f70:	83 ff 03             	cmp    $0x3,%edi
-80103f73:	75 3d                	jne    80103fb2 <scheduler+0x182>
-80103f75:	eb 18                	jmp    80103f8f <scheduler+0x15f>
-80103f77:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80103f7e:	66 90                	xchg   %ax,%ax
-              switch_process(c, lowest_p);
-80103f80:	83 ec 08             	sub    $0x8,%esp
-80103f83:	50                   	push   %eax
-80103f84:	ff 75 e4             	pushl  -0x1c(%ebp)
-80103f87:	e8 f4 fc ff ff       	call   80103c80 <switch_process>
-              lowest_p = findLowestInQueue();
-80103f8c:	83 c4 10             	add    $0x10,%esp
-80103f8f:	e8 fc fd ff ff       	call   80103d90 <findLowestInQueue>
-80103f94:	89 c6                	mov    %eax,%esi
-              if ((int)lowest_p == -1)
-80103f96:	83 f8 ff             	cmp    $0xffffffff,%eax
-80103f99:	75 e5                	jne    80103f80 <scheduler+0x150>
-80103f9b:	83 c7 01             	add    $0x1,%edi
-80103f9e:	eb c6                	jmp    80103f66 <scheduler+0x136>
-              if (p->queue == currentQueue && p->state == RUNNABLE)
-80103fa0:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
-80103fa4:	74 3a                	je     80103fe0 <scheduler+0x1b0>
-            for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80103fa6:	05 10 01 00 00       	add    $0x110,%eax
-80103fab:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80103fb0:	74 3d                	je     80103fef <scheduler+0x1bf>
-              if (p->queue == currentQueue && p->state == RUNNABLE)
-80103fb2:	39 78 7c             	cmp    %edi,0x7c(%eax)
-80103fb5:	75 ef                	jne    80103fa6 <scheduler+0x176>
-80103fb7:	eb e7                	jmp    80103fa0 <scheduler+0x170>
-80103fb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-                switch_process(c, highest_p);
-80103fc0:	83 ec 08             	sub    $0x8,%esp
-80103fc3:	50                   	push   %eax
-80103fc4:	ff 75 e4             	pushl  -0x1c(%ebp)
-80103fc7:	e8 b4 fc ff ff       	call   80103c80 <switch_process>
-              highest_p = findHighestInQueue();
-80103fcc:	83 c4 10             	add    $0x10,%esp
-80103fcf:	e8 fc fc ff ff       	call   80103cd0 <findHighestInQueue>
-80103fd4:	89 c3                	mov    %eax,%ebx
-              if ((int)highest_p == -1)
-80103fd6:	83 f8 ff             	cmp    $0xffffffff,%eax
-80103fd9:	75 e5                	jne    80103fc0 <scheduler+0x190>
-80103fdb:	83 c7 01             	add    $0x1,%edi
-80103fde:	eb 86                	jmp    80103f66 <scheduler+0x136>
-                switch_process(c, p);
-80103fe0:	83 ec 08             	sub    $0x8,%esp
-80103fe3:	50                   	push   %eax
-80103fe4:	ff 75 e4             	pushl  -0x1c(%ebp)
-80103fe7:	e8 94 fc ff ff       	call   80103c80 <switch_process>
-                break;
-80103fec:	83 c4 10             	add    $0x10,%esp
-      for (int currentQueue = 1; currentQueue < 5; currentQueue++)
-80103fef:	83 ff 04             	cmp    $0x4,%edi
-80103ff2:	75 a7                	jne    80103f9b <scheduler+0x16b>
-    release(&ptable.lock);
-80103ff4:	83 ec 0c             	sub    $0xc,%esp
-80103ff7:	68 60 3d 11 80       	push   $0x80113d60
-80103ffc:	e8 7f 0e 00 00       	call   80104e80 <release>
-    sti();
-80104001:	83 c4 10             	add    $0x10,%esp
-80104004:	e9 4f fe ff ff       	jmp    80103e58 <scheduler+0x28>
-80104009:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80104010:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-80104015:	eb 15                	jmp    8010402c <scheduler+0x1fc>
-80104017:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010401e:	66 90                	xchg   %ax,%ax
-80104020:	05 10 01 00 00       	add    $0x110,%eax
-80104025:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-8010402a:	74 6a                	je     80104096 <scheduler+0x266>
-        if (p->state == RUNNABLE)
-8010402c:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
-80104030:	75 ee                	jne    80104020 <scheduler+0x1f0>
-          hasRunnable = 1;
-80104032:	b9 01 00 00 00       	mov    $0x1,%ecx
-      hasRunnable = 0;
-80104037:	89 c6                	mov    %eax,%esi
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with lowest priority
-80104039:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-8010403e:	66 90                	xchg   %ax,%ax
-        if (p->state != RUNNABLE)
-80104040:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
-80104044:	75 0f                	jne    80104055 <scheduler+0x225>
-        if (p->priority > lowest_p->priority)
-80104046:	8b 96 f8 00 00 00    	mov    0xf8(%esi),%edx
-8010404c:	39 90 f8 00 00 00    	cmp    %edx,0xf8(%eax)
-80104052:	0f 4f f0             	cmovg  %eax,%esi
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with lowest priority
-80104055:	05 10 01 00 00       	add    $0x110,%eax
-8010405a:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-8010405f:	75 df                	jne    80104040 <scheduler+0x210>
-      if (hasRunnable)
-80104061:	85 c9                	test   %ecx,%ecx
-80104063:	0f 84 74 fe ff ff    	je     80103edd <scheduler+0xad>
-        switch_process(c, lowest_p);
-80104069:	83 ec 08             	sub    $0x8,%esp
-8010406c:	56                   	push   %esi
-8010406d:	ff 75 e4             	pushl  -0x1c(%ebp)
-80104070:	e8 0b fc ff ff       	call   80103c80 <switch_process>
-80104075:	83 c4 10             	add    $0x10,%esp
-    release(&ptable.lock);
-80104078:	83 ec 0c             	sub    $0xc,%esp
-8010407b:	68 60 3d 11 80       	push   $0x80113d60
-80104080:	e8 fb 0d 00 00       	call   80104e80 <release>
-    sti();
-80104085:	83 c4 10             	add    $0x10,%esp
-80104088:	e9 cb fd ff ff       	jmp    80103e58 <scheduler+0x28>
-8010408d:	89 d8                	mov    %ebx,%eax
-      hasRunnable = 0;
-8010408f:	31 c9                	xor    %ecx,%ecx
-80104091:	e9 15 fe ff ff       	jmp    80103eab <scheduler+0x7b>
-80104096:	89 f0                	mov    %esi,%eax
-      hasRunnable = 0;
-80104098:	31 c9                	xor    %ecx,%ecx
-8010409a:	eb 9b                	jmp    80104037 <scheduler+0x207>
-8010409c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-801040a0 <sched>:
-{
-801040a0:	f3 0f 1e fb          	endbr32 
-801040a4:	55                   	push   %ebp
-801040a5:	89 e5                	mov    %esp,%ebp
-801040a7:	56                   	push   %esi
-801040a8:	53                   	push   %ebx
-  pushcli();
-801040a9:	e8 12 0c 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-801040ae:	e8 6d f8 ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-801040b3:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
-  popcli();
-801040b9:	e8 52 0c 00 00       	call   80104d10 <popcli>
-  if (!holding(&ptable.lock))
-801040be:	83 ec 0c             	sub    $0xc,%esp
-801040c1:	68 60 3d 11 80       	push   $0x80113d60
-801040c6:	e8 a5 0c 00 00       	call   80104d70 <holding>
-801040cb:	83 c4 10             	add    $0x10,%esp
-801040ce:	85 c0                	test   %eax,%eax
-801040d0:	74 4f                	je     80104121 <sched+0x81>
-  if (mycpu()->ncli != 1)
-801040d2:	e8 49 f8 ff ff       	call   80103920 <mycpu>
-801040d7:	83 b8 a4 00 00 00 01 	cmpl   $0x1,0xa4(%eax)
-801040de:	75 68                	jne    80104148 <sched+0xa8>
-  if (p->state == RUNNING)
-801040e0:	83 7b 0c 04          	cmpl   $0x4,0xc(%ebx)
-801040e4:	74 55                	je     8010413b <sched+0x9b>
-  asm volatile("pushfl; popl %0" : "=r" (eflags));
-801040e6:	9c                   	pushf  
-801040e7:	58                   	pop    %eax
-  if (readeflags() & FL_IF)
-801040e8:	f6 c4 02             	test   $0x2,%ah
-801040eb:	75 41                	jne    8010412e <sched+0x8e>
-  intena = mycpu()->intena;
-801040ed:	e8 2e f8 ff ff       	call   80103920 <mycpu>
-  swtch(&p->context, mycpu()->scheduler);
-801040f2:	83 c3 1c             	add    $0x1c,%ebx
-  intena = mycpu()->intena;
-801040f5:	8b b0 a8 00 00 00    	mov    0xa8(%eax),%esi
-  swtch(&p->context, mycpu()->scheduler);
-801040fb:	e8 20 f8 ff ff       	call   80103920 <mycpu>
-80104100:	83 ec 08             	sub    $0x8,%esp
-80104103:	ff 70 04             	pushl  0x4(%eax)
-80104106:	53                   	push   %ebx
-80104107:	e8 e7 0f 00 00       	call   801050f3 <swtch>
-  mycpu()->intena = intena;
-8010410c:	e8 0f f8 ff ff       	call   80103920 <mycpu>
-}
-80104111:	83 c4 10             	add    $0x10,%esp
-  mycpu()->intena = intena;
-80104114:	89 b0 a8 00 00 00    	mov    %esi,0xa8(%eax)
-}
-8010411a:	8d 65 f8             	lea    -0x8(%ebp),%esp
-8010411d:	5b                   	pop    %ebx
-8010411e:	5e                   	pop    %esi
-8010411f:	5d                   	pop    %ebp
-80104120:	c3                   	ret    
-    panic("sched ptable.lock");
-80104121:	83 ec 0c             	sub    $0xc,%esp
-80104124:	68 fb 81 10 80       	push   $0x801081fb
-80104129:	e8 62 c2 ff ff       	call   80100390 <panic>
-    panic("sched interruptible");
-8010412e:	83 ec 0c             	sub    $0xc,%esp
-80104131:	68 27 82 10 80       	push   $0x80108227
-80104136:	e8 55 c2 ff ff       	call   80100390 <panic>
-    panic("sched running");
-8010413b:	83 ec 0c             	sub    $0xc,%esp
-8010413e:	68 19 82 10 80       	push   $0x80108219
-80104143:	e8 48 c2 ff ff       	call   80100390 <panic>
-    panic("sched locks");
-80104148:	83 ec 0c             	sub    $0xc,%esp
-8010414b:	68 0d 82 10 80       	push   $0x8010820d
-80104150:	e8 3b c2 ff ff       	call   80100390 <panic>
-80104155:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010415c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-80104160 <exit>:
-{
-80104160:	f3 0f 1e fb          	endbr32 
-80104164:	55                   	push   %ebp
-80104165:	89 e5                	mov    %esp,%ebp
-80104167:	57                   	push   %edi
-80104168:	56                   	push   %esi
-80104169:	53                   	push   %ebx
-8010416a:	83 ec 0c             	sub    $0xc,%esp
-  pushcli();
-8010416d:	e8 4e 0b 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-80104172:	e8 a9 f7 ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-80104177:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
-  popcli();
-8010417d:	e8 8e 0b 00 00       	call   80104d10 <popcli>
-  if (curproc == initproc)
-80104182:	8d 5e 28             	lea    0x28(%esi),%ebx
-80104185:	8d 7e 68             	lea    0x68(%esi),%edi
-80104188:	39 35 c4 b5 10 80    	cmp    %esi,0x8010b5c4
-8010418e:	0f 84 0d 01 00 00    	je     801042a1 <exit+0x141>
-80104194:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    if (curproc->ofile[fd])
-80104198:	8b 03                	mov    (%ebx),%eax
-8010419a:	85 c0                	test   %eax,%eax
-8010419c:	74 12                	je     801041b0 <exit+0x50>
-      fileclose(curproc->ofile[fd]);
-8010419e:	83 ec 0c             	sub    $0xc,%esp
-801041a1:	50                   	push   %eax
-801041a2:	e8 19 cd ff ff       	call   80100ec0 <fileclose>
-      curproc->ofile[fd] = 0;
-801041a7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
-801041ad:	83 c4 10             	add    $0x10,%esp
-    nextpid = 1;
-801041b0:	c7 05 04 b0 10 80 01 	movl   $0x1,0x8010b004
-801041b7:	00 00 00 
-  for (fd = 0; fd < NOFILE; fd++)
-801041ba:	83 c3 04             	add    $0x4,%ebx
-801041bd:	39 df                	cmp    %ebx,%edi
-801041bf:	75 d7                	jne    80104198 <exit+0x38>
-  begin_op();
-801041c1:	e8 6a eb ff ff       	call   80102d30 <begin_op>
-  iput(curproc->cwd);
-801041c6:	83 ec 0c             	sub    $0xc,%esp
-801041c9:	ff 76 68             	pushl  0x68(%esi)
-801041cc:	e8 bf d6 ff ff       	call   80101890 <iput>
-  end_op();
-801041d1:	e8 ca eb ff ff       	call   80102da0 <end_op>
-  curproc->cwd = 0;
-801041d6:	c7 46 68 00 00 00 00 	movl   $0x0,0x68(%esi)
-  acquire(&ptable.lock);
-801041dd:	c7 04 24 60 3d 11 80 	movl   $0x80113d60,(%esp)
-801041e4:	e8 d7 0b 00 00       	call   80104dc0 <acquire>
-  wakeup1(curproc->parent);
-801041e9:	8b 56 14             	mov    0x14(%esi),%edx
-801041ec:	83 c4 10             	add    $0x10,%esp
-static void
-wakeup1(void *chan)
-{
-  struct proc *p;
-
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-801041ef:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-801041f4:	eb 16                	jmp    8010420c <exit+0xac>
-801041f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801041fd:	8d 76 00             	lea    0x0(%esi),%esi
-80104200:	05 10 01 00 00       	add    $0x110,%eax
-80104205:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-8010420a:	74 1e                	je     8010422a <exit+0xca>
-    if (p->state == SLEEPING && p->chan == chan)
-8010420c:	83 78 0c 02          	cmpl   $0x2,0xc(%eax)
-80104210:	75 ee                	jne    80104200 <exit+0xa0>
-80104212:	3b 50 20             	cmp    0x20(%eax),%edx
-80104215:	75 e9                	jne    80104200 <exit+0xa0>
-      p->state = RUNNABLE;
-80104217:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-8010421e:	05 10 01 00 00       	add    $0x110,%eax
-80104223:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80104228:	75 e2                	jne    8010420c <exit+0xac>
-      p->parent = initproc;
-8010422a:	8b 0d c4 b5 10 80    	mov    0x8010b5c4,%ecx
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80104230:	ba 94 3d 11 80       	mov    $0x80113d94,%edx
-80104235:	eb 17                	jmp    8010424e <exit+0xee>
-80104237:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010423e:	66 90                	xchg   %ax,%ax
-80104240:	81 c2 10 01 00 00    	add    $0x110,%edx
-80104246:	81 fa 94 81 11 80    	cmp    $0x80118194,%edx
-8010424c:	74 3a                	je     80104288 <exit+0x128>
-    if (p->parent == curproc)
-8010424e:	39 72 14             	cmp    %esi,0x14(%edx)
-80104251:	75 ed                	jne    80104240 <exit+0xe0>
-      if (p->state == ZOMBIE)
-80104253:	83 7a 0c 05          	cmpl   $0x5,0xc(%edx)
-      p->parent = initproc;
-80104257:	89 4a 14             	mov    %ecx,0x14(%edx)
-      if (p->state == ZOMBIE)
-8010425a:	75 e4                	jne    80104240 <exit+0xe0>
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-8010425c:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-80104261:	eb 11                	jmp    80104274 <exit+0x114>
-80104263:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80104267:	90                   	nop
-80104268:	05 10 01 00 00       	add    $0x110,%eax
-8010426d:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80104272:	74 cc                	je     80104240 <exit+0xe0>
-    if (p->state == SLEEPING && p->chan == chan)
-80104274:	83 78 0c 02          	cmpl   $0x2,0xc(%eax)
-80104278:	75 ee                	jne    80104268 <exit+0x108>
-8010427a:	3b 48 20             	cmp    0x20(%eax),%ecx
-8010427d:	75 e9                	jne    80104268 <exit+0x108>
-      p->state = RUNNABLE;
-8010427f:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
-80104286:	eb e0                	jmp    80104268 <exit+0x108>
-  curproc->state = ZOMBIE;
-80104288:	c7 46 0c 05 00 00 00 	movl   $0x5,0xc(%esi)
-  sched();
-8010428f:	e8 0c fe ff ff       	call   801040a0 <sched>
-  panic("zombie exit");
-80104294:	83 ec 0c             	sub    $0xc,%esp
-80104297:	68 48 82 10 80       	push   $0x80108248
-8010429c:	e8 ef c0 ff ff       	call   80100390 <panic>
-    panic("init exiting");
-801042a1:	83 ec 0c             	sub    $0xc,%esp
-801042a4:	68 3b 82 10 80       	push   $0x8010823b
-801042a9:	e8 e2 c0 ff ff       	call   80100390 <panic>
-801042ae:	66 90                	xchg   %ax,%ax
-
-801042b0 <yield>:
-{
-801042b0:	f3 0f 1e fb          	endbr32 
-801042b4:	55                   	push   %ebp
-801042b5:	89 e5                	mov    %esp,%ebp
-801042b7:	53                   	push   %ebx
-801042b8:	83 ec 10             	sub    $0x10,%esp
-  acquire(&ptable.lock); //DOC: yieldlock
-801042bb:	68 60 3d 11 80       	push   $0x80113d60
-801042c0:	e8 fb 0a 00 00       	call   80104dc0 <acquire>
-  pushcli();
-801042c5:	e8 f6 09 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-801042ca:	e8 51 f6 ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-801042cf:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
-  popcli();
-801042d5:	e8 36 0a 00 00       	call   80104d10 <popcli>
-  myproc()->state = RUNNABLE;
-801042da:	c7 43 0c 03 00 00 00 	movl   $0x3,0xc(%ebx)
-  sched();
-801042e1:	e8 ba fd ff ff       	call   801040a0 <sched>
-  release(&ptable.lock);
-801042e6:	c7 04 24 60 3d 11 80 	movl   $0x80113d60,(%esp)
-801042ed:	e8 8e 0b 00 00       	call   80104e80 <release>
-}
-801042f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-801042f5:	83 c4 10             	add    $0x10,%esp
-801042f8:	c9                   	leave  
-801042f9:	c3                   	ret    
-801042fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80104300 <sleep>:
-{
-80104300:	f3 0f 1e fb          	endbr32 
-80104304:	55                   	push   %ebp
-80104305:	89 e5                	mov    %esp,%ebp
-80104307:	57                   	push   %edi
-80104308:	56                   	push   %esi
-80104309:	53                   	push   %ebx
-8010430a:	83 ec 0c             	sub    $0xc,%esp
-8010430d:	8b 7d 08             	mov    0x8(%ebp),%edi
-80104310:	8b 75 0c             	mov    0xc(%ebp),%esi
-  pushcli();
-80104313:	e8 a8 09 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-80104318:	e8 03 f6 ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-8010431d:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
-  popcli();
-80104323:	e8 e8 09 00 00       	call   80104d10 <popcli>
-  if (p == 0)
-80104328:	85 db                	test   %ebx,%ebx
-8010432a:	0f 84 83 00 00 00    	je     801043b3 <sleep+0xb3>
-  if (lk == 0)
-80104330:	85 f6                	test   %esi,%esi
-80104332:	74 72                	je     801043a6 <sleep+0xa6>
-  if (lk != &ptable.lock)
-80104334:	81 fe 60 3d 11 80    	cmp    $0x80113d60,%esi
-8010433a:	74 4c                	je     80104388 <sleep+0x88>
-    acquire(&ptable.lock); //DOC: sleeplock1
-8010433c:	83 ec 0c             	sub    $0xc,%esp
-8010433f:	68 60 3d 11 80       	push   $0x80113d60
-80104344:	e8 77 0a 00 00       	call   80104dc0 <acquire>
-    release(lk);
-80104349:	89 34 24             	mov    %esi,(%esp)
-8010434c:	e8 2f 0b 00 00       	call   80104e80 <release>
-  p->chan = chan;
-80104351:	89 7b 20             	mov    %edi,0x20(%ebx)
-  p->state = SLEEPING;
-80104354:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
-  sched();
-8010435b:	e8 40 fd ff ff       	call   801040a0 <sched>
-  p->chan = 0;
-80104360:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
-    release(&ptable.lock);
-80104367:	c7 04 24 60 3d 11 80 	movl   $0x80113d60,(%esp)
-8010436e:	e8 0d 0b 00 00       	call   80104e80 <release>
-    acquire(lk);
-80104373:	89 75 08             	mov    %esi,0x8(%ebp)
-80104376:	83 c4 10             	add    $0x10,%esp
-}
-80104379:	8d 65 f4             	lea    -0xc(%ebp),%esp
-8010437c:	5b                   	pop    %ebx
-8010437d:	5e                   	pop    %esi
-8010437e:	5f                   	pop    %edi
-8010437f:	5d                   	pop    %ebp
-    acquire(lk);
-80104380:	e9 3b 0a 00 00       	jmp    80104dc0 <acquire>
-80104385:	8d 76 00             	lea    0x0(%esi),%esi
-  p->chan = chan;
-80104388:	89 7b 20             	mov    %edi,0x20(%ebx)
-  p->state = SLEEPING;
-8010438b:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
-  sched();
-80104392:	e8 09 fd ff ff       	call   801040a0 <sched>
-  p->chan = 0;
-80104397:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
-}
-8010439e:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801043a1:	5b                   	pop    %ebx
-801043a2:	5e                   	pop    %esi
-801043a3:	5f                   	pop    %edi
-801043a4:	5d                   	pop    %ebp
-801043a5:	c3                   	ret    
-    panic("sleep without lk");
-801043a6:	83 ec 0c             	sub    $0xc,%esp
-801043a9:	68 5a 82 10 80       	push   $0x8010825a
-801043ae:	e8 dd bf ff ff       	call   80100390 <panic>
-    panic("sleep");
-801043b3:	83 ec 0c             	sub    $0xc,%esp
-801043b6:	68 54 82 10 80       	push   $0x80108254
-801043bb:	e8 d0 bf ff ff       	call   80100390 <panic>
-
-801043c0 <wait>:
-{
-801043c0:	f3 0f 1e fb          	endbr32 
-801043c4:	55                   	push   %ebp
-801043c5:	89 e5                	mov    %esp,%ebp
-801043c7:	56                   	push   %esi
-801043c8:	53                   	push   %ebx
-  pushcli();
-801043c9:	e8 f2 08 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-801043ce:	e8 4d f5 ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-801043d3:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
-  popcli();
-801043d9:	e8 32 09 00 00       	call   80104d10 <popcli>
-  acquire(&ptable.lock);
-801043de:	83 ec 0c             	sub    $0xc,%esp
-801043e1:	68 60 3d 11 80       	push   $0x80113d60
-801043e6:	e8 d5 09 00 00       	call   80104dc0 <acquire>
-801043eb:	83 c4 10             	add    $0x10,%esp
-    havekids = 0;
-801043ee:	31 c0                	xor    %eax,%eax
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-801043f0:	bb 94 3d 11 80       	mov    $0x80113d94,%ebx
-801043f5:	eb 17                	jmp    8010440e <wait+0x4e>
-801043f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801043fe:	66 90                	xchg   %ax,%ax
-80104400:	81 c3 10 01 00 00    	add    $0x110,%ebx
-80104406:	81 fb 94 81 11 80    	cmp    $0x80118194,%ebx
-8010440c:	74 1e                	je     8010442c <wait+0x6c>
-      if (p->parent != curproc)
-8010440e:	39 73 14             	cmp    %esi,0x14(%ebx)
-80104411:	75 ed                	jne    80104400 <wait+0x40>
-      if (p->state == ZOMBIE)
-80104413:	83 7b 0c 05          	cmpl   $0x5,0xc(%ebx)
-80104417:	74 37                	je     80104450 <wait+0x90>
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80104419:	81 c3 10 01 00 00    	add    $0x110,%ebx
-      havekids = 1;
-8010441f:	b8 01 00 00 00       	mov    $0x1,%eax
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80104424:	81 fb 94 81 11 80    	cmp    $0x80118194,%ebx
-8010442a:	75 e2                	jne    8010440e <wait+0x4e>
-    if (!havekids || curproc->killed)
-8010442c:	85 c0                	test   %eax,%eax
-8010442e:	74 76                	je     801044a6 <wait+0xe6>
-80104430:	8b 46 24             	mov    0x24(%esi),%eax
-80104433:	85 c0                	test   %eax,%eax
-80104435:	75 6f                	jne    801044a6 <wait+0xe6>
-    sleep(curproc, &ptable.lock); //DOC: wait-sleep
-80104437:	83 ec 08             	sub    $0x8,%esp
-8010443a:	68 60 3d 11 80       	push   $0x80113d60
-8010443f:	56                   	push   %esi
-80104440:	e8 bb fe ff ff       	call   80104300 <sleep>
-    havekids = 0;
-80104445:	83 c4 10             	add    $0x10,%esp
-80104448:	eb a4                	jmp    801043ee <wait+0x2e>
-8010444a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        kfree(p->kstack);
-80104450:	83 ec 0c             	sub    $0xc,%esp
-80104453:	ff 73 08             	pushl  0x8(%ebx)
-        pid = p->pid;
-80104456:	8b 73 10             	mov    0x10(%ebx),%esi
-        kfree(p->kstack);
-80104459:	e8 12 e0 ff ff       	call   80102470 <kfree>
-        freevm(p->pgdir);
-8010445e:	5a                   	pop    %edx
-8010445f:	ff 73 04             	pushl  0x4(%ebx)
-        p->kstack = 0;
-80104462:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
-        freevm(p->pgdir);
-80104469:	e8 02 35 00 00       	call   80107970 <freevm>
-        release(&ptable.lock);
-8010446e:	c7 04 24 60 3d 11 80 	movl   $0x80113d60,(%esp)
-        p->pid = 0;
-80104475:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
-        p->parent = 0;
-8010447c:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
-        p->name[0] = 0;
-80104483:	c6 43 6c 00          	movb   $0x0,0x6c(%ebx)
-        p->killed = 0;
-80104487:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
-        p->state = UNUSED;
-8010448e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
-        release(&ptable.lock);
-80104495:	e8 e6 09 00 00       	call   80104e80 <release>
-        return pid;
-8010449a:	83 c4 10             	add    $0x10,%esp
-}
-8010449d:	8d 65 f8             	lea    -0x8(%ebp),%esp
-801044a0:	89 f0                	mov    %esi,%eax
-801044a2:	5b                   	pop    %ebx
-801044a3:	5e                   	pop    %esi
-801044a4:	5d                   	pop    %ebp
-801044a5:	c3                   	ret    
-      release(&ptable.lock);
-801044a6:	83 ec 0c             	sub    $0xc,%esp
-      return -1;
-801044a9:	be ff ff ff ff       	mov    $0xffffffff,%esi
-      release(&ptable.lock);
-801044ae:	68 60 3d 11 80       	push   $0x80113d60
-801044b3:	e8 c8 09 00 00       	call   80104e80 <release>
-      return -1;
-801044b8:	83 c4 10             	add    $0x10,%esp
-801044bb:	eb e0                	jmp    8010449d <wait+0xdd>
-801044bd:	8d 76 00             	lea    0x0(%esi),%esi
-
-801044c0 <wakeup>:
-}
-
-// Wake up all processes sleeping on chan.
-void wakeup(void *chan)
-{
-801044c0:	f3 0f 1e fb          	endbr32 
-801044c4:	55                   	push   %ebp
-801044c5:	89 e5                	mov    %esp,%ebp
-801044c7:	53                   	push   %ebx
-801044c8:	83 ec 10             	sub    $0x10,%esp
-801044cb:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  acquire(&ptable.lock);
-801044ce:	68 60 3d 11 80       	push   $0x80113d60
-801044d3:	e8 e8 08 00 00       	call   80104dc0 <acquire>
-801044d8:	83 c4 10             	add    $0x10,%esp
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-801044db:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-801044e0:	eb 12                	jmp    801044f4 <wakeup+0x34>
-801044e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-801044e8:	05 10 01 00 00       	add    $0x110,%eax
-801044ed:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-801044f2:	74 1e                	je     80104512 <wakeup+0x52>
-    if (p->state == SLEEPING && p->chan == chan)
-801044f4:	83 78 0c 02          	cmpl   $0x2,0xc(%eax)
-801044f8:	75 ee                	jne    801044e8 <wakeup+0x28>
-801044fa:	3b 58 20             	cmp    0x20(%eax),%ebx
-801044fd:	75 e9                	jne    801044e8 <wakeup+0x28>
-      p->state = RUNNABLE;
-801044ff:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-80104506:	05 10 01 00 00       	add    $0x110,%eax
-8010450b:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80104510:	75 e2                	jne    801044f4 <wakeup+0x34>
-  wakeup1(chan);
-  release(&ptable.lock);
-80104512:	c7 45 08 60 3d 11 80 	movl   $0x80113d60,0x8(%ebp)
-}
-80104519:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-8010451c:	c9                   	leave  
-  release(&ptable.lock);
-8010451d:	e9 5e 09 00 00       	jmp    80104e80 <release>
-80104522:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104529:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-80104530 <kill>:
-
-// Kill the process with the given pid.
-// Process won't exit until it returns
-// to user space (see trap in trap.c).
-int kill(int pid)
-{
-80104530:	f3 0f 1e fb          	endbr32 
-80104534:	55                   	push   %ebp
-80104535:	89 e5                	mov    %esp,%ebp
-80104537:	53                   	push   %ebx
-80104538:	83 ec 10             	sub    $0x10,%esp
-8010453b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  struct proc *p;
-
-  acquire(&ptable.lock);
-8010453e:	68 60 3d 11 80       	push   $0x80113d60
-80104543:	e8 78 08 00 00       	call   80104dc0 <acquire>
-80104548:	83 c4 10             	add    $0x10,%esp
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-8010454b:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-80104550:	eb 12                	jmp    80104564 <kill+0x34>
-80104552:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-80104558:	05 10 01 00 00       	add    $0x110,%eax
-8010455d:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80104562:	74 34                	je     80104598 <kill+0x68>
-  {
-    if (p->pid == pid)
-80104564:	39 58 10             	cmp    %ebx,0x10(%eax)
-80104567:	75 ef                	jne    80104558 <kill+0x28>
-    {
-      p->killed = 1;
-      // Wake process from sleep if necessary.
-      if (p->state == SLEEPING)
-80104569:	83 78 0c 02          	cmpl   $0x2,0xc(%eax)
-      p->killed = 1;
-8010456d:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
-      if (p->state == SLEEPING)
-80104574:	75 07                	jne    8010457d <kill+0x4d>
-        p->state = RUNNABLE;
-80104576:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
-      release(&ptable.lock);
-8010457d:	83 ec 0c             	sub    $0xc,%esp
-80104580:	68 60 3d 11 80       	push   $0x80113d60
-80104585:	e8 f6 08 00 00       	call   80104e80 <release>
-      return 0;
-    }
-  }
-  release(&ptable.lock);
-  return -1;
-}
-8010458a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-      return 0;
-8010458d:	83 c4 10             	add    $0x10,%esp
-80104590:	31 c0                	xor    %eax,%eax
-}
-80104592:	c9                   	leave  
-80104593:	c3                   	ret    
-80104594:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  release(&ptable.lock);
-80104598:	83 ec 0c             	sub    $0xc,%esp
-8010459b:	68 60 3d 11 80       	push   $0x80113d60
-801045a0:	e8 db 08 00 00       	call   80104e80 <release>
-}
-801045a5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-  return -1;
-801045a8:	83 c4 10             	add    $0x10,%esp
-801045ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-801045b0:	c9                   	leave  
-801045b1:	c3                   	ret    
-801045b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801045b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-801045c0 <procdump>:
-//PAGEBREAK: 36
-// Print a process listing to console.  For debugging.
-// Runs when user types ^P on console.
-// No lock to avoid wedging a stuck machine further.
-void procdump(void)
-{
-801045c0:	f3 0f 1e fb          	endbr32 
-801045c4:	55                   	push   %ebp
-801045c5:	89 e5                	mov    %esp,%ebp
-801045c7:	57                   	push   %edi
-801045c8:	56                   	push   %esi
-801045c9:	8d 75 e8             	lea    -0x18(%ebp),%esi
-801045cc:	53                   	push   %ebx
-801045cd:	bb 00 3e 11 80       	mov    $0x80113e00,%ebx
-801045d2:	83 ec 3c             	sub    $0x3c,%esp
-801045d5:	eb 2b                	jmp    80104602 <procdump+0x42>
-801045d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801045de:	66 90                	xchg   %ax,%ax
-    {
-      getcallerpcs((uint *)p->context->ebp + 2, pc);
-      for (i = 0; i < 10 && pc[i] != 0; i++)
-        cprintf(" %p", pc[i]);
-    }
-    cprintf("\n");
-801045e0:	83 ec 0c             	sub    $0xc,%esp
-801045e3:	68 03 86 10 80       	push   $0x80108603
-801045e8:	e8 c3 c0 ff ff       	call   801006b0 <cprintf>
-801045ed:	83 c4 10             	add    $0x10,%esp
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-801045f0:	81 c3 10 01 00 00    	add    $0x110,%ebx
-801045f6:	81 fb 00 82 11 80    	cmp    $0x80118200,%ebx
-801045fc:	0f 84 8e 00 00 00    	je     80104690 <procdump+0xd0>
-    if (p->state == UNUSED)
-80104602:	8b 43 a0             	mov    -0x60(%ebx),%eax
-80104605:	85 c0                	test   %eax,%eax
-80104607:	74 e7                	je     801045f0 <procdump+0x30>
-      state = "???";
-80104609:	ba 6b 82 10 80       	mov    $0x8010826b,%edx
-    if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
-8010460e:	83 f8 05             	cmp    $0x5,%eax
-80104611:	77 11                	ja     80104624 <procdump+0x64>
-80104613:	8b 14 85 cc 82 10 80 	mov    -0x7fef7d34(,%eax,4),%edx
-      state = "???";
-8010461a:	b8 6b 82 10 80       	mov    $0x8010826b,%eax
-8010461f:	85 d2                	test   %edx,%edx
-80104621:	0f 44 d0             	cmove  %eax,%edx
-    cprintf("%d %s %s", p->pid, state, p->name);
-80104624:	53                   	push   %ebx
-80104625:	52                   	push   %edx
-80104626:	ff 73 a4             	pushl  -0x5c(%ebx)
-80104629:	68 6f 82 10 80       	push   $0x8010826f
-8010462e:	e8 7d c0 ff ff       	call   801006b0 <cprintf>
-    if (p->state == SLEEPING)
-80104633:	83 c4 10             	add    $0x10,%esp
-80104636:	83 7b a0 02          	cmpl   $0x2,-0x60(%ebx)
-8010463a:	75 a4                	jne    801045e0 <procdump+0x20>
-      getcallerpcs((uint *)p->context->ebp + 2, pc);
-8010463c:	83 ec 08             	sub    $0x8,%esp
-8010463f:	8d 45 c0             	lea    -0x40(%ebp),%eax
-80104642:	8d 7d c0             	lea    -0x40(%ebp),%edi
-80104645:	50                   	push   %eax
-80104646:	8b 43 b0             	mov    -0x50(%ebx),%eax
-80104649:	8b 40 0c             	mov    0xc(%eax),%eax
-8010464c:	83 c0 08             	add    $0x8,%eax
-8010464f:	50                   	push   %eax
-80104650:	e8 0b 06 00 00       	call   80104c60 <getcallerpcs>
-      for (i = 0; i < 10 && pc[i] != 0; i++)
-80104655:	83 c4 10             	add    $0x10,%esp
-80104658:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010465f:	90                   	nop
-80104660:	8b 17                	mov    (%edi),%edx
-80104662:	85 d2                	test   %edx,%edx
-80104664:	0f 84 76 ff ff ff    	je     801045e0 <procdump+0x20>
-        cprintf(" %p", pc[i]);
-8010466a:	83 ec 08             	sub    $0x8,%esp
-8010466d:	83 c7 04             	add    $0x4,%edi
-80104670:	52                   	push   %edx
-80104671:	68 c1 7c 10 80       	push   $0x80107cc1
-80104676:	e8 35 c0 ff ff       	call   801006b0 <cprintf>
-      for (i = 0; i < 10 && pc[i] != 0; i++)
-8010467b:	83 c4 10             	add    $0x10,%esp
-8010467e:	39 fe                	cmp    %edi,%esi
-80104680:	75 de                	jne    80104660 <procdump+0xa0>
-80104682:	e9 59 ff ff ff       	jmp    801045e0 <procdump+0x20>
-80104687:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010468e:	66 90                	xchg   %ax,%ax
-  }
-}
-80104690:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80104693:	5b                   	pop    %ebx
-80104694:	5e                   	pop    %esi
-80104695:	5f                   	pop    %edi
-80104696:	5d                   	pop    %ebp
-80104697:	c3                   	ret    
-80104698:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010469f:	90                   	nop
-
-801046a0 <updateStateDurations>:
-int create_t = 0;
-void updateStateDurations()
-{
-801046a0:	f3 0f 1e fb          	endbr32 
-801046a4:	55                   	push   %ebp
-801046a5:	8b 0d c0 b5 10 80    	mov    0x8010b5c0,%ecx
-  struct proc *p;
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-801046ab:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-{
-801046b0:	89 e5                	mov    %esp,%ebp
-801046b2:	56                   	push   %esi
-801046b3:	8b 35 bc b5 10 80    	mov    0x8010b5bc,%esi
-801046b9:	53                   	push   %ebx
-801046ba:	31 db                	xor    %ebx,%ebx
-801046bc:	eb 1a                	jmp    801046d8 <updateStateDurations+0x38>
-801046be:	66 90                	xchg   %ax,%ax
-  {
-    switch (p->state)
-801046c0:	83 fa 02             	cmp    $0x2,%edx
-801046c3:	75 07                	jne    801046cc <updateStateDurations+0x2c>
-      create_t = total_t;
-      total_t++;
-        p->creation_t=create_t ;
-        
-    case SLEEPING:
-      p->sleeping_t++;
-801046c5:	83 80 00 01 00 00 01 	addl   $0x1,0x100(%eax)
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-801046cc:	05 10 01 00 00       	add    $0x110,%eax
-801046d1:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-801046d6:	74 40                	je     80104718 <updateStateDurations+0x78>
-    switch (p->state)
-801046d8:	8b 50 0c             	mov    0xc(%eax),%edx
-801046db:	83 fa 03             	cmp    $0x3,%edx
-801046de:	74 50                	je     80104730 <updateStateDurations+0x90>
-801046e0:	77 1e                	ja     80104700 <updateStateDurations+0x60>
-801046e2:	83 fa 01             	cmp    $0x1,%edx
-801046e5:	75 d9                	jne    801046c0 <updateStateDurations+0x20>
-        p->creation_t=create_t ;
-801046e7:	89 88 fc 00 00 00    	mov    %ecx,0xfc(%eax)
-      create_t = total_t;
-801046ed:	89 ce                	mov    %ecx,%esi
-        p->creation_t=create_t ;
-801046ef:	bb 01 00 00 00       	mov    $0x1,%ebx
-      total_t++;
-801046f4:	83 c1 01             	add    $0x1,%ecx
-801046f7:	eb cc                	jmp    801046c5 <updateStateDurations+0x25>
-801046f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    switch (p->state)
-80104700:	83 fa 04             	cmp    $0x4,%edx
-80104703:	75 c7                	jne    801046cc <updateStateDurations+0x2c>
-    case RUNNABLE:
-      p->runnable_t++;
-      break;
-
-    case RUNNING:
-      p->running_t++;
-80104705:	83 80 08 01 00 00 01 	addl   $0x1,0x108(%eax)
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-8010470c:	05 10 01 00 00       	add    $0x110,%eax
-80104711:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-80104716:	75 c0                	jne    801046d8 <updateStateDurations+0x38>
-80104718:	84 db                	test   %bl,%bl
-8010471a:	74 0c                	je     80104728 <updateStateDurations+0x88>
-8010471c:	89 0d c0 b5 10 80    	mov    %ecx,0x8010b5c0
-80104722:	89 35 bc b5 10 80    	mov    %esi,0x8010b5bc
-
-    default:
-      break;
-    }
-  }
-}
-80104728:	5b                   	pop    %ebx
-80104729:	5e                   	pop    %esi
-8010472a:	5d                   	pop    %ebp
-8010472b:	c3                   	ret    
-8010472c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-      p->runnable_t++;
-80104730:	83 80 04 01 00 00 01 	addl   $0x1,0x104(%eax)
-      break;
-80104737:	eb 93                	jmp    801046cc <updateStateDurations+0x2c>
-80104739:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-80104740 <getParentID>:
-
-int getParentID(void)
-{
-80104740:	f3 0f 1e fb          	endbr32 
-80104744:	55                   	push   %ebp
-80104745:	89 e5                	mov    %esp,%ebp
-80104747:	53                   	push   %ebx
-80104748:	83 ec 10             	sub    $0x10,%esp
-  acquire(&ptable.lock);
-8010474b:	68 60 3d 11 80       	push   $0x80113d60
-80104750:	e8 6b 06 00 00       	call   80104dc0 <acquire>
-  pushcli();
-80104755:	e8 66 05 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-8010475a:	e8 c1 f1 ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-8010475f:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
-  popcli();
-80104765:	e8 a6 05 00 00       	call   80104d10 <popcli>
-  struct proc *curproc = myproc();
-  int parent_pid = curproc->parent->pid;
-8010476a:	8b 43 14             	mov    0x14(%ebx),%eax
-8010476d:	8b 58 10             	mov    0x10(%eax),%ebx
-  release(&ptable.lock);
-80104770:	c7 04 24 60 3d 11 80 	movl   $0x80113d60,(%esp)
-80104777:	e8 04 07 00 00       	call   80104e80 <release>
-  return parent_pid;
-}
-8010477c:	89 d8                	mov    %ebx,%eax
-8010477e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80104781:	c9                   	leave  
-80104782:	c3                   	ret    
-80104783:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010478a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80104790 <getChildren>:
-
-int getChildren(int *children_pid)
-{
-80104790:	f3 0f 1e fb          	endbr32 
-80104794:	55                   	push   %ebp
-80104795:	89 e5                	mov    %esp,%ebp
-80104797:	57                   	push   %edi
-80104798:	56                   	push   %esi
-80104799:	53                   	push   %ebx
-8010479a:	83 ec 0c             	sub    $0xc,%esp
-8010479d:	8b 7d 08             	mov    0x8(%ebp),%edi
-  pushcli();
-801047a0:	e8 1b 05 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-801047a5:	e8 76 f1 ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-801047aa:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
-  popcli();
-801047b0:	e8 5b 05 00 00       	call   80104d10 <popcli>
-
-  // to iterate over proccesses
-  struct proc *p;
-  int num_children = 0;
-
-  acquire(&ptable.lock);
-801047b5:	83 ec 0c             	sub    $0xc,%esp
-  int curpid = curproc->pid;
-801047b8:	8b 73 10             	mov    0x10(%ebx),%esi
-  acquire(&ptable.lock);
-801047bb:	68 60 3d 11 80       	push   $0x80113d60
-  int num_children = 0;
-801047c0:	31 db                	xor    %ebx,%ebx
-  acquire(&ptable.lock);
-801047c2:	e8 f9 05 00 00       	call   80104dc0 <acquire>
-801047c7:	83 c4 10             	add    $0x10,%esp
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-801047ca:	b8 94 3d 11 80       	mov    $0x80113d94,%eax
-801047cf:	90                   	nop
-  {
-    if (p->parent->pid == curpid)
-801047d0:	8b 50 14             	mov    0x14(%eax),%edx
-801047d3:	39 72 10             	cmp    %esi,0x10(%edx)
-801047d6:	75 09                	jne    801047e1 <getChildren+0x51>
-      children_pid[num_children++] = p->pid;
-801047d8:	8b 50 10             	mov    0x10(%eax),%edx
-801047db:	89 14 9f             	mov    %edx,(%edi,%ebx,4)
-801047de:	83 c3 01             	add    $0x1,%ebx
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-801047e1:	05 10 01 00 00       	add    $0x110,%eax
-801047e6:	3d 94 81 11 80       	cmp    $0x80118194,%eax
-801047eb:	75 e3                	jne    801047d0 <getChildren+0x40>
-  }
-  release(&ptable.lock);
-801047ed:	83 ec 0c             	sub    $0xc,%esp
-801047f0:	68 60 3d 11 80       	push   $0x80113d60
-801047f5:	e8 86 06 00 00       	call   80104e80 <release>
-
-  return num_children;
-}
-801047fa:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801047fd:	89 d8                	mov    %ebx,%eax
-801047ff:	5b                   	pop    %ebx
-80104800:	5e                   	pop    %esi
-80104801:	5f                   	pop    %edi
-80104802:	5d                   	pop    %ebp
-80104803:	c3                   	ret    
-80104804:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010480b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010480f:	90                   	nop
-
-80104810 <getSyscallCounter>:
-
-int getSyscallCounter(int syscall_num)
-{
-80104810:	f3 0f 1e fb          	endbr32 
-80104814:	55                   	push   %ebp
-80104815:	89 e5                	mov    %esp,%ebp
-80104817:	56                   	push   %esi
-80104818:	53                   	push   %ebx
-80104819:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  pushcli();
-8010481c:	e8 9f 04 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-80104821:	e8 fa f0 ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-80104826:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
-  popcli();
-8010482c:	e8 df 04 00 00       	call   80104d10 <popcli>
-  struct proc *curproc = myproc();
-  if (syscall_num > 0 && syscall_num < NSYSCALLS)
-80104831:	8d 43 ff             	lea    -0x1(%ebx),%eax
-80104834:	83 f8 1b             	cmp    $0x1b,%eax
-80104837:	77 0f                	ja     80104848 <getSyscallCounter+0x38>
-    return curproc->syscallsCount[syscall_num - 1];
-80104839:	8b 44 9e 7c          	mov    0x7c(%esi,%ebx,4),%eax
-  else
-    return -1;
-}
-8010483d:	5b                   	pop    %ebx
-8010483e:	5e                   	pop    %esi
-8010483f:	5d                   	pop    %ebp
-80104840:	c3                   	ret    
-80104841:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
-80104848:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-8010484d:	eb ee                	jmp    8010483d <getSyscallCounter+0x2d>
-8010484f:	90                   	nop
-
-80104850 <setPriority>:
-
-int setPriority(int newPriority)
-{
-80104850:	f3 0f 1e fb          	endbr32 
-80104854:	55                   	push   %ebp
-80104855:	89 e5                	mov    %esp,%ebp
-80104857:	56                   	push   %esi
-80104858:	53                   	push   %ebx
-80104859:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  pushcli();
-8010485c:	e8 5f 04 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-80104861:	e8 ba f0 ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-80104866:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
-  popcli();
-8010486c:	e8 9f 04 00 00       	call   80104d10 <popcli>
-  struct proc *p = myproc();
-  if (newPriority > 0 && newPriority < 7)
-80104871:	8d 43 ff             	lea    -0x1(%ebx),%eax
-80104874:	83 f8 05             	cmp    $0x5,%eax
-80104877:	77 0f                	ja     80104888 <setPriority+0x38>
-  {
-    p->priority = newPriority;
-80104879:	89 9e f8 00 00 00    	mov    %ebx,0xf8(%esi)
-    return 0;
-8010487f:	31 c0                	xor    %eax,%eax
-  }
-  else
-    return -1;
-}
-80104881:	5b                   	pop    %ebx
-80104882:	5e                   	pop    %esi
-80104883:	5d                   	pop    %ebp
-80104884:	c3                   	ret    
-80104885:	8d 76 00             	lea    0x0(%esi),%esi
-    return -1;
-80104888:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-8010488d:	eb f2                	jmp    80104881 <setPriority+0x31>
-8010488f:	90                   	nop
-
-80104890 <changePolicy>:
-
-int changePolicy(int newPolicy)
-{
-80104890:	f3 0f 1e fb          	endbr32 
-80104894:	55                   	push   %ebp
-80104895:	89 e5                	mov    %esp,%ebp
-80104897:	8b 45 08             	mov    0x8(%ebp),%eax
-  if (newPolicy >= 0 && newPolicy < 6)
-8010489a:	83 f8 05             	cmp    $0x5,%eax
-8010489d:	77 11                	ja     801048b0 <changePolicy+0x20>
-  {
-    policy = newPolicy;
-8010489f:	a3 40 3d 11 80       	mov    %eax,0x80113d40
-    return 0;
-  }
-  else
-    return -1;
-}
-801048a4:	5d                   	pop    %ebp
-    return 0;
-801048a5:	31 c0                	xor    %eax,%eax
-}
-801048a7:	c3                   	ret    
-801048a8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801048af:	90                   	nop
-    return -1;
-801048b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-801048b5:	5d                   	pop    %ebp
-801048b6:	c3                   	ret    
-801048b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801048be:	66 90                	xchg   %ax,%ax
-
-801048c0 <getTurnAroundTime>:
-
-int getTurnAroundTime(int pid)
-{//
-801048c0:	f3 0f 1e fb          	endbr32 
-801048c4:	55                   	push   %ebp
-801048c5:	89 e5                	mov    %esp,%ebp
-  // struct proc *p;
-
-  
-  // if ((&ptable.proc[pid])->state == ZOMBIE)
-  return (&ptable.proc[pid])->sleeping_t + (&ptable.proc[pid])->runnable_t + (&ptable.proc[pid])->running_t;
-801048c7:	69 55 08 10 01 00 00 	imul   $0x110,0x8(%ebp),%edx
-  // else
-  //   return -1;
-}
-801048ce:	5d                   	pop    %ebp
-  return (&ptable.proc[pid])->sleeping_t + (&ptable.proc[pid])->runnable_t + (&ptable.proc[pid])->running_t;
-801048cf:	8b 82 98 3e 11 80    	mov    -0x7feec168(%edx),%eax
-801048d5:	03 82 94 3e 11 80    	add    -0x7feec16c(%edx),%eax
-801048db:	03 82 9c 3e 11 80    	add    -0x7feec164(%edx),%eax
-}
-801048e1:	c3                   	ret    
-801048e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801048e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-801048f0 <getBurstTime>:
-int getBurstTime(int pid){
-801048f0:	f3 0f 1e fb          	endbr32 
-801048f4:	55                   	push   %ebp
-801048f5:	89 e5                	mov    %esp,%ebp
-  int cb = 0;
-  cb =(&ptable.proc[pid])->running_t ;
-801048f7:	69 45 08 10 01 00 00 	imul   $0x110,0x8(%ebp),%eax
-  //(&ptable.proc[pid])->running_t = 0;
- // *p->running_t = 0;
-
-  return cb ;
-  //return (&ptable.proc[pid])->creation_t ;
-}
-801048fe:	5d                   	pop    %ebp
-  return cb ;
-801048ff:	8b 80 9c 3e 11 80    	mov    -0x7feec164(%eax),%eax
-}
-80104905:	c3                   	ret    
-80104906:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010490d:	8d 76 00             	lea    0x0(%esi),%esi
-
-80104910 <getCreationTime>:
-int getCreationTime(int pid){
-80104910:	f3 0f 1e fb          	endbr32 
-80104914:	55                   	push   %ebp
-80104915:	89 e5                	mov    %esp,%ebp
-  return (&ptable.proc[pid])->runnable_t ;
-80104917:	69 45 08 10 01 00 00 	imul   $0x110,0x8(%ebp),%eax
-}
-8010491e:	5d                   	pop    %ebp
-  return (&ptable.proc[pid])->runnable_t ;
-8010491f:	8b 80 98 3e 11 80    	mov    -0x7feec168(%eax),%eax
-}
-80104925:	c3                   	ret    
-80104926:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010492d:	8d 76 00             	lea    0x0(%esi),%esi
-
-80104930 <getWaitingTime>:
-
-int getWaitingTime(int pid)
-{
-80104930:	f3 0f 1e fb          	endbr32 
-80104934:	55                   	push   %ebp
-80104935:	89 e5                	mov    %esp,%ebp
-  return (&ptable.proc[pid])->sleeping_t + (&ptable.proc[pid])->runnable_t;
-80104937:	69 55 08 10 01 00 00 	imul   $0x110,0x8(%ebp),%edx
-}
-8010493e:	5d                   	pop    %ebp
-  return (&ptable.proc[pid])->sleeping_t + (&ptable.proc[pid])->runnable_t;
-8010493f:	8b 82 94 3e 11 80    	mov    -0x7feec16c(%edx),%eax
-80104945:	03 82 98 3e 11 80    	add    -0x7feec168(%edx),%eax
-}
-8010494b:	c3                   	ret    
-8010494c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-80104950 <getCBT>:
-80104950:	f3 0f 1e fb          	endbr32 
-80104954:	55                   	push   %ebp
-80104955:	89 e5                	mov    %esp,%ebp
-80104957:	69 45 08 10 01 00 00 	imul   $0x110,0x8(%ebp),%eax
-8010495e:	5d                   	pop    %ebp
-8010495f:	8b 80 9c 3e 11 80    	mov    -0x7feec164(%eax),%eax
-80104965:	c3                   	ret    
-80104966:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010496d:	8d 76 00             	lea    0x0(%esi),%esi
-
-80104970 <customWait>:
-}
-  int order = 0;
-
-// it is almost the same as wait but it gets process differents time such as turnAroundTime and waitingTime and CBT
-int customWait(int *procTimes)
-{
-80104970:	f3 0f 1e fb          	endbr32 
-80104974:	55                   	push   %ebp
-80104975:	89 e5                	mov    %esp,%ebp
-80104977:	57                   	push   %edi
-80104978:	56                   	push   %esi
-80104979:	53                   	push   %ebx
-8010497a:	83 ec 0c             	sub    $0xc,%esp
-8010497d:	8b 7d 08             	mov    0x8(%ebp),%edi
-  pushcli();
-80104980:	e8 3b 03 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-80104985:	e8 96 ef ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-8010498a:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
-  popcli();
-80104990:	e8 7b 03 00 00       	call   80104d10 <popcli>
-  struct proc *p;
-  int havekids, pid;
-  struct proc *curproc = myproc();
-
-  acquire(&ptable.lock);
-80104995:	83 ec 0c             	sub    $0xc,%esp
-80104998:	68 60 3d 11 80       	push   $0x80113d60
-8010499d:	e8 1e 04 00 00       	call   80104dc0 <acquire>
-801049a2:	83 c4 10             	add    $0x10,%esp
-  for (;;)
-  {
-    // Scan through table looking for exited children.
-    havekids = 0;
-801049a5:	31 c0                	xor    %eax,%eax
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-801049a7:	bb 94 3d 11 80       	mov    $0x80113d94,%ebx
-801049ac:	eb 10                	jmp    801049be <customWait+0x4e>
-801049ae:	66 90                	xchg   %ax,%ax
-801049b0:	81 c3 10 01 00 00    	add    $0x110,%ebx
-801049b6:	81 fb 94 81 11 80    	cmp    $0x80118194,%ebx
-801049bc:	74 1e                	je     801049dc <customWait+0x6c>
-    {
-      if (p->parent != curproc)
-801049be:	39 73 14             	cmp    %esi,0x14(%ebx)
-801049c1:	75 ed                	jne    801049b0 <customWait+0x40>
-        continue;
-      havekids = 1;
-      if (p->state == ZOMBIE)
-801049c3:	83 7b 0c 05          	cmpl   $0x5,0xc(%ebx)
-801049c7:	74 3f                	je     80104a08 <customWait+0x98>
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-801049c9:	81 c3 10 01 00 00    	add    $0x110,%ebx
-      havekids = 1;
-801049cf:	b8 01 00 00 00       	mov    $0x1,%eax
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-801049d4:	81 fb 94 81 11 80    	cmp    $0x80118194,%ebx
-801049da:	75 e2                	jne    801049be <customWait+0x4e>
-        return pid;
-      }
-    }
-
-    // No point waiting if we don't have any children.
-    if (!havekids || curproc->killed)
-801049dc:	85 c0                	test   %eax,%eax
-801049de:	0f 84 bc 00 00 00    	je     80104aa0 <customWait+0x130>
-801049e4:	8b 46 24             	mov    0x24(%esi),%eax
-801049e7:	85 c0                	test   %eax,%eax
-801049e9:	0f 85 b1 00 00 00    	jne    80104aa0 <customWait+0x130>
-      release(&ptable.lock);
-      return -1;
-    }
-
-    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock); //DOC: wait-sleep
-801049ef:	83 ec 08             	sub    $0x8,%esp
-801049f2:	68 60 3d 11 80       	push   $0x80113d60
-801049f7:	56                   	push   %esi
-801049f8:	e8 03 f9 ff ff       	call   80104300 <sleep>
-    havekids = 0;
-801049fd:	83 c4 10             	add    $0x10,%esp
-80104a00:	eb a3                	jmp    801049a5 <customWait+0x35>
-80104a02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  return (&ptable.proc[pid])->sleeping_t + (&ptable.proc[pid])->runnable_t + (&ptable.proc[pid])->running_t;
-80104a08:	69 43 10 10 01 00 00 	imul   $0x110,0x10(%ebx),%eax
-        kfree(p->kstack);
-80104a0f:	83 ec 0c             	sub    $0xc,%esp
-  return (&ptable.proc[pid])->sleeping_t + (&ptable.proc[pid])->runnable_t + (&ptable.proc[pid])->running_t;
-80104a12:	8b 90 98 3e 11 80    	mov    -0x7feec168(%eax),%edx
-80104a18:	8b 88 94 3e 11 80    	mov    -0x7feec16c(%eax),%ecx
-80104a1e:	05 60 3d 11 80       	add    $0x80113d60,%eax
-80104a23:	8b 80 3c 01 00 00    	mov    0x13c(%eax),%eax
-80104a29:	01 d1                	add    %edx,%ecx
-80104a2b:	8d 34 01             	lea    (%ecx,%eax,1),%esi
-        procTimes[1] = waitingTime;
-80104a2e:	89 4f 04             	mov    %ecx,0x4(%edi)
-  return (&ptable.proc[pid])->sleeping_t + (&ptable.proc[pid])->runnable_t + (&ptable.proc[pid])->running_t;
-80104a31:	89 37                	mov    %esi,(%edi)
-        procTimes[2] = cbt;
-80104a33:	89 47 08             	mov    %eax,0x8(%edi)
-        procTimes[3] = p->priority;
-80104a36:	8b 83 f8 00 00 00    	mov    0xf8(%ebx),%eax
-        procTimes[4] = creationTime;
-80104a3c:	89 57 10             	mov    %edx,0x10(%edi)
-        procTimes[3] = p->priority;
-80104a3f:	89 47 0c             	mov    %eax,0xc(%edi)
-        pid = p->pid;
-80104a42:	8b 73 10             	mov    0x10(%ebx),%esi
-        kfree(p->kstack);
-80104a45:	ff 73 08             	pushl  0x8(%ebx)
-        create_t = 0;
-80104a48:	c7 05 bc b5 10 80 00 	movl   $0x0,0x8010b5bc
-80104a4f:	00 00 00 
-        kfree(p->kstack);
-80104a52:	e8 19 da ff ff       	call   80102470 <kfree>
-        freevm(p->pgdir);
-80104a57:	5a                   	pop    %edx
-80104a58:	ff 73 04             	pushl  0x4(%ebx)
-        p->kstack = 0;
-80104a5b:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
-        freevm(p->pgdir);
-80104a62:	e8 09 2f 00 00       	call   80107970 <freevm>
-        release(&ptable.lock);
-80104a67:	c7 04 24 60 3d 11 80 	movl   $0x80113d60,(%esp)
-        p->pid = 0;
-80104a6e:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
-        p->parent = 0;
-80104a75:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
-        p->name[0] = 0;
-80104a7c:	c6 43 6c 00          	movb   $0x0,0x6c(%ebx)
-        p->killed = 0;
-80104a80:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
-        p->state = UNUSED;
-80104a87:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
-        release(&ptable.lock);
-80104a8e:	e8 ed 03 00 00       	call   80104e80 <release>
-        return pid;
-80104a93:	83 c4 10             	add    $0x10,%esp
-  }
-}
-80104a96:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80104a99:	89 f0                	mov    %esi,%eax
-80104a9b:	5b                   	pop    %ebx
-80104a9c:	5e                   	pop    %esi
-80104a9d:	5f                   	pop    %edi
-80104a9e:	5d                   	pop    %ebp
-80104a9f:	c3                   	ret    
-      release(&ptable.lock);
-80104aa0:	83 ec 0c             	sub    $0xc,%esp
-      return -1;
-80104aa3:	be ff ff ff ff       	mov    $0xffffffff,%esi
-      release(&ptable.lock);
-80104aa8:	68 60 3d 11 80       	push   $0x80113d60
-80104aad:	e8 ce 03 00 00       	call   80104e80 <release>
-      return -1;
-80104ab2:	83 c4 10             	add    $0x10,%esp
-80104ab5:	eb df                	jmp    80104a96 <customWait+0x126>
-80104ab7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104abe:	66 90                	xchg   %ax,%ax
-
-80104ac0 <setQueue>:
-
-int setQueue(int queueNumber)
-{
-80104ac0:	f3 0f 1e fb          	endbr32 
-80104ac4:	55                   	push   %ebp
-80104ac5:	89 e5                	mov    %esp,%ebp
-80104ac7:	56                   	push   %esi
-80104ac8:	53                   	push   %ebx
-80104ac9:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  pushcli();
-80104acc:	e8 ef 01 00 00       	call   80104cc0 <pushcli>
-  c = mycpu();
-80104ad1:	e8 4a ee ff ff       	call   80103920 <mycpu>
-  p = c->proc;
-80104ad6:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
-  popcli();
-80104adc:	e8 2f 02 00 00       	call   80104d10 <popcli>
-  struct proc *curproc = myproc();
-  if (queueNumber > 4 || queueNumber < 1)
-80104ae1:	8d 43 ff             	lea    -0x1(%ebx),%eax
-80104ae4:	83 f8 03             	cmp    $0x3,%eax
-80104ae7:	77 0f                	ja     80104af8 <setQueue+0x38>
-  {
-    return -1;
-  }
-  else
-  {
-    curproc->queue = queueNumber;
-80104ae9:	89 5e 7c             	mov    %ebx,0x7c(%esi)
-    return 0;
-80104aec:	31 c0                	xor    %eax,%eax
-  }
-80104aee:	5b                   	pop    %ebx
-80104aef:	5e                   	pop    %esi
-80104af0:	5d                   	pop    %ebp
-80104af1:	c3                   	ret    
-80104af2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    return -1;
-80104af8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80104afd:	eb ef                	jmp    80104aee <setQueue+0x2e>
-80104aff:	90                   	nop
-
-80104b00 <initsleeplock>:
-#include "spinlock.h"
-#include "sleeplock.h"
-
-void
-initsleeplock(struct sleeplock *lk, char *name)
-{
-80104b00:	f3 0f 1e fb          	endbr32 
-80104b04:	55                   	push   %ebp
-80104b05:	89 e5                	mov    %esp,%ebp
-80104b07:	53                   	push   %ebx
-80104b08:	83 ec 0c             	sub    $0xc,%esp
-80104b0b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  initlock(&lk->lk, "sleep lock");
-80104b0e:	68 e4 82 10 80       	push   $0x801082e4
-80104b13:	8d 43 04             	lea    0x4(%ebx),%eax
-80104b16:	50                   	push   %eax
-80104b17:	e8 24 01 00 00       	call   80104c40 <initlock>
-  lk->name = name;
-80104b1c:	8b 45 0c             	mov    0xc(%ebp),%eax
-  lk->locked = 0;
-80104b1f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
-  lk->pid = 0;
-}
-80104b25:	83 c4 10             	add    $0x10,%esp
-  lk->pid = 0;
-80104b28:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
-  lk->name = name;
-80104b2f:	89 43 38             	mov    %eax,0x38(%ebx)
-}
-80104b32:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80104b35:	c9                   	leave  
-80104b36:	c3                   	ret    
-80104b37:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104b3e:	66 90                	xchg   %ax,%ax
-
-80104b40 <acquiresleep>:
-
-void
-acquiresleep(struct sleeplock *lk)
-{
-80104b40:	f3 0f 1e fb          	endbr32 
-80104b44:	55                   	push   %ebp
-80104b45:	89 e5                	mov    %esp,%ebp
-80104b47:	56                   	push   %esi
-80104b48:	53                   	push   %ebx
-80104b49:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  acquire(&lk->lk);
-80104b4c:	8d 73 04             	lea    0x4(%ebx),%esi
-80104b4f:	83 ec 0c             	sub    $0xc,%esp
-80104b52:	56                   	push   %esi
-80104b53:	e8 68 02 00 00       	call   80104dc0 <acquire>
-  while (lk->locked) {
-80104b58:	8b 13                	mov    (%ebx),%edx
-80104b5a:	83 c4 10             	add    $0x10,%esp
-80104b5d:	85 d2                	test   %edx,%edx
-80104b5f:	74 1a                	je     80104b7b <acquiresleep+0x3b>
-80104b61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    sleep(lk, &lk->lk);
-80104b68:	83 ec 08             	sub    $0x8,%esp
-80104b6b:	56                   	push   %esi
-80104b6c:	53                   	push   %ebx
-80104b6d:	e8 8e f7 ff ff       	call   80104300 <sleep>
-  while (lk->locked) {
-80104b72:	8b 03                	mov    (%ebx),%eax
-80104b74:	83 c4 10             	add    $0x10,%esp
-80104b77:	85 c0                	test   %eax,%eax
-80104b79:	75 ed                	jne    80104b68 <acquiresleep+0x28>
-  }
-  lk->locked = 1;
-80104b7b:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
-  lk->pid = myproc()->pid;
-80104b81:	e8 2a ee ff ff       	call   801039b0 <myproc>
-80104b86:	8b 40 10             	mov    0x10(%eax),%eax
-80104b89:	89 43 3c             	mov    %eax,0x3c(%ebx)
-  release(&lk->lk);
-80104b8c:	89 75 08             	mov    %esi,0x8(%ebp)
-}
-80104b8f:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80104b92:	5b                   	pop    %ebx
-80104b93:	5e                   	pop    %esi
-80104b94:	5d                   	pop    %ebp
-  release(&lk->lk);
-80104b95:	e9 e6 02 00 00       	jmp    80104e80 <release>
-80104b9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80104ba0 <releasesleep>:
-
-void
-releasesleep(struct sleeplock *lk)
-{
-80104ba0:	f3 0f 1e fb          	endbr32 
-80104ba4:	55                   	push   %ebp
-80104ba5:	89 e5                	mov    %esp,%ebp
-80104ba7:	56                   	push   %esi
-80104ba8:	53                   	push   %ebx
-80104ba9:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  acquire(&lk->lk);
-80104bac:	8d 73 04             	lea    0x4(%ebx),%esi
-80104baf:	83 ec 0c             	sub    $0xc,%esp
-80104bb2:	56                   	push   %esi
-80104bb3:	e8 08 02 00 00       	call   80104dc0 <acquire>
-  lk->locked = 0;
-80104bb8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
-  lk->pid = 0;
-80104bbe:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
-  wakeup(lk);
-80104bc5:	89 1c 24             	mov    %ebx,(%esp)
-80104bc8:	e8 f3 f8 ff ff       	call   801044c0 <wakeup>
-  release(&lk->lk);
-80104bcd:	89 75 08             	mov    %esi,0x8(%ebp)
-80104bd0:	83 c4 10             	add    $0x10,%esp
-}
-80104bd3:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80104bd6:	5b                   	pop    %ebx
-80104bd7:	5e                   	pop    %esi
-80104bd8:	5d                   	pop    %ebp
-  release(&lk->lk);
-80104bd9:	e9 a2 02 00 00       	jmp    80104e80 <release>
-80104bde:	66 90                	xchg   %ax,%ax
-
-80104be0 <holdingsleep>:
-
-int
-holdingsleep(struct sleeplock *lk)
-{
-80104be0:	f3 0f 1e fb          	endbr32 
-80104be4:	55                   	push   %ebp
-80104be5:	89 e5                	mov    %esp,%ebp
-80104be7:	57                   	push   %edi
-80104be8:	31 ff                	xor    %edi,%edi
-80104bea:	56                   	push   %esi
-80104beb:	53                   	push   %ebx
-80104bec:	83 ec 18             	sub    $0x18,%esp
-80104bef:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  int r;
-  
-  acquire(&lk->lk);
-80104bf2:	8d 73 04             	lea    0x4(%ebx),%esi
-80104bf5:	56                   	push   %esi
-80104bf6:	e8 c5 01 00 00       	call   80104dc0 <acquire>
-  r = lk->locked && (lk->pid == myproc()->pid);
-80104bfb:	8b 03                	mov    (%ebx),%eax
-80104bfd:	83 c4 10             	add    $0x10,%esp
-80104c00:	85 c0                	test   %eax,%eax
-80104c02:	75 1c                	jne    80104c20 <holdingsleep+0x40>
-  release(&lk->lk);
-80104c04:	83 ec 0c             	sub    $0xc,%esp
-80104c07:	56                   	push   %esi
-80104c08:	e8 73 02 00 00       	call   80104e80 <release>
-  return r;
-}
-80104c0d:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80104c10:	89 f8                	mov    %edi,%eax
-80104c12:	5b                   	pop    %ebx
-80104c13:	5e                   	pop    %esi
-80104c14:	5f                   	pop    %edi
-80104c15:	5d                   	pop    %ebp
-80104c16:	c3                   	ret    
-80104c17:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104c1e:	66 90                	xchg   %ax,%ax
-  r = lk->locked && (lk->pid == myproc()->pid);
-80104c20:	8b 5b 3c             	mov    0x3c(%ebx),%ebx
-80104c23:	e8 88 ed ff ff       	call   801039b0 <myproc>
-80104c28:	39 58 10             	cmp    %ebx,0x10(%eax)
-80104c2b:	0f 94 c0             	sete   %al
-80104c2e:	0f b6 c0             	movzbl %al,%eax
-80104c31:	89 c7                	mov    %eax,%edi
-80104c33:	eb cf                	jmp    80104c04 <holdingsleep+0x24>
-80104c35:	66 90                	xchg   %ax,%ax
-80104c37:	66 90                	xchg   %ax,%ax
-80104c39:	66 90                	xchg   %ax,%ax
-80104c3b:	66 90                	xchg   %ax,%ax
-80104c3d:	66 90                	xchg   %ax,%ax
-80104c3f:	90                   	nop
-
-80104c40 <initlock>:
-#include "proc.h"
-#include "spinlock.h"
-
-void
-initlock(struct spinlock *lk, char *name)
-{
-80104c40:	f3 0f 1e fb          	endbr32 
-80104c44:	55                   	push   %ebp
-80104c45:	89 e5                	mov    %esp,%ebp
-80104c47:	8b 45 08             	mov    0x8(%ebp),%eax
-  lk->name = name;
-80104c4a:	8b 55 0c             	mov    0xc(%ebp),%edx
-  lk->locked = 0;
-80104c4d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
-  lk->name = name;
-80104c53:	89 50 04             	mov    %edx,0x4(%eax)
-  lk->cpu = 0;
-80104c56:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
-}
-80104c5d:	5d                   	pop    %ebp
-80104c5e:	c3                   	ret    
-80104c5f:	90                   	nop
-
-80104c60 <getcallerpcs>:
-}
-
-// Record the current call stack in pcs[] by following the %ebp chain.
-void
-getcallerpcs(void *v, uint pcs[])
-{
-80104c60:	f3 0f 1e fb          	endbr32 
-80104c64:	55                   	push   %ebp
-  uint *ebp;
-  int i;
-
-  ebp = (uint*)v - 2;
-  for(i = 0; i < 10; i++){
-80104c65:	31 d2                	xor    %edx,%edx
-{
-80104c67:	89 e5                	mov    %esp,%ebp
-80104c69:	53                   	push   %ebx
-  ebp = (uint*)v - 2;
-80104c6a:	8b 45 08             	mov    0x8(%ebp),%eax
-{
-80104c6d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
-  ebp = (uint*)v - 2;
-80104c70:	83 e8 08             	sub    $0x8,%eax
-  for(i = 0; i < 10; i++){
-80104c73:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80104c77:	90                   	nop
-    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
-80104c78:	8d 98 00 00 00 80    	lea    -0x80000000(%eax),%ebx
-80104c7e:	81 fb fe ff ff 7f    	cmp    $0x7ffffffe,%ebx
-80104c84:	77 1a                	ja     80104ca0 <getcallerpcs+0x40>
-      break;
-    pcs[i] = ebp[1];     // saved %eip
-80104c86:	8b 58 04             	mov    0x4(%eax),%ebx
-80104c89:	89 1c 91             	mov    %ebx,(%ecx,%edx,4)
-  for(i = 0; i < 10; i++){
-80104c8c:	83 c2 01             	add    $0x1,%edx
-    ebp = (uint*)ebp[0]; // saved %ebp
-80104c8f:	8b 00                	mov    (%eax),%eax
-  for(i = 0; i < 10; i++){
-80104c91:	83 fa 0a             	cmp    $0xa,%edx
-80104c94:	75 e2                	jne    80104c78 <getcallerpcs+0x18>
-  }
-  for(; i < 10; i++)
-    pcs[i] = 0;
-}
-80104c96:	5b                   	pop    %ebx
-80104c97:	5d                   	pop    %ebp
-80104c98:	c3                   	ret    
-80104c99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  for(; i < 10; i++)
-80104ca0:	8d 04 91             	lea    (%ecx,%edx,4),%eax
-80104ca3:	8d 51 28             	lea    0x28(%ecx),%edx
-80104ca6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104cad:	8d 76 00             	lea    0x0(%esi),%esi
-    pcs[i] = 0;
-80104cb0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
-  for(; i < 10; i++)
-80104cb6:	83 c0 04             	add    $0x4,%eax
-80104cb9:	39 d0                	cmp    %edx,%eax
-80104cbb:	75 f3                	jne    80104cb0 <getcallerpcs+0x50>
-}
-80104cbd:	5b                   	pop    %ebx
-80104cbe:	5d                   	pop    %ebp
-80104cbf:	c3                   	ret    
-
-80104cc0 <pushcli>:
-// it takes two popcli to undo two pushcli.  Also, if interrupts
-// are off, then pushcli, popcli leaves them off.
-
-void
-pushcli(void)
-{
-80104cc0:	f3 0f 1e fb          	endbr32 
-80104cc4:	55                   	push   %ebp
-80104cc5:	89 e5                	mov    %esp,%ebp
-80104cc7:	53                   	push   %ebx
-80104cc8:	83 ec 04             	sub    $0x4,%esp
-80104ccb:	9c                   	pushf  
-80104ccc:	5b                   	pop    %ebx
-  asm volatile("cli");
-80104ccd:	fa                   	cli    
-  int eflags;
-
-  eflags = readeflags();
-  cli();
-  if(mycpu()->ncli == 0)
-80104cce:	e8 4d ec ff ff       	call   80103920 <mycpu>
-80104cd3:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
-80104cd9:	85 c0                	test   %eax,%eax
-80104cdb:	74 13                	je     80104cf0 <pushcli+0x30>
-    mycpu()->intena = eflags & FL_IF;
-  mycpu()->ncli += 1;
-80104cdd:	e8 3e ec ff ff       	call   80103920 <mycpu>
-80104ce2:	83 80 a4 00 00 00 01 	addl   $0x1,0xa4(%eax)
-}
-80104ce9:	83 c4 04             	add    $0x4,%esp
-80104cec:	5b                   	pop    %ebx
-80104ced:	5d                   	pop    %ebp
-80104cee:	c3                   	ret    
-80104cef:	90                   	nop
-    mycpu()->intena = eflags & FL_IF;
-80104cf0:	e8 2b ec ff ff       	call   80103920 <mycpu>
-80104cf5:	81 e3 00 02 00 00    	and    $0x200,%ebx
-80104cfb:	89 98 a8 00 00 00    	mov    %ebx,0xa8(%eax)
-80104d01:	eb da                	jmp    80104cdd <pushcli+0x1d>
-80104d03:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104d0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80104d10 <popcli>:
-
-void
-popcli(void)
-{
-80104d10:	f3 0f 1e fb          	endbr32 
-80104d14:	55                   	push   %ebp
-80104d15:	89 e5                	mov    %esp,%ebp
-80104d17:	83 ec 08             	sub    $0x8,%esp
-  asm volatile("pushfl; popl %0" : "=r" (eflags));
-80104d1a:	9c                   	pushf  
-80104d1b:	58                   	pop    %eax
-  if(readeflags()&FL_IF)
-80104d1c:	f6 c4 02             	test   $0x2,%ah
-80104d1f:	75 31                	jne    80104d52 <popcli+0x42>
-    panic("popcli - interruptible");
-  if(--mycpu()->ncli < 0)
-80104d21:	e8 fa eb ff ff       	call   80103920 <mycpu>
-80104d26:	83 a8 a4 00 00 00 01 	subl   $0x1,0xa4(%eax)
-80104d2d:	78 30                	js     80104d5f <popcli+0x4f>
-    panic("popcli");
-  if(mycpu()->ncli == 0 && mycpu()->intena)
-80104d2f:	e8 ec eb ff ff       	call   80103920 <mycpu>
-80104d34:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
-80104d3a:	85 d2                	test   %edx,%edx
-80104d3c:	74 02                	je     80104d40 <popcli+0x30>
-    sti();
-}
-80104d3e:	c9                   	leave  
-80104d3f:	c3                   	ret    
-  if(mycpu()->ncli == 0 && mycpu()->intena)
-80104d40:	e8 db eb ff ff       	call   80103920 <mycpu>
-80104d45:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
-80104d4b:	85 c0                	test   %eax,%eax
-80104d4d:	74 ef                	je     80104d3e <popcli+0x2e>
-  asm volatile("sti");
-80104d4f:	fb                   	sti    
-}
-80104d50:	c9                   	leave  
-80104d51:	c3                   	ret    
-    panic("popcli - interruptible");
-80104d52:	83 ec 0c             	sub    $0xc,%esp
-80104d55:	68 ef 82 10 80       	push   $0x801082ef
-80104d5a:	e8 31 b6 ff ff       	call   80100390 <panic>
-    panic("popcli");
-80104d5f:	83 ec 0c             	sub    $0xc,%esp
-80104d62:	68 06 83 10 80       	push   $0x80108306
-80104d67:	e8 24 b6 ff ff       	call   80100390 <panic>
-80104d6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-80104d70 <holding>:
-{
-80104d70:	f3 0f 1e fb          	endbr32 
-80104d74:	55                   	push   %ebp
-80104d75:	89 e5                	mov    %esp,%ebp
-80104d77:	56                   	push   %esi
-80104d78:	53                   	push   %ebx
-80104d79:	8b 75 08             	mov    0x8(%ebp),%esi
-80104d7c:	31 db                	xor    %ebx,%ebx
-  pushcli();
-80104d7e:	e8 3d ff ff ff       	call   80104cc0 <pushcli>
-  r = lock->locked && lock->cpu == mycpu();
-80104d83:	8b 06                	mov    (%esi),%eax
-80104d85:	85 c0                	test   %eax,%eax
-80104d87:	75 0f                	jne    80104d98 <holding+0x28>
-  popcli();
-80104d89:	e8 82 ff ff ff       	call   80104d10 <popcli>
-}
-80104d8e:	89 d8                	mov    %ebx,%eax
-80104d90:	5b                   	pop    %ebx
-80104d91:	5e                   	pop    %esi
-80104d92:	5d                   	pop    %ebp
-80104d93:	c3                   	ret    
-80104d94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  r = lock->locked && lock->cpu == mycpu();
-80104d98:	8b 5e 08             	mov    0x8(%esi),%ebx
-80104d9b:	e8 80 eb ff ff       	call   80103920 <mycpu>
-80104da0:	39 c3                	cmp    %eax,%ebx
-80104da2:	0f 94 c3             	sete   %bl
-  popcli();
-80104da5:	e8 66 ff ff ff       	call   80104d10 <popcli>
-  r = lock->locked && lock->cpu == mycpu();
-80104daa:	0f b6 db             	movzbl %bl,%ebx
-}
-80104dad:	89 d8                	mov    %ebx,%eax
-80104daf:	5b                   	pop    %ebx
-80104db0:	5e                   	pop    %esi
-80104db1:	5d                   	pop    %ebp
-80104db2:	c3                   	ret    
-80104db3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104dba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80104dc0 <acquire>:
-{
-80104dc0:	f3 0f 1e fb          	endbr32 
-80104dc4:	55                   	push   %ebp
-80104dc5:	89 e5                	mov    %esp,%ebp
-80104dc7:	56                   	push   %esi
-80104dc8:	53                   	push   %ebx
-  pushcli(); // disable interrupts to avoid deadlock.
-80104dc9:	e8 f2 fe ff ff       	call   80104cc0 <pushcli>
-  if(holding(lk))
-80104dce:	8b 5d 08             	mov    0x8(%ebp),%ebx
-80104dd1:	83 ec 0c             	sub    $0xc,%esp
-80104dd4:	53                   	push   %ebx
-80104dd5:	e8 96 ff ff ff       	call   80104d70 <holding>
-80104dda:	83 c4 10             	add    $0x10,%esp
-80104ddd:	85 c0                	test   %eax,%eax
-80104ddf:	0f 85 7f 00 00 00    	jne    80104e64 <acquire+0xa4>
-80104de5:	89 c6                	mov    %eax,%esi
-  asm volatile("lock; xchgl %0, %1" :
-80104de7:	ba 01 00 00 00       	mov    $0x1,%edx
-80104dec:	eb 05                	jmp    80104df3 <acquire+0x33>
-80104dee:	66 90                	xchg   %ax,%ax
-80104df0:	8b 5d 08             	mov    0x8(%ebp),%ebx
-80104df3:	89 d0                	mov    %edx,%eax
-80104df5:	f0 87 03             	lock xchg %eax,(%ebx)
-  while(xchg(&lk->locked, 1) != 0)
-80104df8:	85 c0                	test   %eax,%eax
-80104dfa:	75 f4                	jne    80104df0 <acquire+0x30>
-  __sync_synchronize();
-80104dfc:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
-  lk->cpu = mycpu();
-80104e01:	8b 5d 08             	mov    0x8(%ebp),%ebx
-80104e04:	e8 17 eb ff ff       	call   80103920 <mycpu>
-80104e09:	89 43 08             	mov    %eax,0x8(%ebx)
-  ebp = (uint*)v - 2;
-80104e0c:	89 e8                	mov    %ebp,%eax
-80104e0e:	66 90                	xchg   %ax,%ax
-    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
-80104e10:	8d 90 00 00 00 80    	lea    -0x80000000(%eax),%edx
-80104e16:	81 fa fe ff ff 7f    	cmp    $0x7ffffffe,%edx
-80104e1c:	77 22                	ja     80104e40 <acquire+0x80>
-    pcs[i] = ebp[1];     // saved %eip
-80104e1e:	8b 50 04             	mov    0x4(%eax),%edx
-80104e21:	89 54 b3 0c          	mov    %edx,0xc(%ebx,%esi,4)
-  for(i = 0; i < 10; i++){
-80104e25:	83 c6 01             	add    $0x1,%esi
-    ebp = (uint*)ebp[0]; // saved %ebp
-80104e28:	8b 00                	mov    (%eax),%eax
-  for(i = 0; i < 10; i++){
-80104e2a:	83 fe 0a             	cmp    $0xa,%esi
-80104e2d:	75 e1                	jne    80104e10 <acquire+0x50>
-}
-80104e2f:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80104e32:	5b                   	pop    %ebx
-80104e33:	5e                   	pop    %esi
-80104e34:	5d                   	pop    %ebp
-80104e35:	c3                   	ret    
-80104e36:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104e3d:	8d 76 00             	lea    0x0(%esi),%esi
-  for(; i < 10; i++)
-80104e40:	8d 44 b3 0c          	lea    0xc(%ebx,%esi,4),%eax
-80104e44:	83 c3 34             	add    $0x34,%ebx
-80104e47:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104e4e:	66 90                	xchg   %ax,%ax
-    pcs[i] = 0;
-80104e50:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
-  for(; i < 10; i++)
-80104e56:	83 c0 04             	add    $0x4,%eax
-80104e59:	39 d8                	cmp    %ebx,%eax
-80104e5b:	75 f3                	jne    80104e50 <acquire+0x90>
-}
-80104e5d:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80104e60:	5b                   	pop    %ebx
-80104e61:	5e                   	pop    %esi
-80104e62:	5d                   	pop    %ebp
-80104e63:	c3                   	ret    
-    panic("acquire");
-80104e64:	83 ec 0c             	sub    $0xc,%esp
-80104e67:	68 0d 83 10 80       	push   $0x8010830d
-80104e6c:	e8 1f b5 ff ff       	call   80100390 <panic>
-80104e71:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104e78:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104e7f:	90                   	nop
-
-80104e80 <release>:
-{
-80104e80:	f3 0f 1e fb          	endbr32 
-80104e84:	55                   	push   %ebp
-80104e85:	89 e5                	mov    %esp,%ebp
-80104e87:	53                   	push   %ebx
-80104e88:	83 ec 10             	sub    $0x10,%esp
-80104e8b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  if(!holding(lk))
-80104e8e:	53                   	push   %ebx
-80104e8f:	e8 dc fe ff ff       	call   80104d70 <holding>
-80104e94:	83 c4 10             	add    $0x10,%esp
-80104e97:	85 c0                	test   %eax,%eax
-80104e99:	74 22                	je     80104ebd <release+0x3d>
-  lk->pcs[0] = 0;
-80104e9b:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
-  lk->cpu = 0;
-80104ea2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
-  __sync_synchronize();
-80104ea9:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
-  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
-80104eae:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
-}
-80104eb4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80104eb7:	c9                   	leave  
-  popcli();
-80104eb8:	e9 53 fe ff ff       	jmp    80104d10 <popcli>
-    panic("release");
-80104ebd:	83 ec 0c             	sub    $0xc,%esp
-80104ec0:	68 15 83 10 80       	push   $0x80108315
-80104ec5:	e8 c6 b4 ff ff       	call   80100390 <panic>
-80104eca:	66 90                	xchg   %ax,%ax
-80104ecc:	66 90                	xchg   %ax,%ax
-80104ece:	66 90                	xchg   %ax,%ax
-
-80104ed0 <memset>:
-#include "types.h"
-#include "x86.h"
-
-void*
-memset(void *dst, int c, uint n)
-{
-80104ed0:	f3 0f 1e fb          	endbr32 
-80104ed4:	55                   	push   %ebp
-80104ed5:	89 e5                	mov    %esp,%ebp
-80104ed7:	57                   	push   %edi
-80104ed8:	8b 55 08             	mov    0x8(%ebp),%edx
-80104edb:	8b 4d 10             	mov    0x10(%ebp),%ecx
-80104ede:	53                   	push   %ebx
-80104edf:	8b 45 0c             	mov    0xc(%ebp),%eax
-  if ((int)dst%4 == 0 && n%4 == 0){
-80104ee2:	89 d7                	mov    %edx,%edi
-80104ee4:	09 cf                	or     %ecx,%edi
-80104ee6:	83 e7 03             	and    $0x3,%edi
-80104ee9:	75 25                	jne    80104f10 <memset+0x40>
-    c &= 0xFF;
-80104eeb:	0f b6 f8             	movzbl %al,%edi
-    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
-80104eee:	c1 e0 18             	shl    $0x18,%eax
-80104ef1:	89 fb                	mov    %edi,%ebx
-80104ef3:	c1 e9 02             	shr    $0x2,%ecx
-80104ef6:	c1 e3 10             	shl    $0x10,%ebx
-80104ef9:	09 d8                	or     %ebx,%eax
-80104efb:	09 f8                	or     %edi,%eax
-80104efd:	c1 e7 08             	shl    $0x8,%edi
-80104f00:	09 f8                	or     %edi,%eax
-  asm volatile("cld; rep stosl" :
-80104f02:	89 d7                	mov    %edx,%edi
-80104f04:	fc                   	cld    
-80104f05:	f3 ab                	rep stos %eax,%es:(%edi)
-  } else
-    stosb(dst, c, n);
-  return dst;
-}
-80104f07:	5b                   	pop    %ebx
-80104f08:	89 d0                	mov    %edx,%eax
-80104f0a:	5f                   	pop    %edi
-80104f0b:	5d                   	pop    %ebp
-80104f0c:	c3                   	ret    
-80104f0d:	8d 76 00             	lea    0x0(%esi),%esi
-  asm volatile("cld; rep stosb" :
-80104f10:	89 d7                	mov    %edx,%edi
-80104f12:	fc                   	cld    
-80104f13:	f3 aa                	rep stos %al,%es:(%edi)
-80104f15:	5b                   	pop    %ebx
-80104f16:	89 d0                	mov    %edx,%eax
-80104f18:	5f                   	pop    %edi
-80104f19:	5d                   	pop    %ebp
-80104f1a:	c3                   	ret    
-80104f1b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80104f1f:	90                   	nop
-
-80104f20 <memcmp>:
-
-int
-memcmp(const void *v1, const void *v2, uint n)
-{
-80104f20:	f3 0f 1e fb          	endbr32 
-80104f24:	55                   	push   %ebp
-80104f25:	89 e5                	mov    %esp,%ebp
-80104f27:	56                   	push   %esi
-80104f28:	8b 75 10             	mov    0x10(%ebp),%esi
-80104f2b:	8b 55 08             	mov    0x8(%ebp),%edx
-80104f2e:	53                   	push   %ebx
-80104f2f:	8b 45 0c             	mov    0xc(%ebp),%eax
-  const uchar *s1, *s2;
-
-  s1 = v1;
-  s2 = v2;
-  while(n-- > 0){
-80104f32:	85 f6                	test   %esi,%esi
-80104f34:	74 2a                	je     80104f60 <memcmp+0x40>
-80104f36:	01 c6                	add    %eax,%esi
-80104f38:	eb 10                	jmp    80104f4a <memcmp+0x2a>
-80104f3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    if(*s1 != *s2)
-      return *s1 - *s2;
-    s1++, s2++;
-80104f40:	83 c0 01             	add    $0x1,%eax
-80104f43:	83 c2 01             	add    $0x1,%edx
-  while(n-- > 0){
-80104f46:	39 f0                	cmp    %esi,%eax
-80104f48:	74 16                	je     80104f60 <memcmp+0x40>
-    if(*s1 != *s2)
-80104f4a:	0f b6 0a             	movzbl (%edx),%ecx
-80104f4d:	0f b6 18             	movzbl (%eax),%ebx
-80104f50:	38 d9                	cmp    %bl,%cl
-80104f52:	74 ec                	je     80104f40 <memcmp+0x20>
-      return *s1 - *s2;
-80104f54:	0f b6 c1             	movzbl %cl,%eax
-80104f57:	29 d8                	sub    %ebx,%eax
-  }
-
-  return 0;
-}
-80104f59:	5b                   	pop    %ebx
-80104f5a:	5e                   	pop    %esi
-80104f5b:	5d                   	pop    %ebp
-80104f5c:	c3                   	ret    
-80104f5d:	8d 76 00             	lea    0x0(%esi),%esi
-80104f60:	5b                   	pop    %ebx
-  return 0;
-80104f61:	31 c0                	xor    %eax,%eax
-}
-80104f63:	5e                   	pop    %esi
-80104f64:	5d                   	pop    %ebp
-80104f65:	c3                   	ret    
-80104f66:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104f6d:	8d 76 00             	lea    0x0(%esi),%esi
-
-80104f70 <memmove>:
-
-void*
-memmove(void *dst, const void *src, uint n)
-{
-80104f70:	f3 0f 1e fb          	endbr32 
-80104f74:	55                   	push   %ebp
-80104f75:	89 e5                	mov    %esp,%ebp
-80104f77:	57                   	push   %edi
-80104f78:	8b 55 08             	mov    0x8(%ebp),%edx
-80104f7b:	8b 4d 10             	mov    0x10(%ebp),%ecx
-80104f7e:	56                   	push   %esi
-80104f7f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  const char *s;
-  char *d;
-
-  s = src;
-  d = dst;
-  if(s < d && s + n > d){
-80104f82:	39 d6                	cmp    %edx,%esi
-80104f84:	73 2a                	jae    80104fb0 <memmove+0x40>
-80104f86:	8d 3c 0e             	lea    (%esi,%ecx,1),%edi
-80104f89:	39 fa                	cmp    %edi,%edx
-80104f8b:	73 23                	jae    80104fb0 <memmove+0x40>
-80104f8d:	8d 41 ff             	lea    -0x1(%ecx),%eax
-    s += n;
-    d += n;
-    while(n-- > 0)
-80104f90:	85 c9                	test   %ecx,%ecx
-80104f92:	74 13                	je     80104fa7 <memmove+0x37>
-80104f94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-      *--d = *--s;
-80104f98:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
-80104f9c:	88 0c 02             	mov    %cl,(%edx,%eax,1)
-    while(n-- > 0)
-80104f9f:	83 e8 01             	sub    $0x1,%eax
-80104fa2:	83 f8 ff             	cmp    $0xffffffff,%eax
-80104fa5:	75 f1                	jne    80104f98 <memmove+0x28>
-  } else
-    while(n-- > 0)
-      *d++ = *s++;
-
-  return dst;
-}
-80104fa7:	5e                   	pop    %esi
-80104fa8:	89 d0                	mov    %edx,%eax
-80104faa:	5f                   	pop    %edi
-80104fab:	5d                   	pop    %ebp
-80104fac:	c3                   	ret    
-80104fad:	8d 76 00             	lea    0x0(%esi),%esi
-    while(n-- > 0)
-80104fb0:	8d 04 0e             	lea    (%esi,%ecx,1),%eax
-80104fb3:	89 d7                	mov    %edx,%edi
-80104fb5:	85 c9                	test   %ecx,%ecx
-80104fb7:	74 ee                	je     80104fa7 <memmove+0x37>
-80104fb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      *d++ = *s++;
-80104fc0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-    while(n-- > 0)
-80104fc1:	39 f0                	cmp    %esi,%eax
-80104fc3:	75 fb                	jne    80104fc0 <memmove+0x50>
-}
-80104fc5:	5e                   	pop    %esi
-80104fc6:	89 d0                	mov    %edx,%eax
-80104fc8:	5f                   	pop    %edi
-80104fc9:	5d                   	pop    %ebp
-80104fca:	c3                   	ret    
-80104fcb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80104fcf:	90                   	nop
-
-80104fd0 <memcpy>:
-
-// memcpy exists to placate GCC.  Use memmove.
-void*
-memcpy(void *dst, const void *src, uint n)
-{
-80104fd0:	f3 0f 1e fb          	endbr32 
-  return memmove(dst, src, n);
-80104fd4:	eb 9a                	jmp    80104f70 <memmove>
-80104fd6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80104fdd:	8d 76 00             	lea    0x0(%esi),%esi
-
-80104fe0 <strncmp>:
-}
-
-int
-strncmp(const char *p, const char *q, uint n)
-{
-80104fe0:	f3 0f 1e fb          	endbr32 
-80104fe4:	55                   	push   %ebp
-80104fe5:	89 e5                	mov    %esp,%ebp
-80104fe7:	56                   	push   %esi
-80104fe8:	8b 75 10             	mov    0x10(%ebp),%esi
-80104feb:	8b 4d 08             	mov    0x8(%ebp),%ecx
-80104fee:	53                   	push   %ebx
-80104fef:	8b 45 0c             	mov    0xc(%ebp),%eax
-  while(n > 0 && *p && *p == *q)
-80104ff2:	85 f6                	test   %esi,%esi
-80104ff4:	74 32                	je     80105028 <strncmp+0x48>
-80104ff6:	01 c6                	add    %eax,%esi
-80104ff8:	eb 14                	jmp    8010500e <strncmp+0x2e>
-80104ffa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-80105000:	38 da                	cmp    %bl,%dl
-80105002:	75 14                	jne    80105018 <strncmp+0x38>
-    n--, p++, q++;
-80105004:	83 c0 01             	add    $0x1,%eax
-80105007:	83 c1 01             	add    $0x1,%ecx
-  while(n > 0 && *p && *p == *q)
-8010500a:	39 f0                	cmp    %esi,%eax
-8010500c:	74 1a                	je     80105028 <strncmp+0x48>
-8010500e:	0f b6 11             	movzbl (%ecx),%edx
-80105011:	0f b6 18             	movzbl (%eax),%ebx
-80105014:	84 d2                	test   %dl,%dl
-80105016:	75 e8                	jne    80105000 <strncmp+0x20>
-  if(n == 0)
-    return 0;
-  return (uchar)*p - (uchar)*q;
-80105018:	0f b6 c2             	movzbl %dl,%eax
-8010501b:	29 d8                	sub    %ebx,%eax
-}
-8010501d:	5b                   	pop    %ebx
-8010501e:	5e                   	pop    %esi
-8010501f:	5d                   	pop    %ebp
-80105020:	c3                   	ret    
-80105021:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80105028:	5b                   	pop    %ebx
-    return 0;
-80105029:	31 c0                	xor    %eax,%eax
-}
-8010502b:	5e                   	pop    %esi
-8010502c:	5d                   	pop    %ebp
-8010502d:	c3                   	ret    
-8010502e:	66 90                	xchg   %ax,%ax
-
-80105030 <strncpy>:
-
-char*
-strncpy(char *s, const char *t, int n)
-{
-80105030:	f3 0f 1e fb          	endbr32 
-80105034:	55                   	push   %ebp
-80105035:	89 e5                	mov    %esp,%ebp
-80105037:	57                   	push   %edi
-80105038:	56                   	push   %esi
-80105039:	8b 75 08             	mov    0x8(%ebp),%esi
-8010503c:	53                   	push   %ebx
-8010503d:	8b 45 10             	mov    0x10(%ebp),%eax
-  char *os;
-
-  os = s;
-  while(n-- > 0 && (*s++ = *t++) != 0)
-80105040:	89 f2                	mov    %esi,%edx
-80105042:	eb 1b                	jmp    8010505f <strncpy+0x2f>
-80105044:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80105048:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
-8010504c:	8b 7d 0c             	mov    0xc(%ebp),%edi
-8010504f:	83 c2 01             	add    $0x1,%edx
-80105052:	0f b6 7f ff          	movzbl -0x1(%edi),%edi
-80105056:	89 f9                	mov    %edi,%ecx
-80105058:	88 4a ff             	mov    %cl,-0x1(%edx)
-8010505b:	84 c9                	test   %cl,%cl
-8010505d:	74 09                	je     80105068 <strncpy+0x38>
-8010505f:	89 c3                	mov    %eax,%ebx
-80105061:	83 e8 01             	sub    $0x1,%eax
-80105064:	85 db                	test   %ebx,%ebx
-80105066:	7f e0                	jg     80105048 <strncpy+0x18>
-    ;
-  while(n-- > 0)
-80105068:	89 d1                	mov    %edx,%ecx
-8010506a:	85 c0                	test   %eax,%eax
-8010506c:	7e 15                	jle    80105083 <strncpy+0x53>
-8010506e:	66 90                	xchg   %ax,%ax
-    *s++ = 0;
-80105070:	83 c1 01             	add    $0x1,%ecx
-80105073:	c6 41 ff 00          	movb   $0x0,-0x1(%ecx)
-  while(n-- > 0)
-80105077:	89 c8                	mov    %ecx,%eax
-80105079:	f7 d0                	not    %eax
-8010507b:	01 d0                	add    %edx,%eax
-8010507d:	01 d8                	add    %ebx,%eax
-8010507f:	85 c0                	test   %eax,%eax
-80105081:	7f ed                	jg     80105070 <strncpy+0x40>
-  return os;
-}
-80105083:	5b                   	pop    %ebx
-80105084:	89 f0                	mov    %esi,%eax
-80105086:	5e                   	pop    %esi
-80105087:	5f                   	pop    %edi
-80105088:	5d                   	pop    %ebp
-80105089:	c3                   	ret    
-8010508a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80105090 <safestrcpy>:
-
-// Like strncpy but guaranteed to NUL-terminate.
-char*
-safestrcpy(char *s, const char *t, int n)
-{
-80105090:	f3 0f 1e fb          	endbr32 
-80105094:	55                   	push   %ebp
-80105095:	89 e5                	mov    %esp,%ebp
-80105097:	56                   	push   %esi
-80105098:	8b 55 10             	mov    0x10(%ebp),%edx
-8010509b:	8b 75 08             	mov    0x8(%ebp),%esi
-8010509e:	53                   	push   %ebx
-8010509f:	8b 45 0c             	mov    0xc(%ebp),%eax
-  char *os;
-
-  os = s;
-  if(n <= 0)
-801050a2:	85 d2                	test   %edx,%edx
-801050a4:	7e 21                	jle    801050c7 <safestrcpy+0x37>
-801050a6:	8d 5c 10 ff          	lea    -0x1(%eax,%edx,1),%ebx
-801050aa:	89 f2                	mov    %esi,%edx
-801050ac:	eb 12                	jmp    801050c0 <safestrcpy+0x30>
-801050ae:	66 90                	xchg   %ax,%ax
-    return os;
-  while(--n > 0 && (*s++ = *t++) != 0)
-801050b0:	0f b6 08             	movzbl (%eax),%ecx
-801050b3:	83 c0 01             	add    $0x1,%eax
-801050b6:	83 c2 01             	add    $0x1,%edx
-801050b9:	88 4a ff             	mov    %cl,-0x1(%edx)
-801050bc:	84 c9                	test   %cl,%cl
-801050be:	74 04                	je     801050c4 <safestrcpy+0x34>
-801050c0:	39 d8                	cmp    %ebx,%eax
-801050c2:	75 ec                	jne    801050b0 <safestrcpy+0x20>
-    ;
-  *s = 0;
-801050c4:	c6 02 00             	movb   $0x0,(%edx)
-  return os;
-}
-801050c7:	89 f0                	mov    %esi,%eax
-801050c9:	5b                   	pop    %ebx
-801050ca:	5e                   	pop    %esi
-801050cb:	5d                   	pop    %ebp
-801050cc:	c3                   	ret    
-801050cd:	8d 76 00             	lea    0x0(%esi),%esi
-
-801050d0 <strlen>:
-
-int
-strlen(const char *s)
-{
-801050d0:	f3 0f 1e fb          	endbr32 
-801050d4:	55                   	push   %ebp
-  int n;
-
-  for(n = 0; s[n]; n++)
-801050d5:	31 c0                	xor    %eax,%eax
-{
-801050d7:	89 e5                	mov    %esp,%ebp
-801050d9:	8b 55 08             	mov    0x8(%ebp),%edx
-  for(n = 0; s[n]; n++)
-801050dc:	80 3a 00             	cmpb   $0x0,(%edx)
-801050df:	74 10                	je     801050f1 <strlen+0x21>
-801050e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801050e8:	83 c0 01             	add    $0x1,%eax
-801050eb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
-801050ef:	75 f7                	jne    801050e8 <strlen+0x18>
-    ;
-  return n;
-}
-801050f1:	5d                   	pop    %ebp
-801050f2:	c3                   	ret    
-
-801050f3 <swtch>:
-# a struct context, and save its address in *old.
-# Switch stacks to new and pop previously-saved registers.
-
-.globl swtch
-swtch:
-  movl 4(%esp), %eax
-801050f3:	8b 44 24 04          	mov    0x4(%esp),%eax
-  movl 8(%esp), %edx
-801050f7:	8b 54 24 08          	mov    0x8(%esp),%edx
-
-  # Save old callee-saved registers
-  pushl %ebp
-801050fb:	55                   	push   %ebp
-  pushl %ebx
-801050fc:	53                   	push   %ebx
-  pushl %esi
-801050fd:	56                   	push   %esi
-  pushl %edi
-801050fe:	57                   	push   %edi
-
-  # Switch stacks
-  movl %esp, (%eax)
-801050ff:	89 20                	mov    %esp,(%eax)
-  movl %edx, %esp
-80105101:	89 d4                	mov    %edx,%esp
-
-  # Load new callee-saved registers
-  popl %edi
-80105103:	5f                   	pop    %edi
-  popl %esi
-80105104:	5e                   	pop    %esi
-  popl %ebx
-80105105:	5b                   	pop    %ebx
-  popl %ebp
-80105106:	5d                   	pop    %ebp
-  ret
-80105107:	c3                   	ret    
-80105108:	66 90                	xchg   %ax,%ax
-8010510a:	66 90                	xchg   %ax,%ax
-8010510c:	66 90                	xchg   %ax,%ax
-8010510e:	66 90                	xchg   %ax,%ax
-
-80105110 <fetchint>:
-// library system call function. The saved user %esp points
-// to a saved program counter, and then the first argument.
-
-// Fetch the int at addr from the current process.
-int fetchint(uint addr, int *ip)
-{
-80105110:	f3 0f 1e fb          	endbr32 
-80105114:	55                   	push   %ebp
-80105115:	89 e5                	mov    %esp,%ebp
-80105117:	53                   	push   %ebx
-80105118:	83 ec 04             	sub    $0x4,%esp
-8010511b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  struct proc *curproc = myproc();
-8010511e:	e8 8d e8 ff ff       	call   801039b0 <myproc>
-
-  if (addr >= curproc->sz || addr + 4 > curproc->sz)
-80105123:	8b 00                	mov    (%eax),%eax
-80105125:	39 d8                	cmp    %ebx,%eax
-80105127:	76 17                	jbe    80105140 <fetchint+0x30>
-80105129:	8d 53 04             	lea    0x4(%ebx),%edx
-8010512c:	39 d0                	cmp    %edx,%eax
-8010512e:	72 10                	jb     80105140 <fetchint+0x30>
-    return -1;
-  *ip = *(int *)(addr);
-80105130:	8b 45 0c             	mov    0xc(%ebp),%eax
-80105133:	8b 13                	mov    (%ebx),%edx
-80105135:	89 10                	mov    %edx,(%eax)
-  return 0;
-80105137:	31 c0                	xor    %eax,%eax
-}
-80105139:	83 c4 04             	add    $0x4,%esp
-8010513c:	5b                   	pop    %ebx
-8010513d:	5d                   	pop    %ebp
-8010513e:	c3                   	ret    
-8010513f:	90                   	nop
-    return -1;
-80105140:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80105145:	eb f2                	jmp    80105139 <fetchint+0x29>
-80105147:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010514e:	66 90                	xchg   %ax,%ax
-
-80105150 <fetchstr>:
-
-// Fetch the nul-terminated string at addr from the current process.
-// Doesn't actually copy the string - just sets *pp to point at it.
-// Returns length of string, not including nul.
-int fetchstr(uint addr, char **pp)
-{
-80105150:	f3 0f 1e fb          	endbr32 
-80105154:	55                   	push   %ebp
-80105155:	89 e5                	mov    %esp,%ebp
-80105157:	53                   	push   %ebx
-80105158:	83 ec 04             	sub    $0x4,%esp
-8010515b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  char *s, *ep;
-  struct proc *curproc = myproc();
-8010515e:	e8 4d e8 ff ff       	call   801039b0 <myproc>
-
-  if (addr >= curproc->sz)
-80105163:	39 18                	cmp    %ebx,(%eax)
-80105165:	76 31                	jbe    80105198 <fetchstr+0x48>
-    return -1;
-  *pp = (char *)addr;
-80105167:	8b 55 0c             	mov    0xc(%ebp),%edx
-8010516a:	89 1a                	mov    %ebx,(%edx)
-  ep = (char *)curproc->sz;
-8010516c:	8b 10                	mov    (%eax),%edx
-  for (s = *pp; s < ep; s++)
-8010516e:	39 d3                	cmp    %edx,%ebx
-80105170:	73 26                	jae    80105198 <fetchstr+0x48>
-80105172:	89 d8                	mov    %ebx,%eax
-80105174:	eb 11                	jmp    80105187 <fetchstr+0x37>
-80105176:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010517d:	8d 76 00             	lea    0x0(%esi),%esi
-80105180:	83 c0 01             	add    $0x1,%eax
-80105183:	39 c2                	cmp    %eax,%edx
-80105185:	76 11                	jbe    80105198 <fetchstr+0x48>
-  {
-    if (*s == 0)
-80105187:	80 38 00             	cmpb   $0x0,(%eax)
-8010518a:	75 f4                	jne    80105180 <fetchstr+0x30>
-      return s - *pp;
-  }
-  return -1;
-}
-8010518c:	83 c4 04             	add    $0x4,%esp
-      return s - *pp;
-8010518f:	29 d8                	sub    %ebx,%eax
-}
-80105191:	5b                   	pop    %ebx
-80105192:	5d                   	pop    %ebp
-80105193:	c3                   	ret    
-80105194:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80105198:	83 c4 04             	add    $0x4,%esp
-    return -1;
-8010519b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-801051a0:	5b                   	pop    %ebx
-801051a1:	5d                   	pop    %ebp
-801051a2:	c3                   	ret    
-801051a3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801051aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-801051b0 <argint>:
-
-// Fetch the nth 32-bit system call argument.
-int argint(int n, int *ip)
-{
-801051b0:	f3 0f 1e fb          	endbr32 
-801051b4:	55                   	push   %ebp
-801051b5:	89 e5                	mov    %esp,%ebp
-801051b7:	56                   	push   %esi
-801051b8:	53                   	push   %ebx
-  return fetchint((myproc()->tf->esp) + 4 + 4 * n, ip);
-801051b9:	e8 f2 e7 ff ff       	call   801039b0 <myproc>
-801051be:	8b 55 08             	mov    0x8(%ebp),%edx
-801051c1:	8b 40 18             	mov    0x18(%eax),%eax
-801051c4:	8b 40 44             	mov    0x44(%eax),%eax
-801051c7:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
-  struct proc *curproc = myproc();
-801051ca:	e8 e1 e7 ff ff       	call   801039b0 <myproc>
-  return fetchint((myproc()->tf->esp) + 4 + 4 * n, ip);
-801051cf:	8d 73 04             	lea    0x4(%ebx),%esi
-  if (addr >= curproc->sz || addr + 4 > curproc->sz)
-801051d2:	8b 00                	mov    (%eax),%eax
-801051d4:	39 c6                	cmp    %eax,%esi
-801051d6:	73 18                	jae    801051f0 <argint+0x40>
-801051d8:	8d 53 08             	lea    0x8(%ebx),%edx
-801051db:	39 d0                	cmp    %edx,%eax
-801051dd:	72 11                	jb     801051f0 <argint+0x40>
-  *ip = *(int *)(addr);
-801051df:	8b 45 0c             	mov    0xc(%ebp),%eax
-801051e2:	8b 53 04             	mov    0x4(%ebx),%edx
-801051e5:	89 10                	mov    %edx,(%eax)
-  return 0;
-801051e7:	31 c0                	xor    %eax,%eax
-}
-801051e9:	5b                   	pop    %ebx
-801051ea:	5e                   	pop    %esi
-801051eb:	5d                   	pop    %ebp
-801051ec:	c3                   	ret    
-801051ed:	8d 76 00             	lea    0x0(%esi),%esi
-    return -1;
-801051f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-  return fetchint((myproc()->tf->esp) + 4 + 4 * n, ip);
-801051f5:	eb f2                	jmp    801051e9 <argint+0x39>
-801051f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801051fe:	66 90                	xchg   %ax,%ax
-
-80105200 <argptr>:
-
-// Fetch the nth word-sized system call argument as a pointer
-// to a block of memory of size bytes.  Check that the pointer
-// lies within the process address space.
-int argptr(int n, char **pp, int size)
-{
-80105200:	f3 0f 1e fb          	endbr32 
-80105204:	55                   	push   %ebp
-80105205:	89 e5                	mov    %esp,%ebp
-80105207:	56                   	push   %esi
-80105208:	53                   	push   %ebx
-80105209:	83 ec 10             	sub    $0x10,%esp
-8010520c:	8b 5d 10             	mov    0x10(%ebp),%ebx
-  int i;
-  struct proc *curproc = myproc();
-8010520f:	e8 9c e7 ff ff       	call   801039b0 <myproc>
-
-  if (argint(n, &i) < 0)
-80105214:	83 ec 08             	sub    $0x8,%esp
-  struct proc *curproc = myproc();
-80105217:	89 c6                	mov    %eax,%esi
-  if (argint(n, &i) < 0)
-80105219:	8d 45 f4             	lea    -0xc(%ebp),%eax
-8010521c:	50                   	push   %eax
-8010521d:	ff 75 08             	pushl  0x8(%ebp)
-80105220:	e8 8b ff ff ff       	call   801051b0 <argint>
-    return -1;
-  if (size < 0 || (uint)i >= curproc->sz || (uint)i + size > curproc->sz)
-80105225:	83 c4 10             	add    $0x10,%esp
-80105228:	85 c0                	test   %eax,%eax
-8010522a:	78 24                	js     80105250 <argptr+0x50>
-8010522c:	85 db                	test   %ebx,%ebx
-8010522e:	78 20                	js     80105250 <argptr+0x50>
-80105230:	8b 16                	mov    (%esi),%edx
-80105232:	8b 45 f4             	mov    -0xc(%ebp),%eax
-80105235:	39 c2                	cmp    %eax,%edx
-80105237:	76 17                	jbe    80105250 <argptr+0x50>
-80105239:	01 c3                	add    %eax,%ebx
-8010523b:	39 da                	cmp    %ebx,%edx
-8010523d:	72 11                	jb     80105250 <argptr+0x50>
-    return -1;
-  *pp = (char *)i;
-8010523f:	8b 55 0c             	mov    0xc(%ebp),%edx
-80105242:	89 02                	mov    %eax,(%edx)
-  return 0;
-80105244:	31 c0                	xor    %eax,%eax
-}
-80105246:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80105249:	5b                   	pop    %ebx
-8010524a:	5e                   	pop    %esi
-8010524b:	5d                   	pop    %ebp
-8010524c:	c3                   	ret    
-8010524d:	8d 76 00             	lea    0x0(%esi),%esi
-    return -1;
-80105250:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80105255:	eb ef                	jmp    80105246 <argptr+0x46>
-80105257:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010525e:	66 90                	xchg   %ax,%ax
-
-80105260 <argstr>:
-// Fetch the nth word-sized system call argument as a string pointer.
-// Check that the pointer is valid and the string is nul-terminated.
-// (There is no shared writable memory, so the string can't change
-// between this check and being used by the kernel.)
-int argstr(int n, char **pp)
-{
-80105260:	f3 0f 1e fb          	endbr32 
-80105264:	55                   	push   %ebp
-80105265:	89 e5                	mov    %esp,%ebp
-80105267:	83 ec 20             	sub    $0x20,%esp
-  int addr;
-  if (argint(n, &addr) < 0)
-8010526a:	8d 45 f4             	lea    -0xc(%ebp),%eax
-8010526d:	50                   	push   %eax
-8010526e:	ff 75 08             	pushl  0x8(%ebp)
-80105271:	e8 3a ff ff ff       	call   801051b0 <argint>
-80105276:	83 c4 10             	add    $0x10,%esp
-80105279:	85 c0                	test   %eax,%eax
-8010527b:	78 13                	js     80105290 <argstr+0x30>
-    return -1;
-  return fetchstr(addr, pp);
-8010527d:	83 ec 08             	sub    $0x8,%esp
-80105280:	ff 75 0c             	pushl  0xc(%ebp)
-80105283:	ff 75 f4             	pushl  -0xc(%ebp)
-80105286:	e8 c5 fe ff ff       	call   80105150 <fetchstr>
-8010528b:	83 c4 10             	add    $0x10,%esp
-}
-8010528e:	c9                   	leave  
-8010528f:	c3                   	ret    
-80105290:	c9                   	leave  
-    return -1;
-80105291:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80105296:	c3                   	ret    
-80105297:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010529e:	66 90                	xchg   %ax,%ax
-
-801052a0 <syscall>:
-    [SYS_getBurstTime] sys_getBurstTime,
-
-};
-
-void syscall(void)
-{
-801052a0:	f3 0f 1e fb          	endbr32 
-801052a4:	55                   	push   %ebp
-801052a5:	89 e5                	mov    %esp,%ebp
-801052a7:	53                   	push   %ebx
-801052a8:	83 ec 04             	sub    $0x4,%esp
-  int num;
-  struct proc *curproc = myproc();
-801052ab:	e8 00 e7 ff ff       	call   801039b0 <myproc>
-801052b0:	89 c3                	mov    %eax,%ebx
-
-  num = curproc->tf->eax;
-801052b2:	8b 40 18             	mov    0x18(%eax),%eax
-801052b5:	8b 40 1c             	mov    0x1c(%eax),%eax
-  if (num > 0 && num < NELEM(syscalls) && syscalls[num])
-801052b8:	8d 50 ff             	lea    -0x1(%eax),%edx
-801052bb:	83 fa 1f             	cmp    $0x1f,%edx
-801052be:	77 20                	ja     801052e0 <syscall+0x40>
-801052c0:	8b 14 85 40 83 10 80 	mov    -0x7fef7cc0(,%eax,4),%edx
-801052c7:	85 d2                	test   %edx,%edx
-801052c9:	74 15                	je     801052e0 <syscall+0x40>
-  {
-    curproc->syscallsCount[num - 1]++;
-801052cb:	83 44 83 7c 01       	addl   $0x1,0x7c(%ebx,%eax,4)
-    curproc->tf->eax = syscalls[num]();
-801052d0:	ff d2                	call   *%edx
-801052d2:	89 c2                	mov    %eax,%edx
-801052d4:	8b 43 18             	mov    0x18(%ebx),%eax
-801052d7:	89 50 1c             	mov    %edx,0x1c(%eax)
-  {
-    cprintf("%d %s: unknown sys call %d\n",
-            curproc->pid, curproc->name, num);
-    curproc->tf->eax = -1;
-  }
-}
-801052da:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-801052dd:	c9                   	leave  
-801052de:	c3                   	ret    
-801052df:	90                   	nop
-    cprintf("%d %s: unknown sys call %d\n",
-801052e0:	50                   	push   %eax
-            curproc->pid, curproc->name, num);
-801052e1:	8d 43 6c             	lea    0x6c(%ebx),%eax
-    cprintf("%d %s: unknown sys call %d\n",
-801052e4:	50                   	push   %eax
-801052e5:	ff 73 10             	pushl  0x10(%ebx)
-801052e8:	68 1d 83 10 80       	push   $0x8010831d
-801052ed:	e8 be b3 ff ff       	call   801006b0 <cprintf>
-    curproc->tf->eax = -1;
-801052f2:	8b 43 18             	mov    0x18(%ebx),%eax
-801052f5:	83 c4 10             	add    $0x10,%esp
-801052f8:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)
-}
-801052ff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80105302:	c9                   	leave  
-80105303:	c3                   	ret    
-80105304:	66 90                	xchg   %ax,%ax
-80105306:	66 90                	xchg   %ax,%ax
-80105308:	66 90                	xchg   %ax,%ax
-8010530a:	66 90                	xchg   %ax,%ax
-8010530c:	66 90                	xchg   %ax,%ax
-8010530e:	66 90                	xchg   %ax,%ax
-
-80105310 <create>:
-  return -1;
-}
-
-static struct inode*
-create(char *path, short type, short major, short minor)
-{
-80105310:	55                   	push   %ebp
-80105311:	89 e5                	mov    %esp,%ebp
-80105313:	57                   	push   %edi
-80105314:	56                   	push   %esi
-  struct inode *ip, *dp;
-  char name[DIRSIZ];
-
-  if((dp = nameiparent(path, name)) == 0)
-80105315:	8d 7d da             	lea    -0x26(%ebp),%edi
-{
-80105318:	53                   	push   %ebx
-80105319:	83 ec 34             	sub    $0x34,%esp
-8010531c:	89 4d d0             	mov    %ecx,-0x30(%ebp)
-8010531f:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  if((dp = nameiparent(path, name)) == 0)
-80105322:	57                   	push   %edi
-80105323:	50                   	push   %eax
-{
-80105324:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-80105327:	89 4d cc             	mov    %ecx,-0x34(%ebp)
-  if((dp = nameiparent(path, name)) == 0)
-8010532a:	e8 21 cd ff ff       	call   80102050 <nameiparent>
-8010532f:	83 c4 10             	add    $0x10,%esp
-80105332:	85 c0                	test   %eax,%eax
-80105334:	0f 84 46 01 00 00    	je     80105480 <create+0x170>
-    return 0;
-  ilock(dp);
-8010533a:	83 ec 0c             	sub    $0xc,%esp
-8010533d:	89 c3                	mov    %eax,%ebx
-8010533f:	50                   	push   %eax
-80105340:	e8 1b c4 ff ff       	call   80101760 <ilock>
-
-  if((ip = dirlookup(dp, name, 0)) != 0){
-80105345:	83 c4 0c             	add    $0xc,%esp
-80105348:	6a 00                	push   $0x0
-8010534a:	57                   	push   %edi
-8010534b:	53                   	push   %ebx
-8010534c:	e8 5f c9 ff ff       	call   80101cb0 <dirlookup>
-80105351:	83 c4 10             	add    $0x10,%esp
-80105354:	89 c6                	mov    %eax,%esi
-80105356:	85 c0                	test   %eax,%eax
-80105358:	74 56                	je     801053b0 <create+0xa0>
-    iunlockput(dp);
-8010535a:	83 ec 0c             	sub    $0xc,%esp
-8010535d:	53                   	push   %ebx
-8010535e:	e8 9d c6 ff ff       	call   80101a00 <iunlockput>
-    ilock(ip);
-80105363:	89 34 24             	mov    %esi,(%esp)
-80105366:	e8 f5 c3 ff ff       	call   80101760 <ilock>
-    if(type == T_FILE && ip->type == T_FILE)
-8010536b:	83 c4 10             	add    $0x10,%esp
-8010536e:	66 83 7d d4 02       	cmpw   $0x2,-0x2c(%ebp)
-80105373:	75 1b                	jne    80105390 <create+0x80>
-80105375:	66 83 7e 50 02       	cmpw   $0x2,0x50(%esi)
-8010537a:	75 14                	jne    80105390 <create+0x80>
-    panic("create: dirlink");
-
-  iunlockput(dp);
-
-  return ip;
-}
-8010537c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-8010537f:	89 f0                	mov    %esi,%eax
-80105381:	5b                   	pop    %ebx
-80105382:	5e                   	pop    %esi
-80105383:	5f                   	pop    %edi
-80105384:	5d                   	pop    %ebp
-80105385:	c3                   	ret    
-80105386:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010538d:	8d 76 00             	lea    0x0(%esi),%esi
-    iunlockput(ip);
-80105390:	83 ec 0c             	sub    $0xc,%esp
-80105393:	56                   	push   %esi
-    return 0;
-80105394:	31 f6                	xor    %esi,%esi
-    iunlockput(ip);
-80105396:	e8 65 c6 ff ff       	call   80101a00 <iunlockput>
-    return 0;
-8010539b:	83 c4 10             	add    $0x10,%esp
-}
-8010539e:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801053a1:	89 f0                	mov    %esi,%eax
-801053a3:	5b                   	pop    %ebx
-801053a4:	5e                   	pop    %esi
-801053a5:	5f                   	pop    %edi
-801053a6:	5d                   	pop    %ebp
-801053a7:	c3                   	ret    
-801053a8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801053af:	90                   	nop
-  if((ip = ialloc(dp->dev, type)) == 0)
-801053b0:	0f bf 45 d4          	movswl -0x2c(%ebp),%eax
-801053b4:	83 ec 08             	sub    $0x8,%esp
-801053b7:	50                   	push   %eax
-801053b8:	ff 33                	pushl  (%ebx)
-801053ba:	e8 21 c2 ff ff       	call   801015e0 <ialloc>
-801053bf:	83 c4 10             	add    $0x10,%esp
-801053c2:	89 c6                	mov    %eax,%esi
-801053c4:	85 c0                	test   %eax,%eax
-801053c6:	0f 84 cd 00 00 00    	je     80105499 <create+0x189>
-  ilock(ip);
-801053cc:	83 ec 0c             	sub    $0xc,%esp
-801053cf:	50                   	push   %eax
-801053d0:	e8 8b c3 ff ff       	call   80101760 <ilock>
-  ip->major = major;
-801053d5:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
-801053d9:	66 89 46 52          	mov    %ax,0x52(%esi)
-  ip->minor = minor;
-801053dd:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax
-801053e1:	66 89 46 54          	mov    %ax,0x54(%esi)
-  ip->nlink = 1;
-801053e5:	b8 01 00 00 00       	mov    $0x1,%eax
-801053ea:	66 89 46 56          	mov    %ax,0x56(%esi)
-  iupdate(ip);
-801053ee:	89 34 24             	mov    %esi,(%esp)
-801053f1:	e8 aa c2 ff ff       	call   801016a0 <iupdate>
-  if(type == T_DIR){  // Create . and .. entries.
-801053f6:	83 c4 10             	add    $0x10,%esp
-801053f9:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%ebp)
-801053fe:	74 30                	je     80105430 <create+0x120>
-  if(dirlink(dp, name, ip->inum) < 0)
-80105400:	83 ec 04             	sub    $0x4,%esp
-80105403:	ff 76 04             	pushl  0x4(%esi)
-80105406:	57                   	push   %edi
-80105407:	53                   	push   %ebx
-80105408:	e8 63 cb ff ff       	call   80101f70 <dirlink>
-8010540d:	83 c4 10             	add    $0x10,%esp
-80105410:	85 c0                	test   %eax,%eax
-80105412:	78 78                	js     8010548c <create+0x17c>
-  iunlockput(dp);
-80105414:	83 ec 0c             	sub    $0xc,%esp
-80105417:	53                   	push   %ebx
-80105418:	e8 e3 c5 ff ff       	call   80101a00 <iunlockput>
-  return ip;
-8010541d:	83 c4 10             	add    $0x10,%esp
-}
-80105420:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80105423:	89 f0                	mov    %esi,%eax
-80105425:	5b                   	pop    %ebx
-80105426:	5e                   	pop    %esi
-80105427:	5f                   	pop    %edi
-80105428:	5d                   	pop    %ebp
-80105429:	c3                   	ret    
-8010542a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    iupdate(dp);
-80105430:	83 ec 0c             	sub    $0xc,%esp
-    dp->nlink++;  // for ".."
-80105433:	66 83 43 56 01       	addw   $0x1,0x56(%ebx)
-    iupdate(dp);
-80105438:	53                   	push   %ebx
-80105439:	e8 62 c2 ff ff       	call   801016a0 <iupdate>
-    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
-8010543e:	83 c4 0c             	add    $0xc,%esp
-80105441:	ff 76 04             	pushl  0x4(%esi)
-80105444:	68 e0 83 10 80       	push   $0x801083e0
-80105449:	56                   	push   %esi
-8010544a:	e8 21 cb ff ff       	call   80101f70 <dirlink>
-8010544f:	83 c4 10             	add    $0x10,%esp
-80105452:	85 c0                	test   %eax,%eax
-80105454:	78 18                	js     8010546e <create+0x15e>
-80105456:	83 ec 04             	sub    $0x4,%esp
-80105459:	ff 73 04             	pushl  0x4(%ebx)
-8010545c:	68 df 83 10 80       	push   $0x801083df
-80105461:	56                   	push   %esi
-80105462:	e8 09 cb ff ff       	call   80101f70 <dirlink>
-80105467:	83 c4 10             	add    $0x10,%esp
-8010546a:	85 c0                	test   %eax,%eax
-8010546c:	79 92                	jns    80105400 <create+0xf0>
-      panic("create dots");
-8010546e:	83 ec 0c             	sub    $0xc,%esp
-80105471:	68 d3 83 10 80       	push   $0x801083d3
-80105476:	e8 15 af ff ff       	call   80100390 <panic>
-8010547b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010547f:	90                   	nop
-}
-80105480:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    return 0;
-80105483:	31 f6                	xor    %esi,%esi
-}
-80105485:	5b                   	pop    %ebx
-80105486:	89 f0                	mov    %esi,%eax
-80105488:	5e                   	pop    %esi
-80105489:	5f                   	pop    %edi
-8010548a:	5d                   	pop    %ebp
-8010548b:	c3                   	ret    
-    panic("create: dirlink");
-8010548c:	83 ec 0c             	sub    $0xc,%esp
-8010548f:	68 e2 83 10 80       	push   $0x801083e2
-80105494:	e8 f7 ae ff ff       	call   80100390 <panic>
-    panic("create: ialloc");
-80105499:	83 ec 0c             	sub    $0xc,%esp
-8010549c:	68 c4 83 10 80       	push   $0x801083c4
-801054a1:	e8 ea ae ff ff       	call   80100390 <panic>
-801054a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801054ad:	8d 76 00             	lea    0x0(%esi),%esi
-
-801054b0 <argfd.constprop.0>:
-argfd(int n, int *pfd, struct file **pf)
-801054b0:	55                   	push   %ebp
-801054b1:	89 e5                	mov    %esp,%ebp
-801054b3:	56                   	push   %esi
-801054b4:	89 d6                	mov    %edx,%esi
-801054b6:	53                   	push   %ebx
-801054b7:	89 c3                	mov    %eax,%ebx
-  if(argint(n, &fd) < 0)
-801054b9:	8d 45 f4             	lea    -0xc(%ebp),%eax
-argfd(int n, int *pfd, struct file **pf)
-801054bc:	83 ec 18             	sub    $0x18,%esp
-  if(argint(n, &fd) < 0)
-801054bf:	50                   	push   %eax
-801054c0:	6a 00                	push   $0x0
-801054c2:	e8 e9 fc ff ff       	call   801051b0 <argint>
-801054c7:	83 c4 10             	add    $0x10,%esp
-801054ca:	85 c0                	test   %eax,%eax
-801054cc:	78 2a                	js     801054f8 <argfd.constprop.0+0x48>
-  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
-801054ce:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
-801054d2:	77 24                	ja     801054f8 <argfd.constprop.0+0x48>
-801054d4:	e8 d7 e4 ff ff       	call   801039b0 <myproc>
-801054d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
-801054dc:	8b 44 90 28          	mov    0x28(%eax,%edx,4),%eax
-801054e0:	85 c0                	test   %eax,%eax
-801054e2:	74 14                	je     801054f8 <argfd.constprop.0+0x48>
-  if(pfd)
-801054e4:	85 db                	test   %ebx,%ebx
-801054e6:	74 02                	je     801054ea <argfd.constprop.0+0x3a>
-    *pfd = fd;
-801054e8:	89 13                	mov    %edx,(%ebx)
-    *pf = f;
-801054ea:	89 06                	mov    %eax,(%esi)
-  return 0;
-801054ec:	31 c0                	xor    %eax,%eax
-}
-801054ee:	8d 65 f8             	lea    -0x8(%ebp),%esp
-801054f1:	5b                   	pop    %ebx
-801054f2:	5e                   	pop    %esi
-801054f3:	5d                   	pop    %ebp
-801054f4:	c3                   	ret    
-801054f5:	8d 76 00             	lea    0x0(%esi),%esi
-    return -1;
-801054f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-801054fd:	eb ef                	jmp    801054ee <argfd.constprop.0+0x3e>
-801054ff:	90                   	nop
-
-80105500 <sys_dup>:
-{
-80105500:	f3 0f 1e fb          	endbr32 
-80105504:	55                   	push   %ebp
-  if(argfd(0, 0, &f) < 0)
-80105505:	31 c0                	xor    %eax,%eax
-{
-80105507:	89 e5                	mov    %esp,%ebp
-80105509:	56                   	push   %esi
-8010550a:	53                   	push   %ebx
-  if(argfd(0, 0, &f) < 0)
-8010550b:	8d 55 f4             	lea    -0xc(%ebp),%edx
-{
-8010550e:	83 ec 10             	sub    $0x10,%esp
-  if(argfd(0, 0, &f) < 0)
-80105511:	e8 9a ff ff ff       	call   801054b0 <argfd.constprop.0>
-80105516:	85 c0                	test   %eax,%eax
-80105518:	78 1e                	js     80105538 <sys_dup+0x38>
-  if((fd=fdalloc(f)) < 0)
-8010551a:	8b 75 f4             	mov    -0xc(%ebp),%esi
-  for(fd = 0; fd < NOFILE; fd++){
-8010551d:	31 db                	xor    %ebx,%ebx
-  struct proc *curproc = myproc();
-8010551f:	e8 8c e4 ff ff       	call   801039b0 <myproc>
-  for(fd = 0; fd < NOFILE; fd++){
-80105524:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    if(curproc->ofile[fd] == 0){
-80105528:	8b 54 98 28          	mov    0x28(%eax,%ebx,4),%edx
-8010552c:	85 d2                	test   %edx,%edx
-8010552e:	74 20                	je     80105550 <sys_dup+0x50>
-  for(fd = 0; fd < NOFILE; fd++){
-80105530:	83 c3 01             	add    $0x1,%ebx
-80105533:	83 fb 10             	cmp    $0x10,%ebx
-80105536:	75 f0                	jne    80105528 <sys_dup+0x28>
-}
-80105538:	8d 65 f8             	lea    -0x8(%ebp),%esp
-    return -1;
-8010553b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
-}
-80105540:	89 d8                	mov    %ebx,%eax
-80105542:	5b                   	pop    %ebx
-80105543:	5e                   	pop    %esi
-80105544:	5d                   	pop    %ebp
-80105545:	c3                   	ret    
-80105546:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010554d:	8d 76 00             	lea    0x0(%esi),%esi
-      curproc->ofile[fd] = f;
-80105550:	89 74 98 28          	mov    %esi,0x28(%eax,%ebx,4)
-  filedup(f);
-80105554:	83 ec 0c             	sub    $0xc,%esp
-80105557:	ff 75 f4             	pushl  -0xc(%ebp)
-8010555a:	e8 11 b9 ff ff       	call   80100e70 <filedup>
-  return fd;
-8010555f:	83 c4 10             	add    $0x10,%esp
-}
-80105562:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80105565:	89 d8                	mov    %ebx,%eax
-80105567:	5b                   	pop    %ebx
-80105568:	5e                   	pop    %esi
-80105569:	5d                   	pop    %ebp
-8010556a:	c3                   	ret    
-8010556b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010556f:	90                   	nop
-
-80105570 <sys_read>:
-{
-80105570:	f3 0f 1e fb          	endbr32 
-80105574:	55                   	push   %ebp
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
-80105575:	31 c0                	xor    %eax,%eax
-{
-80105577:	89 e5                	mov    %esp,%ebp
-80105579:	83 ec 18             	sub    $0x18,%esp
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
-8010557c:	8d 55 ec             	lea    -0x14(%ebp),%edx
-8010557f:	e8 2c ff ff ff       	call   801054b0 <argfd.constprop.0>
-80105584:	85 c0                	test   %eax,%eax
-80105586:	78 48                	js     801055d0 <sys_read+0x60>
-80105588:	83 ec 08             	sub    $0x8,%esp
-8010558b:	8d 45 f0             	lea    -0x10(%ebp),%eax
-8010558e:	50                   	push   %eax
-8010558f:	6a 02                	push   $0x2
-80105591:	e8 1a fc ff ff       	call   801051b0 <argint>
-80105596:	83 c4 10             	add    $0x10,%esp
-80105599:	85 c0                	test   %eax,%eax
-8010559b:	78 33                	js     801055d0 <sys_read+0x60>
-8010559d:	83 ec 04             	sub    $0x4,%esp
-801055a0:	8d 45 f4             	lea    -0xc(%ebp),%eax
-801055a3:	ff 75 f0             	pushl  -0x10(%ebp)
-801055a6:	50                   	push   %eax
-801055a7:	6a 01                	push   $0x1
-801055a9:	e8 52 fc ff ff       	call   80105200 <argptr>
-801055ae:	83 c4 10             	add    $0x10,%esp
-801055b1:	85 c0                	test   %eax,%eax
-801055b3:	78 1b                	js     801055d0 <sys_read+0x60>
-  return fileread(f, p, n);
-801055b5:	83 ec 04             	sub    $0x4,%esp
-801055b8:	ff 75 f0             	pushl  -0x10(%ebp)
-801055bb:	ff 75 f4             	pushl  -0xc(%ebp)
-801055be:	ff 75 ec             	pushl  -0x14(%ebp)
-801055c1:	e8 2a ba ff ff       	call   80100ff0 <fileread>
-801055c6:	83 c4 10             	add    $0x10,%esp
-}
-801055c9:	c9                   	leave  
-801055ca:	c3                   	ret    
-801055cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801055cf:	90                   	nop
-801055d0:	c9                   	leave  
-    return -1;
-801055d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-801055d6:	c3                   	ret    
-801055d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801055de:	66 90                	xchg   %ax,%ax
-
-801055e0 <sys_write>:
-{
-801055e0:	f3 0f 1e fb          	endbr32 
-801055e4:	55                   	push   %ebp
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
-801055e5:	31 c0                	xor    %eax,%eax
-{
-801055e7:	89 e5                	mov    %esp,%ebp
-801055e9:	83 ec 18             	sub    $0x18,%esp
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
-801055ec:	8d 55 ec             	lea    -0x14(%ebp),%edx
-801055ef:	e8 bc fe ff ff       	call   801054b0 <argfd.constprop.0>
-801055f4:	85 c0                	test   %eax,%eax
-801055f6:	78 48                	js     80105640 <sys_write+0x60>
-801055f8:	83 ec 08             	sub    $0x8,%esp
-801055fb:	8d 45 f0             	lea    -0x10(%ebp),%eax
-801055fe:	50                   	push   %eax
-801055ff:	6a 02                	push   $0x2
-80105601:	e8 aa fb ff ff       	call   801051b0 <argint>
-80105606:	83 c4 10             	add    $0x10,%esp
-80105609:	85 c0                	test   %eax,%eax
-8010560b:	78 33                	js     80105640 <sys_write+0x60>
-8010560d:	83 ec 04             	sub    $0x4,%esp
-80105610:	8d 45 f4             	lea    -0xc(%ebp),%eax
-80105613:	ff 75 f0             	pushl  -0x10(%ebp)
-80105616:	50                   	push   %eax
-80105617:	6a 01                	push   $0x1
-80105619:	e8 e2 fb ff ff       	call   80105200 <argptr>
-8010561e:	83 c4 10             	add    $0x10,%esp
-80105621:	85 c0                	test   %eax,%eax
-80105623:	78 1b                	js     80105640 <sys_write+0x60>
-  return filewrite(f, p, n);
-80105625:	83 ec 04             	sub    $0x4,%esp
-80105628:	ff 75 f0             	pushl  -0x10(%ebp)
-8010562b:	ff 75 f4             	pushl  -0xc(%ebp)
-8010562e:	ff 75 ec             	pushl  -0x14(%ebp)
-80105631:	e8 5a ba ff ff       	call   80101090 <filewrite>
-80105636:	83 c4 10             	add    $0x10,%esp
-}
-80105639:	c9                   	leave  
-8010563a:	c3                   	ret    
-8010563b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010563f:	90                   	nop
-80105640:	c9                   	leave  
-    return -1;
-80105641:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80105646:	c3                   	ret    
-80105647:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010564e:	66 90                	xchg   %ax,%ax
-
-80105650 <sys_close>:
-{
-80105650:	f3 0f 1e fb          	endbr32 
-80105654:	55                   	push   %ebp
-80105655:	89 e5                	mov    %esp,%ebp
-80105657:	83 ec 18             	sub    $0x18,%esp
-  if(argfd(0, &fd, &f) < 0)
-8010565a:	8d 55 f4             	lea    -0xc(%ebp),%edx
-8010565d:	8d 45 f0             	lea    -0x10(%ebp),%eax
-80105660:	e8 4b fe ff ff       	call   801054b0 <argfd.constprop.0>
-80105665:	85 c0                	test   %eax,%eax
-80105667:	78 27                	js     80105690 <sys_close+0x40>
-  myproc()->ofile[fd] = 0;
-80105669:	e8 42 e3 ff ff       	call   801039b0 <myproc>
-8010566e:	8b 55 f0             	mov    -0x10(%ebp),%edx
-  fileclose(f);
-80105671:	83 ec 0c             	sub    $0xc,%esp
-  myproc()->ofile[fd] = 0;
-80105674:	c7 44 90 28 00 00 00 	movl   $0x0,0x28(%eax,%edx,4)
-8010567b:	00 
-  fileclose(f);
-8010567c:	ff 75 f4             	pushl  -0xc(%ebp)
-8010567f:	e8 3c b8 ff ff       	call   80100ec0 <fileclose>
-  return 0;
-80105684:	83 c4 10             	add    $0x10,%esp
-80105687:	31 c0                	xor    %eax,%eax
-}
-80105689:	c9                   	leave  
-8010568a:	c3                   	ret    
-8010568b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010568f:	90                   	nop
-80105690:	c9                   	leave  
-    return -1;
-80105691:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80105696:	c3                   	ret    
-80105697:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010569e:	66 90                	xchg   %ax,%ax
-
-801056a0 <sys_fstat>:
-{
-801056a0:	f3 0f 1e fb          	endbr32 
-801056a4:	55                   	push   %ebp
-  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
-801056a5:	31 c0                	xor    %eax,%eax
-{
-801056a7:	89 e5                	mov    %esp,%ebp
-801056a9:	83 ec 18             	sub    $0x18,%esp
-  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
-801056ac:	8d 55 f0             	lea    -0x10(%ebp),%edx
-801056af:	e8 fc fd ff ff       	call   801054b0 <argfd.constprop.0>
-801056b4:	85 c0                	test   %eax,%eax
-801056b6:	78 30                	js     801056e8 <sys_fstat+0x48>
-801056b8:	83 ec 04             	sub    $0x4,%esp
-801056bb:	8d 45 f4             	lea    -0xc(%ebp),%eax
-801056be:	6a 14                	push   $0x14
-801056c0:	50                   	push   %eax
-801056c1:	6a 01                	push   $0x1
-801056c3:	e8 38 fb ff ff       	call   80105200 <argptr>
-801056c8:	83 c4 10             	add    $0x10,%esp
-801056cb:	85 c0                	test   %eax,%eax
-801056cd:	78 19                	js     801056e8 <sys_fstat+0x48>
-  return filestat(f, st);
-801056cf:	83 ec 08             	sub    $0x8,%esp
-801056d2:	ff 75 f4             	pushl  -0xc(%ebp)
-801056d5:	ff 75 f0             	pushl  -0x10(%ebp)
-801056d8:	e8 c3 b8 ff ff       	call   80100fa0 <filestat>
-801056dd:	83 c4 10             	add    $0x10,%esp
-}
-801056e0:	c9                   	leave  
-801056e1:	c3                   	ret    
-801056e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-801056e8:	c9                   	leave  
-    return -1;
-801056e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-801056ee:	c3                   	ret    
-801056ef:	90                   	nop
-
-801056f0 <sys_link>:
-{
-801056f0:	f3 0f 1e fb          	endbr32 
-801056f4:	55                   	push   %ebp
-801056f5:	89 e5                	mov    %esp,%ebp
-801056f7:	57                   	push   %edi
-801056f8:	56                   	push   %esi
-  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
-801056f9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
-{
-801056fc:	53                   	push   %ebx
-801056fd:	83 ec 34             	sub    $0x34,%esp
-  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
-80105700:	50                   	push   %eax
-80105701:	6a 00                	push   $0x0
-80105703:	e8 58 fb ff ff       	call   80105260 <argstr>
-80105708:	83 c4 10             	add    $0x10,%esp
-8010570b:	85 c0                	test   %eax,%eax
-8010570d:	0f 88 ff 00 00 00    	js     80105812 <sys_link+0x122>
-80105713:	83 ec 08             	sub    $0x8,%esp
-80105716:	8d 45 d0             	lea    -0x30(%ebp),%eax
-80105719:	50                   	push   %eax
-8010571a:	6a 01                	push   $0x1
-8010571c:	e8 3f fb ff ff       	call   80105260 <argstr>
-80105721:	83 c4 10             	add    $0x10,%esp
-80105724:	85 c0                	test   %eax,%eax
-80105726:	0f 88 e6 00 00 00    	js     80105812 <sys_link+0x122>
-  begin_op();
-8010572c:	e8 ff d5 ff ff       	call   80102d30 <begin_op>
-  if((ip = namei(old)) == 0){
-80105731:	83 ec 0c             	sub    $0xc,%esp
-80105734:	ff 75 d4             	pushl  -0x2c(%ebp)
-80105737:	e8 f4 c8 ff ff       	call   80102030 <namei>
-8010573c:	83 c4 10             	add    $0x10,%esp
-8010573f:	89 c3                	mov    %eax,%ebx
-80105741:	85 c0                	test   %eax,%eax
-80105743:	0f 84 e8 00 00 00    	je     80105831 <sys_link+0x141>
-  ilock(ip);
-80105749:	83 ec 0c             	sub    $0xc,%esp
-8010574c:	50                   	push   %eax
-8010574d:	e8 0e c0 ff ff       	call   80101760 <ilock>
-  if(ip->type == T_DIR){
-80105752:	83 c4 10             	add    $0x10,%esp
-80105755:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
-8010575a:	0f 84 b9 00 00 00    	je     80105819 <sys_link+0x129>
-  iupdate(ip);
-80105760:	83 ec 0c             	sub    $0xc,%esp
-  ip->nlink++;
-80105763:	66 83 43 56 01       	addw   $0x1,0x56(%ebx)
-  if((dp = nameiparent(new, name)) == 0)
-80105768:	8d 7d da             	lea    -0x26(%ebp),%edi
-  iupdate(ip);
-8010576b:	53                   	push   %ebx
-8010576c:	e8 2f bf ff ff       	call   801016a0 <iupdate>
-  iunlock(ip);
-80105771:	89 1c 24             	mov    %ebx,(%esp)
-80105774:	e8 c7 c0 ff ff       	call   80101840 <iunlock>
-  if((dp = nameiparent(new, name)) == 0)
-80105779:	58                   	pop    %eax
-8010577a:	5a                   	pop    %edx
-8010577b:	57                   	push   %edi
-8010577c:	ff 75 d0             	pushl  -0x30(%ebp)
-8010577f:	e8 cc c8 ff ff       	call   80102050 <nameiparent>
-80105784:	83 c4 10             	add    $0x10,%esp
-80105787:	89 c6                	mov    %eax,%esi
-80105789:	85 c0                	test   %eax,%eax
-8010578b:	74 5f                	je     801057ec <sys_link+0xfc>
-  ilock(dp);
-8010578d:	83 ec 0c             	sub    $0xc,%esp
-80105790:	50                   	push   %eax
-80105791:	e8 ca bf ff ff       	call   80101760 <ilock>
-  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
-80105796:	8b 03                	mov    (%ebx),%eax
-80105798:	83 c4 10             	add    $0x10,%esp
-8010579b:	39 06                	cmp    %eax,(%esi)
-8010579d:	75 41                	jne    801057e0 <sys_link+0xf0>
-8010579f:	83 ec 04             	sub    $0x4,%esp
-801057a2:	ff 73 04             	pushl  0x4(%ebx)
-801057a5:	57                   	push   %edi
-801057a6:	56                   	push   %esi
-801057a7:	e8 c4 c7 ff ff       	call   80101f70 <dirlink>
-801057ac:	83 c4 10             	add    $0x10,%esp
-801057af:	85 c0                	test   %eax,%eax
-801057b1:	78 2d                	js     801057e0 <sys_link+0xf0>
-  iunlockput(dp);
-801057b3:	83 ec 0c             	sub    $0xc,%esp
-801057b6:	56                   	push   %esi
-801057b7:	e8 44 c2 ff ff       	call   80101a00 <iunlockput>
-  iput(ip);
-801057bc:	89 1c 24             	mov    %ebx,(%esp)
-801057bf:	e8 cc c0 ff ff       	call   80101890 <iput>
-  end_op();
-801057c4:	e8 d7 d5 ff ff       	call   80102da0 <end_op>
-  return 0;
-801057c9:	83 c4 10             	add    $0x10,%esp
-801057cc:	31 c0                	xor    %eax,%eax
-}
-801057ce:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801057d1:	5b                   	pop    %ebx
-801057d2:	5e                   	pop    %esi
-801057d3:	5f                   	pop    %edi
-801057d4:	5d                   	pop    %ebp
-801057d5:	c3                   	ret    
-801057d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801057dd:	8d 76 00             	lea    0x0(%esi),%esi
-    iunlockput(dp);
-801057e0:	83 ec 0c             	sub    $0xc,%esp
-801057e3:	56                   	push   %esi
-801057e4:	e8 17 c2 ff ff       	call   80101a00 <iunlockput>
-    goto bad;
-801057e9:	83 c4 10             	add    $0x10,%esp
-  ilock(ip);
-801057ec:	83 ec 0c             	sub    $0xc,%esp
-801057ef:	53                   	push   %ebx
-801057f0:	e8 6b bf ff ff       	call   80101760 <ilock>
-  ip->nlink--;
-801057f5:	66 83 6b 56 01       	subw   $0x1,0x56(%ebx)
-  iupdate(ip);
-801057fa:	89 1c 24             	mov    %ebx,(%esp)
-801057fd:	e8 9e be ff ff       	call   801016a0 <iupdate>
-  iunlockput(ip);
-80105802:	89 1c 24             	mov    %ebx,(%esp)
-80105805:	e8 f6 c1 ff ff       	call   80101a00 <iunlockput>
-  end_op();
-8010580a:	e8 91 d5 ff ff       	call   80102da0 <end_op>
-  return -1;
-8010580f:	83 c4 10             	add    $0x10,%esp
-80105812:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80105817:	eb b5                	jmp    801057ce <sys_link+0xde>
-    iunlockput(ip);
-80105819:	83 ec 0c             	sub    $0xc,%esp
-8010581c:	53                   	push   %ebx
-8010581d:	e8 de c1 ff ff       	call   80101a00 <iunlockput>
-    end_op();
-80105822:	e8 79 d5 ff ff       	call   80102da0 <end_op>
-    return -1;
-80105827:	83 c4 10             	add    $0x10,%esp
-8010582a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-8010582f:	eb 9d                	jmp    801057ce <sys_link+0xde>
-    end_op();
-80105831:	e8 6a d5 ff ff       	call   80102da0 <end_op>
-    return -1;
-80105836:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-8010583b:	eb 91                	jmp    801057ce <sys_link+0xde>
-8010583d:	8d 76 00             	lea    0x0(%esi),%esi
-
-80105840 <sys_unlink>:
-{
-80105840:	f3 0f 1e fb          	endbr32 
-80105844:	55                   	push   %ebp
-80105845:	89 e5                	mov    %esp,%ebp
-80105847:	57                   	push   %edi
-80105848:	56                   	push   %esi
-  if(argstr(0, &path) < 0)
-80105849:	8d 45 c0             	lea    -0x40(%ebp),%eax
-{
-8010584c:	53                   	push   %ebx
-8010584d:	83 ec 54             	sub    $0x54,%esp
-  if(argstr(0, &path) < 0)
-80105850:	50                   	push   %eax
-80105851:	6a 00                	push   $0x0
-80105853:	e8 08 fa ff ff       	call   80105260 <argstr>
-80105858:	83 c4 10             	add    $0x10,%esp
-8010585b:	85 c0                	test   %eax,%eax
-8010585d:	0f 88 7d 01 00 00    	js     801059e0 <sys_unlink+0x1a0>
-  begin_op();
-80105863:	e8 c8 d4 ff ff       	call   80102d30 <begin_op>
-  if((dp = nameiparent(path, name)) == 0){
-80105868:	8d 5d ca             	lea    -0x36(%ebp),%ebx
-8010586b:	83 ec 08             	sub    $0x8,%esp
-8010586e:	53                   	push   %ebx
-8010586f:	ff 75 c0             	pushl  -0x40(%ebp)
-80105872:	e8 d9 c7 ff ff       	call   80102050 <nameiparent>
-80105877:	83 c4 10             	add    $0x10,%esp
-8010587a:	89 c6                	mov    %eax,%esi
-8010587c:	85 c0                	test   %eax,%eax
-8010587e:	0f 84 66 01 00 00    	je     801059ea <sys_unlink+0x1aa>
-  ilock(dp);
-80105884:	83 ec 0c             	sub    $0xc,%esp
-80105887:	50                   	push   %eax
-80105888:	e8 d3 be ff ff       	call   80101760 <ilock>
-  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
-8010588d:	58                   	pop    %eax
-8010588e:	5a                   	pop    %edx
-8010588f:	68 e0 83 10 80       	push   $0x801083e0
-80105894:	53                   	push   %ebx
-80105895:	e8 f6 c3 ff ff       	call   80101c90 <namecmp>
-8010589a:	83 c4 10             	add    $0x10,%esp
-8010589d:	85 c0                	test   %eax,%eax
-8010589f:	0f 84 03 01 00 00    	je     801059a8 <sys_unlink+0x168>
-801058a5:	83 ec 08             	sub    $0x8,%esp
-801058a8:	68 df 83 10 80       	push   $0x801083df
-801058ad:	53                   	push   %ebx
-801058ae:	e8 dd c3 ff ff       	call   80101c90 <namecmp>
-801058b3:	83 c4 10             	add    $0x10,%esp
-801058b6:	85 c0                	test   %eax,%eax
-801058b8:	0f 84 ea 00 00 00    	je     801059a8 <sys_unlink+0x168>
-  if((ip = dirlookup(dp, name, &off)) == 0)
-801058be:	83 ec 04             	sub    $0x4,%esp
-801058c1:	8d 45 c4             	lea    -0x3c(%ebp),%eax
-801058c4:	50                   	push   %eax
-801058c5:	53                   	push   %ebx
-801058c6:	56                   	push   %esi
-801058c7:	e8 e4 c3 ff ff       	call   80101cb0 <dirlookup>
-801058cc:	83 c4 10             	add    $0x10,%esp
-801058cf:	89 c3                	mov    %eax,%ebx
-801058d1:	85 c0                	test   %eax,%eax
-801058d3:	0f 84 cf 00 00 00    	je     801059a8 <sys_unlink+0x168>
-  ilock(ip);
-801058d9:	83 ec 0c             	sub    $0xc,%esp
-801058dc:	50                   	push   %eax
-801058dd:	e8 7e be ff ff       	call   80101760 <ilock>
-  if(ip->nlink < 1)
-801058e2:	83 c4 10             	add    $0x10,%esp
-801058e5:	66 83 7b 56 00       	cmpw   $0x0,0x56(%ebx)
-801058ea:	0f 8e 23 01 00 00    	jle    80105a13 <sys_unlink+0x1d3>
-  if(ip->type == T_DIR && !isdirempty(ip)){
-801058f0:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
-801058f5:	8d 7d d8             	lea    -0x28(%ebp),%edi
-801058f8:	74 66                	je     80105960 <sys_unlink+0x120>
-  memset(&de, 0, sizeof(de));
-801058fa:	83 ec 04             	sub    $0x4,%esp
-801058fd:	6a 10                	push   $0x10
-801058ff:	6a 00                	push   $0x0
-80105901:	57                   	push   %edi
-80105902:	e8 c9 f5 ff ff       	call   80104ed0 <memset>
-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-80105907:	6a 10                	push   $0x10
-80105909:	ff 75 c4             	pushl  -0x3c(%ebp)
-8010590c:	57                   	push   %edi
-8010590d:	56                   	push   %esi
-8010590e:	e8 4d c2 ff ff       	call   80101b60 <writei>
-80105913:	83 c4 20             	add    $0x20,%esp
-80105916:	83 f8 10             	cmp    $0x10,%eax
-80105919:	0f 85 e7 00 00 00    	jne    80105a06 <sys_unlink+0x1c6>
-  if(ip->type == T_DIR){
-8010591f:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
-80105924:	0f 84 96 00 00 00    	je     801059c0 <sys_unlink+0x180>
-  iunlockput(dp);
-8010592a:	83 ec 0c             	sub    $0xc,%esp
-8010592d:	56                   	push   %esi
-8010592e:	e8 cd c0 ff ff       	call   80101a00 <iunlockput>
-  ip->nlink--;
-80105933:	66 83 6b 56 01       	subw   $0x1,0x56(%ebx)
-  iupdate(ip);
-80105938:	89 1c 24             	mov    %ebx,(%esp)
-8010593b:	e8 60 bd ff ff       	call   801016a0 <iupdate>
-  iunlockput(ip);
-80105940:	89 1c 24             	mov    %ebx,(%esp)
-80105943:	e8 b8 c0 ff ff       	call   80101a00 <iunlockput>
-  end_op();
-80105948:	e8 53 d4 ff ff       	call   80102da0 <end_op>
-  return 0;
-8010594d:	83 c4 10             	add    $0x10,%esp
-80105950:	31 c0                	xor    %eax,%eax
-}
-80105952:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80105955:	5b                   	pop    %ebx
-80105956:	5e                   	pop    %esi
-80105957:	5f                   	pop    %edi
-80105958:	5d                   	pop    %ebp
-80105959:	c3                   	ret    
-8010595a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
-80105960:	83 7b 58 20          	cmpl   $0x20,0x58(%ebx)
-80105964:	76 94                	jbe    801058fa <sys_unlink+0xba>
-80105966:	ba 20 00 00 00       	mov    $0x20,%edx
-8010596b:	eb 0b                	jmp    80105978 <sys_unlink+0x138>
-8010596d:	8d 76 00             	lea    0x0(%esi),%esi
-80105970:	83 c2 10             	add    $0x10,%edx
-80105973:	39 53 58             	cmp    %edx,0x58(%ebx)
-80105976:	76 82                	jbe    801058fa <sys_unlink+0xba>
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-80105978:	6a 10                	push   $0x10
-8010597a:	52                   	push   %edx
-8010597b:	57                   	push   %edi
-8010597c:	53                   	push   %ebx
-8010597d:	89 55 b4             	mov    %edx,-0x4c(%ebp)
-80105980:	e8 db c0 ff ff       	call   80101a60 <readi>
-80105985:	83 c4 10             	add    $0x10,%esp
-80105988:	8b 55 b4             	mov    -0x4c(%ebp),%edx
-8010598b:	83 f8 10             	cmp    $0x10,%eax
-8010598e:	75 69                	jne    801059f9 <sys_unlink+0x1b9>
-    if(de.inum != 0)
-80105990:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
-80105995:	74 d9                	je     80105970 <sys_unlink+0x130>
-    iunlockput(ip);
-80105997:	83 ec 0c             	sub    $0xc,%esp
-8010599a:	53                   	push   %ebx
-8010599b:	e8 60 c0 ff ff       	call   80101a00 <iunlockput>
-    goto bad;
-801059a0:	83 c4 10             	add    $0x10,%esp
-801059a3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801059a7:	90                   	nop
-  iunlockput(dp);
-801059a8:	83 ec 0c             	sub    $0xc,%esp
-801059ab:	56                   	push   %esi
-801059ac:	e8 4f c0 ff ff       	call   80101a00 <iunlockput>
-  end_op();
-801059b1:	e8 ea d3 ff ff       	call   80102da0 <end_op>
-  return -1;
-801059b6:	83 c4 10             	add    $0x10,%esp
-801059b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-801059be:	eb 92                	jmp    80105952 <sys_unlink+0x112>
-    iupdate(dp);
-801059c0:	83 ec 0c             	sub    $0xc,%esp
-    dp->nlink--;
-801059c3:	66 83 6e 56 01       	subw   $0x1,0x56(%esi)
-    iupdate(dp);
-801059c8:	56                   	push   %esi
-801059c9:	e8 d2 bc ff ff       	call   801016a0 <iupdate>
-801059ce:	83 c4 10             	add    $0x10,%esp
-801059d1:	e9 54 ff ff ff       	jmp    8010592a <sys_unlink+0xea>
-801059d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801059dd:	8d 76 00             	lea    0x0(%esi),%esi
-    return -1;
-801059e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-801059e5:	e9 68 ff ff ff       	jmp    80105952 <sys_unlink+0x112>
-    end_op();
-801059ea:	e8 b1 d3 ff ff       	call   80102da0 <end_op>
-    return -1;
-801059ef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-801059f4:	e9 59 ff ff ff       	jmp    80105952 <sys_unlink+0x112>
-      panic("isdirempty: readi");
-801059f9:	83 ec 0c             	sub    $0xc,%esp
-801059fc:	68 04 84 10 80       	push   $0x80108404
-80105a01:	e8 8a a9 ff ff       	call   80100390 <panic>
-    panic("unlink: writei");
-80105a06:	83 ec 0c             	sub    $0xc,%esp
-80105a09:	68 16 84 10 80       	push   $0x80108416
-80105a0e:	e8 7d a9 ff ff       	call   80100390 <panic>
-    panic("unlink: nlink < 1");
-80105a13:	83 ec 0c             	sub    $0xc,%esp
-80105a16:	68 f2 83 10 80       	push   $0x801083f2
-80105a1b:	e8 70 a9 ff ff       	call   80100390 <panic>
-
-80105a20 <sys_open>:
-
-int
-sys_open(void)
-{
-80105a20:	f3 0f 1e fb          	endbr32 
-80105a24:	55                   	push   %ebp
-80105a25:	89 e5                	mov    %esp,%ebp
-80105a27:	57                   	push   %edi
-80105a28:	56                   	push   %esi
-  char *path;
-  int fd, omode;
-  struct file *f;
-  struct inode *ip;
-
-  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
-80105a29:	8d 45 e0             	lea    -0x20(%ebp),%eax
-{
-80105a2c:	53                   	push   %ebx
-80105a2d:	83 ec 24             	sub    $0x24,%esp
-  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
-80105a30:	50                   	push   %eax
-80105a31:	6a 00                	push   $0x0
-80105a33:	e8 28 f8 ff ff       	call   80105260 <argstr>
-80105a38:	83 c4 10             	add    $0x10,%esp
-80105a3b:	85 c0                	test   %eax,%eax
-80105a3d:	0f 88 8a 00 00 00    	js     80105acd <sys_open+0xad>
-80105a43:	83 ec 08             	sub    $0x8,%esp
-80105a46:	8d 45 e4             	lea    -0x1c(%ebp),%eax
-80105a49:	50                   	push   %eax
-80105a4a:	6a 01                	push   $0x1
-80105a4c:	e8 5f f7 ff ff       	call   801051b0 <argint>
-80105a51:	83 c4 10             	add    $0x10,%esp
-80105a54:	85 c0                	test   %eax,%eax
-80105a56:	78 75                	js     80105acd <sys_open+0xad>
-    return -1;
-
-  begin_op();
-80105a58:	e8 d3 d2 ff ff       	call   80102d30 <begin_op>
-
-  if(omode & O_CREATE){
-80105a5d:	f6 45 e5 02          	testb  $0x2,-0x1b(%ebp)
-80105a61:	75 75                	jne    80105ad8 <sys_open+0xb8>
-    if(ip == 0){
-      end_op();
-      return -1;
-    }
-  } else {
-    if((ip = namei(path)) == 0){
-80105a63:	83 ec 0c             	sub    $0xc,%esp
-80105a66:	ff 75 e0             	pushl  -0x20(%ebp)
-80105a69:	e8 c2 c5 ff ff       	call   80102030 <namei>
-80105a6e:	83 c4 10             	add    $0x10,%esp
-80105a71:	89 c6                	mov    %eax,%esi
-80105a73:	85 c0                	test   %eax,%eax
-80105a75:	74 7e                	je     80105af5 <sys_open+0xd5>
-      end_op();
-      return -1;
-    }
-    ilock(ip);
-80105a77:	83 ec 0c             	sub    $0xc,%esp
-80105a7a:	50                   	push   %eax
-80105a7b:	e8 e0 bc ff ff       	call   80101760 <ilock>
-    if(ip->type == T_DIR && omode != O_RDONLY){
-80105a80:	83 c4 10             	add    $0x10,%esp
-80105a83:	66 83 7e 50 01       	cmpw   $0x1,0x50(%esi)
-80105a88:	0f 84 c2 00 00 00    	je     80105b50 <sys_open+0x130>
-      end_op();
-      return -1;
-    }
-  }
-
-  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
-80105a8e:	e8 6d b3 ff ff       	call   80100e00 <filealloc>
-80105a93:	89 c7                	mov    %eax,%edi
-80105a95:	85 c0                	test   %eax,%eax
-80105a97:	74 23                	je     80105abc <sys_open+0x9c>
-  struct proc *curproc = myproc();
-80105a99:	e8 12 df ff ff       	call   801039b0 <myproc>
-  for(fd = 0; fd < NOFILE; fd++){
-80105a9e:	31 db                	xor    %ebx,%ebx
-    if(curproc->ofile[fd] == 0){
-80105aa0:	8b 54 98 28          	mov    0x28(%eax,%ebx,4),%edx
-80105aa4:	85 d2                	test   %edx,%edx
-80105aa6:	74 60                	je     80105b08 <sys_open+0xe8>
-  for(fd = 0; fd < NOFILE; fd++){
-80105aa8:	83 c3 01             	add    $0x1,%ebx
-80105aab:	83 fb 10             	cmp    $0x10,%ebx
-80105aae:	75 f0                	jne    80105aa0 <sys_open+0x80>
-    if(f)
-      fileclose(f);
-80105ab0:	83 ec 0c             	sub    $0xc,%esp
-80105ab3:	57                   	push   %edi
-80105ab4:	e8 07 b4 ff ff       	call   80100ec0 <fileclose>
-80105ab9:	83 c4 10             	add    $0x10,%esp
-    iunlockput(ip);
-80105abc:	83 ec 0c             	sub    $0xc,%esp
-80105abf:	56                   	push   %esi
-80105ac0:	e8 3b bf ff ff       	call   80101a00 <iunlockput>
-    end_op();
-80105ac5:	e8 d6 d2 ff ff       	call   80102da0 <end_op>
-    return -1;
-80105aca:	83 c4 10             	add    $0x10,%esp
-80105acd:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
-80105ad2:	eb 6d                	jmp    80105b41 <sys_open+0x121>
-80105ad4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    ip = create(path, T_FILE, 0, 0);
-80105ad8:	83 ec 0c             	sub    $0xc,%esp
-80105adb:	8b 45 e0             	mov    -0x20(%ebp),%eax
-80105ade:	31 c9                	xor    %ecx,%ecx
-80105ae0:	ba 02 00 00 00       	mov    $0x2,%edx
-80105ae5:	6a 00                	push   $0x0
-80105ae7:	e8 24 f8 ff ff       	call   80105310 <create>
-    if(ip == 0){
-80105aec:	83 c4 10             	add    $0x10,%esp
-    ip = create(path, T_FILE, 0, 0);
-80105aef:	89 c6                	mov    %eax,%esi
-    if(ip == 0){
-80105af1:	85 c0                	test   %eax,%eax
-80105af3:	75 99                	jne    80105a8e <sys_open+0x6e>
-      end_op();
-80105af5:	e8 a6 d2 ff ff       	call   80102da0 <end_op>
-      return -1;
-80105afa:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
-80105aff:	eb 40                	jmp    80105b41 <sys_open+0x121>
-80105b01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  }
-  iunlock(ip);
-80105b08:	83 ec 0c             	sub    $0xc,%esp
-      curproc->ofile[fd] = f;
-80105b0b:	89 7c 98 28          	mov    %edi,0x28(%eax,%ebx,4)
-  iunlock(ip);
-80105b0f:	56                   	push   %esi
-80105b10:	e8 2b bd ff ff       	call   80101840 <iunlock>
-  end_op();
-80105b15:	e8 86 d2 ff ff       	call   80102da0 <end_op>
-
-  f->type = FD_INODE;
-80105b1a:	c7 07 02 00 00 00    	movl   $0x2,(%edi)
-  f->ip = ip;
-  f->off = 0;
-  f->readable = !(omode & O_WRONLY);
-80105b20:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
-80105b23:	83 c4 10             	add    $0x10,%esp
-  f->ip = ip;
-80105b26:	89 77 10             	mov    %esi,0x10(%edi)
-  f->readable = !(omode & O_WRONLY);
-80105b29:	89 d0                	mov    %edx,%eax
-  f->off = 0;
-80105b2b:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
-  f->readable = !(omode & O_WRONLY);
-80105b32:	f7 d0                	not    %eax
-80105b34:	83 e0 01             	and    $0x1,%eax
-  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
-80105b37:	83 e2 03             	and    $0x3,%edx
-  f->readable = !(omode & O_WRONLY);
-80105b3a:	88 47 08             	mov    %al,0x8(%edi)
-  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
-80105b3d:	0f 95 47 09          	setne  0x9(%edi)
-  return fd;
-}
-80105b41:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80105b44:	89 d8                	mov    %ebx,%eax
-80105b46:	5b                   	pop    %ebx
-80105b47:	5e                   	pop    %esi
-80105b48:	5f                   	pop    %edi
-80105b49:	5d                   	pop    %ebp
-80105b4a:	c3                   	ret    
-80105b4b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80105b4f:	90                   	nop
-    if(ip->type == T_DIR && omode != O_RDONLY){
-80105b50:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
-80105b53:	85 c9                	test   %ecx,%ecx
-80105b55:	0f 84 33 ff ff ff    	je     80105a8e <sys_open+0x6e>
-80105b5b:	e9 5c ff ff ff       	jmp    80105abc <sys_open+0x9c>
-
-80105b60 <sys_mkdir>:
-
-int
-sys_mkdir(void)
-{
-80105b60:	f3 0f 1e fb          	endbr32 
-80105b64:	55                   	push   %ebp
-80105b65:	89 e5                	mov    %esp,%ebp
-80105b67:	83 ec 18             	sub    $0x18,%esp
-  char *path;
-  struct inode *ip;
-
-  begin_op();
-80105b6a:	e8 c1 d1 ff ff       	call   80102d30 <begin_op>
-  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
-80105b6f:	83 ec 08             	sub    $0x8,%esp
-80105b72:	8d 45 f4             	lea    -0xc(%ebp),%eax
-80105b75:	50                   	push   %eax
-80105b76:	6a 00                	push   $0x0
-80105b78:	e8 e3 f6 ff ff       	call   80105260 <argstr>
-80105b7d:	83 c4 10             	add    $0x10,%esp
-80105b80:	85 c0                	test   %eax,%eax
-80105b82:	78 34                	js     80105bb8 <sys_mkdir+0x58>
-80105b84:	83 ec 0c             	sub    $0xc,%esp
-80105b87:	8b 45 f4             	mov    -0xc(%ebp),%eax
-80105b8a:	31 c9                	xor    %ecx,%ecx
-80105b8c:	ba 01 00 00 00       	mov    $0x1,%edx
-80105b91:	6a 00                	push   $0x0
-80105b93:	e8 78 f7 ff ff       	call   80105310 <create>
-80105b98:	83 c4 10             	add    $0x10,%esp
-80105b9b:	85 c0                	test   %eax,%eax
-80105b9d:	74 19                	je     80105bb8 <sys_mkdir+0x58>
-    end_op();
-    return -1;
-  }
-  iunlockput(ip);
-80105b9f:	83 ec 0c             	sub    $0xc,%esp
-80105ba2:	50                   	push   %eax
-80105ba3:	e8 58 be ff ff       	call   80101a00 <iunlockput>
-  end_op();
-80105ba8:	e8 f3 d1 ff ff       	call   80102da0 <end_op>
-  return 0;
-80105bad:	83 c4 10             	add    $0x10,%esp
-80105bb0:	31 c0                	xor    %eax,%eax
-}
-80105bb2:	c9                   	leave  
-80105bb3:	c3                   	ret    
-80105bb4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    end_op();
-80105bb8:	e8 e3 d1 ff ff       	call   80102da0 <end_op>
-    return -1;
-80105bbd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80105bc2:	c9                   	leave  
-80105bc3:	c3                   	ret    
-80105bc4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80105bcb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80105bcf:	90                   	nop
-
-80105bd0 <sys_mknod>:
-
-int
-sys_mknod(void)
-{
-80105bd0:	f3 0f 1e fb          	endbr32 
-80105bd4:	55                   	push   %ebp
-80105bd5:	89 e5                	mov    %esp,%ebp
-80105bd7:	83 ec 18             	sub    $0x18,%esp
-  struct inode *ip;
-  char *path;
-  int major, minor;
-
-  begin_op();
-80105bda:	e8 51 d1 ff ff       	call   80102d30 <begin_op>
-  if((argstr(0, &path)) < 0 ||
-80105bdf:	83 ec 08             	sub    $0x8,%esp
-80105be2:	8d 45 ec             	lea    -0x14(%ebp),%eax
-80105be5:	50                   	push   %eax
-80105be6:	6a 00                	push   $0x0
-80105be8:	e8 73 f6 ff ff       	call   80105260 <argstr>
-80105bed:	83 c4 10             	add    $0x10,%esp
-80105bf0:	85 c0                	test   %eax,%eax
-80105bf2:	78 64                	js     80105c58 <sys_mknod+0x88>
-     argint(1, &major) < 0 ||
-80105bf4:	83 ec 08             	sub    $0x8,%esp
-80105bf7:	8d 45 f0             	lea    -0x10(%ebp),%eax
-80105bfa:	50                   	push   %eax
-80105bfb:	6a 01                	push   $0x1
-80105bfd:	e8 ae f5 ff ff       	call   801051b0 <argint>
-  if((argstr(0, &path)) < 0 ||
-80105c02:	83 c4 10             	add    $0x10,%esp
-80105c05:	85 c0                	test   %eax,%eax
-80105c07:	78 4f                	js     80105c58 <sys_mknod+0x88>
-     argint(2, &minor) < 0 ||
-80105c09:	83 ec 08             	sub    $0x8,%esp
-80105c0c:	8d 45 f4             	lea    -0xc(%ebp),%eax
-80105c0f:	50                   	push   %eax
-80105c10:	6a 02                	push   $0x2
-80105c12:	e8 99 f5 ff ff       	call   801051b0 <argint>
-     argint(1, &major) < 0 ||
-80105c17:	83 c4 10             	add    $0x10,%esp
-80105c1a:	85 c0                	test   %eax,%eax
-80105c1c:	78 3a                	js     80105c58 <sys_mknod+0x88>
-     (ip = create(path, T_DEV, major, minor)) == 0){
-80105c1e:	0f bf 45 f4          	movswl -0xc(%ebp),%eax
-80105c22:	83 ec 0c             	sub    $0xc,%esp
-80105c25:	0f bf 4d f0          	movswl -0x10(%ebp),%ecx
-80105c29:	ba 03 00 00 00       	mov    $0x3,%edx
-80105c2e:	50                   	push   %eax
-80105c2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
-80105c32:	e8 d9 f6 ff ff       	call   80105310 <create>
-     argint(2, &minor) < 0 ||
-80105c37:	83 c4 10             	add    $0x10,%esp
-80105c3a:	85 c0                	test   %eax,%eax
-80105c3c:	74 1a                	je     80105c58 <sys_mknod+0x88>
-    end_op();
-    return -1;
-  }
-  iunlockput(ip);
-80105c3e:	83 ec 0c             	sub    $0xc,%esp
-80105c41:	50                   	push   %eax
-80105c42:	e8 b9 bd ff ff       	call   80101a00 <iunlockput>
-  end_op();
-80105c47:	e8 54 d1 ff ff       	call   80102da0 <end_op>
-  return 0;
-80105c4c:	83 c4 10             	add    $0x10,%esp
-80105c4f:	31 c0                	xor    %eax,%eax
-}
-80105c51:	c9                   	leave  
-80105c52:	c3                   	ret    
-80105c53:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80105c57:	90                   	nop
-    end_op();
-80105c58:	e8 43 d1 ff ff       	call   80102da0 <end_op>
-    return -1;
-80105c5d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80105c62:	c9                   	leave  
-80105c63:	c3                   	ret    
-80105c64:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80105c6b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80105c6f:	90                   	nop
-
-80105c70 <sys_chdir>:
-
-int
-sys_chdir(void)
-{
-80105c70:	f3 0f 1e fb          	endbr32 
-80105c74:	55                   	push   %ebp
-80105c75:	89 e5                	mov    %esp,%ebp
-80105c77:	56                   	push   %esi
-80105c78:	53                   	push   %ebx
-80105c79:	83 ec 10             	sub    $0x10,%esp
-  char *path;
-  struct inode *ip;
-  struct proc *curproc = myproc();
-80105c7c:	e8 2f dd ff ff       	call   801039b0 <myproc>
-80105c81:	89 c6                	mov    %eax,%esi
-  
-  begin_op();
-80105c83:	e8 a8 d0 ff ff       	call   80102d30 <begin_op>
-  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
-80105c88:	83 ec 08             	sub    $0x8,%esp
-80105c8b:	8d 45 f4             	lea    -0xc(%ebp),%eax
-80105c8e:	50                   	push   %eax
-80105c8f:	6a 00                	push   $0x0
-80105c91:	e8 ca f5 ff ff       	call   80105260 <argstr>
-80105c96:	83 c4 10             	add    $0x10,%esp
-80105c99:	85 c0                	test   %eax,%eax
-80105c9b:	78 73                	js     80105d10 <sys_chdir+0xa0>
-80105c9d:	83 ec 0c             	sub    $0xc,%esp
-80105ca0:	ff 75 f4             	pushl  -0xc(%ebp)
-80105ca3:	e8 88 c3 ff ff       	call   80102030 <namei>
-80105ca8:	83 c4 10             	add    $0x10,%esp
-80105cab:	89 c3                	mov    %eax,%ebx
-80105cad:	85 c0                	test   %eax,%eax
-80105caf:	74 5f                	je     80105d10 <sys_chdir+0xa0>
-    end_op();
-    return -1;
-  }
-  ilock(ip);
-80105cb1:	83 ec 0c             	sub    $0xc,%esp
-80105cb4:	50                   	push   %eax
-80105cb5:	e8 a6 ba ff ff       	call   80101760 <ilock>
-  if(ip->type != T_DIR){
-80105cba:	83 c4 10             	add    $0x10,%esp
-80105cbd:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
-80105cc2:	75 2c                	jne    80105cf0 <sys_chdir+0x80>
-    iunlockput(ip);
-    end_op();
-    return -1;
-  }
-  iunlock(ip);
-80105cc4:	83 ec 0c             	sub    $0xc,%esp
-80105cc7:	53                   	push   %ebx
-80105cc8:	e8 73 bb ff ff       	call   80101840 <iunlock>
-  iput(curproc->cwd);
-80105ccd:	58                   	pop    %eax
-80105cce:	ff 76 68             	pushl  0x68(%esi)
-80105cd1:	e8 ba bb ff ff       	call   80101890 <iput>
-  end_op();
-80105cd6:	e8 c5 d0 ff ff       	call   80102da0 <end_op>
-  curproc->cwd = ip;
-80105cdb:	89 5e 68             	mov    %ebx,0x68(%esi)
-  return 0;
-80105cde:	83 c4 10             	add    $0x10,%esp
-80105ce1:	31 c0                	xor    %eax,%eax
-}
-80105ce3:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80105ce6:	5b                   	pop    %ebx
-80105ce7:	5e                   	pop    %esi
-80105ce8:	5d                   	pop    %ebp
-80105ce9:	c3                   	ret    
-80105cea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    iunlockput(ip);
-80105cf0:	83 ec 0c             	sub    $0xc,%esp
-80105cf3:	53                   	push   %ebx
-80105cf4:	e8 07 bd ff ff       	call   80101a00 <iunlockput>
-    end_op();
-80105cf9:	e8 a2 d0 ff ff       	call   80102da0 <end_op>
-    return -1;
-80105cfe:	83 c4 10             	add    $0x10,%esp
-80105d01:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80105d06:	eb db                	jmp    80105ce3 <sys_chdir+0x73>
-80105d08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80105d0f:	90                   	nop
-    end_op();
-80105d10:	e8 8b d0 ff ff       	call   80102da0 <end_op>
-    return -1;
-80105d15:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80105d1a:	eb c7                	jmp    80105ce3 <sys_chdir+0x73>
-80105d1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-80105d20 <sys_exec>:
-
-int
-sys_exec(void)
-{
-80105d20:	f3 0f 1e fb          	endbr32 
-80105d24:	55                   	push   %ebp
-80105d25:	89 e5                	mov    %esp,%ebp
-80105d27:	57                   	push   %edi
-80105d28:	56                   	push   %esi
-  char *path, *argv[MAXARG];
-  int i;
-  uint uargv, uarg;
-
-  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
-80105d29:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
-{
-80105d2f:	53                   	push   %ebx
-80105d30:	81 ec a4 00 00 00    	sub    $0xa4,%esp
-  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
-80105d36:	50                   	push   %eax
-80105d37:	6a 00                	push   $0x0
-80105d39:	e8 22 f5 ff ff       	call   80105260 <argstr>
-80105d3e:	83 c4 10             	add    $0x10,%esp
-80105d41:	85 c0                	test   %eax,%eax
-80105d43:	0f 88 8b 00 00 00    	js     80105dd4 <sys_exec+0xb4>
-80105d49:	83 ec 08             	sub    $0x8,%esp
-80105d4c:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
-80105d52:	50                   	push   %eax
-80105d53:	6a 01                	push   $0x1
-80105d55:	e8 56 f4 ff ff       	call   801051b0 <argint>
-80105d5a:	83 c4 10             	add    $0x10,%esp
-80105d5d:	85 c0                	test   %eax,%eax
-80105d5f:	78 73                	js     80105dd4 <sys_exec+0xb4>
-    return -1;
-  }
-  memset(argv, 0, sizeof(argv));
-80105d61:	83 ec 04             	sub    $0x4,%esp
-80105d64:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
-  for(i=0;; i++){
-80105d6a:	31 db                	xor    %ebx,%ebx
-  memset(argv, 0, sizeof(argv));
-80105d6c:	68 80 00 00 00       	push   $0x80
-80105d71:	8d bd 64 ff ff ff    	lea    -0x9c(%ebp),%edi
-80105d77:	6a 00                	push   $0x0
-80105d79:	50                   	push   %eax
-80105d7a:	e8 51 f1 ff ff       	call   80104ed0 <memset>
-80105d7f:	83 c4 10             	add    $0x10,%esp
-80105d82:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    if(i >= NELEM(argv))
-      return -1;
-    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
-80105d88:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
-80105d8e:	8d 34 9d 00 00 00 00 	lea    0x0(,%ebx,4),%esi
-80105d95:	83 ec 08             	sub    $0x8,%esp
-80105d98:	57                   	push   %edi
-80105d99:	01 f0                	add    %esi,%eax
-80105d9b:	50                   	push   %eax
-80105d9c:	e8 6f f3 ff ff       	call   80105110 <fetchint>
-80105da1:	83 c4 10             	add    $0x10,%esp
-80105da4:	85 c0                	test   %eax,%eax
-80105da6:	78 2c                	js     80105dd4 <sys_exec+0xb4>
-      return -1;
-    if(uarg == 0){
-80105da8:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
-80105dae:	85 c0                	test   %eax,%eax
-80105db0:	74 36                	je     80105de8 <sys_exec+0xc8>
-      argv[i] = 0;
-      break;
-    }
-    if(fetchstr(uarg, &argv[i]) < 0)
-80105db2:	8d 8d 68 ff ff ff    	lea    -0x98(%ebp),%ecx
-80105db8:	83 ec 08             	sub    $0x8,%esp
-80105dbb:	8d 14 31             	lea    (%ecx,%esi,1),%edx
-80105dbe:	52                   	push   %edx
-80105dbf:	50                   	push   %eax
-80105dc0:	e8 8b f3 ff ff       	call   80105150 <fetchstr>
-80105dc5:	83 c4 10             	add    $0x10,%esp
-80105dc8:	85 c0                	test   %eax,%eax
-80105dca:	78 08                	js     80105dd4 <sys_exec+0xb4>
-  for(i=0;; i++){
-80105dcc:	83 c3 01             	add    $0x1,%ebx
-    if(i >= NELEM(argv))
-80105dcf:	83 fb 20             	cmp    $0x20,%ebx
-80105dd2:	75 b4                	jne    80105d88 <sys_exec+0x68>
-      return -1;
-  }
-  return exec(path, argv);
-}
-80105dd4:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    return -1;
-80105dd7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80105ddc:	5b                   	pop    %ebx
-80105ddd:	5e                   	pop    %esi
-80105dde:	5f                   	pop    %edi
-80105ddf:	5d                   	pop    %ebp
-80105de0:	c3                   	ret    
-80105de1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return exec(path, argv);
-80105de8:	83 ec 08             	sub    $0x8,%esp
-80105deb:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
-      argv[i] = 0;
-80105df1:	c7 84 9d 68 ff ff ff 	movl   $0x0,-0x98(%ebp,%ebx,4)
-80105df8:	00 00 00 00 
-  return exec(path, argv);
-80105dfc:	50                   	push   %eax
-80105dfd:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
-80105e03:	e8 78 ac ff ff       	call   80100a80 <exec>
-80105e08:	83 c4 10             	add    $0x10,%esp
-}
-80105e0b:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80105e0e:	5b                   	pop    %ebx
-80105e0f:	5e                   	pop    %esi
-80105e10:	5f                   	pop    %edi
-80105e11:	5d                   	pop    %ebp
-80105e12:	c3                   	ret    
-80105e13:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80105e1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80105e20 <sys_pipe>:
-
-int
-sys_pipe(void)
-{
-80105e20:	f3 0f 1e fb          	endbr32 
-80105e24:	55                   	push   %ebp
-80105e25:	89 e5                	mov    %esp,%ebp
-80105e27:	57                   	push   %edi
-80105e28:	56                   	push   %esi
-  int *fd;
-  struct file *rf, *wf;
-  int fd0, fd1;
-
-  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
-80105e29:	8d 45 dc             	lea    -0x24(%ebp),%eax
-{
-80105e2c:	53                   	push   %ebx
-80105e2d:	83 ec 20             	sub    $0x20,%esp
-  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
-80105e30:	6a 08                	push   $0x8
-80105e32:	50                   	push   %eax
-80105e33:	6a 00                	push   $0x0
-80105e35:	e8 c6 f3 ff ff       	call   80105200 <argptr>
-80105e3a:	83 c4 10             	add    $0x10,%esp
-80105e3d:	85 c0                	test   %eax,%eax
-80105e3f:	78 4e                	js     80105e8f <sys_pipe+0x6f>
-    return -1;
-  if(pipealloc(&rf, &wf) < 0)
-80105e41:	83 ec 08             	sub    $0x8,%esp
-80105e44:	8d 45 e4             	lea    -0x1c(%ebp),%eax
-80105e47:	50                   	push   %eax
-80105e48:	8d 45 e0             	lea    -0x20(%ebp),%eax
-80105e4b:	50                   	push   %eax
-80105e4c:	e8 9f d5 ff ff       	call   801033f0 <pipealloc>
-80105e51:	83 c4 10             	add    $0x10,%esp
-80105e54:	85 c0                	test   %eax,%eax
-80105e56:	78 37                	js     80105e8f <sys_pipe+0x6f>
-    return -1;
-  fd0 = -1;
-  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
-80105e58:	8b 7d e0             	mov    -0x20(%ebp),%edi
-  for(fd = 0; fd < NOFILE; fd++){
-80105e5b:	31 db                	xor    %ebx,%ebx
-  struct proc *curproc = myproc();
-80105e5d:	e8 4e db ff ff       	call   801039b0 <myproc>
-  for(fd = 0; fd < NOFILE; fd++){
-80105e62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    if(curproc->ofile[fd] == 0){
-80105e68:	8b 74 98 28          	mov    0x28(%eax,%ebx,4),%esi
-80105e6c:	85 f6                	test   %esi,%esi
-80105e6e:	74 30                	je     80105ea0 <sys_pipe+0x80>
-  for(fd = 0; fd < NOFILE; fd++){
-80105e70:	83 c3 01             	add    $0x1,%ebx
-80105e73:	83 fb 10             	cmp    $0x10,%ebx
-80105e76:	75 f0                	jne    80105e68 <sys_pipe+0x48>
-    if(fd0 >= 0)
-      myproc()->ofile[fd0] = 0;
-    fileclose(rf);
-80105e78:	83 ec 0c             	sub    $0xc,%esp
-80105e7b:	ff 75 e0             	pushl  -0x20(%ebp)
-80105e7e:	e8 3d b0 ff ff       	call   80100ec0 <fileclose>
-    fileclose(wf);
-80105e83:	58                   	pop    %eax
-80105e84:	ff 75 e4             	pushl  -0x1c(%ebp)
-80105e87:	e8 34 b0 ff ff       	call   80100ec0 <fileclose>
-    return -1;
-80105e8c:	83 c4 10             	add    $0x10,%esp
-80105e8f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80105e94:	eb 5b                	jmp    80105ef1 <sys_pipe+0xd1>
-80105e96:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80105e9d:	8d 76 00             	lea    0x0(%esi),%esi
-      curproc->ofile[fd] = f;
-80105ea0:	8d 73 08             	lea    0x8(%ebx),%esi
-80105ea3:	89 7c b0 08          	mov    %edi,0x8(%eax,%esi,4)
-  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
-80105ea7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
-  struct proc *curproc = myproc();
-80105eaa:	e8 01 db ff ff       	call   801039b0 <myproc>
-  for(fd = 0; fd < NOFILE; fd++){
-80105eaf:	31 d2                	xor    %edx,%edx
-80105eb1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    if(curproc->ofile[fd] == 0){
-80105eb8:	8b 4c 90 28          	mov    0x28(%eax,%edx,4),%ecx
-80105ebc:	85 c9                	test   %ecx,%ecx
-80105ebe:	74 20                	je     80105ee0 <sys_pipe+0xc0>
-  for(fd = 0; fd < NOFILE; fd++){
-80105ec0:	83 c2 01             	add    $0x1,%edx
-80105ec3:	83 fa 10             	cmp    $0x10,%edx
-80105ec6:	75 f0                	jne    80105eb8 <sys_pipe+0x98>
-      myproc()->ofile[fd0] = 0;
-80105ec8:	e8 e3 da ff ff       	call   801039b0 <myproc>
-80105ecd:	c7 44 b0 08 00 00 00 	movl   $0x0,0x8(%eax,%esi,4)
-80105ed4:	00 
-80105ed5:	eb a1                	jmp    80105e78 <sys_pipe+0x58>
-80105ed7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80105ede:	66 90                	xchg   %ax,%ax
-      curproc->ofile[fd] = f;
-80105ee0:	89 7c 90 28          	mov    %edi,0x28(%eax,%edx,4)
-  }
-  fd[0] = fd0;
-80105ee4:	8b 45 dc             	mov    -0x24(%ebp),%eax
-80105ee7:	89 18                	mov    %ebx,(%eax)
-  fd[1] = fd1;
-80105ee9:	8b 45 dc             	mov    -0x24(%ebp),%eax
-80105eec:	89 50 04             	mov    %edx,0x4(%eax)
-  return 0;
-80105eef:	31 c0                	xor    %eax,%eax
-}
-80105ef1:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80105ef4:	5b                   	pop    %ebx
-80105ef5:	5e                   	pop    %esi
-80105ef6:	5f                   	pop    %edi
-80105ef7:	5d                   	pop    %ebp
-80105ef8:	c3                   	ret    
-80105ef9:	66 90                	xchg   %ax,%ax
-80105efb:	66 90                	xchg   %ax,%ax
-80105efd:	66 90                	xchg   %ax,%ax
-80105eff:	90                   	nop
-
-80105f00 <sys_fork>:
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-
-int sys_fork(void)
-{
-80105f00:	f3 0f 1e fb          	endbr32 
-  return fork();
-80105f04:	e9 57 dc ff ff       	jmp    80103b60 <fork>
-80105f09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-80105f10 <sys_exit>:
-}
-
-int sys_exit(void)
-{
-80105f10:	f3 0f 1e fb          	endbr32 
-80105f14:	55                   	push   %ebp
-80105f15:	89 e5                	mov    %esp,%ebp
-80105f17:	83 ec 08             	sub    $0x8,%esp
-  exit();
-80105f1a:	e8 41 e2 ff ff       	call   80104160 <exit>
-  return 0; // not reached
-}
-80105f1f:	31 c0                	xor    %eax,%eax
-80105f21:	c9                   	leave  
-80105f22:	c3                   	ret    
-80105f23:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80105f2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80105f30 <sys_wait>:
-
-int sys_wait(void)
-{
-80105f30:	f3 0f 1e fb          	endbr32 
-  return wait();
-80105f34:	e9 87 e4 ff ff       	jmp    801043c0 <wait>
-80105f39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-80105f40 <sys_kill>:
-}
-
-int sys_kill(void)
-{
-80105f40:	f3 0f 1e fb          	endbr32 
-80105f44:	55                   	push   %ebp
-80105f45:	89 e5                	mov    %esp,%ebp
-80105f47:	83 ec 20             	sub    $0x20,%esp
-  int pid;
-
-  if (argint(0, &pid) < 0)
-80105f4a:	8d 45 f4             	lea    -0xc(%ebp),%eax
-80105f4d:	50                   	push   %eax
-80105f4e:	6a 00                	push   $0x0
-80105f50:	e8 5b f2 ff ff       	call   801051b0 <argint>
-80105f55:	83 c4 10             	add    $0x10,%esp
-80105f58:	85 c0                	test   %eax,%eax
-80105f5a:	78 14                	js     80105f70 <sys_kill+0x30>
-    return -1;
-  return kill(pid);
-80105f5c:	83 ec 0c             	sub    $0xc,%esp
-80105f5f:	ff 75 f4             	pushl  -0xc(%ebp)
-80105f62:	e8 c9 e5 ff ff       	call   80104530 <kill>
-80105f67:	83 c4 10             	add    $0x10,%esp
-}
-80105f6a:	c9                   	leave  
-80105f6b:	c3                   	ret    
-80105f6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80105f70:	c9                   	leave  
-    return -1;
-80105f71:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80105f76:	c3                   	ret    
-80105f77:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80105f7e:	66 90                	xchg   %ax,%ax
-
-80105f80 <sys_getpid>:
-
-int sys_getpid(void)
-{
-80105f80:	f3 0f 1e fb          	endbr32 
-80105f84:	55                   	push   %ebp
-80105f85:	89 e5                	mov    %esp,%ebp
-80105f87:	83 ec 08             	sub    $0x8,%esp
-  return myproc()->pid;
-80105f8a:	e8 21 da ff ff       	call   801039b0 <myproc>
-80105f8f:	8b 40 10             	mov    0x10(%eax),%eax
-}
-80105f92:	c9                   	leave  
-80105f93:	c3                   	ret    
-80105f94:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80105f9b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80105f9f:	90                   	nop
-
-80105fa0 <sys_sbrk>:
-
-int sys_sbrk(void)
-{
-80105fa0:	f3 0f 1e fb          	endbr32 
-80105fa4:	55                   	push   %ebp
-80105fa5:	89 e5                	mov    %esp,%ebp
-80105fa7:	53                   	push   %ebx
-  int addr;
-  int n;
-
-  if (argint(0, &n) < 0)
-80105fa8:	8d 45 f4             	lea    -0xc(%ebp),%eax
-{
-80105fab:	83 ec 1c             	sub    $0x1c,%esp
-  if (argint(0, &n) < 0)
-80105fae:	50                   	push   %eax
-80105faf:	6a 00                	push   $0x0
-80105fb1:	e8 fa f1 ff ff       	call   801051b0 <argint>
-80105fb6:	83 c4 10             	add    $0x10,%esp
-80105fb9:	85 c0                	test   %eax,%eax
-80105fbb:	78 23                	js     80105fe0 <sys_sbrk+0x40>
-    return -1;
-  addr = myproc()->sz;
-80105fbd:	e8 ee d9 ff ff       	call   801039b0 <myproc>
-  if (growproc(n) < 0)
-80105fc2:	83 ec 0c             	sub    $0xc,%esp
-  addr = myproc()->sz;
-80105fc5:	8b 18                	mov    (%eax),%ebx
-  if (growproc(n) < 0)
-80105fc7:	ff 75 f4             	pushl  -0xc(%ebp)
-80105fca:	e8 11 db ff ff       	call   80103ae0 <growproc>
-80105fcf:	83 c4 10             	add    $0x10,%esp
-80105fd2:	85 c0                	test   %eax,%eax
-80105fd4:	78 0a                	js     80105fe0 <sys_sbrk+0x40>
-    return -1;
-  return addr;
-}
-80105fd6:	89 d8                	mov    %ebx,%eax
-80105fd8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80105fdb:	c9                   	leave  
-80105fdc:	c3                   	ret    
-80105fdd:	8d 76 00             	lea    0x0(%esi),%esi
-    return -1;
-80105fe0:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
-80105fe5:	eb ef                	jmp    80105fd6 <sys_sbrk+0x36>
-80105fe7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80105fee:	66 90                	xchg   %ax,%ax
-
-80105ff0 <sys_sleep>:
-
-int sys_sleep(void)
-{
-80105ff0:	f3 0f 1e fb          	endbr32 
-80105ff4:	55                   	push   %ebp
-80105ff5:	89 e5                	mov    %esp,%ebp
-80105ff7:	53                   	push   %ebx
-  int n;
-  uint ticks0;
-
-  if (argint(0, &n) < 0)
-80105ff8:	8d 45 f4             	lea    -0xc(%ebp),%eax
-{
-80105ffb:	83 ec 1c             	sub    $0x1c,%esp
-  if (argint(0, &n) < 0)
-80105ffe:	50                   	push   %eax
-80105fff:	6a 00                	push   $0x0
-80106001:	e8 aa f1 ff ff       	call   801051b0 <argint>
-80106006:	83 c4 10             	add    $0x10,%esp
-80106009:	85 c0                	test   %eax,%eax
-8010600b:	0f 88 86 00 00 00    	js     80106097 <sys_sleep+0xa7>
-    return -1;
-  acquire(&tickslock);
-80106011:	83 ec 0c             	sub    $0xc,%esp
-80106014:	68 a0 81 11 80       	push   $0x801181a0
-80106019:	e8 a2 ed ff ff       	call   80104dc0 <acquire>
-  ticks0 = ticks;
-  while (ticks - ticks0 < n)
-8010601e:	8b 55 f4             	mov    -0xc(%ebp),%edx
-  ticks0 = ticks;
-80106021:	8b 1d e0 89 11 80    	mov    0x801189e0,%ebx
-  while (ticks - ticks0 < n)
-80106027:	83 c4 10             	add    $0x10,%esp
-8010602a:	85 d2                	test   %edx,%edx
-8010602c:	75 23                	jne    80106051 <sys_sleep+0x61>
-8010602e:	eb 50                	jmp    80106080 <sys_sleep+0x90>
-    if (myproc()->killed)
-    {
-      release(&tickslock);
-      return -1;
-    }
-    sleep(&ticks, &tickslock);
-80106030:	83 ec 08             	sub    $0x8,%esp
-80106033:	68 a0 81 11 80       	push   $0x801181a0
-80106038:	68 e0 89 11 80       	push   $0x801189e0
-8010603d:	e8 be e2 ff ff       	call   80104300 <sleep>
-  while (ticks - ticks0 < n)
-80106042:	a1 e0 89 11 80       	mov    0x801189e0,%eax
-80106047:	83 c4 10             	add    $0x10,%esp
-8010604a:	29 d8                	sub    %ebx,%eax
-8010604c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-8010604f:	73 2f                	jae    80106080 <sys_sleep+0x90>
-    if (myproc()->killed)
-80106051:	e8 5a d9 ff ff       	call   801039b0 <myproc>
-80106056:	8b 40 24             	mov    0x24(%eax),%eax
-80106059:	85 c0                	test   %eax,%eax
-8010605b:	74 d3                	je     80106030 <sys_sleep+0x40>
-      release(&tickslock);
-8010605d:	83 ec 0c             	sub    $0xc,%esp
-80106060:	68 a0 81 11 80       	push   $0x801181a0
-80106065:	e8 16 ee ff ff       	call   80104e80 <release>
-  }
-  release(&tickslock);
-  return 0;
-}
-8010606a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-      return -1;
-8010606d:	83 c4 10             	add    $0x10,%esp
-80106070:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80106075:	c9                   	leave  
-80106076:	c3                   	ret    
-80106077:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010607e:	66 90                	xchg   %ax,%ax
-  release(&tickslock);
-80106080:	83 ec 0c             	sub    $0xc,%esp
-80106083:	68 a0 81 11 80       	push   $0x801181a0
-80106088:	e8 f3 ed ff ff       	call   80104e80 <release>
-  return 0;
-8010608d:	83 c4 10             	add    $0x10,%esp
-80106090:	31 c0                	xor    %eax,%eax
-}
-80106092:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-80106095:	c9                   	leave  
-80106096:	c3                   	ret    
-    return -1;
-80106097:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-8010609c:	eb f4                	jmp    80106092 <sys_sleep+0xa2>
-8010609e:	66 90                	xchg   %ax,%ax
-
-801060a0 <sys_uptime>:
-
-// return how many clock tick interrupts have occurred
-// since start.
-int sys_uptime(void)
-{
-801060a0:	f3 0f 1e fb          	endbr32 
-801060a4:	55                   	push   %ebp
-801060a5:	89 e5                	mov    %esp,%ebp
-801060a7:	53                   	push   %ebx
-801060a8:	83 ec 10             	sub    $0x10,%esp
-  uint xticks;
-
-  acquire(&tickslock);
-801060ab:	68 a0 81 11 80       	push   $0x801181a0
-801060b0:	e8 0b ed ff ff       	call   80104dc0 <acquire>
-  xticks = ticks;
-801060b5:	8b 1d e0 89 11 80    	mov    0x801189e0,%ebx
-  release(&tickslock);
-801060bb:	c7 04 24 a0 81 11 80 	movl   $0x801181a0,(%esp)
-801060c2:	e8 b9 ed ff ff       	call   80104e80 <release>
-  return xticks;
-}
-801060c7:	89 d8                	mov    %ebx,%eax
-801060c9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-801060cc:	c9                   	leave  
-801060cd:	c3                   	ret    
-801060ce:	66 90                	xchg   %ax,%ax
-
-801060d0 <sys_getParentID>:
-
-int sys_getParentID(void)
-{
-801060d0:	f3 0f 1e fb          	endbr32 
-  return getParentID();
-801060d4:	e9 67 e6 ff ff       	jmp    80104740 <getParentID>
-801060d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-801060e0 <sys_getChildren>:
-}
-
-int sys_getChildren(void)
-{
-801060e0:	f3 0f 1e fb          	endbr32 
-801060e4:	55                   	push   %ebp
-801060e5:	89 e5                	mov    %esp,%ebp
-801060e7:	83 ec 1c             	sub    $0x1c,%esp
-  int *children_pid;
-  if (argptr(0, (void *)&children_pid, sizeof(*children_pid)) < 0)
-801060ea:	8d 45 f4             	lea    -0xc(%ebp),%eax
-801060ed:	6a 04                	push   $0x4
-801060ef:	50                   	push   %eax
-801060f0:	6a 00                	push   $0x0
-801060f2:	e8 09 f1 ff ff       	call   80105200 <argptr>
-801060f7:	83 c4 10             	add    $0x10,%esp
-801060fa:	85 c0                	test   %eax,%eax
-801060fc:	78 12                	js     80106110 <sys_getChildren+0x30>
-  {
-    return -1;
-  }
-  else
-  {
-    return getChildren(children_pid);
-801060fe:	83 ec 0c             	sub    $0xc,%esp
-80106101:	ff 75 f4             	pushl  -0xc(%ebp)
-80106104:	e8 87 e6 ff ff       	call   80104790 <getChildren>
-80106109:	83 c4 10             	add    $0x10,%esp
-  }
-}
-8010610c:	c9                   	leave  
-8010610d:	c3                   	ret    
-8010610e:	66 90                	xchg   %ax,%ax
-80106110:	c9                   	leave  
-    return -1;
-80106111:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80106116:	c3                   	ret    
-80106117:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010611e:	66 90                	xchg   %ax,%ax
-
-80106120 <sys_getSyscallCounter>:
-
-int sys_getSyscallCounter(void)
-{
-80106120:	f3 0f 1e fb          	endbr32 
-80106124:	55                   	push   %ebp
-80106125:	89 e5                	mov    %esp,%ebp
-80106127:	83 ec 20             	sub    $0x20,%esp
-  int syscall_num;
-  if (argint(0, &syscall_num) < 0)
-8010612a:	8d 45 f4             	lea    -0xc(%ebp),%eax
-8010612d:	50                   	push   %eax
-8010612e:	6a 00                	push   $0x0
-80106130:	e8 7b f0 ff ff       	call   801051b0 <argint>
-80106135:	83 c4 10             	add    $0x10,%esp
-80106138:	85 c0                	test   %eax,%eax
-8010613a:	78 14                	js     80106150 <sys_getSyscallCounter+0x30>
-  {
-    return -1;
-  }
-  else
-  {
-    return getSyscallCounter(syscall_num);
-8010613c:	83 ec 0c             	sub    $0xc,%esp
-8010613f:	ff 75 f4             	pushl  -0xc(%ebp)
-80106142:	e8 c9 e6 ff ff       	call   80104810 <getSyscallCounter>
-80106147:	83 c4 10             	add    $0x10,%esp
-  }
-}
-8010614a:	c9                   	leave  
-8010614b:	c3                   	ret    
-8010614c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80106150:	c9                   	leave  
-    return -1;
-80106151:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80106156:	c3                   	ret    
-80106157:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010615e:	66 90                	xchg   %ax,%ax
-
-80106160 <sys_setPriority>:
-
-int sys_setPriority(void)
-{
-80106160:	f3 0f 1e fb          	endbr32 
-80106164:	55                   	push   %ebp
-80106165:	89 e5                	mov    %esp,%ebp
-80106167:	83 ec 20             	sub    $0x20,%esp
-  int newPriority;
-  if (argint(0, &newPriority) < 0)
-8010616a:	8d 45 f4             	lea    -0xc(%ebp),%eax
-8010616d:	50                   	push   %eax
-8010616e:	6a 00                	push   $0x0
-80106170:	e8 3b f0 ff ff       	call   801051b0 <argint>
-80106175:	83 c4 10             	add    $0x10,%esp
-80106178:	85 c0                	test   %eax,%eax
-8010617a:	78 14                	js     80106190 <sys_setPriority+0x30>
-    return -1;
-  else
-    return setPriority(newPriority);
-8010617c:	83 ec 0c             	sub    $0xc,%esp
-8010617f:	ff 75 f4             	pushl  -0xc(%ebp)
-80106182:	e8 c9 e6 ff ff       	call   80104850 <setPriority>
-80106187:	83 c4 10             	add    $0x10,%esp
-}
-8010618a:	c9                   	leave  
-8010618b:	c3                   	ret    
-8010618c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80106190:	c9                   	leave  
-    return -1;
-80106191:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80106196:	c3                   	ret    
-80106197:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010619e:	66 90                	xchg   %ax,%ax
-
-801061a0 <sys_changePolicy>:
-
-int sys_changePolicy(void)
-{
-801061a0:	f3 0f 1e fb          	endbr32 
-801061a4:	55                   	push   %ebp
-801061a5:	89 e5                	mov    %esp,%ebp
-801061a7:	83 ec 20             	sub    $0x20,%esp
-  int newPolicy;
-  if (argint(0, &newPolicy) < 0)
-801061aa:	8d 45 f4             	lea    -0xc(%ebp),%eax
-801061ad:	50                   	push   %eax
-801061ae:	6a 00                	push   $0x0
-801061b0:	e8 fb ef ff ff       	call   801051b0 <argint>
-801061b5:	83 c4 10             	add    $0x10,%esp
-801061b8:	85 c0                	test   %eax,%eax
-801061ba:	78 14                	js     801061d0 <sys_changePolicy+0x30>
-    return -1;
-  else
-    return changePolicy(newPolicy);
-801061bc:	83 ec 0c             	sub    $0xc,%esp
-801061bf:	ff 75 f4             	pushl  -0xc(%ebp)
-801061c2:	e8 c9 e6 ff ff       	call   80104890 <changePolicy>
-801061c7:	83 c4 10             	add    $0x10,%esp
-}
-801061ca:	c9                   	leave  
-801061cb:	c3                   	ret    
-801061cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801061d0:	c9                   	leave  
-    return -1;
-801061d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-801061d6:	c3                   	ret    
-801061d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801061de:	66 90                	xchg   %ax,%ax
-
-801061e0 <sys_getCreationTime>:
-int sys_getCreationTime(void)
-{
-801061e0:	f3 0f 1e fb          	endbr32 
-801061e4:	55                   	push   %ebp
-801061e5:	89 e5                	mov    %esp,%ebp
-801061e7:	83 ec 20             	sub    $0x20,%esp
-  int pid;
-  if (argint(0, &pid) < 0)
-801061ea:	8d 45 f4             	lea    -0xc(%ebp),%eax
-801061ed:	50                   	push   %eax
-801061ee:	6a 00                	push   $0x0
-801061f0:	e8 bb ef ff ff       	call   801051b0 <argint>
-801061f5:	83 c4 10             	add    $0x10,%esp
-801061f8:	85 c0                	test   %eax,%eax
-801061fa:	78 14                	js     80106210 <sys_getCreationTime+0x30>
-    return -1;
-  else
-    return getCreationTime(pid);
-801061fc:	83 ec 0c             	sub    $0xc,%esp
-801061ff:	ff 75 f4             	pushl  -0xc(%ebp)
-80106202:	e8 09 e7 ff ff       	call   80104910 <getCreationTime>
-80106207:	83 c4 10             	add    $0x10,%esp
-}
-8010620a:	c9                   	leave  
-8010620b:	c3                   	ret    
-8010620c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80106210:	c9                   	leave  
-    return -1;
-80106211:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80106216:	c3                   	ret    
-80106217:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010621e:	66 90                	xchg   %ax,%ax
-
-80106220 <sys_getTurnAroundTime>:
-
-int sys_getTurnAroundTime(void)
-{
-80106220:	f3 0f 1e fb          	endbr32 
-80106224:	55                   	push   %ebp
-80106225:	89 e5                	mov    %esp,%ebp
-80106227:	83 ec 20             	sub    $0x20,%esp
-  int pid;
-  if (argint(0, &pid) < 0)
-8010622a:	8d 45 f4             	lea    -0xc(%ebp),%eax
-8010622d:	50                   	push   %eax
-8010622e:	6a 00                	push   $0x0
-80106230:	e8 7b ef ff ff       	call   801051b0 <argint>
-80106235:	83 c4 10             	add    $0x10,%esp
-80106238:	85 c0                	test   %eax,%eax
-8010623a:	78 14                	js     80106250 <sys_getTurnAroundTime+0x30>
-    return -1;
-  else
-    return getTurnAroundTime(pid);
-8010623c:	83 ec 0c             	sub    $0xc,%esp
-8010623f:	ff 75 f4             	pushl  -0xc(%ebp)
-80106242:	e8 79 e6 ff ff       	call   801048c0 <getTurnAroundTime>
-80106247:	83 c4 10             	add    $0x10,%esp
-}
-8010624a:	c9                   	leave  
-8010624b:	c3                   	ret    
-8010624c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80106250:	c9                   	leave  
-    return -1;
-80106251:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80106256:	c3                   	ret    
-80106257:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010625e:	66 90                	xchg   %ax,%ax
-
-80106260 <sys_getBurstTime>:
-int sys_getBurstTime(void)
-{
-80106260:	f3 0f 1e fb          	endbr32 
-80106264:	55                   	push   %ebp
-80106265:	89 e5                	mov    %esp,%ebp
-80106267:	83 ec 20             	sub    $0x20,%esp
-  int pid;
-  if (argint(0, &pid) < 0)
-8010626a:	8d 45 f4             	lea    -0xc(%ebp),%eax
-8010626d:	50                   	push   %eax
-8010626e:	6a 00                	push   $0x0
-80106270:	e8 3b ef ff ff       	call   801051b0 <argint>
-80106275:	83 c4 10             	add    $0x10,%esp
-80106278:	85 c0                	test   %eax,%eax
-8010627a:	78 14                	js     80106290 <sys_getBurstTime+0x30>
-    return -1;
-  else
-  return getBurstTime(pid);
-8010627c:	83 ec 0c             	sub    $0xc,%esp
-8010627f:	ff 75 f4             	pushl  -0xc(%ebp)
-80106282:	e8 69 e6 ff ff       	call   801048f0 <getBurstTime>
-80106287:	83 c4 10             	add    $0x10,%esp
-}
-8010628a:	c9                   	leave  
-8010628b:	c3                   	ret    
-8010628c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80106290:	c9                   	leave  
-    return -1;
-80106291:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80106296:	c3                   	ret    
-80106297:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010629e:	66 90                	xchg   %ax,%ax
-
-801062a0 <sys_getWaitingTime>:
-int sys_getWaitingTime(void)
-{
-801062a0:	f3 0f 1e fb          	endbr32 
-801062a4:	55                   	push   %ebp
-801062a5:	89 e5                	mov    %esp,%ebp
-801062a7:	83 ec 20             	sub    $0x20,%esp
-  int pid;
-  if (argint(0, &pid) < 0)
-801062aa:	8d 45 f4             	lea    -0xc(%ebp),%eax
-801062ad:	50                   	push   %eax
-801062ae:	6a 00                	push   $0x0
-801062b0:	e8 fb ee ff ff       	call   801051b0 <argint>
-801062b5:	83 c4 10             	add    $0x10,%esp
-801062b8:	85 c0                	test   %eax,%eax
-801062ba:	78 14                	js     801062d0 <sys_getWaitingTime+0x30>
-    return -1;
-  else
-    return getWaitingTime(pid);
-801062bc:	83 ec 0c             	sub    $0xc,%esp
-801062bf:	ff 75 f4             	pushl  -0xc(%ebp)
-801062c2:	e8 69 e6 ff ff       	call   80104930 <getWaitingTime>
-801062c7:	83 c4 10             	add    $0x10,%esp
-}
-801062ca:	c9                   	leave  
-801062cb:	c3                   	ret    
-801062cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801062d0:	c9                   	leave  
-    return -1;
-801062d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-801062d6:	c3                   	ret    
-801062d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801062de:	66 90                	xchg   %ax,%ax
-
-801062e0 <sys_getCBT>:
-
-int sys_getCBT(void)
-{
-801062e0:	f3 0f 1e fb          	endbr32 
-801062e4:	55                   	push   %ebp
-801062e5:	89 e5                	mov    %esp,%ebp
-801062e7:	83 ec 20             	sub    $0x20,%esp
-  int pid;
-  if (argint(0, &pid) < 0)
-801062ea:	8d 45 f4             	lea    -0xc(%ebp),%eax
-801062ed:	50                   	push   %eax
-801062ee:	6a 00                	push   $0x0
-801062f0:	e8 bb ee ff ff       	call   801051b0 <argint>
-801062f5:	83 c4 10             	add    $0x10,%esp
-801062f8:	85 c0                	test   %eax,%eax
-801062fa:	78 14                	js     80106310 <sys_getCBT+0x30>
-    return -1;
-  else
-    return getCBT(pid);
-801062fc:	83 ec 0c             	sub    $0xc,%esp
-801062ff:	ff 75 f4             	pushl  -0xc(%ebp)
-80106302:	e8 49 e6 ff ff       	call   80104950 <getCBT>
-80106307:	83 c4 10             	add    $0x10,%esp
-}
-8010630a:	c9                   	leave  
-8010630b:	c3                   	ret    
-8010630c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80106310:	c9                   	leave  
-    return -1;
-80106311:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80106316:	c3                   	ret    
-80106317:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010631e:	66 90                	xchg   %ax,%ax
-
-80106320 <sys_customWait>:
-
-int sys_customWait(void)
-{
-80106320:	f3 0f 1e fb          	endbr32 
-80106324:	55                   	push   %ebp
-80106325:	89 e5                	mov    %esp,%ebp
-80106327:	83 ec 1c             	sub    $0x1c,%esp
-  int *procTimes;
-  if (argptr(0, (void *)&procTimes, sizeof(*procTimes)) < 0)
-8010632a:	8d 45 f4             	lea    -0xc(%ebp),%eax
-8010632d:	6a 04                	push   $0x4
-8010632f:	50                   	push   %eax
-80106330:	6a 00                	push   $0x0
-80106332:	e8 c9 ee ff ff       	call   80105200 <argptr>
-80106337:	83 c4 10             	add    $0x10,%esp
-8010633a:	85 c0                	test   %eax,%eax
-8010633c:	78 12                	js     80106350 <sys_customWait+0x30>
-  {
-    return -1;
-  }
-  else
-  {
-    return customWait(procTimes);
-8010633e:	83 ec 0c             	sub    $0xc,%esp
-80106341:	ff 75 f4             	pushl  -0xc(%ebp)
-80106344:	e8 27 e6 ff ff       	call   80104970 <customWait>
-80106349:	83 c4 10             	add    $0x10,%esp
-  }
-}
-8010634c:	c9                   	leave  
-8010634d:	c3                   	ret    
-8010634e:	66 90                	xchg   %ax,%ax
-80106350:	c9                   	leave  
-    return -1;
-80106351:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80106356:	c3                   	ret    
-80106357:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010635e:	66 90                	xchg   %ax,%ax
-
-80106360 <sys_setQueue>:
-
-int sys_setQueue(void)
-{
-80106360:	f3 0f 1e fb          	endbr32 
-80106364:	55                   	push   %ebp
-80106365:	89 e5                	mov    %esp,%ebp
-80106367:	83 ec 20             	sub    $0x20,%esp
-  int queueNumber;
-  if (argint(0, &queueNumber) < 0)
-8010636a:	8d 45 f4             	lea    -0xc(%ebp),%eax
-8010636d:	50                   	push   %eax
-8010636e:	6a 00                	push   $0x0
-80106370:	e8 3b ee ff ff       	call   801051b0 <argint>
-80106375:	83 c4 10             	add    $0x10,%esp
-80106378:	85 c0                	test   %eax,%eax
-8010637a:	78 14                	js     80106390 <sys_setQueue+0x30>
-  {    
-    return -1;
-  }
-  else
-    return setQueue(queueNumber);
-8010637c:	83 ec 0c             	sub    $0xc,%esp
-8010637f:	ff 75 f4             	pushl  -0xc(%ebp)
-80106382:	e8 39 e7 ff ff       	call   80104ac0 <setQueue>
-80106387:	83 c4 10             	add    $0x10,%esp
-
-8010638a:	c9                   	leave  
-8010638b:	c3                   	ret    
-8010638c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80106390:	c9                   	leave  
-    return -1;
-80106391:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-80106396:	c3                   	ret    
-
-80106397 <alltraps>:
-
-  # vectors.S sends all traps here.
-.globl alltraps
-alltraps:
-  # Build trap frame.
-  pushl %ds
-80106397:	1e                   	push   %ds
-  pushl %es
-80106398:	06                   	push   %es
-  pushl %fs
-80106399:	0f a0                	push   %fs
-  pushl %gs
-8010639b:	0f a8                	push   %gs
-  pushal
-8010639d:	60                   	pusha  
-  
-  # Set up data segments.
-  movw $(SEG_KDATA<<3), %ax
-8010639e:	66 b8 10 00          	mov    $0x10,%ax
-  movw %ax, %ds
-801063a2:	8e d8                	mov    %eax,%ds
-  movw %ax, %es
-801063a4:	8e c0                	mov    %eax,%es
-
-  # Call trap(tf), where tf=%esp
-  pushl %esp
-801063a6:	54                   	push   %esp
-  call trap
-801063a7:	e8 c4 00 00 00       	call   80106470 <trap>
-  addl $4, %esp
-801063ac:	83 c4 04             	add    $0x4,%esp
-
-801063af <trapret>:
-
-  # Return falls through to trapret...
-.globl trapret
-trapret:
-  popal
-801063af:	61                   	popa   
-  popl %gs
-801063b0:	0f a9                	pop    %gs
-  popl %fs
-801063b2:	0f a1                	pop    %fs
-  popl %es
-801063b4:	07                   	pop    %es
-  popl %ds
-801063b5:	1f                   	pop    %ds
-  addl $0x8, %esp  # trapno and errcode
-801063b6:	83 c4 08             	add    $0x8,%esp
-  iret
-801063b9:	cf                   	iret   
-801063ba:	66 90                	xchg   %ax,%ax
-801063bc:	66 90                	xchg   %ax,%ax
-801063be:	66 90                	xchg   %ax,%ax
-
-801063c0 <tvinit>:
-extern uint vectors[]; // in vectors.S: array of 256 entry pointers
-struct spinlock tickslock;
-uint ticks;
-
-void tvinit(void)
-{
-801063c0:	f3 0f 1e fb          	endbr32 
-801063c4:	55                   	push   %ebp
-  int i;
-
-  for (i = 0; i < 256; i++)
-801063c5:	31 c0                	xor    %eax,%eax
-{
-801063c7:	89 e5                	mov    %esp,%ebp
-801063c9:	83 ec 08             	sub    $0x8,%esp
-801063cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    SETGATE(idt[i], 0, SEG_KCODE << 3, vectors[i], 0);
-801063d0:	8b 14 85 08 b0 10 80 	mov    -0x7fef4ff8(,%eax,4),%edx
-801063d7:	c7 04 c5 e2 81 11 80 	movl   $0x8e000008,-0x7fee7e1e(,%eax,8)
-801063de:	08 00 00 8e 
-801063e2:	66 89 14 c5 e0 81 11 	mov    %dx,-0x7fee7e20(,%eax,8)
-801063e9:	80 
-801063ea:	c1 ea 10             	shr    $0x10,%edx
-801063ed:	66 89 14 c5 e6 81 11 	mov    %dx,-0x7fee7e1a(,%eax,8)
-801063f4:	80 
-  for (i = 0; i < 256; i++)
-801063f5:	83 c0 01             	add    $0x1,%eax
-801063f8:	3d 00 01 00 00       	cmp    $0x100,%eax
-801063fd:	75 d1                	jne    801063d0 <tvinit+0x10>
-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE << 3, vectors[T_SYSCALL], DPL_USER);
-
-  initlock(&tickslock, "time");
-801063ff:	83 ec 08             	sub    $0x8,%esp
-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE << 3, vectors[T_SYSCALL], DPL_USER);
-80106402:	a1 08 b1 10 80       	mov    0x8010b108,%eax
-80106407:	c7 05 e2 83 11 80 08 	movl   $0xef000008,0x801183e2
-8010640e:	00 00 ef 
-  initlock(&tickslock, "time");
-80106411:	68 25 84 10 80       	push   $0x80108425
-80106416:	68 a0 81 11 80       	push   $0x801181a0
-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE << 3, vectors[T_SYSCALL], DPL_USER);
-8010641b:	66 a3 e0 83 11 80    	mov    %ax,0x801183e0
-80106421:	c1 e8 10             	shr    $0x10,%eax
-80106424:	66 a3 e6 83 11 80    	mov    %ax,0x801183e6
-  initlock(&tickslock, "time");
-8010642a:	e8 11 e8 ff ff       	call   80104c40 <initlock>
-}
-8010642f:	83 c4 10             	add    $0x10,%esp
-80106432:	c9                   	leave  
-80106433:	c3                   	ret    
-80106434:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010643b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010643f:	90                   	nop
-
-80106440 <idtinit>:
-
-void idtinit(void)
-{
-80106440:	f3 0f 1e fb          	endbr32 
-80106444:	55                   	push   %ebp
-  pd[0] = size-1;
-80106445:	b8 ff 07 00 00       	mov    $0x7ff,%eax
-8010644a:	89 e5                	mov    %esp,%ebp
-8010644c:	83 ec 10             	sub    $0x10,%esp
-8010644f:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
-  pd[1] = (uint)p;
-80106453:	b8 e0 81 11 80       	mov    $0x801181e0,%eax
-80106458:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
-  pd[2] = (uint)p >> 16;
-8010645c:	c1 e8 10             	shr    $0x10,%eax
-8010645f:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
-  asm volatile("lidt (%0)" : : "r" (pd));
-80106463:	8d 45 fa             	lea    -0x6(%ebp),%eax
-80106466:	0f 01 18             	lidtl  (%eax)
-  lidt(idt, sizeof(idt));
-}
-80106469:	c9                   	leave  
-8010646a:	c3                   	ret    
-8010646b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010646f:	90                   	nop
-
-80106470 <trap>:
-
-//PAGEBREAK: 41
-void trap(struct trapframe *tf)
-{
-80106470:	f3 0f 1e fb          	endbr32 
-80106474:	55                   	push   %ebp
-80106475:	89 e5                	mov    %esp,%ebp
-80106477:	57                   	push   %edi
-80106478:	56                   	push   %esi
-80106479:	53                   	push   %ebx
-8010647a:	83 ec 1c             	sub    $0x1c,%esp
-8010647d:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  if (tf->trapno == T_SYSCALL)
-80106480:	8b 43 30             	mov    0x30(%ebx),%eax
-80106483:	83 f8 40             	cmp    $0x40,%eax
-80106486:	0f 84 f4 01 00 00    	je     80106680 <trap+0x210>
-    if (myproc()->killed)
-      exit();
-    return;
-  }
-
-  switch (tf->trapno)
-8010648c:	83 e8 20             	sub    $0x20,%eax
-8010648f:	83 f8 1f             	cmp    $0x1f,%eax
-80106492:	77 08                	ja     8010649c <trap+0x2c>
-80106494:	3e ff 24 85 cc 84 10 	notrack jmp *-0x7fef7b34(,%eax,4)
-8010649b:	80 
-    lapiceoi();
-    break;
-
-  //PAGEBREAK: 13
-  default:
-    if (myproc() == 0 || (tf->cs & 3) == 0)
-8010649c:	e8 0f d5 ff ff       	call   801039b0 <myproc>
-801064a1:	8b 7b 38             	mov    0x38(%ebx),%edi
-801064a4:	85 c0                	test   %eax,%eax
-801064a6:	0f 84 64 02 00 00    	je     80106710 <trap+0x2a0>
-801064ac:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
-801064b0:	0f 84 5a 02 00 00    	je     80106710 <trap+0x2a0>
-
-static inline uint
-rcr2(void)
-{
-  uint val;
-  asm volatile("movl %%cr2,%0" : "=r" (val));
-801064b6:	0f 20 d1             	mov    %cr2,%ecx
-801064b9:	89 4d d8             	mov    %ecx,-0x28(%ebp)
-      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
-              tf->trapno, cpuid(), tf->eip, rcr2());
-      panic("trap");
-    }
-    // In user space, assume process misbehaved.
-    cprintf("pid %d %s: trap %d err %d on cpu %d "
-801064bc:	e8 cf d4 ff ff       	call   80103990 <cpuid>
-801064c1:	8b 73 30             	mov    0x30(%ebx),%esi
-801064c4:	89 45 dc             	mov    %eax,-0x24(%ebp)
-801064c7:	8b 43 34             	mov    0x34(%ebx),%eax
-801064ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-            "eip 0x%x addr 0x%x--kill proc\n",
-            myproc()->pid, myproc()->name, tf->trapno,
-801064cd:	e8 de d4 ff ff       	call   801039b0 <myproc>
-801064d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
-801064d5:	e8 d6 d4 ff ff       	call   801039b0 <myproc>
-    cprintf("pid %d %s: trap %d err %d on cpu %d "
-801064da:	8b 4d d8             	mov    -0x28(%ebp),%ecx
-801064dd:	8b 55 dc             	mov    -0x24(%ebp),%edx
-801064e0:	51                   	push   %ecx
-801064e1:	57                   	push   %edi
-801064e2:	52                   	push   %edx
-801064e3:	ff 75 e4             	pushl  -0x1c(%ebp)
-801064e6:	56                   	push   %esi
-            myproc()->pid, myproc()->name, tf->trapno,
-801064e7:	8b 75 e0             	mov    -0x20(%ebp),%esi
-801064ea:	83 c6 6c             	add    $0x6c,%esi
-    cprintf("pid %d %s: trap %d err %d on cpu %d "
-801064ed:	56                   	push   %esi
-801064ee:	ff 70 10             	pushl  0x10(%eax)
-801064f1:	68 88 84 10 80       	push   $0x80108488
-801064f6:	e8 b5 a1 ff ff       	call   801006b0 <cprintf>
-            tf->err, cpuid(), tf->eip, rcr2());
-    myproc()->killed = 1;
-801064fb:	83 c4 20             	add    $0x20,%esp
-801064fe:	e8 ad d4 ff ff       	call   801039b0 <myproc>
-80106503:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
-  }
-
-  // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running
-  // until it gets to the regular system call return.)
-  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
-8010650a:	e8 a1 d4 ff ff       	call   801039b0 <myproc>
-8010650f:	85 c0                	test   %eax,%eax
-80106511:	74 1d                	je     80106530 <trap+0xc0>
-80106513:	e8 98 d4 ff ff       	call   801039b0 <myproc>
-80106518:	8b 48 24             	mov    0x24(%eax),%ecx
-8010651b:	85 c9                	test   %ecx,%ecx
-8010651d:	74 11                	je     80106530 <trap+0xc0>
-8010651f:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
-80106523:	83 e0 03             	and    $0x3,%eax
-80106526:	66 83 f8 03          	cmp    $0x3,%ax
-8010652a:	0f 84 b8 01 00 00    	je     801066e8 <trap+0x278>
-
-  // Force process to give up CPU on clock tick.
-  // If interrupts were on while locks held, would need to check nlock.
-  // On each tick, check the remaining time left for current process,
-  // if zero, yield.
-  if (myproc() && myproc()->state == RUNNING &&
-80106530:	e8 7b d4 ff ff       	call   801039b0 <myproc>
-80106535:	85 c0                	test   %eax,%eax
-80106537:	74 0f                	je     80106548 <trap+0xd8>
-80106539:	e8 72 d4 ff ff       	call   801039b0 <myproc>
-8010653e:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
-80106542:	0f 84 f8 00 00 00    	je     80106640 <trap+0x1d0>
-80106548:	8b 43 30             	mov    0x30(%ebx),%eax
-      break;
-    }
-  }
-
-  // Update each process sleeping, runnable, running time
-  if (tf->trapno == T_IRQ0 + IRQ_TIMER)
-8010654b:	83 f8 20             	cmp    $0x20,%eax
-8010654e:	0f 84 84 01 00 00    	je     801066d8 <trap+0x268>
-  {
-    updateStateDurations();
-  }
-
-  // Check if the process has been killed since we yielded
-  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
-80106554:	e8 57 d4 ff ff       	call   801039b0 <myproc>
-80106559:	85 c0                	test   %eax,%eax
-8010655b:	74 1d                	je     8010657a <trap+0x10a>
-8010655d:	e8 4e d4 ff ff       	call   801039b0 <myproc>
-80106562:	8b 40 24             	mov    0x24(%eax),%eax
-80106565:	85 c0                	test   %eax,%eax
-80106567:	74 11                	je     8010657a <trap+0x10a>
-80106569:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
-8010656d:	83 e0 03             	and    $0x3,%eax
-80106570:	66 83 f8 03          	cmp    $0x3,%ax
-80106574:	0f 84 2f 01 00 00    	je     801066a9 <trap+0x239>
-    exit();
-}
-8010657a:	8d 65 f4             	lea    -0xc(%ebp),%esp
-8010657d:	5b                   	pop    %ebx
-8010657e:	5e                   	pop    %esi
-8010657f:	5f                   	pop    %edi
-80106580:	5d                   	pop    %ebp
-80106581:	c3                   	ret    
-    ideintr();
-80106582:	e8 59 bc ff ff       	call   801021e0 <ideintr>
-    lapiceoi();
-80106587:	e8 34 c3 ff ff       	call   801028c0 <lapiceoi>
-  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
-8010658c:	e8 1f d4 ff ff       	call   801039b0 <myproc>
-80106591:	85 c0                	test   %eax,%eax
-80106593:	0f 85 7a ff ff ff    	jne    80106513 <trap+0xa3>
-80106599:	eb 95                	jmp    80106530 <trap+0xc0>
-    if (cpuid() == 0)
-8010659b:	e8 f0 d3 ff ff       	call   80103990 <cpuid>
-801065a0:	85 c0                	test   %eax,%eax
-801065a2:	75 e3                	jne    80106587 <trap+0x117>
-      acquire(&tickslock);
-801065a4:	83 ec 0c             	sub    $0xc,%esp
-801065a7:	68 a0 81 11 80       	push   $0x801181a0
-801065ac:	e8 0f e8 ff ff       	call   80104dc0 <acquire>
-      wakeup(&ticks);
-801065b1:	c7 04 24 e0 89 11 80 	movl   $0x801189e0,(%esp)
-      ticks++;
-801065b8:	83 05 e0 89 11 80 01 	addl   $0x1,0x801189e0
-      wakeup(&ticks);
-801065bf:	e8 fc de ff ff       	call   801044c0 <wakeup>
-      release(&tickslock);
-801065c4:	c7 04 24 a0 81 11 80 	movl   $0x801181a0,(%esp)
-801065cb:	e8 b0 e8 ff ff       	call   80104e80 <release>
-801065d0:	83 c4 10             	add    $0x10,%esp
-    lapiceoi();
-801065d3:	eb b2                	jmp    80106587 <trap+0x117>
-    kbdintr();
-801065d5:	e8 a6 c1 ff ff       	call   80102780 <kbdintr>
-    lapiceoi();
-801065da:	e8 e1 c2 ff ff       	call   801028c0 <lapiceoi>
-  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
-801065df:	e8 cc d3 ff ff       	call   801039b0 <myproc>
-801065e4:	85 c0                	test   %eax,%eax
-801065e6:	0f 85 27 ff ff ff    	jne    80106513 <trap+0xa3>
-801065ec:	e9 3f ff ff ff       	jmp    80106530 <trap+0xc0>
-    uartintr();
-801065f1:	e8 ba 02 00 00       	call   801068b0 <uartintr>
-    lapiceoi();
-801065f6:	e8 c5 c2 ff ff       	call   801028c0 <lapiceoi>
-  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
-801065fb:	e8 b0 d3 ff ff       	call   801039b0 <myproc>
-80106600:	85 c0                	test   %eax,%eax
-80106602:	0f 85 0b ff ff ff    	jne    80106513 <trap+0xa3>
-80106608:	e9 23 ff ff ff       	jmp    80106530 <trap+0xc0>
-    cprintf("cpu%d: spurious interrupt at %x:%x\n",
-8010660d:	8b 7b 38             	mov    0x38(%ebx),%edi
-80106610:	0f b7 73 3c          	movzwl 0x3c(%ebx),%esi
-80106614:	e8 77 d3 ff ff       	call   80103990 <cpuid>
-80106619:	57                   	push   %edi
-8010661a:	56                   	push   %esi
-8010661b:	50                   	push   %eax
-8010661c:	68 30 84 10 80       	push   $0x80108430
-80106621:	e8 8a a0 ff ff       	call   801006b0 <cprintf>
-    lapiceoi();
-80106626:	e8 95 c2 ff ff       	call   801028c0 <lapiceoi>
-    break;
-8010662b:	83 c4 10             	add    $0x10,%esp
-  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
-8010662e:	e8 7d d3 ff ff       	call   801039b0 <myproc>
-80106633:	85 c0                	test   %eax,%eax
-80106635:	0f 85 d8 fe ff ff    	jne    80106513 <trap+0xa3>
-8010663b:	e9 f0 fe ff ff       	jmp    80106530 <trap+0xc0>
-  if (myproc() && myproc()->state == RUNNING &&
-80106640:	83 7b 30 20          	cmpl   $0x20,0x30(%ebx)
-80106644:	0f 85 0a ff ff ff    	jne    80106554 <trap+0xe4>
-    switch (policy)
-8010664a:	a1 40 3d 11 80       	mov    0x80113d40,%eax
-8010664f:	83 f8 03             	cmp    $0x3,%eax
-80106652:	77 64                	ja     801066b8 <trap+0x248>
-80106654:	83 f8 01             	cmp    $0x1,%eax
-80106657:	75 6f                	jne    801066c8 <trap+0x258>
-        if (myproc()->rr_remaining_t == 0)
-80106659:	e8 52 d3 ff ff       	call   801039b0 <myproc>
-8010665e:	8b 90 f4 00 00 00    	mov    0xf4(%eax),%edx
-80106664:	85 d2                	test   %edx,%edx
-80106666:	0f 85 93 00 00 00    	jne    801066ff <trap+0x28f>
-          myproc()->rr_remaining_t = QUANTUM;
-8010666c:	e8 3f d3 ff ff       	call   801039b0 <myproc>
-80106671:	c7 80 f4 00 00 00 64 	movl   $0x64,0xf4(%eax)
-80106678:	00 00 00 
-8010667b:	eb 4b                	jmp    801066c8 <trap+0x258>
-8010667d:	8d 76 00             	lea    0x0(%esi),%esi
-    if (myproc()->killed)
-80106680:	e8 2b d3 ff ff       	call   801039b0 <myproc>
-80106685:	8b 70 24             	mov    0x24(%eax),%esi
-80106688:	85 f6                	test   %esi,%esi
-8010668a:	75 6c                	jne    801066f8 <trap+0x288>
-    myproc()->tf = tf;
-8010668c:	e8 1f d3 ff ff       	call   801039b0 <myproc>
-80106691:	89 58 18             	mov    %ebx,0x18(%eax)
-    syscall();
-80106694:	e8 07 ec ff ff       	call   801052a0 <syscall>
-    if (myproc()->killed)
-80106699:	e8 12 d3 ff ff       	call   801039b0 <myproc>
-8010669e:	8b 58 24             	mov    0x24(%eax),%ebx
-801066a1:	85 db                	test   %ebx,%ebx
-801066a3:	0f 84 d1 fe ff ff    	je     8010657a <trap+0x10a>
-}
-801066a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801066ac:	5b                   	pop    %ebx
-801066ad:	5e                   	pop    %esi
-801066ae:	5f                   	pop    %edi
-801066af:	5d                   	pop    %ebp
-      exit();
-801066b0:	e9 ab da ff ff       	jmp    80104160 <exit>
-801066b5:	8d 76 00             	lea    0x0(%esi),%esi
-    switch (policy)
-801066b8:	83 f8 04             	cmp    $0x4,%eax
-801066bb:	75 1b                	jne    801066d8 <trap+0x268>
-      switch (myproc()->queue)
-801066bd:	e8 ee d2 ff ff       	call   801039b0 <myproc>
-801066c2:	83 78 7c 04          	cmpl   $0x4,0x7c(%eax)
-801066c6:	74 91                	je     80106659 <trap+0x1e9>
-          yield();
-801066c8:	e8 e3 db ff ff       	call   801042b0 <yield>
-801066cd:	8b 43 30             	mov    0x30(%ebx),%eax
-801066d0:	e9 76 fe ff ff       	jmp    8010654b <trap+0xdb>
-801066d5:	8d 76 00             	lea    0x0(%esi),%esi
-    updateStateDurations();
-801066d8:	e8 c3 df ff ff       	call   801046a0 <updateStateDurations>
-801066dd:	e9 72 fe ff ff       	jmp    80106554 <trap+0xe4>
-801066e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    exit();
-801066e8:	e8 73 da ff ff       	call   80104160 <exit>
-801066ed:	e9 3e fe ff ff       	jmp    80106530 <trap+0xc0>
-801066f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-      exit();
-801066f8:	e8 63 da ff ff       	call   80104160 <exit>
-801066fd:	eb 8d                	jmp    8010668c <trap+0x21c>
-          myproc()->rr_remaining_t--;
-801066ff:	e8 ac d2 ff ff       	call   801039b0 <myproc>
-80106704:	83 a8 f4 00 00 00 01 	subl   $0x1,0xf4(%eax)
-8010670b:	e9 38 fe ff ff       	jmp    80106548 <trap+0xd8>
-80106710:	0f 20 d6             	mov    %cr2,%esi
-      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
-80106713:	e8 78 d2 ff ff       	call   80103990 <cpuid>
-80106718:	83 ec 0c             	sub    $0xc,%esp
-8010671b:	56                   	push   %esi
-8010671c:	57                   	push   %edi
-8010671d:	50                   	push   %eax
-8010671e:	ff 73 30             	pushl  0x30(%ebx)
-80106721:	68 54 84 10 80       	push   $0x80108454
-80106726:	e8 85 9f ff ff       	call   801006b0 <cprintf>
-      panic("trap");
-8010672b:	83 c4 14             	add    $0x14,%esp
-8010672e:	68 2a 84 10 80       	push   $0x8010842a
-80106733:	e8 58 9c ff ff       	call   80100390 <panic>
-80106738:	66 90                	xchg   %ax,%ax
-8010673a:	66 90                	xchg   %ax,%ax
-8010673c:	66 90                	xchg   %ax,%ax
-8010673e:	66 90                	xchg   %ax,%ax
-
-80106740 <uartgetc>:
-  outb(COM1+0, c);
-}
-
-static int
-uartgetc(void)
-{
-80106740:	f3 0f 1e fb          	endbr32 
-  if(!uart)
-80106744:	a1 c8 b5 10 80       	mov    0x8010b5c8,%eax
-80106749:	85 c0                	test   %eax,%eax
-8010674b:	74 1b                	je     80106768 <uartgetc+0x28>
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-8010674d:	ba fd 03 00 00       	mov    $0x3fd,%edx
-80106752:	ec                   	in     (%dx),%al
-    return -1;
-  if(!(inb(COM1+5) & 0x01))
-80106753:	a8 01                	test   $0x1,%al
-80106755:	74 11                	je     80106768 <uartgetc+0x28>
-80106757:	ba f8 03 00 00       	mov    $0x3f8,%edx
-8010675c:	ec                   	in     (%dx),%al
-    return -1;
-  return inb(COM1+0);
-8010675d:	0f b6 c0             	movzbl %al,%eax
-80106760:	c3                   	ret    
-80106761:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
-80106768:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-8010676d:	c3                   	ret    
-8010676e:	66 90                	xchg   %ax,%ax
-
-80106770 <uartputc.part.0>:
-uartputc(int c)
-80106770:	55                   	push   %ebp
-80106771:	89 e5                	mov    %esp,%ebp
-80106773:	57                   	push   %edi
-80106774:	89 c7                	mov    %eax,%edi
-80106776:	56                   	push   %esi
-80106777:	be fd 03 00 00       	mov    $0x3fd,%esi
-8010677c:	53                   	push   %ebx
-8010677d:	bb 80 00 00 00       	mov    $0x80,%ebx
-80106782:	83 ec 0c             	sub    $0xc,%esp
-80106785:	eb 1b                	jmp    801067a2 <uartputc.part.0+0x32>
-80106787:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010678e:	66 90                	xchg   %ax,%ax
-    microdelay(10);
-80106790:	83 ec 0c             	sub    $0xc,%esp
-80106793:	6a 0a                	push   $0xa
-80106795:	e8 46 c1 ff ff       	call   801028e0 <microdelay>
-  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
-8010679a:	83 c4 10             	add    $0x10,%esp
-8010679d:	83 eb 01             	sub    $0x1,%ebx
-801067a0:	74 07                	je     801067a9 <uartputc.part.0+0x39>
-801067a2:	89 f2                	mov    %esi,%edx
-801067a4:	ec                   	in     (%dx),%al
-801067a5:	a8 20                	test   $0x20,%al
-801067a7:	74 e7                	je     80106790 <uartputc.part.0+0x20>
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-801067a9:	ba f8 03 00 00       	mov    $0x3f8,%edx
-801067ae:	89 f8                	mov    %edi,%eax
-801067b0:	ee                   	out    %al,(%dx)
-}
-801067b1:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801067b4:	5b                   	pop    %ebx
-801067b5:	5e                   	pop    %esi
-801067b6:	5f                   	pop    %edi
-801067b7:	5d                   	pop    %ebp
-801067b8:	c3                   	ret    
-801067b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-801067c0 <uartinit>:
-{
-801067c0:	f3 0f 1e fb          	endbr32 
-801067c4:	55                   	push   %ebp
-801067c5:	31 c9                	xor    %ecx,%ecx
-801067c7:	89 c8                	mov    %ecx,%eax
-801067c9:	89 e5                	mov    %esp,%ebp
-801067cb:	57                   	push   %edi
-801067cc:	56                   	push   %esi
-801067cd:	53                   	push   %ebx
-801067ce:	bb fa 03 00 00       	mov    $0x3fa,%ebx
-801067d3:	89 da                	mov    %ebx,%edx
-801067d5:	83 ec 0c             	sub    $0xc,%esp
-801067d8:	ee                   	out    %al,(%dx)
-801067d9:	bf fb 03 00 00       	mov    $0x3fb,%edi
-801067de:	b8 80 ff ff ff       	mov    $0xffffff80,%eax
-801067e3:	89 fa                	mov    %edi,%edx
-801067e5:	ee                   	out    %al,(%dx)
-801067e6:	b8 0c 00 00 00       	mov    $0xc,%eax
-801067eb:	ba f8 03 00 00       	mov    $0x3f8,%edx
-801067f0:	ee                   	out    %al,(%dx)
-801067f1:	be f9 03 00 00       	mov    $0x3f9,%esi
-801067f6:	89 c8                	mov    %ecx,%eax
-801067f8:	89 f2                	mov    %esi,%edx
-801067fa:	ee                   	out    %al,(%dx)
-801067fb:	b8 03 00 00 00       	mov    $0x3,%eax
-80106800:	89 fa                	mov    %edi,%edx
-80106802:	ee                   	out    %al,(%dx)
-80106803:	ba fc 03 00 00       	mov    $0x3fc,%edx
-80106808:	89 c8                	mov    %ecx,%eax
-8010680a:	ee                   	out    %al,(%dx)
-8010680b:	b8 01 00 00 00       	mov    $0x1,%eax
-80106810:	89 f2                	mov    %esi,%edx
-80106812:	ee                   	out    %al,(%dx)
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-80106813:	ba fd 03 00 00       	mov    $0x3fd,%edx
-80106818:	ec                   	in     (%dx),%al
-  if(inb(COM1+5) == 0xFF)
-80106819:	3c ff                	cmp    $0xff,%al
-8010681b:	74 52                	je     8010686f <uartinit+0xaf>
-  uart = 1;
-8010681d:	c7 05 c8 b5 10 80 01 	movl   $0x1,0x8010b5c8
-80106824:	00 00 00 
-80106827:	89 da                	mov    %ebx,%edx
-80106829:	ec                   	in     (%dx),%al
-8010682a:	ba f8 03 00 00       	mov    $0x3f8,%edx
-8010682f:	ec                   	in     (%dx),%al
-  ioapicenable(IRQ_COM1, 0);
-80106830:	83 ec 08             	sub    $0x8,%esp
-80106833:	be 76 00 00 00       	mov    $0x76,%esi
-  for(p="xv6...\n"; *p; p++)
-80106838:	bb 4c 85 10 80       	mov    $0x8010854c,%ebx
-  ioapicenable(IRQ_COM1, 0);
-8010683d:	6a 00                	push   $0x0
-8010683f:	6a 04                	push   $0x4
-80106841:	e8 ea bb ff ff       	call   80102430 <ioapicenable>
-80106846:	83 c4 10             	add    $0x10,%esp
-  for(p="xv6...\n"; *p; p++)
-80106849:	b8 78 00 00 00       	mov    $0x78,%eax
-8010684e:	eb 04                	jmp    80106854 <uartinit+0x94>
-80106850:	0f b6 73 01          	movzbl 0x1(%ebx),%esi
-  if(!uart)
-80106854:	8b 15 c8 b5 10 80    	mov    0x8010b5c8,%edx
-8010685a:	85 d2                	test   %edx,%edx
-8010685c:	74 08                	je     80106866 <uartinit+0xa6>
-    uartputc(*p);
-8010685e:	0f be c0             	movsbl %al,%eax
-80106861:	e8 0a ff ff ff       	call   80106770 <uartputc.part.0>
-  for(p="xv6...\n"; *p; p++)
-80106866:	89 f0                	mov    %esi,%eax
-80106868:	83 c3 01             	add    $0x1,%ebx
-8010686b:	84 c0                	test   %al,%al
-8010686d:	75 e1                	jne    80106850 <uartinit+0x90>
-}
-8010686f:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80106872:	5b                   	pop    %ebx
-80106873:	5e                   	pop    %esi
-80106874:	5f                   	pop    %edi
-80106875:	5d                   	pop    %ebp
-80106876:	c3                   	ret    
-80106877:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010687e:	66 90                	xchg   %ax,%ax
-
-80106880 <uartputc>:
-{
-80106880:	f3 0f 1e fb          	endbr32 
-80106884:	55                   	push   %ebp
-  if(!uart)
-80106885:	8b 15 c8 b5 10 80    	mov    0x8010b5c8,%edx
-{
-8010688b:	89 e5                	mov    %esp,%ebp
-8010688d:	8b 45 08             	mov    0x8(%ebp),%eax
-  if(!uart)
-80106890:	85 d2                	test   %edx,%edx
-80106892:	74 0c                	je     801068a0 <uartputc+0x20>
-}
-80106894:	5d                   	pop    %ebp
-80106895:	e9 d6 fe ff ff       	jmp    80106770 <uartputc.part.0>
-8010689a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-801068a0:	5d                   	pop    %ebp
-801068a1:	c3                   	ret    
-801068a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801068a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-801068b0 <uartintr>:
-
-void
-uartintr(void)
-{
-801068b0:	f3 0f 1e fb          	endbr32 
-801068b4:	55                   	push   %ebp
-801068b5:	89 e5                	mov    %esp,%ebp
-801068b7:	83 ec 14             	sub    $0x14,%esp
-  consoleintr(uartgetc);
-801068ba:	68 40 67 10 80       	push   $0x80106740
-801068bf:	e8 9c 9f ff ff       	call   80100860 <consoleintr>
-}
-801068c4:	83 c4 10             	add    $0x10,%esp
-801068c7:	c9                   	leave  
-801068c8:	c3                   	ret    
-
-801068c9 <vector0>:
-# generated by vectors.pl - do not edit
-# handlers
-.globl alltraps
-.globl vector0
-vector0:
-  pushl $0
-801068c9:	6a 00                	push   $0x0
-  pushl $0
-801068cb:	6a 00                	push   $0x0
-  jmp alltraps
-801068cd:	e9 c5 fa ff ff       	jmp    80106397 <alltraps>
-
-801068d2 <vector1>:
-.globl vector1
-vector1:
-  pushl $0
-801068d2:	6a 00                	push   $0x0
-  pushl $1
-801068d4:	6a 01                	push   $0x1
-  jmp alltraps
-801068d6:	e9 bc fa ff ff       	jmp    80106397 <alltraps>
-
-801068db <vector2>:
-.globl vector2
-vector2:
-  pushl $0
-801068db:	6a 00                	push   $0x0
-  pushl $2
-801068dd:	6a 02                	push   $0x2
-  jmp alltraps
-801068df:	e9 b3 fa ff ff       	jmp    80106397 <alltraps>
-
-801068e4 <vector3>:
-.globl vector3
-vector3:
-  pushl $0
-801068e4:	6a 00                	push   $0x0
-  pushl $3
-801068e6:	6a 03                	push   $0x3
-  jmp alltraps
-801068e8:	e9 aa fa ff ff       	jmp    80106397 <alltraps>
-
-801068ed <vector4>:
-.globl vector4
-vector4:
-  pushl $0
-801068ed:	6a 00                	push   $0x0
-  pushl $4
-801068ef:	6a 04                	push   $0x4
-  jmp alltraps
-801068f1:	e9 a1 fa ff ff       	jmp    80106397 <alltraps>
-
-801068f6 <vector5>:
-.globl vector5
-vector5:
-  pushl $0
-801068f6:	6a 00                	push   $0x0
-  pushl $5
-801068f8:	6a 05                	push   $0x5
-  jmp alltraps
-801068fa:	e9 98 fa ff ff       	jmp    80106397 <alltraps>
-
-801068ff <vector6>:
-.globl vector6
-vector6:
-  pushl $0
-801068ff:	6a 00                	push   $0x0
-  pushl $6
-80106901:	6a 06                	push   $0x6
-  jmp alltraps
-80106903:	e9 8f fa ff ff       	jmp    80106397 <alltraps>
-
-80106908 <vector7>:
-.globl vector7
-vector7:
-  pushl $0
-80106908:	6a 00                	push   $0x0
-  pushl $7
-8010690a:	6a 07                	push   $0x7
-  jmp alltraps
-8010690c:	e9 86 fa ff ff       	jmp    80106397 <alltraps>
-
-80106911 <vector8>:
-.globl vector8
-vector8:
-  pushl $8
-80106911:	6a 08                	push   $0x8
-  jmp alltraps
-80106913:	e9 7f fa ff ff       	jmp    80106397 <alltraps>
-
-80106918 <vector9>:
-.globl vector9
-vector9:
-  pushl $0
-80106918:	6a 00                	push   $0x0
-  pushl $9
-8010691a:	6a 09                	push   $0x9
-  jmp alltraps
-8010691c:	e9 76 fa ff ff       	jmp    80106397 <alltraps>
-
-80106921 <vector10>:
-.globl vector10
-vector10:
-  pushl $10
-80106921:	6a 0a                	push   $0xa
-  jmp alltraps
-80106923:	e9 6f fa ff ff       	jmp    80106397 <alltraps>
-
-80106928 <vector11>:
-.globl vector11
-vector11:
-  pushl $11
-80106928:	6a 0b                	push   $0xb
-  jmp alltraps
-8010692a:	e9 68 fa ff ff       	jmp    80106397 <alltraps>
-
-8010692f <vector12>:
-.globl vector12
-vector12:
-  pushl $12
-8010692f:	6a 0c                	push   $0xc
-  jmp alltraps
-80106931:	e9 61 fa ff ff       	jmp    80106397 <alltraps>
-
-80106936 <vector13>:
-.globl vector13
-vector13:
-  pushl $13
-80106936:	6a 0d                	push   $0xd
-  jmp alltraps
-80106938:	e9 5a fa ff ff       	jmp    80106397 <alltraps>
-
-8010693d <vector14>:
-.globl vector14
-vector14:
-  pushl $14
-8010693d:	6a 0e                	push   $0xe
-  jmp alltraps
-8010693f:	e9 53 fa ff ff       	jmp    80106397 <alltraps>
-
-80106944 <vector15>:
-.globl vector15
-vector15:
-  pushl $0
-80106944:	6a 00                	push   $0x0
-  pushl $15
-80106946:	6a 0f                	push   $0xf
-  jmp alltraps
-80106948:	e9 4a fa ff ff       	jmp    80106397 <alltraps>
-
-8010694d <vector16>:
-.globl vector16
-vector16:
-  pushl $0
-8010694d:	6a 00                	push   $0x0
-  pushl $16
-8010694f:	6a 10                	push   $0x10
-  jmp alltraps
-80106951:	e9 41 fa ff ff       	jmp    80106397 <alltraps>
-
-80106956 <vector17>:
-.globl vector17
-vector17:
-  pushl $17
-80106956:	6a 11                	push   $0x11
-  jmp alltraps
-80106958:	e9 3a fa ff ff       	jmp    80106397 <alltraps>
-
-8010695d <vector18>:
-.globl vector18
-vector18:
-  pushl $0
-8010695d:	6a 00                	push   $0x0
-  pushl $18
-8010695f:	6a 12                	push   $0x12
-  jmp alltraps
-80106961:	e9 31 fa ff ff       	jmp    80106397 <alltraps>
-
-80106966 <vector19>:
-.globl vector19
-vector19:
-  pushl $0
-80106966:	6a 00                	push   $0x0
-  pushl $19
-80106968:	6a 13                	push   $0x13
-  jmp alltraps
-8010696a:	e9 28 fa ff ff       	jmp    80106397 <alltraps>
-
-8010696f <vector20>:
-.globl vector20
-vector20:
-  pushl $0
-8010696f:	6a 00                	push   $0x0
-  pushl $20
-80106971:	6a 14                	push   $0x14
-  jmp alltraps
-80106973:	e9 1f fa ff ff       	jmp    80106397 <alltraps>
-
-80106978 <vector21>:
-.globl vector21
-vector21:
-  pushl $0
-80106978:	6a 00                	push   $0x0
-  pushl $21
-8010697a:	6a 15                	push   $0x15
-  jmp alltraps
-8010697c:	e9 16 fa ff ff       	jmp    80106397 <alltraps>
-
-80106981 <vector22>:
-.globl vector22
-vector22:
-  pushl $0
-80106981:	6a 00                	push   $0x0
-  pushl $22
-80106983:	6a 16                	push   $0x16
-  jmp alltraps
-80106985:	e9 0d fa ff ff       	jmp    80106397 <alltraps>
-
-8010698a <vector23>:
-.globl vector23
-vector23:
-  pushl $0
-8010698a:	6a 00                	push   $0x0
-  pushl $23
-8010698c:	6a 17                	push   $0x17
-  jmp alltraps
-8010698e:	e9 04 fa ff ff       	jmp    80106397 <alltraps>
-
-80106993 <vector24>:
-.globl vector24
-vector24:
-  pushl $0
-80106993:	6a 00                	push   $0x0
-  pushl $24
-80106995:	6a 18                	push   $0x18
-  jmp alltraps
-80106997:	e9 fb f9 ff ff       	jmp    80106397 <alltraps>
-
-8010699c <vector25>:
-.globl vector25
-vector25:
-  pushl $0
-8010699c:	6a 00                	push   $0x0
-  pushl $25
-8010699e:	6a 19                	push   $0x19
-  jmp alltraps
-801069a0:	e9 f2 f9 ff ff       	jmp    80106397 <alltraps>
-
-801069a5 <vector26>:
-.globl vector26
-vector26:
-  pushl $0
-801069a5:	6a 00                	push   $0x0
-  pushl $26
-801069a7:	6a 1a                	push   $0x1a
-  jmp alltraps
-801069a9:	e9 e9 f9 ff ff       	jmp    80106397 <alltraps>
-
-801069ae <vector27>:
-.globl vector27
-vector27:
-  pushl $0
-801069ae:	6a 00                	push   $0x0
-  pushl $27
-801069b0:	6a 1b                	push   $0x1b
-  jmp alltraps
-801069b2:	e9 e0 f9 ff ff       	jmp    80106397 <alltraps>
-
-801069b7 <vector28>:
-.globl vector28
-vector28:
-  pushl $0
-801069b7:	6a 00                	push   $0x0
-  pushl $28
-801069b9:	6a 1c                	push   $0x1c
-  jmp alltraps
-801069bb:	e9 d7 f9 ff ff       	jmp    80106397 <alltraps>
-
-801069c0 <vector29>:
-.globl vector29
-vector29:
-  pushl $0
-801069c0:	6a 00                	push   $0x0
-  pushl $29
-801069c2:	6a 1d                	push   $0x1d
-  jmp alltraps
-801069c4:	e9 ce f9 ff ff       	jmp    80106397 <alltraps>
-
-801069c9 <vector30>:
-.globl vector30
-vector30:
-  pushl $0
-801069c9:	6a 00                	push   $0x0
-  pushl $30
-801069cb:	6a 1e                	push   $0x1e
-  jmp alltraps
-801069cd:	e9 c5 f9 ff ff       	jmp    80106397 <alltraps>
-
-801069d2 <vector31>:
-.globl vector31
-vector31:
-  pushl $0
-801069d2:	6a 00                	push   $0x0
-  pushl $31
-801069d4:	6a 1f                	push   $0x1f
-  jmp alltraps
-801069d6:	e9 bc f9 ff ff       	jmp    80106397 <alltraps>
-
-801069db <vector32>:
-.globl vector32
-vector32:
-  pushl $0
-801069db:	6a 00                	push   $0x0
-  pushl $32
-801069dd:	6a 20                	push   $0x20
-  jmp alltraps
-801069df:	e9 b3 f9 ff ff       	jmp    80106397 <alltraps>
-
-801069e4 <vector33>:
-.globl vector33
-vector33:
-  pushl $0
-801069e4:	6a 00                	push   $0x0
-  pushl $33
-801069e6:	6a 21                	push   $0x21
-  jmp alltraps
-801069e8:	e9 aa f9 ff ff       	jmp    80106397 <alltraps>
-
-801069ed <vector34>:
-.globl vector34
-vector34:
-  pushl $0
-801069ed:	6a 00                	push   $0x0
-  pushl $34
-801069ef:	6a 22                	push   $0x22
-  jmp alltraps
-801069f1:	e9 a1 f9 ff ff       	jmp    80106397 <alltraps>
-
-801069f6 <vector35>:
-.globl vector35
-vector35:
-  pushl $0
-801069f6:	6a 00                	push   $0x0
-  pushl $35
-801069f8:	6a 23                	push   $0x23
-  jmp alltraps
-801069fa:	e9 98 f9 ff ff       	jmp    80106397 <alltraps>
-
-801069ff <vector36>:
-.globl vector36
-vector36:
-  pushl $0
-801069ff:	6a 00                	push   $0x0
-  pushl $36
-80106a01:	6a 24                	push   $0x24
-  jmp alltraps
-80106a03:	e9 8f f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a08 <vector37>:
-.globl vector37
-vector37:
-  pushl $0
-80106a08:	6a 00                	push   $0x0
-  pushl $37
-80106a0a:	6a 25                	push   $0x25
-  jmp alltraps
-80106a0c:	e9 86 f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a11 <vector38>:
-.globl vector38
-vector38:
-  pushl $0
-80106a11:	6a 00                	push   $0x0
-  pushl $38
-80106a13:	6a 26                	push   $0x26
-  jmp alltraps
-80106a15:	e9 7d f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a1a <vector39>:
-.globl vector39
-vector39:
-  pushl $0
-80106a1a:	6a 00                	push   $0x0
-  pushl $39
-80106a1c:	6a 27                	push   $0x27
-  jmp alltraps
-80106a1e:	e9 74 f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a23 <vector40>:
-.globl vector40
-vector40:
-  pushl $0
-80106a23:	6a 00                	push   $0x0
-  pushl $40
-80106a25:	6a 28                	push   $0x28
-  jmp alltraps
-80106a27:	e9 6b f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a2c <vector41>:
-.globl vector41
-vector41:
-  pushl $0
-80106a2c:	6a 00                	push   $0x0
-  pushl $41
-80106a2e:	6a 29                	push   $0x29
-  jmp alltraps
-80106a30:	e9 62 f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a35 <vector42>:
-.globl vector42
-vector42:
-  pushl $0
-80106a35:	6a 00                	push   $0x0
-  pushl $42
-80106a37:	6a 2a                	push   $0x2a
-  jmp alltraps
-80106a39:	e9 59 f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a3e <vector43>:
-.globl vector43
-vector43:
-  pushl $0
-80106a3e:	6a 00                	push   $0x0
-  pushl $43
-80106a40:	6a 2b                	push   $0x2b
-  jmp alltraps
-80106a42:	e9 50 f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a47 <vector44>:
-.globl vector44
-vector44:
-  pushl $0
-80106a47:	6a 00                	push   $0x0
-  pushl $44
-80106a49:	6a 2c                	push   $0x2c
-  jmp alltraps
-80106a4b:	e9 47 f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a50 <vector45>:
-.globl vector45
-vector45:
-  pushl $0
-80106a50:	6a 00                	push   $0x0
-  pushl $45
-80106a52:	6a 2d                	push   $0x2d
-  jmp alltraps
-80106a54:	e9 3e f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a59 <vector46>:
-.globl vector46
-vector46:
-  pushl $0
-80106a59:	6a 00                	push   $0x0
-  pushl $46
-80106a5b:	6a 2e                	push   $0x2e
-  jmp alltraps
-80106a5d:	e9 35 f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a62 <vector47>:
-.globl vector47
-vector47:
-  pushl $0
-80106a62:	6a 00                	push   $0x0
-  pushl $47
-80106a64:	6a 2f                	push   $0x2f
-  jmp alltraps
-80106a66:	e9 2c f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a6b <vector48>:
-.globl vector48
-vector48:
-  pushl $0
-80106a6b:	6a 00                	push   $0x0
-  pushl $48
-80106a6d:	6a 30                	push   $0x30
-  jmp alltraps
-80106a6f:	e9 23 f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a74 <vector49>:
-.globl vector49
-vector49:
-  pushl $0
-80106a74:	6a 00                	push   $0x0
-  pushl $49
-80106a76:	6a 31                	push   $0x31
-  jmp alltraps
-80106a78:	e9 1a f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a7d <vector50>:
-.globl vector50
-vector50:
-  pushl $0
-80106a7d:	6a 00                	push   $0x0
-  pushl $50
-80106a7f:	6a 32                	push   $0x32
-  jmp alltraps
-80106a81:	e9 11 f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a86 <vector51>:
-.globl vector51
-vector51:
-  pushl $0
-80106a86:	6a 00                	push   $0x0
-  pushl $51
-80106a88:	6a 33                	push   $0x33
-  jmp alltraps
-80106a8a:	e9 08 f9 ff ff       	jmp    80106397 <alltraps>
-
-80106a8f <vector52>:
-.globl vector52
-vector52:
-  pushl $0
-80106a8f:	6a 00                	push   $0x0
-  pushl $52
-80106a91:	6a 34                	push   $0x34
-  jmp alltraps
-80106a93:	e9 ff f8 ff ff       	jmp    80106397 <alltraps>
-
-80106a98 <vector53>:
-.globl vector53
-vector53:
-  pushl $0
-80106a98:	6a 00                	push   $0x0
-  pushl $53
-80106a9a:	6a 35                	push   $0x35
-  jmp alltraps
-80106a9c:	e9 f6 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106aa1 <vector54>:
-.globl vector54
-vector54:
-  pushl $0
-80106aa1:	6a 00                	push   $0x0
-  pushl $54
-80106aa3:	6a 36                	push   $0x36
-  jmp alltraps
-80106aa5:	e9 ed f8 ff ff       	jmp    80106397 <alltraps>
-
-80106aaa <vector55>:
-.globl vector55
-vector55:
-  pushl $0
-80106aaa:	6a 00                	push   $0x0
-  pushl $55
-80106aac:	6a 37                	push   $0x37
-  jmp alltraps
-80106aae:	e9 e4 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106ab3 <vector56>:
-.globl vector56
-vector56:
-  pushl $0
-80106ab3:	6a 00                	push   $0x0
-  pushl $56
-80106ab5:	6a 38                	push   $0x38
-  jmp alltraps
-80106ab7:	e9 db f8 ff ff       	jmp    80106397 <alltraps>
-
-80106abc <vector57>:
-.globl vector57
-vector57:
-  pushl $0
-80106abc:	6a 00                	push   $0x0
-  pushl $57
-80106abe:	6a 39                	push   $0x39
-  jmp alltraps
-80106ac0:	e9 d2 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106ac5 <vector58>:
-.globl vector58
-vector58:
-  pushl $0
-80106ac5:	6a 00                	push   $0x0
-  pushl $58
-80106ac7:	6a 3a                	push   $0x3a
-  jmp alltraps
-80106ac9:	e9 c9 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106ace <vector59>:
-.globl vector59
-vector59:
-  pushl $0
-80106ace:	6a 00                	push   $0x0
-  pushl $59
-80106ad0:	6a 3b                	push   $0x3b
-  jmp alltraps
-80106ad2:	e9 c0 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106ad7 <vector60>:
-.globl vector60
-vector60:
-  pushl $0
-80106ad7:	6a 00                	push   $0x0
-  pushl $60
-80106ad9:	6a 3c                	push   $0x3c
-  jmp alltraps
-80106adb:	e9 b7 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106ae0 <vector61>:
-.globl vector61
-vector61:
-  pushl $0
-80106ae0:	6a 00                	push   $0x0
-  pushl $61
-80106ae2:	6a 3d                	push   $0x3d
-  jmp alltraps
-80106ae4:	e9 ae f8 ff ff       	jmp    80106397 <alltraps>
-
-80106ae9 <vector62>:
-.globl vector62
-vector62:
-  pushl $0
-80106ae9:	6a 00                	push   $0x0
-  pushl $62
-80106aeb:	6a 3e                	push   $0x3e
-  jmp alltraps
-80106aed:	e9 a5 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106af2 <vector63>:
-.globl vector63
-vector63:
-  pushl $0
-80106af2:	6a 00                	push   $0x0
-  pushl $63
-80106af4:	6a 3f                	push   $0x3f
-  jmp alltraps
-80106af6:	e9 9c f8 ff ff       	jmp    80106397 <alltraps>
-
-80106afb <vector64>:
-.globl vector64
-vector64:
-  pushl $0
-80106afb:	6a 00                	push   $0x0
-  pushl $64
-80106afd:	6a 40                	push   $0x40
-  jmp alltraps
-80106aff:	e9 93 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b04 <vector65>:
-.globl vector65
-vector65:
-  pushl $0
-80106b04:	6a 00                	push   $0x0
-  pushl $65
-80106b06:	6a 41                	push   $0x41
-  jmp alltraps
-80106b08:	e9 8a f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b0d <vector66>:
-.globl vector66
-vector66:
-  pushl $0
-80106b0d:	6a 00                	push   $0x0
-  pushl $66
-80106b0f:	6a 42                	push   $0x42
-  jmp alltraps
-80106b11:	e9 81 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b16 <vector67>:
-.globl vector67
-vector67:
-  pushl $0
-80106b16:	6a 00                	push   $0x0
-  pushl $67
-80106b18:	6a 43                	push   $0x43
-  jmp alltraps
-80106b1a:	e9 78 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b1f <vector68>:
-.globl vector68
-vector68:
-  pushl $0
-80106b1f:	6a 00                	push   $0x0
-  pushl $68
-80106b21:	6a 44                	push   $0x44
-  jmp alltraps
-80106b23:	e9 6f f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b28 <vector69>:
-.globl vector69
-vector69:
-  pushl $0
-80106b28:	6a 00                	push   $0x0
-  pushl $69
-80106b2a:	6a 45                	push   $0x45
-  jmp alltraps
-80106b2c:	e9 66 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b31 <vector70>:
-.globl vector70
-vector70:
-  pushl $0
-80106b31:	6a 00                	push   $0x0
-  pushl $70
-80106b33:	6a 46                	push   $0x46
-  jmp alltraps
-80106b35:	e9 5d f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b3a <vector71>:
-.globl vector71
-vector71:
-  pushl $0
-80106b3a:	6a 00                	push   $0x0
-  pushl $71
-80106b3c:	6a 47                	push   $0x47
-  jmp alltraps
-80106b3e:	e9 54 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b43 <vector72>:
-.globl vector72
-vector72:
-  pushl $0
-80106b43:	6a 00                	push   $0x0
-  pushl $72
-80106b45:	6a 48                	push   $0x48
-  jmp alltraps
-80106b47:	e9 4b f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b4c <vector73>:
-.globl vector73
-vector73:
-  pushl $0
-80106b4c:	6a 00                	push   $0x0
-  pushl $73
-80106b4e:	6a 49                	push   $0x49
-  jmp alltraps
-80106b50:	e9 42 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b55 <vector74>:
-.globl vector74
-vector74:
-  pushl $0
-80106b55:	6a 00                	push   $0x0
-  pushl $74
-80106b57:	6a 4a                	push   $0x4a
-  jmp alltraps
-80106b59:	e9 39 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b5e <vector75>:
-.globl vector75
-vector75:
-  pushl $0
-80106b5e:	6a 00                	push   $0x0
-  pushl $75
-80106b60:	6a 4b                	push   $0x4b
-  jmp alltraps
-80106b62:	e9 30 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b67 <vector76>:
-.globl vector76
-vector76:
-  pushl $0
-80106b67:	6a 00                	push   $0x0
-  pushl $76
-80106b69:	6a 4c                	push   $0x4c
-  jmp alltraps
-80106b6b:	e9 27 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b70 <vector77>:
-.globl vector77
-vector77:
-  pushl $0
-80106b70:	6a 00                	push   $0x0
-  pushl $77
-80106b72:	6a 4d                	push   $0x4d
-  jmp alltraps
-80106b74:	e9 1e f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b79 <vector78>:
-.globl vector78
-vector78:
-  pushl $0
-80106b79:	6a 00                	push   $0x0
-  pushl $78
-80106b7b:	6a 4e                	push   $0x4e
-  jmp alltraps
-80106b7d:	e9 15 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b82 <vector79>:
-.globl vector79
-vector79:
-  pushl $0
-80106b82:	6a 00                	push   $0x0
-  pushl $79
-80106b84:	6a 4f                	push   $0x4f
-  jmp alltraps
-80106b86:	e9 0c f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b8b <vector80>:
-.globl vector80
-vector80:
-  pushl $0
-80106b8b:	6a 00                	push   $0x0
-  pushl $80
-80106b8d:	6a 50                	push   $0x50
-  jmp alltraps
-80106b8f:	e9 03 f8 ff ff       	jmp    80106397 <alltraps>
-
-80106b94 <vector81>:
-.globl vector81
-vector81:
-  pushl $0
-80106b94:	6a 00                	push   $0x0
-  pushl $81
-80106b96:	6a 51                	push   $0x51
-  jmp alltraps
-80106b98:	e9 fa f7 ff ff       	jmp    80106397 <alltraps>
-
-80106b9d <vector82>:
-.globl vector82
-vector82:
-  pushl $0
-80106b9d:	6a 00                	push   $0x0
-  pushl $82
-80106b9f:	6a 52                	push   $0x52
-  jmp alltraps
-80106ba1:	e9 f1 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106ba6 <vector83>:
-.globl vector83
-vector83:
-  pushl $0
-80106ba6:	6a 00                	push   $0x0
-  pushl $83
-80106ba8:	6a 53                	push   $0x53
-  jmp alltraps
-80106baa:	e9 e8 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106baf <vector84>:
-.globl vector84
-vector84:
-  pushl $0
-80106baf:	6a 00                	push   $0x0
-  pushl $84
-80106bb1:	6a 54                	push   $0x54
-  jmp alltraps
-80106bb3:	e9 df f7 ff ff       	jmp    80106397 <alltraps>
-
-80106bb8 <vector85>:
-.globl vector85
-vector85:
-  pushl $0
-80106bb8:	6a 00                	push   $0x0
-  pushl $85
-80106bba:	6a 55                	push   $0x55
-  jmp alltraps
-80106bbc:	e9 d6 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106bc1 <vector86>:
-.globl vector86
-vector86:
-  pushl $0
-80106bc1:	6a 00                	push   $0x0
-  pushl $86
-80106bc3:	6a 56                	push   $0x56
-  jmp alltraps
-80106bc5:	e9 cd f7 ff ff       	jmp    80106397 <alltraps>
-
-80106bca <vector87>:
-.globl vector87
-vector87:
-  pushl $0
-80106bca:	6a 00                	push   $0x0
-  pushl $87
-80106bcc:	6a 57                	push   $0x57
-  jmp alltraps
-80106bce:	e9 c4 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106bd3 <vector88>:
-.globl vector88
-vector88:
-  pushl $0
-80106bd3:	6a 00                	push   $0x0
-  pushl $88
-80106bd5:	6a 58                	push   $0x58
-  jmp alltraps
-80106bd7:	e9 bb f7 ff ff       	jmp    80106397 <alltraps>
-
-80106bdc <vector89>:
-.globl vector89
-vector89:
-  pushl $0
-80106bdc:	6a 00                	push   $0x0
-  pushl $89
-80106bde:	6a 59                	push   $0x59
-  jmp alltraps
-80106be0:	e9 b2 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106be5 <vector90>:
-.globl vector90
-vector90:
-  pushl $0
-80106be5:	6a 00                	push   $0x0
-  pushl $90
-80106be7:	6a 5a                	push   $0x5a
-  jmp alltraps
-80106be9:	e9 a9 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106bee <vector91>:
-.globl vector91
-vector91:
-  pushl $0
-80106bee:	6a 00                	push   $0x0
-  pushl $91
-80106bf0:	6a 5b                	push   $0x5b
-  jmp alltraps
-80106bf2:	e9 a0 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106bf7 <vector92>:
-.globl vector92
-vector92:
-  pushl $0
-80106bf7:	6a 00                	push   $0x0
-  pushl $92
-80106bf9:	6a 5c                	push   $0x5c
-  jmp alltraps
-80106bfb:	e9 97 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c00 <vector93>:
-.globl vector93
-vector93:
-  pushl $0
-80106c00:	6a 00                	push   $0x0
-  pushl $93
-80106c02:	6a 5d                	push   $0x5d
-  jmp alltraps
-80106c04:	e9 8e f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c09 <vector94>:
-.globl vector94
-vector94:
-  pushl $0
-80106c09:	6a 00                	push   $0x0
-  pushl $94
-80106c0b:	6a 5e                	push   $0x5e
-  jmp alltraps
-80106c0d:	e9 85 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c12 <vector95>:
-.globl vector95
-vector95:
-  pushl $0
-80106c12:	6a 00                	push   $0x0
-  pushl $95
-80106c14:	6a 5f                	push   $0x5f
-  jmp alltraps
-80106c16:	e9 7c f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c1b <vector96>:
-.globl vector96
-vector96:
-  pushl $0
-80106c1b:	6a 00                	push   $0x0
-  pushl $96
-80106c1d:	6a 60                	push   $0x60
-  jmp alltraps
-80106c1f:	e9 73 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c24 <vector97>:
-.globl vector97
-vector97:
-  pushl $0
-80106c24:	6a 00                	push   $0x0
-  pushl $97
-80106c26:	6a 61                	push   $0x61
-  jmp alltraps
-80106c28:	e9 6a f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c2d <vector98>:
-.globl vector98
-vector98:
-  pushl $0
-80106c2d:	6a 00                	push   $0x0
-  pushl $98
-80106c2f:	6a 62                	push   $0x62
-  jmp alltraps
-80106c31:	e9 61 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c36 <vector99>:
-.globl vector99
-vector99:
-  pushl $0
-80106c36:	6a 00                	push   $0x0
-  pushl $99
-80106c38:	6a 63                	push   $0x63
-  jmp alltraps
-80106c3a:	e9 58 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c3f <vector100>:
-.globl vector100
-vector100:
-  pushl $0
-80106c3f:	6a 00                	push   $0x0
-  pushl $100
-80106c41:	6a 64                	push   $0x64
-  jmp alltraps
-80106c43:	e9 4f f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c48 <vector101>:
-.globl vector101
-vector101:
-  pushl $0
-80106c48:	6a 00                	push   $0x0
-  pushl $101
-80106c4a:	6a 65                	push   $0x65
-  jmp alltraps
-80106c4c:	e9 46 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c51 <vector102>:
-.globl vector102
-vector102:
-  pushl $0
-80106c51:	6a 00                	push   $0x0
-  pushl $102
-80106c53:	6a 66                	push   $0x66
-  jmp alltraps
-80106c55:	e9 3d f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c5a <vector103>:
-.globl vector103
-vector103:
-  pushl $0
-80106c5a:	6a 00                	push   $0x0
-  pushl $103
-80106c5c:	6a 67                	push   $0x67
-  jmp alltraps
-80106c5e:	e9 34 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c63 <vector104>:
-.globl vector104
-vector104:
-  pushl $0
-80106c63:	6a 00                	push   $0x0
-  pushl $104
-80106c65:	6a 68                	push   $0x68
-  jmp alltraps
-80106c67:	e9 2b f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c6c <vector105>:
-.globl vector105
-vector105:
-  pushl $0
-80106c6c:	6a 00                	push   $0x0
-  pushl $105
-80106c6e:	6a 69                	push   $0x69
-  jmp alltraps
-80106c70:	e9 22 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c75 <vector106>:
-.globl vector106
-vector106:
-  pushl $0
-80106c75:	6a 00                	push   $0x0
-  pushl $106
-80106c77:	6a 6a                	push   $0x6a
-  jmp alltraps
-80106c79:	e9 19 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c7e <vector107>:
-.globl vector107
-vector107:
-  pushl $0
-80106c7e:	6a 00                	push   $0x0
-  pushl $107
-80106c80:	6a 6b                	push   $0x6b
-  jmp alltraps
-80106c82:	e9 10 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c87 <vector108>:
-.globl vector108
-vector108:
-  pushl $0
-80106c87:	6a 00                	push   $0x0
-  pushl $108
-80106c89:	6a 6c                	push   $0x6c
-  jmp alltraps
-80106c8b:	e9 07 f7 ff ff       	jmp    80106397 <alltraps>
-
-80106c90 <vector109>:
-.globl vector109
-vector109:
-  pushl $0
-80106c90:	6a 00                	push   $0x0
-  pushl $109
-80106c92:	6a 6d                	push   $0x6d
-  jmp alltraps
-80106c94:	e9 fe f6 ff ff       	jmp    80106397 <alltraps>
-
-80106c99 <vector110>:
-.globl vector110
-vector110:
-  pushl $0
-80106c99:	6a 00                	push   $0x0
-  pushl $110
-80106c9b:	6a 6e                	push   $0x6e
-  jmp alltraps
-80106c9d:	e9 f5 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106ca2 <vector111>:
-.globl vector111
-vector111:
-  pushl $0
-80106ca2:	6a 00                	push   $0x0
-  pushl $111
-80106ca4:	6a 6f                	push   $0x6f
-  jmp alltraps
-80106ca6:	e9 ec f6 ff ff       	jmp    80106397 <alltraps>
-
-80106cab <vector112>:
-.globl vector112
-vector112:
-  pushl $0
-80106cab:	6a 00                	push   $0x0
-  pushl $112
-80106cad:	6a 70                	push   $0x70
-  jmp alltraps
-80106caf:	e9 e3 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106cb4 <vector113>:
-.globl vector113
-vector113:
-  pushl $0
-80106cb4:	6a 00                	push   $0x0
-  pushl $113
-80106cb6:	6a 71                	push   $0x71
-  jmp alltraps
-80106cb8:	e9 da f6 ff ff       	jmp    80106397 <alltraps>
-
-80106cbd <vector114>:
-.globl vector114
-vector114:
-  pushl $0
-80106cbd:	6a 00                	push   $0x0
-  pushl $114
-80106cbf:	6a 72                	push   $0x72
-  jmp alltraps
-80106cc1:	e9 d1 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106cc6 <vector115>:
-.globl vector115
-vector115:
-  pushl $0
-80106cc6:	6a 00                	push   $0x0
-  pushl $115
-80106cc8:	6a 73                	push   $0x73
-  jmp alltraps
-80106cca:	e9 c8 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106ccf <vector116>:
-.globl vector116
-vector116:
-  pushl $0
-80106ccf:	6a 00                	push   $0x0
-  pushl $116
-80106cd1:	6a 74                	push   $0x74
-  jmp alltraps
-80106cd3:	e9 bf f6 ff ff       	jmp    80106397 <alltraps>
-
-80106cd8 <vector117>:
-.globl vector117
-vector117:
-  pushl $0
-80106cd8:	6a 00                	push   $0x0
-  pushl $117
-80106cda:	6a 75                	push   $0x75
-  jmp alltraps
-80106cdc:	e9 b6 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106ce1 <vector118>:
-.globl vector118
-vector118:
-  pushl $0
-80106ce1:	6a 00                	push   $0x0
-  pushl $118
-80106ce3:	6a 76                	push   $0x76
-  jmp alltraps
-80106ce5:	e9 ad f6 ff ff       	jmp    80106397 <alltraps>
-
-80106cea <vector119>:
-.globl vector119
-vector119:
-  pushl $0
-80106cea:	6a 00                	push   $0x0
-  pushl $119
-80106cec:	6a 77                	push   $0x77
-  jmp alltraps
-80106cee:	e9 a4 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106cf3 <vector120>:
-.globl vector120
-vector120:
-  pushl $0
-80106cf3:	6a 00                	push   $0x0
-  pushl $120
-80106cf5:	6a 78                	push   $0x78
-  jmp alltraps
-80106cf7:	e9 9b f6 ff ff       	jmp    80106397 <alltraps>
-
-80106cfc <vector121>:
-.globl vector121
-vector121:
-  pushl $0
-80106cfc:	6a 00                	push   $0x0
-  pushl $121
-80106cfe:	6a 79                	push   $0x79
-  jmp alltraps
-80106d00:	e9 92 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d05 <vector122>:
-.globl vector122
-vector122:
-  pushl $0
-80106d05:	6a 00                	push   $0x0
-  pushl $122
-80106d07:	6a 7a                	push   $0x7a
-  jmp alltraps
-80106d09:	e9 89 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d0e <vector123>:
-.globl vector123
-vector123:
-  pushl $0
-80106d0e:	6a 00                	push   $0x0
-  pushl $123
-80106d10:	6a 7b                	push   $0x7b
-  jmp alltraps
-80106d12:	e9 80 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d17 <vector124>:
-.globl vector124
-vector124:
-  pushl $0
-80106d17:	6a 00                	push   $0x0
-  pushl $124
-80106d19:	6a 7c                	push   $0x7c
-  jmp alltraps
-80106d1b:	e9 77 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d20 <vector125>:
-.globl vector125
-vector125:
-  pushl $0
-80106d20:	6a 00                	push   $0x0
-  pushl $125
-80106d22:	6a 7d                	push   $0x7d
-  jmp alltraps
-80106d24:	e9 6e f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d29 <vector126>:
-.globl vector126
-vector126:
-  pushl $0
-80106d29:	6a 00                	push   $0x0
-  pushl $126
-80106d2b:	6a 7e                	push   $0x7e
-  jmp alltraps
-80106d2d:	e9 65 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d32 <vector127>:
-.globl vector127
-vector127:
-  pushl $0
-80106d32:	6a 00                	push   $0x0
-  pushl $127
-80106d34:	6a 7f                	push   $0x7f
-  jmp alltraps
-80106d36:	e9 5c f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d3b <vector128>:
-.globl vector128
-vector128:
-  pushl $0
-80106d3b:	6a 00                	push   $0x0
-  pushl $128
-80106d3d:	68 80 00 00 00       	push   $0x80
-  jmp alltraps
-80106d42:	e9 50 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d47 <vector129>:
-.globl vector129
-vector129:
-  pushl $0
-80106d47:	6a 00                	push   $0x0
-  pushl $129
-80106d49:	68 81 00 00 00       	push   $0x81
-  jmp alltraps
-80106d4e:	e9 44 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d53 <vector130>:
-.globl vector130
-vector130:
-  pushl $0
-80106d53:	6a 00                	push   $0x0
-  pushl $130
-80106d55:	68 82 00 00 00       	push   $0x82
-  jmp alltraps
-80106d5a:	e9 38 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d5f <vector131>:
-.globl vector131
-vector131:
-  pushl $0
-80106d5f:	6a 00                	push   $0x0
-  pushl $131
-80106d61:	68 83 00 00 00       	push   $0x83
-  jmp alltraps
-80106d66:	e9 2c f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d6b <vector132>:
-.globl vector132
-vector132:
-  pushl $0
-80106d6b:	6a 00                	push   $0x0
-  pushl $132
-80106d6d:	68 84 00 00 00       	push   $0x84
-  jmp alltraps
-80106d72:	e9 20 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d77 <vector133>:
-.globl vector133
-vector133:
-  pushl $0
-80106d77:	6a 00                	push   $0x0
-  pushl $133
-80106d79:	68 85 00 00 00       	push   $0x85
-  jmp alltraps
-80106d7e:	e9 14 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d83 <vector134>:
-.globl vector134
-vector134:
-  pushl $0
-80106d83:	6a 00                	push   $0x0
-  pushl $134
-80106d85:	68 86 00 00 00       	push   $0x86
-  jmp alltraps
-80106d8a:	e9 08 f6 ff ff       	jmp    80106397 <alltraps>
-
-80106d8f <vector135>:
-.globl vector135
-vector135:
-  pushl $0
-80106d8f:	6a 00                	push   $0x0
-  pushl $135
-80106d91:	68 87 00 00 00       	push   $0x87
-  jmp alltraps
-80106d96:	e9 fc f5 ff ff       	jmp    80106397 <alltraps>
-
-80106d9b <vector136>:
-.globl vector136
-vector136:
-  pushl $0
-80106d9b:	6a 00                	push   $0x0
-  pushl $136
-80106d9d:	68 88 00 00 00       	push   $0x88
-  jmp alltraps
-80106da2:	e9 f0 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106da7 <vector137>:
-.globl vector137
-vector137:
-  pushl $0
-80106da7:	6a 00                	push   $0x0
-  pushl $137
-80106da9:	68 89 00 00 00       	push   $0x89
-  jmp alltraps
-80106dae:	e9 e4 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106db3 <vector138>:
-.globl vector138
-vector138:
-  pushl $0
-80106db3:	6a 00                	push   $0x0
-  pushl $138
-80106db5:	68 8a 00 00 00       	push   $0x8a
-  jmp alltraps
-80106dba:	e9 d8 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106dbf <vector139>:
-.globl vector139
-vector139:
-  pushl $0
-80106dbf:	6a 00                	push   $0x0
-  pushl $139
-80106dc1:	68 8b 00 00 00       	push   $0x8b
-  jmp alltraps
-80106dc6:	e9 cc f5 ff ff       	jmp    80106397 <alltraps>
-
-80106dcb <vector140>:
-.globl vector140
-vector140:
-  pushl $0
-80106dcb:	6a 00                	push   $0x0
-  pushl $140
-80106dcd:	68 8c 00 00 00       	push   $0x8c
-  jmp alltraps
-80106dd2:	e9 c0 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106dd7 <vector141>:
-.globl vector141
-vector141:
-  pushl $0
-80106dd7:	6a 00                	push   $0x0
-  pushl $141
-80106dd9:	68 8d 00 00 00       	push   $0x8d
-  jmp alltraps
-80106dde:	e9 b4 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106de3 <vector142>:
-.globl vector142
-vector142:
-  pushl $0
-80106de3:	6a 00                	push   $0x0
-  pushl $142
-80106de5:	68 8e 00 00 00       	push   $0x8e
-  jmp alltraps
-80106dea:	e9 a8 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106def <vector143>:
-.globl vector143
-vector143:
-  pushl $0
-80106def:	6a 00                	push   $0x0
-  pushl $143
-80106df1:	68 8f 00 00 00       	push   $0x8f
-  jmp alltraps
-80106df6:	e9 9c f5 ff ff       	jmp    80106397 <alltraps>
-
-80106dfb <vector144>:
-.globl vector144
-vector144:
-  pushl $0
-80106dfb:	6a 00                	push   $0x0
-  pushl $144
-80106dfd:	68 90 00 00 00       	push   $0x90
-  jmp alltraps
-80106e02:	e9 90 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e07 <vector145>:
-.globl vector145
-vector145:
-  pushl $0
-80106e07:	6a 00                	push   $0x0
-  pushl $145
-80106e09:	68 91 00 00 00       	push   $0x91
-  jmp alltraps
-80106e0e:	e9 84 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e13 <vector146>:
-.globl vector146
-vector146:
-  pushl $0
-80106e13:	6a 00                	push   $0x0
-  pushl $146
-80106e15:	68 92 00 00 00       	push   $0x92
-  jmp alltraps
-80106e1a:	e9 78 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e1f <vector147>:
-.globl vector147
-vector147:
-  pushl $0
-80106e1f:	6a 00                	push   $0x0
-  pushl $147
-80106e21:	68 93 00 00 00       	push   $0x93
-  jmp alltraps
-80106e26:	e9 6c f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e2b <vector148>:
-.globl vector148
-vector148:
-  pushl $0
-80106e2b:	6a 00                	push   $0x0
-  pushl $148
-80106e2d:	68 94 00 00 00       	push   $0x94
-  jmp alltraps
-80106e32:	e9 60 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e37 <vector149>:
-.globl vector149
-vector149:
-  pushl $0
-80106e37:	6a 00                	push   $0x0
-  pushl $149
-80106e39:	68 95 00 00 00       	push   $0x95
-  jmp alltraps
-80106e3e:	e9 54 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e43 <vector150>:
-.globl vector150
-vector150:
-  pushl $0
-80106e43:	6a 00                	push   $0x0
-  pushl $150
-80106e45:	68 96 00 00 00       	push   $0x96
-  jmp alltraps
-80106e4a:	e9 48 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e4f <vector151>:
-.globl vector151
-vector151:
-  pushl $0
-80106e4f:	6a 00                	push   $0x0
-  pushl $151
-80106e51:	68 97 00 00 00       	push   $0x97
-  jmp alltraps
-80106e56:	e9 3c f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e5b <vector152>:
-.globl vector152
-vector152:
-  pushl $0
-80106e5b:	6a 00                	push   $0x0
-  pushl $152
-80106e5d:	68 98 00 00 00       	push   $0x98
-  jmp alltraps
-80106e62:	e9 30 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e67 <vector153>:
-.globl vector153
-vector153:
-  pushl $0
-80106e67:	6a 00                	push   $0x0
-  pushl $153
-80106e69:	68 99 00 00 00       	push   $0x99
-  jmp alltraps
-80106e6e:	e9 24 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e73 <vector154>:
-.globl vector154
-vector154:
-  pushl $0
-80106e73:	6a 00                	push   $0x0
-  pushl $154
-80106e75:	68 9a 00 00 00       	push   $0x9a
-  jmp alltraps
-80106e7a:	e9 18 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e7f <vector155>:
-.globl vector155
-vector155:
-  pushl $0
-80106e7f:	6a 00                	push   $0x0
-  pushl $155
-80106e81:	68 9b 00 00 00       	push   $0x9b
-  jmp alltraps
-80106e86:	e9 0c f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e8b <vector156>:
-.globl vector156
-vector156:
-  pushl $0
-80106e8b:	6a 00                	push   $0x0
-  pushl $156
-80106e8d:	68 9c 00 00 00       	push   $0x9c
-  jmp alltraps
-80106e92:	e9 00 f5 ff ff       	jmp    80106397 <alltraps>
-
-80106e97 <vector157>:
-.globl vector157
-vector157:
-  pushl $0
-80106e97:	6a 00                	push   $0x0
-  pushl $157
-80106e99:	68 9d 00 00 00       	push   $0x9d
-  jmp alltraps
-80106e9e:	e9 f4 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106ea3 <vector158>:
-.globl vector158
-vector158:
-  pushl $0
-80106ea3:	6a 00                	push   $0x0
-  pushl $158
-80106ea5:	68 9e 00 00 00       	push   $0x9e
-  jmp alltraps
-80106eaa:	e9 e8 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106eaf <vector159>:
-.globl vector159
-vector159:
-  pushl $0
-80106eaf:	6a 00                	push   $0x0
-  pushl $159
-80106eb1:	68 9f 00 00 00       	push   $0x9f
-  jmp alltraps
-80106eb6:	e9 dc f4 ff ff       	jmp    80106397 <alltraps>
-
-80106ebb <vector160>:
-.globl vector160
-vector160:
-  pushl $0
-80106ebb:	6a 00                	push   $0x0
-  pushl $160
-80106ebd:	68 a0 00 00 00       	push   $0xa0
-  jmp alltraps
-80106ec2:	e9 d0 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106ec7 <vector161>:
-.globl vector161
-vector161:
-  pushl $0
-80106ec7:	6a 00                	push   $0x0
-  pushl $161
-80106ec9:	68 a1 00 00 00       	push   $0xa1
-  jmp alltraps
-80106ece:	e9 c4 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106ed3 <vector162>:
-.globl vector162
-vector162:
-  pushl $0
-80106ed3:	6a 00                	push   $0x0
-  pushl $162
-80106ed5:	68 a2 00 00 00       	push   $0xa2
-  jmp alltraps
-80106eda:	e9 b8 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106edf <vector163>:
-.globl vector163
-vector163:
-  pushl $0
-80106edf:	6a 00                	push   $0x0
-  pushl $163
-80106ee1:	68 a3 00 00 00       	push   $0xa3
-  jmp alltraps
-80106ee6:	e9 ac f4 ff ff       	jmp    80106397 <alltraps>
-
-80106eeb <vector164>:
-.globl vector164
-vector164:
-  pushl $0
-80106eeb:	6a 00                	push   $0x0
-  pushl $164
-80106eed:	68 a4 00 00 00       	push   $0xa4
-  jmp alltraps
-80106ef2:	e9 a0 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106ef7 <vector165>:
-.globl vector165
-vector165:
-  pushl $0
-80106ef7:	6a 00                	push   $0x0
-  pushl $165
-80106ef9:	68 a5 00 00 00       	push   $0xa5
-  jmp alltraps
-80106efe:	e9 94 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f03 <vector166>:
-.globl vector166
-vector166:
-  pushl $0
-80106f03:	6a 00                	push   $0x0
-  pushl $166
-80106f05:	68 a6 00 00 00       	push   $0xa6
-  jmp alltraps
-80106f0a:	e9 88 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f0f <vector167>:
-.globl vector167
-vector167:
-  pushl $0
-80106f0f:	6a 00                	push   $0x0
-  pushl $167
-80106f11:	68 a7 00 00 00       	push   $0xa7
-  jmp alltraps
-80106f16:	e9 7c f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f1b <vector168>:
-.globl vector168
-vector168:
-  pushl $0
-80106f1b:	6a 00                	push   $0x0
-  pushl $168
-80106f1d:	68 a8 00 00 00       	push   $0xa8
-  jmp alltraps
-80106f22:	e9 70 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f27 <vector169>:
-.globl vector169
-vector169:
-  pushl $0
-80106f27:	6a 00                	push   $0x0
-  pushl $169
-80106f29:	68 a9 00 00 00       	push   $0xa9
-  jmp alltraps
-80106f2e:	e9 64 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f33 <vector170>:
-.globl vector170
-vector170:
-  pushl $0
-80106f33:	6a 00                	push   $0x0
-  pushl $170
-80106f35:	68 aa 00 00 00       	push   $0xaa
-  jmp alltraps
-80106f3a:	e9 58 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f3f <vector171>:
-.globl vector171
-vector171:
-  pushl $0
-80106f3f:	6a 00                	push   $0x0
-  pushl $171
-80106f41:	68 ab 00 00 00       	push   $0xab
-  jmp alltraps
-80106f46:	e9 4c f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f4b <vector172>:
-.globl vector172
-vector172:
-  pushl $0
-80106f4b:	6a 00                	push   $0x0
-  pushl $172
-80106f4d:	68 ac 00 00 00       	push   $0xac
-  jmp alltraps
-80106f52:	e9 40 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f57 <vector173>:
-.globl vector173
-vector173:
-  pushl $0
-80106f57:	6a 00                	push   $0x0
-  pushl $173
-80106f59:	68 ad 00 00 00       	push   $0xad
-  jmp alltraps
-80106f5e:	e9 34 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f63 <vector174>:
-.globl vector174
-vector174:
-  pushl $0
-80106f63:	6a 00                	push   $0x0
-  pushl $174
-80106f65:	68 ae 00 00 00       	push   $0xae
-  jmp alltraps
-80106f6a:	e9 28 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f6f <vector175>:
-.globl vector175
-vector175:
-  pushl $0
-80106f6f:	6a 00                	push   $0x0
-  pushl $175
-80106f71:	68 af 00 00 00       	push   $0xaf
-  jmp alltraps
-80106f76:	e9 1c f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f7b <vector176>:
-.globl vector176
-vector176:
-  pushl $0
-80106f7b:	6a 00                	push   $0x0
-  pushl $176
-80106f7d:	68 b0 00 00 00       	push   $0xb0
-  jmp alltraps
-80106f82:	e9 10 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f87 <vector177>:
-.globl vector177
-vector177:
-  pushl $0
-80106f87:	6a 00                	push   $0x0
-  pushl $177
-80106f89:	68 b1 00 00 00       	push   $0xb1
-  jmp alltraps
-80106f8e:	e9 04 f4 ff ff       	jmp    80106397 <alltraps>
-
-80106f93 <vector178>:
-.globl vector178
-vector178:
-  pushl $0
-80106f93:	6a 00                	push   $0x0
-  pushl $178
-80106f95:	68 b2 00 00 00       	push   $0xb2
-  jmp alltraps
-80106f9a:	e9 f8 f3 ff ff       	jmp    80106397 <alltraps>
-
-80106f9f <vector179>:
-.globl vector179
-vector179:
-  pushl $0
-80106f9f:	6a 00                	push   $0x0
-  pushl $179
-80106fa1:	68 b3 00 00 00       	push   $0xb3
-  jmp alltraps
-80106fa6:	e9 ec f3 ff ff       	jmp    80106397 <alltraps>
-
-80106fab <vector180>:
-.globl vector180
-vector180:
-  pushl $0
-80106fab:	6a 00                	push   $0x0
-  pushl $180
-80106fad:	68 b4 00 00 00       	push   $0xb4
-  jmp alltraps
-80106fb2:	e9 e0 f3 ff ff       	jmp    80106397 <alltraps>
-
-80106fb7 <vector181>:
-.globl vector181
-vector181:
-  pushl $0
-80106fb7:	6a 00                	push   $0x0
-  pushl $181
-80106fb9:	68 b5 00 00 00       	push   $0xb5
-  jmp alltraps
-80106fbe:	e9 d4 f3 ff ff       	jmp    80106397 <alltraps>
-
-80106fc3 <vector182>:
-.globl vector182
-vector182:
-  pushl $0
-80106fc3:	6a 00                	push   $0x0
-  pushl $182
-80106fc5:	68 b6 00 00 00       	push   $0xb6
-  jmp alltraps
-80106fca:	e9 c8 f3 ff ff       	jmp    80106397 <alltraps>
-
-80106fcf <vector183>:
-.globl vector183
-vector183:
-  pushl $0
-80106fcf:	6a 00                	push   $0x0
-  pushl $183
-80106fd1:	68 b7 00 00 00       	push   $0xb7
-  jmp alltraps
-80106fd6:	e9 bc f3 ff ff       	jmp    80106397 <alltraps>
-
-80106fdb <vector184>:
-.globl vector184
-vector184:
-  pushl $0
-80106fdb:	6a 00                	push   $0x0
-  pushl $184
-80106fdd:	68 b8 00 00 00       	push   $0xb8
-  jmp alltraps
-80106fe2:	e9 b0 f3 ff ff       	jmp    80106397 <alltraps>
-
-80106fe7 <vector185>:
-.globl vector185
-vector185:
-  pushl $0
-80106fe7:	6a 00                	push   $0x0
-  pushl $185
-80106fe9:	68 b9 00 00 00       	push   $0xb9
-  jmp alltraps
-80106fee:	e9 a4 f3 ff ff       	jmp    80106397 <alltraps>
-
-80106ff3 <vector186>:
-.globl vector186
-vector186:
-  pushl $0
-80106ff3:	6a 00                	push   $0x0
-  pushl $186
-80106ff5:	68 ba 00 00 00       	push   $0xba
-  jmp alltraps
-80106ffa:	e9 98 f3 ff ff       	jmp    80106397 <alltraps>
-
-80106fff <vector187>:
-.globl vector187
-vector187:
-  pushl $0
-80106fff:	6a 00                	push   $0x0
-  pushl $187
-80107001:	68 bb 00 00 00       	push   $0xbb
-  jmp alltraps
-80107006:	e9 8c f3 ff ff       	jmp    80106397 <alltraps>
-
-8010700b <vector188>:
-.globl vector188
-vector188:
-  pushl $0
-8010700b:	6a 00                	push   $0x0
-  pushl $188
-8010700d:	68 bc 00 00 00       	push   $0xbc
-  jmp alltraps
-80107012:	e9 80 f3 ff ff       	jmp    80106397 <alltraps>
-
-80107017 <vector189>:
-.globl vector189
-vector189:
-  pushl $0
-80107017:	6a 00                	push   $0x0
-  pushl $189
-80107019:	68 bd 00 00 00       	push   $0xbd
-  jmp alltraps
-8010701e:	e9 74 f3 ff ff       	jmp    80106397 <alltraps>
-
-80107023 <vector190>:
-.globl vector190
-vector190:
-  pushl $0
-80107023:	6a 00                	push   $0x0
-  pushl $190
-80107025:	68 be 00 00 00       	push   $0xbe
-  jmp alltraps
-8010702a:	e9 68 f3 ff ff       	jmp    80106397 <alltraps>
-
-8010702f <vector191>:
-.globl vector191
-vector191:
-  pushl $0
-8010702f:	6a 00                	push   $0x0
-  pushl $191
-80107031:	68 bf 00 00 00       	push   $0xbf
-  jmp alltraps
-80107036:	e9 5c f3 ff ff       	jmp    80106397 <alltraps>
-
-8010703b <vector192>:
-.globl vector192
-vector192:
-  pushl $0
-8010703b:	6a 00                	push   $0x0
-  pushl $192
-8010703d:	68 c0 00 00 00       	push   $0xc0
-  jmp alltraps
-80107042:	e9 50 f3 ff ff       	jmp    80106397 <alltraps>
-
-80107047 <vector193>:
-.globl vector193
-vector193:
-  pushl $0
-80107047:	6a 00                	push   $0x0
-  pushl $193
-80107049:	68 c1 00 00 00       	push   $0xc1
-  jmp alltraps
-8010704e:	e9 44 f3 ff ff       	jmp    80106397 <alltraps>
-
-80107053 <vector194>:
-.globl vector194
-vector194:
-  pushl $0
-80107053:	6a 00                	push   $0x0
-  pushl $194
-80107055:	68 c2 00 00 00       	push   $0xc2
-  jmp alltraps
-8010705a:	e9 38 f3 ff ff       	jmp    80106397 <alltraps>
-
-8010705f <vector195>:
-.globl vector195
-vector195:
-  pushl $0
-8010705f:	6a 00                	push   $0x0
-  pushl $195
-80107061:	68 c3 00 00 00       	push   $0xc3
-  jmp alltraps
-80107066:	e9 2c f3 ff ff       	jmp    80106397 <alltraps>
-
-8010706b <vector196>:
-.globl vector196
-vector196:
-  pushl $0
-8010706b:	6a 00                	push   $0x0
-  pushl $196
-8010706d:	68 c4 00 00 00       	push   $0xc4
-  jmp alltraps
-80107072:	e9 20 f3 ff ff       	jmp    80106397 <alltraps>
-
-80107077 <vector197>:
-.globl vector197
-vector197:
-  pushl $0
-80107077:	6a 00                	push   $0x0
-  pushl $197
-80107079:	68 c5 00 00 00       	push   $0xc5
-  jmp alltraps
-8010707e:	e9 14 f3 ff ff       	jmp    80106397 <alltraps>
-
-80107083 <vector198>:
-.globl vector198
-vector198:
-  pushl $0
-80107083:	6a 00                	push   $0x0
-  pushl $198
-80107085:	68 c6 00 00 00       	push   $0xc6
-  jmp alltraps
-8010708a:	e9 08 f3 ff ff       	jmp    80106397 <alltraps>
-
-8010708f <vector199>:
-.globl vector199
-vector199:
-  pushl $0
-8010708f:	6a 00                	push   $0x0
-  pushl $199
-80107091:	68 c7 00 00 00       	push   $0xc7
-  jmp alltraps
-80107096:	e9 fc f2 ff ff       	jmp    80106397 <alltraps>
-
-8010709b <vector200>:
-.globl vector200
-vector200:
-  pushl $0
-8010709b:	6a 00                	push   $0x0
-  pushl $200
-8010709d:	68 c8 00 00 00       	push   $0xc8
-  jmp alltraps
-801070a2:	e9 f0 f2 ff ff       	jmp    80106397 <alltraps>
-
-801070a7 <vector201>:
-.globl vector201
-vector201:
-  pushl $0
-801070a7:	6a 00                	push   $0x0
-  pushl $201
-801070a9:	68 c9 00 00 00       	push   $0xc9
-  jmp alltraps
-801070ae:	e9 e4 f2 ff ff       	jmp    80106397 <alltraps>
-
-801070b3 <vector202>:
-.globl vector202
-vector202:
-  pushl $0
-801070b3:	6a 00                	push   $0x0
-  pushl $202
-801070b5:	68 ca 00 00 00       	push   $0xca
-  jmp alltraps
-801070ba:	e9 d8 f2 ff ff       	jmp    80106397 <alltraps>
-
-801070bf <vector203>:
-.globl vector203
-vector203:
-  pushl $0
-801070bf:	6a 00                	push   $0x0
-  pushl $203
-801070c1:	68 cb 00 00 00       	push   $0xcb
-  jmp alltraps
-801070c6:	e9 cc f2 ff ff       	jmp    80106397 <alltraps>
-
-801070cb <vector204>:
-.globl vector204
-vector204:
-  pushl $0
-801070cb:	6a 00                	push   $0x0
-  pushl $204
-801070cd:	68 cc 00 00 00       	push   $0xcc
-  jmp alltraps
-801070d2:	e9 c0 f2 ff ff       	jmp    80106397 <alltraps>
-
-801070d7 <vector205>:
-.globl vector205
-vector205:
-  pushl $0
-801070d7:	6a 00                	push   $0x0
-  pushl $205
-801070d9:	68 cd 00 00 00       	push   $0xcd
-  jmp alltraps
-801070de:	e9 b4 f2 ff ff       	jmp    80106397 <alltraps>
-
-801070e3 <vector206>:
-.globl vector206
-vector206:
-  pushl $0
-801070e3:	6a 00                	push   $0x0
-  pushl $206
-801070e5:	68 ce 00 00 00       	push   $0xce
-  jmp alltraps
-801070ea:	e9 a8 f2 ff ff       	jmp    80106397 <alltraps>
-
-801070ef <vector207>:
-.globl vector207
-vector207:
-  pushl $0
-801070ef:	6a 00                	push   $0x0
-  pushl $207
-801070f1:	68 cf 00 00 00       	push   $0xcf
-  jmp alltraps
-801070f6:	e9 9c f2 ff ff       	jmp    80106397 <alltraps>
-
-801070fb <vector208>:
-.globl vector208
-vector208:
-  pushl $0
-801070fb:	6a 00                	push   $0x0
-  pushl $208
-801070fd:	68 d0 00 00 00       	push   $0xd0
-  jmp alltraps
-80107102:	e9 90 f2 ff ff       	jmp    80106397 <alltraps>
-
-80107107 <vector209>:
-.globl vector209
-vector209:
-  pushl $0
-80107107:	6a 00                	push   $0x0
-  pushl $209
-80107109:	68 d1 00 00 00       	push   $0xd1
-  jmp alltraps
-8010710e:	e9 84 f2 ff ff       	jmp    80106397 <alltraps>
-
-80107113 <vector210>:
-.globl vector210
-vector210:
-  pushl $0
-80107113:	6a 00                	push   $0x0
-  pushl $210
-80107115:	68 d2 00 00 00       	push   $0xd2
-  jmp alltraps
-8010711a:	e9 78 f2 ff ff       	jmp    80106397 <alltraps>
-
-8010711f <vector211>:
-.globl vector211
-vector211:
-  pushl $0
-8010711f:	6a 00                	push   $0x0
-  pushl $211
-80107121:	68 d3 00 00 00       	push   $0xd3
-  jmp alltraps
-80107126:	e9 6c f2 ff ff       	jmp    80106397 <alltraps>
-
-8010712b <vector212>:
-.globl vector212
-vector212:
-  pushl $0
-8010712b:	6a 00                	push   $0x0
-  pushl $212
-8010712d:	68 d4 00 00 00       	push   $0xd4
-  jmp alltraps
-80107132:	e9 60 f2 ff ff       	jmp    80106397 <alltraps>
-
-80107137 <vector213>:
-.globl vector213
-vector213:
-  pushl $0
-80107137:	6a 00                	push   $0x0
-  pushl $213
-80107139:	68 d5 00 00 00       	push   $0xd5
-  jmp alltraps
-8010713e:	e9 54 f2 ff ff       	jmp    80106397 <alltraps>
-
-80107143 <vector214>:
-.globl vector214
-vector214:
-  pushl $0
-80107143:	6a 00                	push   $0x0
-  pushl $214
-80107145:	68 d6 00 00 00       	push   $0xd6
-  jmp alltraps
-8010714a:	e9 48 f2 ff ff       	jmp    80106397 <alltraps>
-
-8010714f <vector215>:
-.globl vector215
-vector215:
-  pushl $0
-8010714f:	6a 00                	push   $0x0
-  pushl $215
-80107151:	68 d7 00 00 00       	push   $0xd7
-  jmp alltraps
-80107156:	e9 3c f2 ff ff       	jmp    80106397 <alltraps>
-
-8010715b <vector216>:
-.globl vector216
-vector216:
-  pushl $0
-8010715b:	6a 00                	push   $0x0
-  pushl $216
-8010715d:	68 d8 00 00 00       	push   $0xd8
-  jmp alltraps
-80107162:	e9 30 f2 ff ff       	jmp    80106397 <alltraps>
-
-80107167 <vector217>:
-.globl vector217
-vector217:
-  pushl $0
-80107167:	6a 00                	push   $0x0
-  pushl $217
-80107169:	68 d9 00 00 00       	push   $0xd9
-  jmp alltraps
-8010716e:	e9 24 f2 ff ff       	jmp    80106397 <alltraps>
-
-80107173 <vector218>:
-.globl vector218
-vector218:
-  pushl $0
-80107173:	6a 00                	push   $0x0
-  pushl $218
-80107175:	68 da 00 00 00       	push   $0xda
-  jmp alltraps
-8010717a:	e9 18 f2 ff ff       	jmp    80106397 <alltraps>
-
-8010717f <vector219>:
-.globl vector219
-vector219:
-  pushl $0
-8010717f:	6a 00                	push   $0x0
-  pushl $219
-80107181:	68 db 00 00 00       	push   $0xdb
-  jmp alltraps
-80107186:	e9 0c f2 ff ff       	jmp    80106397 <alltraps>
-
-8010718b <vector220>:
-.globl vector220
-vector220:
-  pushl $0
-8010718b:	6a 00                	push   $0x0
-  pushl $220
-8010718d:	68 dc 00 00 00       	push   $0xdc
-  jmp alltraps
-80107192:	e9 00 f2 ff ff       	jmp    80106397 <alltraps>
-
-80107197 <vector221>:
-.globl vector221
-vector221:
-  pushl $0
-80107197:	6a 00                	push   $0x0
-  pushl $221
-80107199:	68 dd 00 00 00       	push   $0xdd
-  jmp alltraps
-8010719e:	e9 f4 f1 ff ff       	jmp    80106397 <alltraps>
-
-801071a3 <vector222>:
-.globl vector222
-vector222:
-  pushl $0
-801071a3:	6a 00                	push   $0x0
-  pushl $222
-801071a5:	68 de 00 00 00       	push   $0xde
-  jmp alltraps
-801071aa:	e9 e8 f1 ff ff       	jmp    80106397 <alltraps>
-
-801071af <vector223>:
-.globl vector223
-vector223:
-  pushl $0
-801071af:	6a 00                	push   $0x0
-  pushl $223
-801071b1:	68 df 00 00 00       	push   $0xdf
-  jmp alltraps
-801071b6:	e9 dc f1 ff ff       	jmp    80106397 <alltraps>
-
-801071bb <vector224>:
-.globl vector224
-vector224:
-  pushl $0
-801071bb:	6a 00                	push   $0x0
-  pushl $224
-801071bd:	68 e0 00 00 00       	push   $0xe0
-  jmp alltraps
-801071c2:	e9 d0 f1 ff ff       	jmp    80106397 <alltraps>
-
-801071c7 <vector225>:
-.globl vector225
-vector225:
-  pushl $0
-801071c7:	6a 00                	push   $0x0
-  pushl $225
-801071c9:	68 e1 00 00 00       	push   $0xe1
-  jmp alltraps
-801071ce:	e9 c4 f1 ff ff       	jmp    80106397 <alltraps>
-
-801071d3 <vector226>:
-.globl vector226
-vector226:
-  pushl $0
-801071d3:	6a 00                	push   $0x0
-  pushl $226
-801071d5:	68 e2 00 00 00       	push   $0xe2
-  jmp alltraps
-801071da:	e9 b8 f1 ff ff       	jmp    80106397 <alltraps>
-
-801071df <vector227>:
-.globl vector227
-vector227:
-  pushl $0
-801071df:	6a 00                	push   $0x0
-  pushl $227
-801071e1:	68 e3 00 00 00       	push   $0xe3
-  jmp alltraps
-801071e6:	e9 ac f1 ff ff       	jmp    80106397 <alltraps>
-
-801071eb <vector228>:
-.globl vector228
-vector228:
-  pushl $0
-801071eb:	6a 00                	push   $0x0
-  pushl $228
-801071ed:	68 e4 00 00 00       	push   $0xe4
-  jmp alltraps
-801071f2:	e9 a0 f1 ff ff       	jmp    80106397 <alltraps>
-
-801071f7 <vector229>:
-.globl vector229
-vector229:
-  pushl $0
-801071f7:	6a 00                	push   $0x0
-  pushl $229
-801071f9:	68 e5 00 00 00       	push   $0xe5
-  jmp alltraps
-801071fe:	e9 94 f1 ff ff       	jmp    80106397 <alltraps>
-
-80107203 <vector230>:
-.globl vector230
-vector230:
-  pushl $0
-80107203:	6a 00                	push   $0x0
-  pushl $230
-80107205:	68 e6 00 00 00       	push   $0xe6
-  jmp alltraps
-8010720a:	e9 88 f1 ff ff       	jmp    80106397 <alltraps>
-
-8010720f <vector231>:
-.globl vector231
-vector231:
-  pushl $0
-8010720f:	6a 00                	push   $0x0
-  pushl $231
-80107211:	68 e7 00 00 00       	push   $0xe7
-  jmp alltraps
-80107216:	e9 7c f1 ff ff       	jmp    80106397 <alltraps>
-
-8010721b <vector232>:
-.globl vector232
-vector232:
-  pushl $0
-8010721b:	6a 00                	push   $0x0
-  pushl $232
-8010721d:	68 e8 00 00 00       	push   $0xe8
-  jmp alltraps
-80107222:	e9 70 f1 ff ff       	jmp    80106397 <alltraps>
-
-80107227 <vector233>:
-.globl vector233
-vector233:
-  pushl $0
-80107227:	6a 00                	push   $0x0
-  pushl $233
-80107229:	68 e9 00 00 00       	push   $0xe9
-  jmp alltraps
-8010722e:	e9 64 f1 ff ff       	jmp    80106397 <alltraps>
-
-80107233 <vector234>:
-.globl vector234
-vector234:
-  pushl $0
-80107233:	6a 00                	push   $0x0
-  pushl $234
-80107235:	68 ea 00 00 00       	push   $0xea
-  jmp alltraps
-8010723a:	e9 58 f1 ff ff       	jmp    80106397 <alltraps>
-
-8010723f <vector235>:
-.globl vector235
-vector235:
-  pushl $0
-8010723f:	6a 00                	push   $0x0
-  pushl $235
-80107241:	68 eb 00 00 00       	push   $0xeb
-  jmp alltraps
-80107246:	e9 4c f1 ff ff       	jmp    80106397 <alltraps>
-
-8010724b <vector236>:
-.globl vector236
-vector236:
-  pushl $0
-8010724b:	6a 00                	push   $0x0
-  pushl $236
-8010724d:	68 ec 00 00 00       	push   $0xec
-  jmp alltraps
-80107252:	e9 40 f1 ff ff       	jmp    80106397 <alltraps>
-
-80107257 <vector237>:
-.globl vector237
-vector237:
-  pushl $0
-80107257:	6a 00                	push   $0x0
-  pushl $237
-80107259:	68 ed 00 00 00       	push   $0xed
-  jmp alltraps
-8010725e:	e9 34 f1 ff ff       	jmp    80106397 <alltraps>
-
-80107263 <vector238>:
-.globl vector238
-vector238:
-  pushl $0
-80107263:	6a 00                	push   $0x0
-  pushl $238
-80107265:	68 ee 00 00 00       	push   $0xee
-  jmp alltraps
-8010726a:	e9 28 f1 ff ff       	jmp    80106397 <alltraps>
-
-8010726f <vector239>:
-.globl vector239
-vector239:
-  pushl $0
-8010726f:	6a 00                	push   $0x0
-  pushl $239
-80107271:	68 ef 00 00 00       	push   $0xef
-  jmp alltraps
-80107276:	e9 1c f1 ff ff       	jmp    80106397 <alltraps>
-
-8010727b <vector240>:
-.globl vector240
-vector240:
-  pushl $0
-8010727b:	6a 00                	push   $0x0
-  pushl $240
-8010727d:	68 f0 00 00 00       	push   $0xf0
-  jmp alltraps
-80107282:	e9 10 f1 ff ff       	jmp    80106397 <alltraps>
-
-80107287 <vector241>:
-.globl vector241
-vector241:
-  pushl $0
-80107287:	6a 00                	push   $0x0
-  pushl $241
-80107289:	68 f1 00 00 00       	push   $0xf1
-  jmp alltraps
-8010728e:	e9 04 f1 ff ff       	jmp    80106397 <alltraps>
-
-80107293 <vector242>:
-.globl vector242
-vector242:
-  pushl $0
-80107293:	6a 00                	push   $0x0
-  pushl $242
-80107295:	68 f2 00 00 00       	push   $0xf2
-  jmp alltraps
-8010729a:	e9 f8 f0 ff ff       	jmp    80106397 <alltraps>
-
-8010729f <vector243>:
-.globl vector243
-vector243:
-  pushl $0
-8010729f:	6a 00                	push   $0x0
-  pushl $243
-801072a1:	68 f3 00 00 00       	push   $0xf3
-  jmp alltraps
-801072a6:	e9 ec f0 ff ff       	jmp    80106397 <alltraps>
-
-801072ab <vector244>:
-.globl vector244
-vector244:
-  pushl $0
-801072ab:	6a 00                	push   $0x0
-  pushl $244
-801072ad:	68 f4 00 00 00       	push   $0xf4
-  jmp alltraps
-801072b2:	e9 e0 f0 ff ff       	jmp    80106397 <alltraps>
-
-801072b7 <vector245>:
-.globl vector245
-vector245:
-  pushl $0
-801072b7:	6a 00                	push   $0x0
-  pushl $245
-801072b9:	68 f5 00 00 00       	push   $0xf5
-  jmp alltraps
-801072be:	e9 d4 f0 ff ff       	jmp    80106397 <alltraps>
-
-801072c3 <vector246>:
-.globl vector246
-vector246:
-  pushl $0
-801072c3:	6a 00                	push   $0x0
-  pushl $246
-801072c5:	68 f6 00 00 00       	push   $0xf6
-  jmp alltraps
-801072ca:	e9 c8 f0 ff ff       	jmp    80106397 <alltraps>
-
-801072cf <vector247>:
-.globl vector247
-vector247:
-  pushl $0
-801072cf:	6a 00                	push   $0x0
-  pushl $247
-801072d1:	68 f7 00 00 00       	push   $0xf7
-  jmp alltraps
-801072d6:	e9 bc f0 ff ff       	jmp    80106397 <alltraps>
-
-801072db <vector248>:
-.globl vector248
-vector248:
-  pushl $0
-801072db:	6a 00                	push   $0x0
-  pushl $248
-801072dd:	68 f8 00 00 00       	push   $0xf8
-  jmp alltraps
-801072e2:	e9 b0 f0 ff ff       	jmp    80106397 <alltraps>
-
-801072e7 <vector249>:
-.globl vector249
-vector249:
-  pushl $0
-801072e7:	6a 00                	push   $0x0
-  pushl $249
-801072e9:	68 f9 00 00 00       	push   $0xf9
-  jmp alltraps
-801072ee:	e9 a4 f0 ff ff       	jmp    80106397 <alltraps>
-
-801072f3 <vector250>:
-.globl vector250
-vector250:
-  pushl $0
-801072f3:	6a 00                	push   $0x0
-  pushl $250
-801072f5:	68 fa 00 00 00       	push   $0xfa
-  jmp alltraps
-801072fa:	e9 98 f0 ff ff       	jmp    80106397 <alltraps>
-
-801072ff <vector251>:
-.globl vector251
-vector251:
-  pushl $0
-801072ff:	6a 00                	push   $0x0
-  pushl $251
-80107301:	68 fb 00 00 00       	push   $0xfb
-  jmp alltraps
-80107306:	e9 8c f0 ff ff       	jmp    80106397 <alltraps>
-
-8010730b <vector252>:
-.globl vector252
-vector252:
-  pushl $0
-8010730b:	6a 00                	push   $0x0
-  pushl $252
-8010730d:	68 fc 00 00 00       	push   $0xfc
-  jmp alltraps
-80107312:	e9 80 f0 ff ff       	jmp    80106397 <alltraps>
-
-80107317 <vector253>:
-.globl vector253
-vector253:
-  pushl $0
-80107317:	6a 00                	push   $0x0
-  pushl $253
-80107319:	68 fd 00 00 00       	push   $0xfd
-  jmp alltraps
-8010731e:	e9 74 f0 ff ff       	jmp    80106397 <alltraps>
-
-80107323 <vector254>:
-.globl vector254
-vector254:
-  pushl $0
-80107323:	6a 00                	push   $0x0
-  pushl $254
-80107325:	68 fe 00 00 00       	push   $0xfe
-  jmp alltraps
-8010732a:	e9 68 f0 ff ff       	jmp    80106397 <alltraps>
-
-8010732f <vector255>:
-.globl vector255
-vector255:
-  pushl $0
-8010732f:	6a 00                	push   $0x0
-  pushl $255
-80107331:	68 ff 00 00 00       	push   $0xff
-  jmp alltraps
-80107336:	e9 5c f0 ff ff       	jmp    80106397 <alltraps>
-8010733b:	66 90                	xchg   %ax,%ax
-8010733d:	66 90                	xchg   %ax,%ax
-8010733f:	90                   	nop
-
-80107340 <walkpgdir>:
-// Return the address of the PTE in page table pgdir
-// that corresponds to virtual address va.  If alloc!=0,
-// create any required page table pages.
-static pte_t *
-walkpgdir(pde_t *pgdir, const void *va, int alloc)
-{
-80107340:	55                   	push   %ebp
-80107341:	89 e5                	mov    %esp,%ebp
-80107343:	57                   	push   %edi
-80107344:	56                   	push   %esi
-80107345:	89 d6                	mov    %edx,%esi
-  pde_t *pde;
-  pte_t *pgtab;
-
-  pde = &pgdir[PDX(va)];
-80107347:	c1 ea 16             	shr    $0x16,%edx
-{
-8010734a:	53                   	push   %ebx
-  pde = &pgdir[PDX(va)];
-8010734b:	8d 3c 90             	lea    (%eax,%edx,4),%edi
-{
-8010734e:	83 ec 0c             	sub    $0xc,%esp
-  if(*pde & PTE_P){
-80107351:	8b 1f                	mov    (%edi),%ebx
-80107353:	f6 c3 01             	test   $0x1,%bl
-80107356:	74 28                	je     80107380 <walkpgdir+0x40>
-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
-80107358:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
-8010735e:	81 c3 00 00 00 80    	add    $0x80000000,%ebx
-    // The permissions here are overly generous, but they can
-    // be further restricted by the permissions in the page table
-    // entries, if necessary.
-    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
-  }
-  return &pgtab[PTX(va)];
-80107364:	89 f0                	mov    %esi,%eax
-}
-80107366:	8d 65 f4             	lea    -0xc(%ebp),%esp
-  return &pgtab[PTX(va)];
-80107369:	c1 e8 0a             	shr    $0xa,%eax
-8010736c:	25 fc 0f 00 00       	and    $0xffc,%eax
-80107371:	01 d8                	add    %ebx,%eax
-}
-80107373:	5b                   	pop    %ebx
-80107374:	5e                   	pop    %esi
-80107375:	5f                   	pop    %edi
-80107376:	5d                   	pop    %ebp
-80107377:	c3                   	ret    
-80107378:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010737f:	90                   	nop
-    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
-80107380:	85 c9                	test   %ecx,%ecx
-80107382:	74 2c                	je     801073b0 <walkpgdir+0x70>
-80107384:	e8 a7 b2 ff ff       	call   80102630 <kalloc>
-80107389:	89 c3                	mov    %eax,%ebx
-8010738b:	85 c0                	test   %eax,%eax
-8010738d:	74 21                	je     801073b0 <walkpgdir+0x70>
-    memset(pgtab, 0, PGSIZE);
-8010738f:	83 ec 04             	sub    $0x4,%esp
-80107392:	68 00 10 00 00       	push   $0x1000
-80107397:	6a 00                	push   $0x0
-80107399:	50                   	push   %eax
-8010739a:	e8 31 db ff ff       	call   80104ed0 <memset>
-    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
-8010739f:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
-801073a5:	83 c4 10             	add    $0x10,%esp
-801073a8:	83 c8 07             	or     $0x7,%eax
-801073ab:	89 07                	mov    %eax,(%edi)
-801073ad:	eb b5                	jmp    80107364 <walkpgdir+0x24>
-801073af:	90                   	nop
-}
-801073b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return 0;
-801073b3:	31 c0                	xor    %eax,%eax
-}
-801073b5:	5b                   	pop    %ebx
-801073b6:	5e                   	pop    %esi
-801073b7:	5f                   	pop    %edi
-801073b8:	5d                   	pop    %ebp
-801073b9:	c3                   	ret    
-801073ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-801073c0 <mappages>:
-// Create PTEs for virtual addresses starting at va that refer to
-// physical addresses starting at pa. va and size might not
-// be page-aligned.
-static int
-mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
-{
-801073c0:	55                   	push   %ebp
-801073c1:	89 e5                	mov    %esp,%ebp
-801073c3:	57                   	push   %edi
-801073c4:	89 c7                	mov    %eax,%edi
-  char *a, *last;
-  pte_t *pte;
-
-  a = (char*)PGROUNDDOWN((uint)va);
-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
-801073c6:	8d 44 0a ff          	lea    -0x1(%edx,%ecx,1),%eax
-{
-801073ca:	56                   	push   %esi
-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
-801073cb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-  a = (char*)PGROUNDDOWN((uint)va);
-801073d0:	89 d6                	mov    %edx,%esi
-{
-801073d2:	53                   	push   %ebx
-  a = (char*)PGROUNDDOWN((uint)va);
-801073d3:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
-{
-801073d9:	83 ec 1c             	sub    $0x1c,%esp
-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
-801073dc:	89 45 e0             	mov    %eax,-0x20(%ebp)
-801073df:	8b 45 08             	mov    0x8(%ebp),%eax
-801073e2:	29 f0                	sub    %esi,%eax
-801073e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-801073e7:	eb 1f                	jmp    80107408 <mappages+0x48>
-801073e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  for(;;){
-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
-      return -1;
-    if(*pte & PTE_P)
-801073f0:	f6 00 01             	testb  $0x1,(%eax)
-801073f3:	75 45                	jne    8010743a <mappages+0x7a>
-      panic("remap");
-    *pte = pa | perm | PTE_P;
-801073f5:	0b 5d 0c             	or     0xc(%ebp),%ebx
-801073f8:	83 cb 01             	or     $0x1,%ebx
-801073fb:	89 18                	mov    %ebx,(%eax)
-    if(a == last)
-801073fd:	3b 75 e0             	cmp    -0x20(%ebp),%esi
-80107400:	74 2e                	je     80107430 <mappages+0x70>
-      break;
-    a += PGSIZE;
-80107402:	81 c6 00 10 00 00    	add    $0x1000,%esi
-  for(;;){
-80107408:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
-8010740b:	b9 01 00 00 00       	mov    $0x1,%ecx
-80107410:	89 f2                	mov    %esi,%edx
-80107412:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
-80107415:	89 f8                	mov    %edi,%eax
-80107417:	e8 24 ff ff ff       	call   80107340 <walkpgdir>
-8010741c:	85 c0                	test   %eax,%eax
-8010741e:	75 d0                	jne    801073f0 <mappages+0x30>
-    pa += PGSIZE;
-  }
-  return 0;
-}
-80107420:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return -1;
-80107423:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80107428:	5b                   	pop    %ebx
-80107429:	5e                   	pop    %esi
-8010742a:	5f                   	pop    %edi
-8010742b:	5d                   	pop    %ebp
-8010742c:	c3                   	ret    
-8010742d:	8d 76 00             	lea    0x0(%esi),%esi
-80107430:	8d 65 f4             	lea    -0xc(%ebp),%esp
-  return 0;
-80107433:	31 c0                	xor    %eax,%eax
-}
-80107435:	5b                   	pop    %ebx
-80107436:	5e                   	pop    %esi
-80107437:	5f                   	pop    %edi
-80107438:	5d                   	pop    %ebp
-80107439:	c3                   	ret    
-      panic("remap");
-8010743a:	83 ec 0c             	sub    $0xc,%esp
-8010743d:	68 54 85 10 80       	push   $0x80108554
-80107442:	e8 49 8f ff ff       	call   80100390 <panic>
-80107447:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010744e:	66 90                	xchg   %ax,%ax
-
-80107450 <deallocuvm.part.0>:
-// Deallocate user pages to bring the process size from oldsz to
-// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
-// need to be less than oldsz.  oldsz can be larger than the actual
-// process size.  Returns the new process size.
-int
-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
-80107450:	55                   	push   %ebp
-80107451:	89 e5                	mov    %esp,%ebp
-80107453:	57                   	push   %edi
-80107454:	56                   	push   %esi
-80107455:	89 c6                	mov    %eax,%esi
-80107457:	53                   	push   %ebx
-80107458:	89 d3                	mov    %edx,%ebx
-  uint a, pa;
-
-  if(newsz >= oldsz)
-    return oldsz;
-
-  a = PGROUNDUP(newsz);
-8010745a:	8d 91 ff 0f 00 00    	lea    0xfff(%ecx),%edx
-80107460:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
-80107466:	83 ec 1c             	sub    $0x1c,%esp
-80107469:	89 4d e0             	mov    %ecx,-0x20(%ebp)
-  for(; a  < oldsz; a += PGSIZE){
-8010746c:	39 da                	cmp    %ebx,%edx
-8010746e:	73 5b                	jae    801074cb <deallocuvm.part.0+0x7b>
-80107470:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
-80107473:	89 d7                	mov    %edx,%edi
-80107475:	eb 14                	jmp    8010748b <deallocuvm.part.0+0x3b>
-80107477:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010747e:	66 90                	xchg   %ax,%ax
-80107480:	81 c7 00 10 00 00    	add    $0x1000,%edi
-80107486:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
-80107489:	76 40                	jbe    801074cb <deallocuvm.part.0+0x7b>
-    pte = walkpgdir(pgdir, (char*)a, 0);
-8010748b:	31 c9                	xor    %ecx,%ecx
-8010748d:	89 fa                	mov    %edi,%edx
-8010748f:	89 f0                	mov    %esi,%eax
-80107491:	e8 aa fe ff ff       	call   80107340 <walkpgdir>
-80107496:	89 c3                	mov    %eax,%ebx
-    if(!pte)
-80107498:	85 c0                	test   %eax,%eax
-8010749a:	74 44                	je     801074e0 <deallocuvm.part.0+0x90>
-      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
-    else if((*pte & PTE_P) != 0){
-8010749c:	8b 00                	mov    (%eax),%eax
-8010749e:	a8 01                	test   $0x1,%al
-801074a0:	74 de                	je     80107480 <deallocuvm.part.0+0x30>
-      pa = PTE_ADDR(*pte);
-      if(pa == 0)
-801074a2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-801074a7:	74 47                	je     801074f0 <deallocuvm.part.0+0xa0>
-        panic("kfree");
-      char *v = P2V(pa);
-      kfree(v);
-801074a9:	83 ec 0c             	sub    $0xc,%esp
-      char *v = P2V(pa);
-801074ac:	05 00 00 00 80       	add    $0x80000000,%eax
-801074b1:	81 c7 00 10 00 00    	add    $0x1000,%edi
-      kfree(v);
-801074b7:	50                   	push   %eax
-801074b8:	e8 b3 af ff ff       	call   80102470 <kfree>
-      *pte = 0;
-801074bd:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
-801074c3:	83 c4 10             	add    $0x10,%esp
-  for(; a  < oldsz; a += PGSIZE){
-801074c6:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
-801074c9:	77 c0                	ja     8010748b <deallocuvm.part.0+0x3b>
-    }
-  }
-  return newsz;
-}
-801074cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
-801074ce:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801074d1:	5b                   	pop    %ebx
-801074d2:	5e                   	pop    %esi
-801074d3:	5f                   	pop    %edi
-801074d4:	5d                   	pop    %ebp
-801074d5:	c3                   	ret    
-801074d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801074dd:	8d 76 00             	lea    0x0(%esi),%esi
-      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
-801074e0:	89 fa                	mov    %edi,%edx
-801074e2:	81 e2 00 00 c0 ff    	and    $0xffc00000,%edx
-801074e8:	8d ba 00 00 40 00    	lea    0x400000(%edx),%edi
-801074ee:	eb 96                	jmp    80107486 <deallocuvm.part.0+0x36>
-        panic("kfree");
-801074f0:	83 ec 0c             	sub    $0xc,%esp
-801074f3:	68 e6 7e 10 80       	push   $0x80107ee6
-801074f8:	e8 93 8e ff ff       	call   80100390 <panic>
-801074fd:	8d 76 00             	lea    0x0(%esi),%esi
-
-80107500 <seginit>:
-{
-80107500:	f3 0f 1e fb          	endbr32 
-80107504:	55                   	push   %ebp
-80107505:	89 e5                	mov    %esp,%ebp
-80107507:	83 ec 18             	sub    $0x18,%esp
-  c = &cpus[cpuid()];
-8010750a:	e8 81 c4 ff ff       	call   80103990 <cpuid>
-  pd[0] = size-1;
-8010750f:	ba 2f 00 00 00       	mov    $0x2f,%edx
-80107514:	69 c0 b0 00 00 00    	imul   $0xb0,%eax,%eax
-8010751a:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
-  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
-8010751e:	c7 80 18 38 11 80 ff 	movl   $0xffff,-0x7feec7e8(%eax)
-80107525:	ff 00 00 
-80107528:	c7 80 1c 38 11 80 00 	movl   $0xcf9a00,-0x7feec7e4(%eax)
-8010752f:	9a cf 00 
-  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
-80107532:	c7 80 20 38 11 80 ff 	movl   $0xffff,-0x7feec7e0(%eax)
-80107539:	ff 00 00 
-8010753c:	c7 80 24 38 11 80 00 	movl   $0xcf9200,-0x7feec7dc(%eax)
-80107543:	92 cf 00 
-  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
-80107546:	c7 80 28 38 11 80 ff 	movl   $0xffff,-0x7feec7d8(%eax)
-8010754d:	ff 00 00 
-80107550:	c7 80 2c 38 11 80 00 	movl   $0xcffa00,-0x7feec7d4(%eax)
-80107557:	fa cf 00 
-  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
-8010755a:	c7 80 30 38 11 80 ff 	movl   $0xffff,-0x7feec7d0(%eax)
-80107561:	ff 00 00 
-80107564:	c7 80 34 38 11 80 00 	movl   $0xcff200,-0x7feec7cc(%eax)
-8010756b:	f2 cf 00 
-  lgdt(c->gdt, sizeof(c->gdt));
-8010756e:	05 10 38 11 80       	add    $0x80113810,%eax
-  pd[1] = (uint)p;
-80107573:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
-  pd[2] = (uint)p >> 16;
-80107577:	c1 e8 10             	shr    $0x10,%eax
-8010757a:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
-  asm volatile("lgdt (%0)" : : "r" (pd));
-8010757e:	8d 45 f2             	lea    -0xe(%ebp),%eax
-80107581:	0f 01 10             	lgdtl  (%eax)
-}
-80107584:	c9                   	leave  
-80107585:	c3                   	ret    
-80107586:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010758d:	8d 76 00             	lea    0x0(%esi),%esi
-
-80107590 <switchkvm>:
-{
-80107590:	f3 0f 1e fb          	endbr32 
-  lcr3(V2P(kpgdir));   // switch to the kernel page table
-80107594:	a1 e4 89 11 80       	mov    0x801189e4,%eax
-80107599:	05 00 00 00 80       	add    $0x80000000,%eax
-}
-
-static inline void
-lcr3(uint val)
-{
-  asm volatile("movl %0,%%cr3" : : "r" (val));
-8010759e:	0f 22 d8             	mov    %eax,%cr3
-}
-801075a1:	c3                   	ret    
-801075a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801075a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-801075b0 <switchuvm>:
-{
-801075b0:	f3 0f 1e fb          	endbr32 
-801075b4:	55                   	push   %ebp
-801075b5:	89 e5                	mov    %esp,%ebp
-801075b7:	57                   	push   %edi
-801075b8:	56                   	push   %esi
-801075b9:	53                   	push   %ebx
-801075ba:	83 ec 1c             	sub    $0x1c,%esp
-801075bd:	8b 75 08             	mov    0x8(%ebp),%esi
-  if(p == 0)
-801075c0:	85 f6                	test   %esi,%esi
-801075c2:	0f 84 cb 00 00 00    	je     80107693 <switchuvm+0xe3>
-  if(p->kstack == 0)
-801075c8:	8b 46 08             	mov    0x8(%esi),%eax
-801075cb:	85 c0                	test   %eax,%eax
-801075cd:	0f 84 da 00 00 00    	je     801076ad <switchuvm+0xfd>
-  if(p->pgdir == 0)
-801075d3:	8b 46 04             	mov    0x4(%esi),%eax
-801075d6:	85 c0                	test   %eax,%eax
-801075d8:	0f 84 c2 00 00 00    	je     801076a0 <switchuvm+0xf0>
-  pushcli();
-801075de:	e8 dd d6 ff ff       	call   80104cc0 <pushcli>
-  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
-801075e3:	e8 38 c3 ff ff       	call   80103920 <mycpu>
-801075e8:	89 c3                	mov    %eax,%ebx
-801075ea:	e8 31 c3 ff ff       	call   80103920 <mycpu>
-801075ef:	89 c7                	mov    %eax,%edi
-801075f1:	e8 2a c3 ff ff       	call   80103920 <mycpu>
-801075f6:	83 c7 08             	add    $0x8,%edi
-801075f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-801075fc:	e8 1f c3 ff ff       	call   80103920 <mycpu>
-80107601:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
-80107604:	ba 67 00 00 00       	mov    $0x67,%edx
-80107609:	66 89 bb 9a 00 00 00 	mov    %di,0x9a(%ebx)
-80107610:	83 c0 08             	add    $0x8,%eax
-80107613:	66 89 93 98 00 00 00 	mov    %dx,0x98(%ebx)
-  mycpu()->ts.iomb = (ushort) 0xFFFF;
-8010761a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
-  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
-8010761f:	83 c1 08             	add    $0x8,%ecx
-80107622:	c1 e8 18             	shr    $0x18,%eax
-80107625:	c1 e9 10             	shr    $0x10,%ecx
-80107628:	88 83 9f 00 00 00    	mov    %al,0x9f(%ebx)
-8010762e:	88 8b 9c 00 00 00    	mov    %cl,0x9c(%ebx)
-80107634:	b9 99 40 00 00       	mov    $0x4099,%ecx
-80107639:	66 89 8b 9d 00 00 00 	mov    %cx,0x9d(%ebx)
-  mycpu()->ts.ss0 = SEG_KDATA << 3;
-80107640:	bb 10 00 00 00       	mov    $0x10,%ebx
-  mycpu()->gdt[SEG_TSS].s = 0;
-80107645:	e8 d6 c2 ff ff       	call   80103920 <mycpu>
-8010764a:	80 a0 9d 00 00 00 ef 	andb   $0xef,0x9d(%eax)
-  mycpu()->ts.ss0 = SEG_KDATA << 3;
-80107651:	e8 ca c2 ff ff       	call   80103920 <mycpu>
-80107656:	66 89 58 10          	mov    %bx,0x10(%eax)
-  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
-8010765a:	8b 5e 08             	mov    0x8(%esi),%ebx
-8010765d:	81 c3 00 10 00 00    	add    $0x1000,%ebx
-80107663:	e8 b8 c2 ff ff       	call   80103920 <mycpu>
-80107668:	89 58 0c             	mov    %ebx,0xc(%eax)
-  mycpu()->ts.iomb = (ushort) 0xFFFF;
-8010766b:	e8 b0 c2 ff ff       	call   80103920 <mycpu>
-80107670:	66 89 78 6e          	mov    %di,0x6e(%eax)
-  asm volatile("ltr %0" : : "r" (sel));
-80107674:	b8 28 00 00 00       	mov    $0x28,%eax
-80107679:	0f 00 d8             	ltr    %ax
-  lcr3(V2P(p->pgdir));  // switch to process's address space
-8010767c:	8b 46 04             	mov    0x4(%esi),%eax
-8010767f:	05 00 00 00 80       	add    $0x80000000,%eax
-  asm volatile("movl %0,%%cr3" : : "r" (val));
-80107684:	0f 22 d8             	mov    %eax,%cr3
-}
-80107687:	8d 65 f4             	lea    -0xc(%ebp),%esp
-8010768a:	5b                   	pop    %ebx
-8010768b:	5e                   	pop    %esi
-8010768c:	5f                   	pop    %edi
-8010768d:	5d                   	pop    %ebp
-  popcli();
-8010768e:	e9 7d d6 ff ff       	jmp    80104d10 <popcli>
-    panic("switchuvm: no process");
-80107693:	83 ec 0c             	sub    $0xc,%esp
-80107696:	68 5a 85 10 80       	push   $0x8010855a
-8010769b:	e8 f0 8c ff ff       	call   80100390 <panic>
-    panic("switchuvm: no pgdir");
-801076a0:	83 ec 0c             	sub    $0xc,%esp
-801076a3:	68 85 85 10 80       	push   $0x80108585
-801076a8:	e8 e3 8c ff ff       	call   80100390 <panic>
-    panic("switchuvm: no kstack");
-801076ad:	83 ec 0c             	sub    $0xc,%esp
-801076b0:	68 70 85 10 80       	push   $0x80108570
-801076b5:	e8 d6 8c ff ff       	call   80100390 <panic>
-801076ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-801076c0 <inituvm>:
-{
-801076c0:	f3 0f 1e fb          	endbr32 
-801076c4:	55                   	push   %ebp
-801076c5:	89 e5                	mov    %esp,%ebp
-801076c7:	57                   	push   %edi
-801076c8:	56                   	push   %esi
-801076c9:	53                   	push   %ebx
-801076ca:	83 ec 1c             	sub    $0x1c,%esp
-801076cd:	8b 45 0c             	mov    0xc(%ebp),%eax
-801076d0:	8b 75 10             	mov    0x10(%ebp),%esi
-801076d3:	8b 7d 08             	mov    0x8(%ebp),%edi
-801076d6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-  if(sz >= PGSIZE)
-801076d9:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
-801076df:	77 4b                	ja     8010772c <inituvm+0x6c>
-  mem = kalloc();
-801076e1:	e8 4a af ff ff       	call   80102630 <kalloc>
-  memset(mem, 0, PGSIZE);
-801076e6:	83 ec 04             	sub    $0x4,%esp
-801076e9:	68 00 10 00 00       	push   $0x1000
-  mem = kalloc();
-801076ee:	89 c3                	mov    %eax,%ebx
-  memset(mem, 0, PGSIZE);
-801076f0:	6a 00                	push   $0x0
-801076f2:	50                   	push   %eax
-801076f3:	e8 d8 d7 ff ff       	call   80104ed0 <memset>
-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
-801076f8:	58                   	pop    %eax
-801076f9:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
-801076ff:	5a                   	pop    %edx
-80107700:	6a 06                	push   $0x6
-80107702:	b9 00 10 00 00       	mov    $0x1000,%ecx
-80107707:	31 d2                	xor    %edx,%edx
-80107709:	50                   	push   %eax
-8010770a:	89 f8                	mov    %edi,%eax
-8010770c:	e8 af fc ff ff       	call   801073c0 <mappages>
-  memmove(mem, init, sz);
-80107711:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-80107714:	89 75 10             	mov    %esi,0x10(%ebp)
-80107717:	83 c4 10             	add    $0x10,%esp
-8010771a:	89 5d 08             	mov    %ebx,0x8(%ebp)
-8010771d:	89 45 0c             	mov    %eax,0xc(%ebp)
-}
-80107720:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80107723:	5b                   	pop    %ebx
-80107724:	5e                   	pop    %esi
-80107725:	5f                   	pop    %edi
-80107726:	5d                   	pop    %ebp
-  memmove(mem, init, sz);
-80107727:	e9 44 d8 ff ff       	jmp    80104f70 <memmove>
-    panic("inituvm: more than a page");
-8010772c:	83 ec 0c             	sub    $0xc,%esp
-8010772f:	68 99 85 10 80       	push   $0x80108599
-80107734:	e8 57 8c ff ff       	call   80100390 <panic>
-80107739:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-80107740 <loaduvm>:
-{
-80107740:	f3 0f 1e fb          	endbr32 
-80107744:	55                   	push   %ebp
-80107745:	89 e5                	mov    %esp,%ebp
-80107747:	57                   	push   %edi
-80107748:	56                   	push   %esi
-80107749:	53                   	push   %ebx
-8010774a:	83 ec 1c             	sub    $0x1c,%esp
-8010774d:	8b 45 0c             	mov    0xc(%ebp),%eax
-80107750:	8b 75 18             	mov    0x18(%ebp),%esi
-  if((uint) addr % PGSIZE != 0)
-80107753:	a9 ff 0f 00 00       	test   $0xfff,%eax
-80107758:	0f 85 99 00 00 00    	jne    801077f7 <loaduvm+0xb7>
-  for(i = 0; i < sz; i += PGSIZE){
-8010775e:	01 f0                	add    %esi,%eax
-80107760:	89 f3                	mov    %esi,%ebx
-80107762:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-    if(readi(ip, P2V(pa), offset+i, n) != n)
-80107765:	8b 45 14             	mov    0x14(%ebp),%eax
-80107768:	01 f0                	add    %esi,%eax
-8010776a:	89 45 e0             	mov    %eax,-0x20(%ebp)
-  for(i = 0; i < sz; i += PGSIZE){
-8010776d:	85 f6                	test   %esi,%esi
-8010776f:	75 15                	jne    80107786 <loaduvm+0x46>
-80107771:	eb 6d                	jmp    801077e0 <loaduvm+0xa0>
-80107773:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80107777:	90                   	nop
-80107778:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
-8010777e:	89 f0                	mov    %esi,%eax
-80107780:	29 d8                	sub    %ebx,%eax
-80107782:	39 c6                	cmp    %eax,%esi
-80107784:	76 5a                	jbe    801077e0 <loaduvm+0xa0>
-    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
-80107786:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-80107789:	8b 45 08             	mov    0x8(%ebp),%eax
-8010778c:	31 c9                	xor    %ecx,%ecx
-8010778e:	29 da                	sub    %ebx,%edx
-80107790:	e8 ab fb ff ff       	call   80107340 <walkpgdir>
-80107795:	85 c0                	test   %eax,%eax
-80107797:	74 51                	je     801077ea <loaduvm+0xaa>
-    pa = PTE_ADDR(*pte);
-80107799:	8b 00                	mov    (%eax),%eax
-    if(readi(ip, P2V(pa), offset+i, n) != n)
-8010779b:	8b 4d e0             	mov    -0x20(%ebp),%ecx
-    if(sz - i < PGSIZE)
-8010779e:	bf 00 10 00 00       	mov    $0x1000,%edi
-    pa = PTE_ADDR(*pte);
-801077a3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-    if(sz - i < PGSIZE)
-801077a8:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
-801077ae:	0f 46 fb             	cmovbe %ebx,%edi
-    if(readi(ip, P2V(pa), offset+i, n) != n)
-801077b1:	29 d9                	sub    %ebx,%ecx
-801077b3:	05 00 00 00 80       	add    $0x80000000,%eax
-801077b8:	57                   	push   %edi
-801077b9:	51                   	push   %ecx
-801077ba:	50                   	push   %eax
-801077bb:	ff 75 10             	pushl  0x10(%ebp)
-801077be:	e8 9d a2 ff ff       	call   80101a60 <readi>
-801077c3:	83 c4 10             	add    $0x10,%esp
-801077c6:	39 f8                	cmp    %edi,%eax
-801077c8:	74 ae                	je     80107778 <loaduvm+0x38>
-}
-801077ca:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return -1;
-801077cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-801077d2:	5b                   	pop    %ebx
-801077d3:	5e                   	pop    %esi
-801077d4:	5f                   	pop    %edi
-801077d5:	5d                   	pop    %ebp
-801077d6:	c3                   	ret    
-801077d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801077de:	66 90                	xchg   %ax,%ax
-801077e0:	8d 65 f4             	lea    -0xc(%ebp),%esp
-  return 0;
-801077e3:	31 c0                	xor    %eax,%eax
-}
-801077e5:	5b                   	pop    %ebx
-801077e6:	5e                   	pop    %esi
-801077e7:	5f                   	pop    %edi
-801077e8:	5d                   	pop    %ebp
-801077e9:	c3                   	ret    
-      panic("loaduvm: address should exist");
-801077ea:	83 ec 0c             	sub    $0xc,%esp
-801077ed:	68 b3 85 10 80       	push   $0x801085b3
-801077f2:	e8 99 8b ff ff       	call   80100390 <panic>
-    panic("loaduvm: addr must be page aligned");
-801077f7:	83 ec 0c             	sub    $0xc,%esp
-801077fa:	68 54 86 10 80       	push   $0x80108654
-801077ff:	e8 8c 8b ff ff       	call   80100390 <panic>
-80107804:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010780b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010780f:	90                   	nop
-
-80107810 <allocuvm>:
-{
-80107810:	f3 0f 1e fb          	endbr32 
-80107814:	55                   	push   %ebp
-80107815:	89 e5                	mov    %esp,%ebp
-80107817:	57                   	push   %edi
-80107818:	56                   	push   %esi
-80107819:	53                   	push   %ebx
-8010781a:	83 ec 1c             	sub    $0x1c,%esp
-  if(newsz >= KERNBASE)
-8010781d:	8b 45 10             	mov    0x10(%ebp),%eax
-{
-80107820:	8b 7d 08             	mov    0x8(%ebp),%edi
-  if(newsz >= KERNBASE)
-80107823:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-80107826:	85 c0                	test   %eax,%eax
-80107828:	0f 88 b2 00 00 00    	js     801078e0 <allocuvm+0xd0>
-  if(newsz < oldsz)
-8010782e:	3b 45 0c             	cmp    0xc(%ebp),%eax
-    return oldsz;
-80107831:	8b 45 0c             	mov    0xc(%ebp),%eax
-  if(newsz < oldsz)
-80107834:	0f 82 96 00 00 00    	jb     801078d0 <allocuvm+0xc0>
-  a = PGROUNDUP(oldsz);
-8010783a:	8d b0 ff 0f 00 00    	lea    0xfff(%eax),%esi
-80107840:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
-  for(; a < newsz; a += PGSIZE){
-80107846:	39 75 10             	cmp    %esi,0x10(%ebp)
-80107849:	77 40                	ja     8010788b <allocuvm+0x7b>
-8010784b:	e9 83 00 00 00       	jmp    801078d3 <allocuvm+0xc3>
-    memset(mem, 0, PGSIZE);
-80107850:	83 ec 04             	sub    $0x4,%esp
-80107853:	68 00 10 00 00       	push   $0x1000
-80107858:	6a 00                	push   $0x0
-8010785a:	50                   	push   %eax
-8010785b:	e8 70 d6 ff ff       	call   80104ed0 <memset>
-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
-80107860:	58                   	pop    %eax
-80107861:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
-80107867:	5a                   	pop    %edx
-80107868:	6a 06                	push   $0x6
-8010786a:	b9 00 10 00 00       	mov    $0x1000,%ecx
-8010786f:	89 f2                	mov    %esi,%edx
-80107871:	50                   	push   %eax
-80107872:	89 f8                	mov    %edi,%eax
-80107874:	e8 47 fb ff ff       	call   801073c0 <mappages>
-80107879:	83 c4 10             	add    $0x10,%esp
-8010787c:	85 c0                	test   %eax,%eax
-8010787e:	78 78                	js     801078f8 <allocuvm+0xe8>
-  for(; a < newsz; a += PGSIZE){
-80107880:	81 c6 00 10 00 00    	add    $0x1000,%esi
-80107886:	39 75 10             	cmp    %esi,0x10(%ebp)
-80107889:	76 48                	jbe    801078d3 <allocuvm+0xc3>
-    mem = kalloc();
-8010788b:	e8 a0 ad ff ff       	call   80102630 <kalloc>
-80107890:	89 c3                	mov    %eax,%ebx
-    if(mem == 0){
-80107892:	85 c0                	test   %eax,%eax
-80107894:	75 ba                	jne    80107850 <allocuvm+0x40>
-      cprintf("allocuvm out of memory\n");
-80107896:	83 ec 0c             	sub    $0xc,%esp
-80107899:	68 d1 85 10 80       	push   $0x801085d1
-8010789e:	e8 0d 8e ff ff       	call   801006b0 <cprintf>
-  if(newsz >= oldsz)
-801078a3:	8b 45 0c             	mov    0xc(%ebp),%eax
-801078a6:	83 c4 10             	add    $0x10,%esp
-801078a9:	39 45 10             	cmp    %eax,0x10(%ebp)
-801078ac:	74 32                	je     801078e0 <allocuvm+0xd0>
-801078ae:	8b 55 10             	mov    0x10(%ebp),%edx
-801078b1:	89 c1                	mov    %eax,%ecx
-801078b3:	89 f8                	mov    %edi,%eax
-801078b5:	e8 96 fb ff ff       	call   80107450 <deallocuvm.part.0>
-      return 0;
-801078ba:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
-}
-801078c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-801078c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801078c7:	5b                   	pop    %ebx
-801078c8:	5e                   	pop    %esi
-801078c9:	5f                   	pop    %edi
-801078ca:	5d                   	pop    %ebp
-801078cb:	c3                   	ret    
-801078cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    return oldsz;
-801078d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-}
-801078d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-801078d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801078d9:	5b                   	pop    %ebx
-801078da:	5e                   	pop    %esi
-801078db:	5f                   	pop    %edi
-801078dc:	5d                   	pop    %ebp
-801078dd:	c3                   	ret    
-801078de:	66 90                	xchg   %ax,%ax
-    return 0;
-801078e0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
-}
-801078e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-801078ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801078ed:	5b                   	pop    %ebx
-801078ee:	5e                   	pop    %esi
-801078ef:	5f                   	pop    %edi
-801078f0:	5d                   	pop    %ebp
-801078f1:	c3                   	ret    
-801078f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-      cprintf("allocuvm out of memory (2)\n");
-801078f8:	83 ec 0c             	sub    $0xc,%esp
-801078fb:	68 e9 85 10 80       	push   $0x801085e9
-80107900:	e8 ab 8d ff ff       	call   801006b0 <cprintf>
-  if(newsz >= oldsz)
-80107905:	8b 45 0c             	mov    0xc(%ebp),%eax
-80107908:	83 c4 10             	add    $0x10,%esp
-8010790b:	39 45 10             	cmp    %eax,0x10(%ebp)
-8010790e:	74 0c                	je     8010791c <allocuvm+0x10c>
-80107910:	8b 55 10             	mov    0x10(%ebp),%edx
-80107913:	89 c1                	mov    %eax,%ecx
-80107915:	89 f8                	mov    %edi,%eax
-80107917:	e8 34 fb ff ff       	call   80107450 <deallocuvm.part.0>
-      kfree(mem);
-8010791c:	83 ec 0c             	sub    $0xc,%esp
-8010791f:	53                   	push   %ebx
-80107920:	e8 4b ab ff ff       	call   80102470 <kfree>
-      return 0;
-80107925:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
-8010792c:	83 c4 10             	add    $0x10,%esp
-}
-8010792f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-80107932:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80107935:	5b                   	pop    %ebx
-80107936:	5e                   	pop    %esi
-80107937:	5f                   	pop    %edi
-80107938:	5d                   	pop    %ebp
-80107939:	c3                   	ret    
-8010793a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-80107940 <deallocuvm>:
-{
-80107940:	f3 0f 1e fb          	endbr32 
-80107944:	55                   	push   %ebp
-80107945:	89 e5                	mov    %esp,%ebp
-80107947:	8b 55 0c             	mov    0xc(%ebp),%edx
-8010794a:	8b 4d 10             	mov    0x10(%ebp),%ecx
-8010794d:	8b 45 08             	mov    0x8(%ebp),%eax
-  if(newsz >= oldsz)
-80107950:	39 d1                	cmp    %edx,%ecx
-80107952:	73 0c                	jae    80107960 <deallocuvm+0x20>
-}
-80107954:	5d                   	pop    %ebp
-80107955:	e9 f6 fa ff ff       	jmp    80107450 <deallocuvm.part.0>
-8010795a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-80107960:	89 d0                	mov    %edx,%eax
-80107962:	5d                   	pop    %ebp
-80107963:	c3                   	ret    
-80107964:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-8010796b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-8010796f:	90                   	nop
-
-80107970 <freevm>:
-
-// Free a page table and all the physical memory pages
-// in the user part.
-void
-freevm(pde_t *pgdir)
-{
-80107970:	f3 0f 1e fb          	endbr32 
-80107974:	55                   	push   %ebp
-80107975:	89 e5                	mov    %esp,%ebp
-80107977:	57                   	push   %edi
-80107978:	56                   	push   %esi
-80107979:	53                   	push   %ebx
-8010797a:	83 ec 0c             	sub    $0xc,%esp
-8010797d:	8b 75 08             	mov    0x8(%ebp),%esi
-  uint i;
-
-  if(pgdir == 0)
-80107980:	85 f6                	test   %esi,%esi
-80107982:	74 55                	je     801079d9 <freevm+0x69>
-  if(newsz >= oldsz)
-80107984:	31 c9                	xor    %ecx,%ecx
-80107986:	ba 00 00 00 80       	mov    $0x80000000,%edx
-8010798b:	89 f0                	mov    %esi,%eax
-8010798d:	89 f3                	mov    %esi,%ebx
-8010798f:	e8 bc fa ff ff       	call   80107450 <deallocuvm.part.0>
-    panic("freevm: no pgdir");
-  deallocuvm(pgdir, KERNBASE, 0);
-  for(i = 0; i < NPDENTRIES; i++){
-80107994:	8d be 00 10 00 00    	lea    0x1000(%esi),%edi
-8010799a:	eb 0b                	jmp    801079a7 <freevm+0x37>
-8010799c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-801079a0:	83 c3 04             	add    $0x4,%ebx
-801079a3:	39 df                	cmp    %ebx,%edi
-801079a5:	74 23                	je     801079ca <freevm+0x5a>
-    if(pgdir[i] & PTE_P){
-801079a7:	8b 03                	mov    (%ebx),%eax
-801079a9:	a8 01                	test   $0x1,%al
-801079ab:	74 f3                	je     801079a0 <freevm+0x30>
-      char * v = P2V(PTE_ADDR(pgdir[i]));
-801079ad:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-      kfree(v);
-801079b2:	83 ec 0c             	sub    $0xc,%esp
-801079b5:	83 c3 04             	add    $0x4,%ebx
-      char * v = P2V(PTE_ADDR(pgdir[i]));
-801079b8:	05 00 00 00 80       	add    $0x80000000,%eax
-      kfree(v);
-801079bd:	50                   	push   %eax
-801079be:	e8 ad aa ff ff       	call   80102470 <kfree>
-801079c3:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; i < NPDENTRIES; i++){
-801079c6:	39 df                	cmp    %ebx,%edi
-801079c8:	75 dd                	jne    801079a7 <freevm+0x37>
-    }
-  }
-  kfree((char*)pgdir);
-801079ca:	89 75 08             	mov    %esi,0x8(%ebp)
-}
-801079cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
-801079d0:	5b                   	pop    %ebx
-801079d1:	5e                   	pop    %esi
-801079d2:	5f                   	pop    %edi
-801079d3:	5d                   	pop    %ebp
-  kfree((char*)pgdir);
-801079d4:	e9 97 aa ff ff       	jmp    80102470 <kfree>
-    panic("freevm: no pgdir");
-801079d9:	83 ec 0c             	sub    $0xc,%esp
-801079dc:	68 05 86 10 80       	push   $0x80108605
-801079e1:	e8 aa 89 ff ff       	call   80100390 <panic>
-801079e6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-801079ed:	8d 76 00             	lea    0x0(%esi),%esi
-
-801079f0 <setupkvm>:
-{
-801079f0:	f3 0f 1e fb          	endbr32 
-801079f4:	55                   	push   %ebp
-801079f5:	89 e5                	mov    %esp,%ebp
-801079f7:	56                   	push   %esi
-801079f8:	53                   	push   %ebx
-  if((pgdir = (pde_t*)kalloc()) == 0)
-801079f9:	e8 32 ac ff ff       	call   80102630 <kalloc>
-801079fe:	89 c6                	mov    %eax,%esi
-80107a00:	85 c0                	test   %eax,%eax
-80107a02:	74 42                	je     80107a46 <setupkvm+0x56>
-  memset(pgdir, 0, PGSIZE);
-80107a04:	83 ec 04             	sub    $0x4,%esp
-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
-80107a07:	bb 20 b4 10 80       	mov    $0x8010b420,%ebx
-  memset(pgdir, 0, PGSIZE);
-80107a0c:	68 00 10 00 00       	push   $0x1000
-80107a11:	6a 00                	push   $0x0
-80107a13:	50                   	push   %eax
-80107a14:	e8 b7 d4 ff ff       	call   80104ed0 <memset>
-80107a19:	83 c4 10             	add    $0x10,%esp
-                (uint)k->phys_start, k->perm) < 0) {
-80107a1c:	8b 43 04             	mov    0x4(%ebx),%eax
-    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
-80107a1f:	83 ec 08             	sub    $0x8,%esp
-80107a22:	8b 4b 08             	mov    0x8(%ebx),%ecx
-80107a25:	ff 73 0c             	pushl  0xc(%ebx)
-80107a28:	8b 13                	mov    (%ebx),%edx
-80107a2a:	50                   	push   %eax
-80107a2b:	29 c1                	sub    %eax,%ecx
-80107a2d:	89 f0                	mov    %esi,%eax
-80107a2f:	e8 8c f9 ff ff       	call   801073c0 <mappages>
-80107a34:	83 c4 10             	add    $0x10,%esp
-80107a37:	85 c0                	test   %eax,%eax
-80107a39:	78 15                	js     80107a50 <setupkvm+0x60>
-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
-80107a3b:	83 c3 10             	add    $0x10,%ebx
-80107a3e:	81 fb 60 b4 10 80    	cmp    $0x8010b460,%ebx
-80107a44:	75 d6                	jne    80107a1c <setupkvm+0x2c>
-}
-80107a46:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80107a49:	89 f0                	mov    %esi,%eax
-80107a4b:	5b                   	pop    %ebx
-80107a4c:	5e                   	pop    %esi
-80107a4d:	5d                   	pop    %ebp
-80107a4e:	c3                   	ret    
-80107a4f:	90                   	nop
-      freevm(pgdir);
-80107a50:	83 ec 0c             	sub    $0xc,%esp
-80107a53:	56                   	push   %esi
-      return 0;
-80107a54:	31 f6                	xor    %esi,%esi
-      freevm(pgdir);
-80107a56:	e8 15 ff ff ff       	call   80107970 <freevm>
-      return 0;
-80107a5b:	83 c4 10             	add    $0x10,%esp
-}
-80107a5e:	8d 65 f8             	lea    -0x8(%ebp),%esp
-80107a61:	89 f0                	mov    %esi,%eax
-80107a63:	5b                   	pop    %ebx
-80107a64:	5e                   	pop    %esi
-80107a65:	5d                   	pop    %ebp
-80107a66:	c3                   	ret    
-80107a67:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80107a6e:	66 90                	xchg   %ax,%ax
-
-80107a70 <kvmalloc>:
-{
-80107a70:	f3 0f 1e fb          	endbr32 
-80107a74:	55                   	push   %ebp
-80107a75:	89 e5                	mov    %esp,%ebp
-80107a77:	83 ec 08             	sub    $0x8,%esp
-  kpgdir = setupkvm();
-80107a7a:	e8 71 ff ff ff       	call   801079f0 <setupkvm>
-80107a7f:	a3 e4 89 11 80       	mov    %eax,0x801189e4
-  lcr3(V2P(kpgdir));   // switch to the kernel page table
-80107a84:	05 00 00 00 80       	add    $0x80000000,%eax
-80107a89:	0f 22 d8             	mov    %eax,%cr3
-}
-80107a8c:	c9                   	leave  
-80107a8d:	c3                   	ret    
-80107a8e:	66 90                	xchg   %ax,%ax
-
-80107a90 <clearpteu>:
-
-// Clear PTE_U on a page. Used to create an inaccessible
-// page beneath the user stack.
-void
-clearpteu(pde_t *pgdir, char *uva)
-{
-80107a90:	f3 0f 1e fb          	endbr32 
-80107a94:	55                   	push   %ebp
-  pte_t *pte;
-
-  pte = walkpgdir(pgdir, uva, 0);
-80107a95:	31 c9                	xor    %ecx,%ecx
-{
-80107a97:	89 e5                	mov    %esp,%ebp
-80107a99:	83 ec 08             	sub    $0x8,%esp
-  pte = walkpgdir(pgdir, uva, 0);
-80107a9c:	8b 55 0c             	mov    0xc(%ebp),%edx
-80107a9f:	8b 45 08             	mov    0x8(%ebp),%eax
-80107aa2:	e8 99 f8 ff ff       	call   80107340 <walkpgdir>
-  if(pte == 0)
-80107aa7:	85 c0                	test   %eax,%eax
-80107aa9:	74 05                	je     80107ab0 <clearpteu+0x20>
-    panic("clearpteu");
-  *pte &= ~PTE_U;
-80107aab:	83 20 fb             	andl   $0xfffffffb,(%eax)
-}
-80107aae:	c9                   	leave  
-80107aaf:	c3                   	ret    
-    panic("clearpteu");
-80107ab0:	83 ec 0c             	sub    $0xc,%esp
-80107ab3:	68 16 86 10 80       	push   $0x80108616
-80107ab8:	e8 d3 88 ff ff       	call   80100390 <panic>
-80107abd:	8d 76 00             	lea    0x0(%esi),%esi
-
-80107ac0 <copyuvm>:
-
-// Given a parent process's page table, create a copy
-// of it for a child.
-pde_t*
-copyuvm(pde_t *pgdir, uint sz)
-{
-80107ac0:	f3 0f 1e fb          	endbr32 
-80107ac4:	55                   	push   %ebp
-80107ac5:	89 e5                	mov    %esp,%ebp
-80107ac7:	57                   	push   %edi
-80107ac8:	56                   	push   %esi
-80107ac9:	53                   	push   %ebx
-80107aca:	83 ec 1c             	sub    $0x1c,%esp
-  pde_t *d;
-  pte_t *pte;
-  uint pa, i, flags;
-  char *mem;
-
-  if((d = setupkvm()) == 0)
-80107acd:	e8 1e ff ff ff       	call   801079f0 <setupkvm>
-80107ad2:	89 45 e0             	mov    %eax,-0x20(%ebp)
-80107ad5:	85 c0                	test   %eax,%eax
-80107ad7:	0f 84 9b 00 00 00    	je     80107b78 <copyuvm+0xb8>
-    return 0;
-  for(i = 0; i < sz; i += PGSIZE){
-80107add:	8b 4d 0c             	mov    0xc(%ebp),%ecx
-80107ae0:	85 c9                	test   %ecx,%ecx
-80107ae2:	0f 84 90 00 00 00    	je     80107b78 <copyuvm+0xb8>
-80107ae8:	31 f6                	xor    %esi,%esi
-80107aea:	eb 46                	jmp    80107b32 <copyuvm+0x72>
-80107aec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-      panic("copyuvm: page not present");
-    pa = PTE_ADDR(*pte);
-    flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto bad;
-    memmove(mem, (char*)P2V(pa), PGSIZE);
-80107af0:	83 ec 04             	sub    $0x4,%esp
-80107af3:	81 c7 00 00 00 80    	add    $0x80000000,%edi
-80107af9:	68 00 10 00 00       	push   $0x1000
-80107afe:	57                   	push   %edi
-80107aff:	50                   	push   %eax
-80107b00:	e8 6b d4 ff ff       	call   80104f70 <memmove>
-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
-80107b05:	58                   	pop    %eax
-80107b06:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
-80107b0c:	5a                   	pop    %edx
-80107b0d:	ff 75 e4             	pushl  -0x1c(%ebp)
-80107b10:	b9 00 10 00 00       	mov    $0x1000,%ecx
-80107b15:	89 f2                	mov    %esi,%edx
-80107b17:	50                   	push   %eax
-80107b18:	8b 45 e0             	mov    -0x20(%ebp),%eax
-80107b1b:	e8 a0 f8 ff ff       	call   801073c0 <mappages>
-80107b20:	83 c4 10             	add    $0x10,%esp
-80107b23:	85 c0                	test   %eax,%eax
-80107b25:	78 61                	js     80107b88 <copyuvm+0xc8>
-  for(i = 0; i < sz; i += PGSIZE){
-80107b27:	81 c6 00 10 00 00    	add    $0x1000,%esi
-80107b2d:	39 75 0c             	cmp    %esi,0xc(%ebp)
-80107b30:	76 46                	jbe    80107b78 <copyuvm+0xb8>
-    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
-80107b32:	8b 45 08             	mov    0x8(%ebp),%eax
-80107b35:	31 c9                	xor    %ecx,%ecx
-80107b37:	89 f2                	mov    %esi,%edx
-80107b39:	e8 02 f8 ff ff       	call   80107340 <walkpgdir>
-80107b3e:	85 c0                	test   %eax,%eax
-80107b40:	74 61                	je     80107ba3 <copyuvm+0xe3>
-    if(!(*pte & PTE_P))
-80107b42:	8b 00                	mov    (%eax),%eax
-80107b44:	a8 01                	test   $0x1,%al
-80107b46:	74 4e                	je     80107b96 <copyuvm+0xd6>
-    pa = PTE_ADDR(*pte);
-80107b48:	89 c7                	mov    %eax,%edi
-    flags = PTE_FLAGS(*pte);
-80107b4a:	25 ff 0f 00 00       	and    $0xfff,%eax
-80107b4f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-    pa = PTE_ADDR(*pte);
-80107b52:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
-    if((mem = kalloc()) == 0)
-80107b58:	e8 d3 aa ff ff       	call   80102630 <kalloc>
-80107b5d:	89 c3                	mov    %eax,%ebx
-80107b5f:	85 c0                	test   %eax,%eax
-80107b61:	75 8d                	jne    80107af0 <copyuvm+0x30>
-    }
-  }
-  return d;
-
-bad:
-  freevm(d);
-80107b63:	83 ec 0c             	sub    $0xc,%esp
-80107b66:	ff 75 e0             	pushl  -0x20(%ebp)
-80107b69:	e8 02 fe ff ff       	call   80107970 <freevm>
-  return 0;
-80107b6e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
-80107b75:	83 c4 10             	add    $0x10,%esp
-}
-80107b78:	8b 45 e0             	mov    -0x20(%ebp),%eax
-80107b7b:	8d 65 f4             	lea    -0xc(%ebp),%esp
-80107b7e:	5b                   	pop    %ebx
-80107b7f:	5e                   	pop    %esi
-80107b80:	5f                   	pop    %edi
-80107b81:	5d                   	pop    %ebp
-80107b82:	c3                   	ret    
-80107b83:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-80107b87:	90                   	nop
-      kfree(mem);
-80107b88:	83 ec 0c             	sub    $0xc,%esp
-80107b8b:	53                   	push   %ebx
-80107b8c:	e8 df a8 ff ff       	call   80102470 <kfree>
-      goto bad;
-80107b91:	83 c4 10             	add    $0x10,%esp
-80107b94:	eb cd                	jmp    80107b63 <copyuvm+0xa3>
-      panic("copyuvm: page not present");
-80107b96:	83 ec 0c             	sub    $0xc,%esp
-80107b99:	68 3a 86 10 80       	push   $0x8010863a
-80107b9e:	e8 ed 87 ff ff       	call   80100390 <panic>
-      panic("copyuvm: pte should exist");
-80107ba3:	83 ec 0c             	sub    $0xc,%esp
-80107ba6:	68 20 86 10 80       	push   $0x80108620
-80107bab:	e8 e0 87 ff ff       	call   80100390 <panic>
-
-80107bb0 <uva2ka>:
-
-//PAGEBREAK!
-// Map user virtual address to kernel address.
-char*
-uva2ka(pde_t *pgdir, char *uva)
-{
-80107bb0:	f3 0f 1e fb          	endbr32 
-80107bb4:	55                   	push   %ebp
-  pte_t *pte;
-
-  pte = walkpgdir(pgdir, uva, 0);
-80107bb5:	31 c9                	xor    %ecx,%ecx
-{
-80107bb7:	89 e5                	mov    %esp,%ebp
-80107bb9:	83 ec 08             	sub    $0x8,%esp
-  pte = walkpgdir(pgdir, uva, 0);
-80107bbc:	8b 55 0c             	mov    0xc(%ebp),%edx
-80107bbf:	8b 45 08             	mov    0x8(%ebp),%eax
-80107bc2:	e8 79 f7 ff ff       	call   80107340 <walkpgdir>
-  if((*pte & PTE_P) == 0)
-80107bc7:	8b 00                	mov    (%eax),%eax
-    return 0;
-  if((*pte & PTE_U) == 0)
-    return 0;
-  return (char*)P2V(PTE_ADDR(*pte));
-}
-80107bc9:	c9                   	leave  
-  if((*pte & PTE_U) == 0)
-80107bca:	89 c2                	mov    %eax,%edx
-  return (char*)P2V(PTE_ADDR(*pte));
-80107bcc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-  if((*pte & PTE_U) == 0)
-80107bd1:	83 e2 05             	and    $0x5,%edx
-  return (char*)P2V(PTE_ADDR(*pte));
-80107bd4:	05 00 00 00 80       	add    $0x80000000,%eax
-80107bd9:	83 fa 05             	cmp    $0x5,%edx
-80107bdc:	ba 00 00 00 00       	mov    $0x0,%edx
-80107be1:	0f 45 c2             	cmovne %edx,%eax
-}
-80107be4:	c3                   	ret    
-80107be5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-80107bec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-80107bf0 <copyout>:
-// Copy len bytes from p to user address va in page table pgdir.
-// Most useful when pgdir is not the current page table.
-// uva2ka ensures this only works for PTE_U pages.
-int
-copyout(pde_t *pgdir, uint va, void *p, uint len)
-{
-80107bf0:	f3 0f 1e fb          	endbr32 
-80107bf4:	55                   	push   %ebp
-80107bf5:	89 e5                	mov    %esp,%ebp
-80107bf7:	57                   	push   %edi
-80107bf8:	56                   	push   %esi
-80107bf9:	53                   	push   %ebx
-80107bfa:	83 ec 0c             	sub    $0xc,%esp
-80107bfd:	8b 75 14             	mov    0x14(%ebp),%esi
-80107c00:	8b 55 0c             	mov    0xc(%ebp),%edx
-  char *buf, *pa0;
-  uint n, va0;
-
-  buf = (char*)p;
-  while(len > 0){
-80107c03:	85 f6                	test   %esi,%esi
-80107c05:	75 3c                	jne    80107c43 <copyout+0x53>
-80107c07:	eb 67                	jmp    80107c70 <copyout+0x80>
-80107c09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    va0 = (uint)PGROUNDDOWN(va);
-    pa0 = uva2ka(pgdir, (char*)va0);
-    if(pa0 == 0)
-      return -1;
-    n = PGSIZE - (va - va0);
-80107c10:	8b 55 0c             	mov    0xc(%ebp),%edx
-80107c13:	89 fb                	mov    %edi,%ebx
-80107c15:	29 d3                	sub    %edx,%ebx
-80107c17:	81 c3 00 10 00 00    	add    $0x1000,%ebx
-    if(n > len)
-80107c1d:	39 f3                	cmp    %esi,%ebx
-80107c1f:	0f 47 de             	cmova  %esi,%ebx
-      n = len;
-    memmove(pa0 + (va - va0), buf, n);
-80107c22:	29 fa                	sub    %edi,%edx
-80107c24:	83 ec 04             	sub    $0x4,%esp
-80107c27:	01 c2                	add    %eax,%edx
-80107c29:	53                   	push   %ebx
-80107c2a:	ff 75 10             	pushl  0x10(%ebp)
-80107c2d:	52                   	push   %edx
-80107c2e:	e8 3d d3 ff ff       	call   80104f70 <memmove>
-    len -= n;
-    buf += n;
-80107c33:	01 5d 10             	add    %ebx,0x10(%ebp)
-    va = va0 + PGSIZE;
-80107c36:	8d 97 00 10 00 00    	lea    0x1000(%edi),%edx
-  while(len > 0){
-80107c3c:	83 c4 10             	add    $0x10,%esp
-80107c3f:	29 de                	sub    %ebx,%esi
-80107c41:	74 2d                	je     80107c70 <copyout+0x80>
-    va0 = (uint)PGROUNDDOWN(va);
-80107c43:	89 d7                	mov    %edx,%edi
-    pa0 = uva2ka(pgdir, (char*)va0);
-80107c45:	83 ec 08             	sub    $0x8,%esp
-    va0 = (uint)PGROUNDDOWN(va);
-80107c48:	89 55 0c             	mov    %edx,0xc(%ebp)
-80107c4b:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
-    pa0 = uva2ka(pgdir, (char*)va0);
-80107c51:	57                   	push   %edi
-80107c52:	ff 75 08             	pushl  0x8(%ebp)
-80107c55:	e8 56 ff ff ff       	call   80107bb0 <uva2ka>
-    if(pa0 == 0)
-80107c5a:	83 c4 10             	add    $0x10,%esp
-80107c5d:	85 c0                	test   %eax,%eax
-80107c5f:	75 af                	jne    80107c10 <copyout+0x20>
-  }
-  return 0;
-}
-80107c61:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return -1;
-80107c64:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-}
-80107c69:	5b                   	pop    %ebx
-80107c6a:	5e                   	pop    %esi
-80107c6b:	5f                   	pop    %edi
-80107c6c:	5d                   	pop    %ebp
-80107c6d:	c3                   	ret    
-80107c6e:	66 90                	xchg   %ax,%ax
-80107c70:	8d 65 f4             	lea    -0xc(%ebp),%esp
-  return 0;
-80107c73:	31 c0                	xor    %eax,%eax
-}
-80107c75:	5b                   	pop    %ebx
-80107c76:	5e                   	pop    %esi
-80107c77:	5f                   	pop    %edi
-80107c78:	5d                   	pop    %ebp
-80107c79:	c3                   	ret    
diff --git a/xv6-public/Operating-System-Project/kernel.ld b/xv6-public/Operating-System-Project/kernel.ld
deleted file mode 100644
index 4e12e14..0000000
--- a/xv6-public/Operating-System-Project/kernel.ld
+++ /dev/null
@@ -1,64 +0,0 @@
-/* Simple linker script for the JOS kernel.
-   See the GNU ld 'info' manual ("info ld") to learn the syntax. */
-
-OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
-OUTPUT_ARCH(i386)
-ENTRY(_start)
-
-SECTIONS
-{
-	/* Link the kernel at this address: "." means the current address */
-        /* Must be equal to KERNLINK */
-	. = 0x80100000;
-
-	.text : AT(0x100000) {
-		*(.text .stub .text.* .gnu.linkonce.t.*)
-	}
-
-	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
-
-	.rodata : {
-		*(.rodata .rodata.* .gnu.linkonce.r.*)
-	}
-
-	/* Include debugging information in kernel memory */
-	.stab : {
-		PROVIDE(__STAB_BEGIN__ = .);
-		*(.stab);
-		PROVIDE(__STAB_END__ = .);
-	}
-
-	.stabstr : {
-		PROVIDE(__STABSTR_BEGIN__ = .);
-		*(.stabstr);
-		PROVIDE(__STABSTR_END__ = .);
-	}
-
-	/* Adjust the address for the data segment to the next page */
-	. = ALIGN(0x1000);
-
-	/* Conventionally, Unix linkers provide pseudo-symbols
-	 * etext, edata, and end, at the end of the text, data, and bss.
-	 * For the kernel mapping, we need the address at the beginning
-	 * of the data section, but that's not one of the conventional
-	 * symbols, because the convention started before there was a
-	 * read-only rodata section between text and data. */
-	PROVIDE(data = .);
-
-	/* The data segment */
-	.data : {
-		*(.data)
-	}
-
-	PROVIDE(edata = .);
-
-	.bss : {
-		*(.bss)
-	}
-
-	PROVIDE(end = .);
-
-	/DISCARD/ : {
-		*(.eh_frame .note.GNU-stack)
-	}
-}
diff --git a/xv6-public/Operating-System-Project/kernel.sym b/xv6-public/Operating-System-Project/kernel.sym
deleted file mode 100644
index 701bb43..0000000
--- a/xv6-public/Operating-System-Project/kernel.sym
+++ /dev/null
@@ -1,548 +0,0 @@
-80100000 .text
-80107c80 .rodata
-80109000 .data
-8010b520 .bss
-00000000 .debug_line
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_aranges
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 .comment
-00000000 bio.c
-00000000 console.c
-8010b520 cons
-8010b558 panicked
-80100410 consputc.part.0
-801005a0 printint
-80107cf0 digits.1619
-00000000 exec.c
-00000000 file.c
-00000000 fs.c
-801011b0 bfree
-80101230 balloc
-80101340 iget
-80101430 bmap
-80101d70 namex
-00000000 ide.c
-80102070 idestart
-8010b580 idelock
-8010b560 havedisk1
-8010b564 idequeue
-00000000 ioapic.c
-00000000 kalloc.c
-00000000 kbd.c
-8010b5b4 shift.1444
-80108020 shiftcode
-80107f20 togglecode
-80107f00 charcode.1445
-80109200 normalmap
-80109100 shiftmap
-80109000 ctlmap
-00000000 lapic.c
-00000000 log.c
-80102b90 install_trans
-80102c30 write_head
-00000000 main.c
-80102fe0 mpmain
-80103020 mpenter
-00000000 mp.c
-80103170 mpsearch1
-00000000 picirq.c
-00000000 pipe.c
-00000000 proc.c
-80103790 allocproc
-8010b000 first.1732
-8010b5c4 initproc
-801082cc states.1758
-00000000 sleeplock.c
-00000000 spinlock.c
-00000000 string.c
-00000000 syscall.c
-80108340 syscalls
-00000000 sysfile.c
-80105310 create
-801054b0 argfd.constprop.0
-00000000 sysproc.c
-00000000 trap.c
-00000000 uart.c
-80106740 uartgetc
-8010b5c8 uart
-80106770 uartputc.part.0
-00000000 vm.c
-80107340 walkpgdir
-801073c0 mappages
-80107450 deallocuvm.part.0
-8010b420 kmap
-80100290 consoleread
-80107293 vector242
-80106cea vector119
-8010000c entry
-80106bca vector87
-80106bc1 vector86
-80105090 safestrcpy
-801062a0 sys_getWaitingTime
-80105650 sys_close
-801072ff vector251
-80106bee vector91
-801069e4 vector33
-80106ed3 vector162
-801042b0 yield
-801136a0 log
-80113660 kmem
-80107137 vector213
-80106c87 vector108
-801067c0 uartinit
-80106a3e vector43
-801028c0 lapiceoi
-80106ef7 vector165
-80106fe7 vector185
-80102380 ioapicinit
-80104790 getChildren
-80106cc6 vector115
-80100ff0 fileread
-80106d05 vector122
-80105fa0 sys_sbrk
-80113780 ioapicid
-80106220 sys_getTurnAroundTime
-801060d0 sys_getParentID
-80106e8b vector156
-801072b7 vector245
-80113654 ioapic
-80107017 vector189
-80106908 vector7
-80106ae0 vector61
-80106993 vector24
-80106ca2 vector111
-8010709b vector200
-80106b16 vector67
-80106db3 vector138
-80106b55 vector74
-801040a0 sched
-80104f70 memmove
-80106abc vector57
-801052a0 syscall
-80107143 vector214
-80106c36 vector99
-80103990 cpuid
-80101b60 writei
-80106dd7 vector141
-80105f00 sys_fork
-8010c5e0 bcache
-80106f4b vector172
-80107287 vector241
-80104c60 getcallerpcs
-80105b60 sys_mkdir
-80107317 vector253
-801068e4 vector3
-801068db vector2
-80101c90 namecmp
-801071df vector227
-80107113 vector210
-80105260 argstr
-801071bb vector224
-80106a2c vector41
-801006b0 cprintf
-80100e70 filedup
-80102030 namei
-80106978 vector21
-80100040 binit
-80106f87 vector177
-80106ce1 vector118
-80106b31 vector70
-80106b28 vector69
-80107257 vector237
-80106afb vector64
-801069ae vector27
-80104970 customWait
-80106d6b vector132
-80106ff3 vector186
-80105570 sys_read
-80107167 vector217
-80105110 fetchint
-801079f0 setupkvm
-80104fd0 memcpy
-80107970 freevm
-801068d2 vector1
-80106f93 vector178
-80106a11 vector38
-80102470 kfree
-80107263 vector238
-80103920 mycpu
-80101890 iput
-80106d77 vector133
-80106b4c vector73
-80106dfb vector144
-80104950 getCBT
-80103cd0 findHighestInQueue
-80107323 vector254
-801062e0 sys_getCBT
-80101500 readsb
-8010b004 nextpid
-80106c48 vector101
-8010711f vector211
-801031f0 mpinit
-80106f63 vector174
-8010729f vector243
-80100de0 fileinit
-80104c40 initlock
-80106d3b vector128
-80107bf0 copyout
-80106b94 vector81
-80104300 sleep
-801028e0 microdelay
-80103d90 findLowestInQueue
-80106936 vector13
-80106a86 vector51
-8010694d vector16
-80110f40 input
-8010727b vector240
-80106aa1 vector54
-80106966 vector19
-80106bf7 vector92
-801072ab vector244
-80101a30 stati
-80106dcb vector140
-80105f40 sys_kill
-80106a50 vector45
-80106b82 vector79
-80103500 pipeclose
-801071f7 vector229
-80106ea3 vector158
-801056a0 sys_fstat
-80100640 consolewrite
-80106a1a vector39
-80106f1b vector168
-80102da0 end_op
-801069f6 vector35
-80106cb4 vector113
-80102510 freerange
-80106d20 vector125
-80107810 allocuvm
-801063af trapret
-8010715b vector216
-80106af2 vector63
-801069a5 vector26
-80107047 vector193
-801027a0 lapicinit
-8010706b vector196
-80107107 vector209
-8010b5c0 total_t
-801068ed vector4
-80106f33 vector170
-8010b5d0 stack
-80106d9b vector136
-80106921 vector10
-801070e3 vector206
-80101840 iunlock
-80105ff0 sys_sleep
-8010732f vector255
-80106fb7 vector181
-80106ace vector59
-80106bb8 vector85
-80106baf vector84
-80106fcf vector183
-80106eaf vector159
-8010712b vector212
-801056f0 sys_link
-80106a62 vector47
-801071eb vector228
-80106a35 vector42
-801046a0 updateStateDurations
-80106cbd vector114
-80104890 changePolicy
-80107bb0 uva2ka
-80106f6f vector175
-80106def vector143
-80100e00 filealloc
-801044c0 wakeup
-80106d53 vector130
-801072c3 vector246
-80106918 vector9
-80106de3 vector142
-80106c3f vector100
-801070a7 vector201
-80107a90 clearpteu
-801039b0 myproc
-801063c0 tvinit
-80106ad7 vector60
-8010698a vector23
-80101730 idup
-8010724b vector236
-80102780 kbdintr
-80105a20 sys_open
-8010720f vector231
-80106120 sys_getSyscallCounter
-80106b0d vector66
-801069c0 vector29
-80101a60 readi
-80106d8f vector135
-80100860 consoleintr
-80104530 kill
-80106b70 vector77
-801015e0 ialloc
-80106fab vector180
-801189e4 kpgdir
-801070fb vector208
-80102990 cmostime
-801068b0 uartintr
-80106c2d vector98
-80106c24 vector97
-80106f7b vector176
-80107053 vector194
-801069db vector32
-801189e8 end
-8010708f vector199
-80106d5f vector131
-80106260 sys_getBurstTime
-8010730b vector252
-80101090 filewrite
-801068c9 vector0
-80104ac0 setQueue
-801051b0 argint
-80100a80 exec
-80106e07 vector145
-801055e0 sys_write
-80104e80 release
-80105150 fetchstr
-80106c7e vector107
-80106a23 vector40
-801043c0 wait
-80106c51 vector102
-8010a000 entrypgdir
-0010000c _start
-80106ab3 vector56
-80106b1f vector68
-801068ff vector6
-8010b48c _binary_initcode_end
-80100000 multiboot_header
-80106d47 vector129
-80103c80 switch_process
-80103e30 scheduler
-80101cb0 dirlookup
-80107077 vector197
-80100ec0 fileclose
-80102d30 begin_op
-80106e5b vector152
-80107a70 kvmalloc
-80107203 vector230
-80104fe0 strncmp
-80106a08 vector37
-801070d7 vector205
-801048f0 getBurstTime
-80106ec7 vector161
-801181a0 tickslock
-801035a0 pipewrite
-80105030 strncpy
-80106b3a vector71
-80107ac0 copyuvm
-80110fe0 ftable
-80106ebb vector160
-80105200 argptr
-8010714f vector215
-80106e97 vector157
-80105500 sys_dup
-80106cab vector112
-80100390 panic
-801038b0 forkret
-80106fc3 vector182
-8010692f vector12
-80104f20 memcmp
-801026a0 kbdgetc
-80106c90 vector109
-8010696f vector20
-801060e0 sys_getChildren
-80103b60 fork
-80106a98 vector53
-8010695d vector18
-0000008a _binary_entryother_size
-801137a0 cpus
-80104ba0 releasesleep
-801048c0 getTurnAroundTime
-80106c12 vector95
-80104d70 holding
-801119e0 sb
-80104dc0 acquire
-801071d3 vector226
-80102050 nameiparent
-80106a74 vector49
-80106a47 vector44
-8011369c lapic
-80106b79 vector78
-80106397 alltraps
-80106f57 vector173
-80106cd8 vector117
-80106b9d vector82
-801071a3 vector222
-80106911 vector8
-80106e37 vector149
-801016a0 iupdate
-80109000 data
-80104ed0 memset
-8010721b vector232
-80103040 main
-80107590 switchkvm
-80106c75 vector106
-8010718b vector220
-80106be5 vector90
-80106edf vector163
-80107233 vector234
-80102f10 log_write
-80104b40 acquiresleep
-80105840 sys_unlink
-80106ae9 vector62
-8010699c vector25
-80107083 vector198
-80106cf3 vector120
-8010b5b8 order
-8010b48c _binary_entryother_start
-80102560 kinit1
-80106a7d vector50
-80106944 vector15
-80106160 sys_setPriority
-80106e4f vector151
-80106ba6 vector83
-80106bdc vector89
-80106bd3 vector88
-80106470 trap
-801060a0 sys_uptime
-80106f9f vector179
-801069ed vector34
-80106a59 vector46
-80106d83 vector134
-801071af vector223
-801181e0 idt
-80104810 getSyscallCounter
-80107173 vector218
-80103900 pinit
-80107940 deallocuvm
-801071c7 vector225
-801028a0 lapicid
-80106fff vector187
-80103ae0 growproc
-80104be0 holdingsleep
-80113d20 ncpu
-8010b5bc create_t
-801069c9 vector30
-801039e0 userinit
-801000d0 bread
-80106d32 vector127
-801036a0 piperead
-801189e0 ticks
-8010703b vector192
-80106f03 vector166
-80100a30 consoleinit
-80106b67 vector76
-80106b5e vector75
-801021e0 ideintr
-8010705f vector195
-80106e43 vector150
-80106ac5 vector58
-801072db vector248
-80106d0e vector123
-80106c1b vector96
-801069d2 vector31
-801070bf vector203
-80106dbf vector139
-80106e67 vector153
-80106eeb vector164
-80104740 getParentID
-801045c0 procdump
-80106cfc vector121
-80106880 uartputc
-801068f6 vector5
-80106f0f vector167
-80106e7f vector155
-801072e7 vector249
-801001f0 brelse
-801072f3 vector250
-80106d17 vector124
-80106c99 vector110
-801070cb vector204
-80101760 ilock
-80105d20 sys_exec
-80106da7 vector137
-8010b460 _binary_initcode_start
-801050f3 swtch
-801072cf vector247
-80106981 vector22
-80106320 sys_customWait
-801070b3 vector202
-80107500 seginit
-80101a00 iunlockput
-80106b43 vector72
-80106aaa vector55
-80113d40 policy
-80106d29 vector126
-80106b04 vector65
-801069b7 vector28
-8010b516 _binary_entryother_end
-80106f27 vector169
-801001b0 bwrite
-80107227 vector233
-80106360 sys_setQueue
-80106440 idtinit
-80104160 exit
-80105f30 sys_wait
-80105f10 sys_exit
-80101f70 dirlink
-0000002c _binary_initcode_size
-80104850 setPriority
-80106e1f vector147
-80104b00 initsleeplock
-80102150 ideinit
-80107740 loaduvm
-80106c63 vector104
-80106ccf vector116
-80113d60 ptable
-80102430 ioapicenable
-80104910 getCreationTime
-80104d10 popcli
-8010b008 vectors
-80106a8f vector52
-80106956 vector17
-80106fdb vector184
-801050d0 strlen
-80105e20 sys_pipe
-80101540 iinit
-801033d0 picinit
-801070ef vector207
-801076c0 inituvm
-80107023 vector190
-8010726f vector239
-80106c09 vector94
-80106c00 vector93
-80102c90 initlog
-8010700b vector188
-801061e0 sys_getCreationTime
-80106a6b vector48
-80102280 iderw
-8010717f vector219
-80106e2b vector148
-80107197 vector221
-80102630 kalloc
-80111980 devsw
-80105f80 sys_getpid
-80106b8b vector80
-80106f3f vector171
-80106e73 vector154
-801069ff vector36
-801033f0 pipealloc
-8010723f vector235
-80106c6c vector105
-80105c70 sys_chdir
-80111a00 icache
-801061a0 sys_changePolicy
-80106e13 vector146
-8010702f vector191
-80106c5a vector103
-80104930 getWaitingTime
-80105bd0 sys_mknod
-801028f0 lapicstartap
-801075b0 switchuvm
-80104cc0 pushcli
-801025d0 kinit2
-80106928 vector11
-8010693d vector14
-80100fa0 filestat
diff --git a/xv6-public/Operating-System-Project/kill.asm b/xv6-public/Operating-System-Project/kill.asm
deleted file mode 100644
index 497fb6d..0000000
--- a/xv6-public/Operating-System-Project/kill.asm
+++ /dev/null
@@ -1,1269 +0,0 @@
-
-_kill:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char **argv)
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	56                   	push   %esi
-  12:	53                   	push   %ebx
-  13:	51                   	push   %ecx
-  14:	83 ec 0c             	sub    $0xc,%esp
-  17:	8b 01                	mov    (%ecx),%eax
-  19:	8b 51 04             	mov    0x4(%ecx),%edx
-  int i;
-
-  if(argc < 2){
-  1c:	83 f8 01             	cmp    $0x1,%eax
-  1f:	7e 30                	jle    51 <main+0x51>
-  21:	8d 5a 04             	lea    0x4(%edx),%ebx
-  24:	8d 34 82             	lea    (%edx,%eax,4),%esi
-  27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  2e:	66 90                	xchg   %ax,%ax
-    printf(2, "usage: kill pid...\n");
-    exit();
-  }
-  for(i=1; i<argc; i++)
-    kill(atoi(argv[i]));
-  30:	83 ec 0c             	sub    $0xc,%esp
-  33:	ff 33                	pushl  (%ebx)
-  35:	83 c3 04             	add    $0x4,%ebx
-  38:	e8 23 02 00 00       	call   260 <atoi>
-  3d:	89 04 24             	mov    %eax,(%esp)
-  40:	e8 be 02 00 00       	call   303 <kill>
-  for(i=1; i<argc; i++)
-  45:	83 c4 10             	add    $0x10,%esp
-  48:	39 f3                	cmp    %esi,%ebx
-  4a:	75 e4                	jne    30 <main+0x30>
-  exit();
-  4c:	e8 82 02 00 00       	call   2d3 <exit>
-    printf(2, "usage: kill pid...\n");
-  51:	50                   	push   %eax
-  52:	50                   	push   %eax
-  53:	68 f8 07 00 00       	push   $0x7f8
-  58:	6a 02                	push   $0x2
-  5a:	e8 31 04 00 00       	call   490 <printf>
-    exit();
-  5f:	e8 6f 02 00 00       	call   2d3 <exit>
-  64:	66 90                	xchg   %ax,%ax
-  66:	66 90                	xchg   %ax,%ax
-  68:	66 90                	xchg   %ax,%ax
-  6a:	66 90                	xchg   %ax,%ax
-  6c:	66 90                	xchg   %ax,%ax
-  6e:	66 90                	xchg   %ax,%ax
-
-00000070 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  70:	f3 0f 1e fb          	endbr32 
-  74:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  75:	31 c0                	xor    %eax,%eax
-{
-  77:	89 e5                	mov    %esp,%ebp
-  79:	53                   	push   %ebx
-  7a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  7d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-  80:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-  84:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-  87:	83 c0 01             	add    $0x1,%eax
-  8a:	84 d2                	test   %dl,%dl
-  8c:	75 f2                	jne    80 <strcpy+0x10>
-    ;
-  return os;
-}
-  8e:	89 c8                	mov    %ecx,%eax
-  90:	5b                   	pop    %ebx
-  91:	5d                   	pop    %ebp
-  92:	c3                   	ret    
-  93:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-000000a0 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-  a0:	f3 0f 1e fb          	endbr32 
-  a4:	55                   	push   %ebp
-  a5:	89 e5                	mov    %esp,%ebp
-  a7:	53                   	push   %ebx
-  a8:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  ab:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-  ae:	0f b6 01             	movzbl (%ecx),%eax
-  b1:	0f b6 1a             	movzbl (%edx),%ebx
-  b4:	84 c0                	test   %al,%al
-  b6:	75 19                	jne    d1 <strcmp+0x31>
-  b8:	eb 26                	jmp    e0 <strcmp+0x40>
-  ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  c0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-  c4:	83 c1 01             	add    $0x1,%ecx
-  c7:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-  ca:	0f b6 1a             	movzbl (%edx),%ebx
-  cd:	84 c0                	test   %al,%al
-  cf:	74 0f                	je     e0 <strcmp+0x40>
-  d1:	38 d8                	cmp    %bl,%al
-  d3:	74 eb                	je     c0 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-  d5:	29 d8                	sub    %ebx,%eax
-}
-  d7:	5b                   	pop    %ebx
-  d8:	5d                   	pop    %ebp
-  d9:	c3                   	ret    
-  da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  e0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-  e2:	29 d8                	sub    %ebx,%eax
-}
-  e4:	5b                   	pop    %ebx
-  e5:	5d                   	pop    %ebp
-  e6:	c3                   	ret    
-  e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  ee:	66 90                	xchg   %ax,%ax
-
-000000f0 <strlen>:
-
-uint
-strlen(const char *s)
-{
-  f0:	f3 0f 1e fb          	endbr32 
-  f4:	55                   	push   %ebp
-  f5:	89 e5                	mov    %esp,%ebp
-  f7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
-  fa:	80 3a 00             	cmpb   $0x0,(%edx)
-  fd:	74 21                	je     120 <strlen+0x30>
-  ff:	31 c0                	xor    %eax,%eax
- 101:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 108:	83 c0 01             	add    $0x1,%eax
- 10b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 10f:	89 c1                	mov    %eax,%ecx
- 111:	75 f5                	jne    108 <strlen+0x18>
-    ;
-  return n;
-}
- 113:	89 c8                	mov    %ecx,%eax
- 115:	5d                   	pop    %ebp
- 116:	c3                   	ret    
- 117:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 11e:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 120:	31 c9                	xor    %ecx,%ecx
-}
- 122:	5d                   	pop    %ebp
- 123:	89 c8                	mov    %ecx,%eax
- 125:	c3                   	ret    
- 126:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 12d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000130 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 130:	f3 0f 1e fb          	endbr32 
- 134:	55                   	push   %ebp
- 135:	89 e5                	mov    %esp,%ebp
- 137:	57                   	push   %edi
- 138:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 13b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 13e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 141:	89 d7                	mov    %edx,%edi
- 143:	fc                   	cld    
- 144:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 146:	89 d0                	mov    %edx,%eax
- 148:	5f                   	pop    %edi
- 149:	5d                   	pop    %ebp
- 14a:	c3                   	ret    
- 14b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 14f:	90                   	nop
-
-00000150 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 150:	f3 0f 1e fb          	endbr32 
- 154:	55                   	push   %ebp
- 155:	89 e5                	mov    %esp,%ebp
- 157:	8b 45 08             	mov    0x8(%ebp),%eax
- 15a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 15e:	0f b6 10             	movzbl (%eax),%edx
- 161:	84 d2                	test   %dl,%dl
- 163:	75 16                	jne    17b <strchr+0x2b>
- 165:	eb 21                	jmp    188 <strchr+0x38>
- 167:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 16e:	66 90                	xchg   %ax,%ax
- 170:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 174:	83 c0 01             	add    $0x1,%eax
- 177:	84 d2                	test   %dl,%dl
- 179:	74 0d                	je     188 <strchr+0x38>
-    if(*s == c)
- 17b:	38 d1                	cmp    %dl,%cl
- 17d:	75 f1                	jne    170 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 17f:	5d                   	pop    %ebp
- 180:	c3                   	ret    
- 181:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 188:	31 c0                	xor    %eax,%eax
-}
- 18a:	5d                   	pop    %ebp
- 18b:	c3                   	ret    
- 18c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000190 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 190:	f3 0f 1e fb          	endbr32 
- 194:	55                   	push   %ebp
- 195:	89 e5                	mov    %esp,%ebp
- 197:	57                   	push   %edi
- 198:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 199:	31 f6                	xor    %esi,%esi
-{
- 19b:	53                   	push   %ebx
- 19c:	89 f3                	mov    %esi,%ebx
- 19e:	83 ec 1c             	sub    $0x1c,%esp
- 1a1:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 1a4:	eb 33                	jmp    1d9 <gets+0x49>
- 1a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1ad:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 1b0:	83 ec 04             	sub    $0x4,%esp
- 1b3:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 1b6:	6a 01                	push   $0x1
- 1b8:	50                   	push   %eax
- 1b9:	6a 00                	push   $0x0
- 1bb:	e8 2b 01 00 00       	call   2eb <read>
-    if(cc < 1)
- 1c0:	83 c4 10             	add    $0x10,%esp
- 1c3:	85 c0                	test   %eax,%eax
- 1c5:	7e 1c                	jle    1e3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 1c7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 1cb:	83 c7 01             	add    $0x1,%edi
- 1ce:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 1d1:	3c 0a                	cmp    $0xa,%al
- 1d3:	74 23                	je     1f8 <gets+0x68>
- 1d5:	3c 0d                	cmp    $0xd,%al
- 1d7:	74 1f                	je     1f8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 1d9:	83 c3 01             	add    $0x1,%ebx
- 1dc:	89 fe                	mov    %edi,%esi
- 1de:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 1e1:	7c cd                	jl     1b0 <gets+0x20>
- 1e3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 1e5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 1e8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1ee:	5b                   	pop    %ebx
- 1ef:	5e                   	pop    %esi
- 1f0:	5f                   	pop    %edi
- 1f1:	5d                   	pop    %ebp
- 1f2:	c3                   	ret    
- 1f3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 1f7:	90                   	nop
- 1f8:	8b 75 08             	mov    0x8(%ebp),%esi
- 1fb:	8b 45 08             	mov    0x8(%ebp),%eax
- 1fe:	01 de                	add    %ebx,%esi
- 200:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 202:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 205:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 208:	5b                   	pop    %ebx
- 209:	5e                   	pop    %esi
- 20a:	5f                   	pop    %edi
- 20b:	5d                   	pop    %ebp
- 20c:	c3                   	ret    
- 20d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000210 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 210:	f3 0f 1e fb          	endbr32 
- 214:	55                   	push   %ebp
- 215:	89 e5                	mov    %esp,%ebp
- 217:	56                   	push   %esi
- 218:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 219:	83 ec 08             	sub    $0x8,%esp
- 21c:	6a 00                	push   $0x0
- 21e:	ff 75 08             	pushl  0x8(%ebp)
- 221:	e8 ed 00 00 00       	call   313 <open>
-  if(fd < 0)
- 226:	83 c4 10             	add    $0x10,%esp
- 229:	85 c0                	test   %eax,%eax
- 22b:	78 2b                	js     258 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 22d:	83 ec 08             	sub    $0x8,%esp
- 230:	ff 75 0c             	pushl  0xc(%ebp)
- 233:	89 c3                	mov    %eax,%ebx
- 235:	50                   	push   %eax
- 236:	e8 f0 00 00 00       	call   32b <fstat>
-  close(fd);
- 23b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 23e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 240:	e8 b6 00 00 00       	call   2fb <close>
-  return r;
- 245:	83 c4 10             	add    $0x10,%esp
-}
- 248:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 24b:	89 f0                	mov    %esi,%eax
- 24d:	5b                   	pop    %ebx
- 24e:	5e                   	pop    %esi
- 24f:	5d                   	pop    %ebp
- 250:	c3                   	ret    
- 251:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 258:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 25d:	eb e9                	jmp    248 <stat+0x38>
- 25f:	90                   	nop
-
-00000260 <atoi>:
-
-int
-atoi(const char *s)
-{
- 260:	f3 0f 1e fb          	endbr32 
- 264:	55                   	push   %ebp
- 265:	89 e5                	mov    %esp,%ebp
- 267:	53                   	push   %ebx
- 268:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 26b:	0f be 02             	movsbl (%edx),%eax
- 26e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 271:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 274:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 279:	77 1a                	ja     295 <atoi+0x35>
- 27b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 27f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 280:	83 c2 01             	add    $0x1,%edx
- 283:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 286:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 28a:	0f be 02             	movsbl (%edx),%eax
- 28d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 290:	80 fb 09             	cmp    $0x9,%bl
- 293:	76 eb                	jbe    280 <atoi+0x20>
-  return n;
-}
- 295:	89 c8                	mov    %ecx,%eax
- 297:	5b                   	pop    %ebx
- 298:	5d                   	pop    %ebp
- 299:	c3                   	ret    
- 29a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-000002a0 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 2a0:	f3 0f 1e fb          	endbr32 
- 2a4:	55                   	push   %ebp
- 2a5:	89 e5                	mov    %esp,%ebp
- 2a7:	57                   	push   %edi
- 2a8:	8b 45 10             	mov    0x10(%ebp),%eax
- 2ab:	8b 55 08             	mov    0x8(%ebp),%edx
- 2ae:	56                   	push   %esi
- 2af:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 2b2:	85 c0                	test   %eax,%eax
- 2b4:	7e 0f                	jle    2c5 <memmove+0x25>
- 2b6:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 2b8:	89 d7                	mov    %edx,%edi
- 2ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 2c0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 2c1:	39 f8                	cmp    %edi,%eax
- 2c3:	75 fb                	jne    2c0 <memmove+0x20>
-  return vdst;
-}
- 2c5:	5e                   	pop    %esi
- 2c6:	89 d0                	mov    %edx,%eax
- 2c8:	5f                   	pop    %edi
- 2c9:	5d                   	pop    %ebp
- 2ca:	c3                   	ret    
-
-000002cb <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 2cb:	b8 01 00 00 00       	mov    $0x1,%eax
- 2d0:	cd 40                	int    $0x40
- 2d2:	c3                   	ret    
-
-000002d3 <exit>:
-SYSCALL(exit)
- 2d3:	b8 02 00 00 00       	mov    $0x2,%eax
- 2d8:	cd 40                	int    $0x40
- 2da:	c3                   	ret    
-
-000002db <wait>:
-SYSCALL(wait)
- 2db:	b8 03 00 00 00       	mov    $0x3,%eax
- 2e0:	cd 40                	int    $0x40
- 2e2:	c3                   	ret    
-
-000002e3 <pipe>:
-SYSCALL(pipe)
- 2e3:	b8 04 00 00 00       	mov    $0x4,%eax
- 2e8:	cd 40                	int    $0x40
- 2ea:	c3                   	ret    
-
-000002eb <read>:
-SYSCALL(read)
- 2eb:	b8 05 00 00 00       	mov    $0x5,%eax
- 2f0:	cd 40                	int    $0x40
- 2f2:	c3                   	ret    
-
-000002f3 <write>:
-SYSCALL(write)
- 2f3:	b8 10 00 00 00       	mov    $0x10,%eax
- 2f8:	cd 40                	int    $0x40
- 2fa:	c3                   	ret    
-
-000002fb <close>:
-SYSCALL(close)
- 2fb:	b8 15 00 00 00       	mov    $0x15,%eax
- 300:	cd 40                	int    $0x40
- 302:	c3                   	ret    
-
-00000303 <kill>:
-SYSCALL(kill)
- 303:	b8 06 00 00 00       	mov    $0x6,%eax
- 308:	cd 40                	int    $0x40
- 30a:	c3                   	ret    
-
-0000030b <exec>:
-SYSCALL(exec)
- 30b:	b8 07 00 00 00       	mov    $0x7,%eax
- 310:	cd 40                	int    $0x40
- 312:	c3                   	ret    
-
-00000313 <open>:
-SYSCALL(open)
- 313:	b8 0f 00 00 00       	mov    $0xf,%eax
- 318:	cd 40                	int    $0x40
- 31a:	c3                   	ret    
-
-0000031b <mknod>:
-SYSCALL(mknod)
- 31b:	b8 11 00 00 00       	mov    $0x11,%eax
- 320:	cd 40                	int    $0x40
- 322:	c3                   	ret    
-
-00000323 <unlink>:
-SYSCALL(unlink)
- 323:	b8 12 00 00 00       	mov    $0x12,%eax
- 328:	cd 40                	int    $0x40
- 32a:	c3                   	ret    
-
-0000032b <fstat>:
-SYSCALL(fstat)
- 32b:	b8 08 00 00 00       	mov    $0x8,%eax
- 330:	cd 40                	int    $0x40
- 332:	c3                   	ret    
-
-00000333 <link>:
-SYSCALL(link)
- 333:	b8 13 00 00 00       	mov    $0x13,%eax
- 338:	cd 40                	int    $0x40
- 33a:	c3                   	ret    
-
-0000033b <mkdir>:
-SYSCALL(mkdir)
- 33b:	b8 14 00 00 00       	mov    $0x14,%eax
- 340:	cd 40                	int    $0x40
- 342:	c3                   	ret    
-
-00000343 <chdir>:
-SYSCALL(chdir)
- 343:	b8 09 00 00 00       	mov    $0x9,%eax
- 348:	cd 40                	int    $0x40
- 34a:	c3                   	ret    
-
-0000034b <dup>:
-SYSCALL(dup)
- 34b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <getpid>:
-SYSCALL(getpid)
- 353:	b8 0b 00 00 00       	mov    $0xb,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <sbrk>:
-SYSCALL(sbrk)
- 35b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <sleep>:
-SYSCALL(sleep)
- 363:	b8 0d 00 00 00       	mov    $0xd,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <uptime>:
-SYSCALL(uptime)
- 36b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <getParentID>:
-SYSCALL(getParentID)
- 373:	b8 16 00 00 00       	mov    $0x16,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <getChildren>:
-SYSCALL(getChildren)
- 37b:	b8 17 00 00 00       	mov    $0x17,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 383:	b8 18 00 00 00       	mov    $0x18,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <setPriority>:
-SYSCALL(setPriority)
- 38b:	b8 19 00 00 00       	mov    $0x19,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <changePolicy>:
-SYSCALL(changePolicy)
- 393:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 39b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
-
-000003a3 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 3a3:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 3a8:	cd 40                	int    $0x40
- 3aa:	c3                   	ret    
-
-000003ab <getCBT>:
-SYSCALL(getCBT)
- 3ab:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
-
-000003b3 <customWait>:
-SYSCALL(customWait)
- 3b3:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 3b8:	cd 40                	int    $0x40
- 3ba:	c3                   	ret    
-
-000003bb <setQueue>:
-SYSCALL(setQueue)
- 3bb:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 3c0:	cd 40                	int    $0x40
- 3c2:	c3                   	ret    
-
-000003c3 <getBurstTime>:
-SYSCALL(getBurstTime)
- 3c3:	b8 20 00 00 00       	mov    $0x20,%eax
- 3c8:	cd 40                	int    $0x40
- 3ca:	c3                   	ret    
-
-000003cb <getCreationTime>:
- 3cb:	b8 21 00 00 00       	mov    $0x21,%eax
- 3d0:	cd 40                	int    $0x40
- 3d2:	c3                   	ret    
- 3d3:	66 90                	xchg   %ax,%ax
- 3d5:	66 90                	xchg   %ax,%ax
- 3d7:	66 90                	xchg   %ax,%ax
- 3d9:	66 90                	xchg   %ax,%ax
- 3db:	66 90                	xchg   %ax,%ax
- 3dd:	66 90                	xchg   %ax,%ax
- 3df:	90                   	nop
-
-000003e0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 3e0:	55                   	push   %ebp
- 3e1:	89 e5                	mov    %esp,%ebp
- 3e3:	57                   	push   %edi
- 3e4:	56                   	push   %esi
- 3e5:	53                   	push   %ebx
- 3e6:	83 ec 3c             	sub    $0x3c,%esp
- 3e9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 3ec:	89 d1                	mov    %edx,%ecx
-{
- 3ee:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 3f1:	85 d2                	test   %edx,%edx
- 3f3:	0f 89 7f 00 00 00    	jns    478 <printint+0x98>
- 3f9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 3fd:	74 79                	je     478 <printint+0x98>
-    neg = 1;
- 3ff:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 406:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 408:	31 db                	xor    %ebx,%ebx
- 40a:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 40d:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 410:	89 c8                	mov    %ecx,%eax
- 412:	31 d2                	xor    %edx,%edx
- 414:	89 cf                	mov    %ecx,%edi
- 416:	f7 75 c4             	divl   -0x3c(%ebp)
- 419:	0f b6 92 14 08 00 00 	movzbl 0x814(%edx),%edx
- 420:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 423:	89 d8                	mov    %ebx,%eax
- 425:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 428:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 42b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 42e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 431:	76 dd                	jbe    410 <printint+0x30>
-  if(neg)
- 433:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 436:	85 c9                	test   %ecx,%ecx
- 438:	74 0c                	je     446 <printint+0x66>
-    buf[i++] = '-';
- 43a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 43f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 441:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 446:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 449:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 44d:	eb 07                	jmp    456 <printint+0x76>
- 44f:	90                   	nop
- 450:	0f b6 13             	movzbl (%ebx),%edx
- 453:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 456:	83 ec 04             	sub    $0x4,%esp
- 459:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 45c:	6a 01                	push   $0x1
- 45e:	56                   	push   %esi
- 45f:	57                   	push   %edi
- 460:	e8 8e fe ff ff       	call   2f3 <write>
-  while(--i >= 0)
- 465:	83 c4 10             	add    $0x10,%esp
- 468:	39 de                	cmp    %ebx,%esi
- 46a:	75 e4                	jne    450 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 46c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 46f:	5b                   	pop    %ebx
- 470:	5e                   	pop    %esi
- 471:	5f                   	pop    %edi
- 472:	5d                   	pop    %ebp
- 473:	c3                   	ret    
- 474:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 478:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 47f:	eb 87                	jmp    408 <printint+0x28>
- 481:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 488:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 48f:	90                   	nop
-
-00000490 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 490:	f3 0f 1e fb          	endbr32 
- 494:	55                   	push   %ebp
- 495:	89 e5                	mov    %esp,%ebp
- 497:	57                   	push   %edi
- 498:	56                   	push   %esi
- 499:	53                   	push   %ebx
- 49a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 49d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 4a0:	0f b6 1e             	movzbl (%esi),%ebx
- 4a3:	84 db                	test   %bl,%bl
- 4a5:	0f 84 b4 00 00 00    	je     55f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 4ab:	8d 45 10             	lea    0x10(%ebp),%eax
- 4ae:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 4b1:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 4b4:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 4b6:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 4b9:	eb 33                	jmp    4ee <printf+0x5e>
- 4bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 4bf:	90                   	nop
- 4c0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 4c3:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 4c8:	83 f8 25             	cmp    $0x25,%eax
- 4cb:	74 17                	je     4e4 <printf+0x54>
-  write(fd, &c, 1);
- 4cd:	83 ec 04             	sub    $0x4,%esp
- 4d0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 4d3:	6a 01                	push   $0x1
- 4d5:	57                   	push   %edi
- 4d6:	ff 75 08             	pushl  0x8(%ebp)
- 4d9:	e8 15 fe ff ff       	call   2f3 <write>
- 4de:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 4e1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 4e4:	0f b6 1e             	movzbl (%esi),%ebx
- 4e7:	83 c6 01             	add    $0x1,%esi
- 4ea:	84 db                	test   %bl,%bl
- 4ec:	74 71                	je     55f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 4ee:	0f be cb             	movsbl %bl,%ecx
- 4f1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 4f4:	85 d2                	test   %edx,%edx
- 4f6:	74 c8                	je     4c0 <printf+0x30>
-      }
-    } else if(state == '%'){
- 4f8:	83 fa 25             	cmp    $0x25,%edx
- 4fb:	75 e7                	jne    4e4 <printf+0x54>
-      if(c == 'd'){
- 4fd:	83 f8 64             	cmp    $0x64,%eax
- 500:	0f 84 9a 00 00 00    	je     5a0 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 506:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 50c:	83 f9 70             	cmp    $0x70,%ecx
- 50f:	74 5f                	je     570 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 511:	83 f8 73             	cmp    $0x73,%eax
- 514:	0f 84 d6 00 00 00    	je     5f0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 51a:	83 f8 63             	cmp    $0x63,%eax
- 51d:	0f 84 8d 00 00 00    	je     5b0 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 523:	83 f8 25             	cmp    $0x25,%eax
- 526:	0f 84 b4 00 00 00    	je     5e0 <printf+0x150>
-  write(fd, &c, 1);
- 52c:	83 ec 04             	sub    $0x4,%esp
- 52f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 533:	6a 01                	push   $0x1
- 535:	57                   	push   %edi
- 536:	ff 75 08             	pushl  0x8(%ebp)
- 539:	e8 b5 fd ff ff       	call   2f3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 53e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 541:	83 c4 0c             	add    $0xc,%esp
- 544:	6a 01                	push   $0x1
- 546:	83 c6 01             	add    $0x1,%esi
- 549:	57                   	push   %edi
- 54a:	ff 75 08             	pushl  0x8(%ebp)
- 54d:	e8 a1 fd ff ff       	call   2f3 <write>
-  for(i = 0; fmt[i]; i++){
- 552:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 556:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 559:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 55b:	84 db                	test   %bl,%bl
- 55d:	75 8f                	jne    4ee <printf+0x5e>
-    }
-  }
-}
- 55f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 562:	5b                   	pop    %ebx
- 563:	5e                   	pop    %esi
- 564:	5f                   	pop    %edi
- 565:	5d                   	pop    %ebp
- 566:	c3                   	ret    
- 567:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 56e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 570:	83 ec 0c             	sub    $0xc,%esp
- 573:	b9 10 00 00 00       	mov    $0x10,%ecx
- 578:	6a 00                	push   $0x0
- 57a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 57d:	8b 45 08             	mov    0x8(%ebp),%eax
- 580:	8b 13                	mov    (%ebx),%edx
- 582:	e8 59 fe ff ff       	call   3e0 <printint>
-        ap++;
- 587:	89 d8                	mov    %ebx,%eax
- 589:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 58c:	31 d2                	xor    %edx,%edx
-        ap++;
- 58e:	83 c0 04             	add    $0x4,%eax
- 591:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 594:	e9 4b ff ff ff       	jmp    4e4 <printf+0x54>
- 599:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 5a0:	83 ec 0c             	sub    $0xc,%esp
- 5a3:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 5a8:	6a 01                	push   $0x1
- 5aa:	eb ce                	jmp    57a <printf+0xea>
- 5ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 5b0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 5b3:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 5b6:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 5b8:	6a 01                	push   $0x1
-        ap++;
- 5ba:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 5bd:	57                   	push   %edi
- 5be:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 5c1:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 5c4:	e8 2a fd ff ff       	call   2f3 <write>
-        ap++;
- 5c9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 5cc:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 5cf:	31 d2                	xor    %edx,%edx
- 5d1:	e9 0e ff ff ff       	jmp    4e4 <printf+0x54>
- 5d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5dd:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 5e0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5e3:	83 ec 04             	sub    $0x4,%esp
- 5e6:	e9 59 ff ff ff       	jmp    544 <printf+0xb4>
- 5eb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 5ef:	90                   	nop
-        s = (char*)*ap;
- 5f0:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 5f3:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 5f5:	83 c0 04             	add    $0x4,%eax
- 5f8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 5fb:	85 db                	test   %ebx,%ebx
- 5fd:	74 17                	je     616 <printf+0x186>
-        while(*s != 0){
- 5ff:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 602:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 604:	84 c0                	test   %al,%al
- 606:	0f 84 d8 fe ff ff    	je     4e4 <printf+0x54>
- 60c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 60f:	89 de                	mov    %ebx,%esi
- 611:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 614:	eb 1a                	jmp    630 <printf+0x1a0>
-          s = "(null)";
- 616:	bb 0c 08 00 00       	mov    $0x80c,%ebx
-        while(*s != 0){
- 61b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 61e:	b8 28 00 00 00       	mov    $0x28,%eax
- 623:	89 de                	mov    %ebx,%esi
- 625:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 628:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 62f:	90                   	nop
-  write(fd, &c, 1);
- 630:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 633:	83 c6 01             	add    $0x1,%esi
- 636:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 639:	6a 01                	push   $0x1
- 63b:	57                   	push   %edi
- 63c:	53                   	push   %ebx
- 63d:	e8 b1 fc ff ff       	call   2f3 <write>
-        while(*s != 0){
- 642:	0f b6 06             	movzbl (%esi),%eax
- 645:	83 c4 10             	add    $0x10,%esp
- 648:	84 c0                	test   %al,%al
- 64a:	75 e4                	jne    630 <printf+0x1a0>
- 64c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 64f:	31 d2                	xor    %edx,%edx
- 651:	e9 8e fe ff ff       	jmp    4e4 <printf+0x54>
- 656:	66 90                	xchg   %ax,%ax
- 658:	66 90                	xchg   %ax,%ax
- 65a:	66 90                	xchg   %ax,%ax
- 65c:	66 90                	xchg   %ax,%ax
- 65e:	66 90                	xchg   %ax,%ax
-
-00000660 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 660:	f3 0f 1e fb          	endbr32 
- 664:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 665:	a1 c4 0a 00 00       	mov    0xac4,%eax
-{
- 66a:	89 e5                	mov    %esp,%ebp
- 66c:	57                   	push   %edi
- 66d:	56                   	push   %esi
- 66e:	53                   	push   %ebx
- 66f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 672:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 674:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 677:	39 c8                	cmp    %ecx,%eax
- 679:	73 15                	jae    690 <free+0x30>
- 67b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 67f:	90                   	nop
- 680:	39 d1                	cmp    %edx,%ecx
- 682:	72 14                	jb     698 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 684:	39 d0                	cmp    %edx,%eax
- 686:	73 10                	jae    698 <free+0x38>
-{
- 688:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 68a:	8b 10                	mov    (%eax),%edx
- 68c:	39 c8                	cmp    %ecx,%eax
- 68e:	72 f0                	jb     680 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 690:	39 d0                	cmp    %edx,%eax
- 692:	72 f4                	jb     688 <free+0x28>
- 694:	39 d1                	cmp    %edx,%ecx
- 696:	73 f0                	jae    688 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 698:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 69b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 69e:	39 fa                	cmp    %edi,%edx
- 6a0:	74 1e                	je     6c0 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 6a2:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 6a5:	8b 50 04             	mov    0x4(%eax),%edx
- 6a8:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6ab:	39 f1                	cmp    %esi,%ecx
- 6ad:	74 28                	je     6d7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 6af:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 6b1:	5b                   	pop    %ebx
-  freep = p;
- 6b2:	a3 c4 0a 00 00       	mov    %eax,0xac4
-}
- 6b7:	5e                   	pop    %esi
- 6b8:	5f                   	pop    %edi
- 6b9:	5d                   	pop    %ebp
- 6ba:	c3                   	ret    
- 6bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 6bf:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 6c0:	03 72 04             	add    0x4(%edx),%esi
- 6c3:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 6c6:	8b 10                	mov    (%eax),%edx
- 6c8:	8b 12                	mov    (%edx),%edx
- 6ca:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 6cd:	8b 50 04             	mov    0x4(%eax),%edx
- 6d0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6d3:	39 f1                	cmp    %esi,%ecx
- 6d5:	75 d8                	jne    6af <free+0x4f>
-    p->s.size += bp->s.size;
- 6d7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 6da:	a3 c4 0a 00 00       	mov    %eax,0xac4
-    p->s.size += bp->s.size;
- 6df:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 6e2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 6e5:	89 10                	mov    %edx,(%eax)
-}
- 6e7:	5b                   	pop    %ebx
- 6e8:	5e                   	pop    %esi
- 6e9:	5f                   	pop    %edi
- 6ea:	5d                   	pop    %ebp
- 6eb:	c3                   	ret    
- 6ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000006f0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 6f0:	f3 0f 1e fb          	endbr32 
- 6f4:	55                   	push   %ebp
- 6f5:	89 e5                	mov    %esp,%ebp
- 6f7:	57                   	push   %edi
- 6f8:	56                   	push   %esi
- 6f9:	53                   	push   %ebx
- 6fa:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6fd:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 700:	8b 3d c4 0a 00 00    	mov    0xac4,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 706:	8d 70 07             	lea    0x7(%eax),%esi
- 709:	c1 ee 03             	shr    $0x3,%esi
- 70c:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 70f:	85 ff                	test   %edi,%edi
- 711:	0f 84 a9 00 00 00    	je     7c0 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 717:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 719:	8b 48 04             	mov    0x4(%eax),%ecx
- 71c:	39 f1                	cmp    %esi,%ecx
- 71e:	73 6d                	jae    78d <malloc+0x9d>
- 720:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 726:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 72b:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 72e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 735:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 738:	eb 17                	jmp    751 <malloc+0x61>
- 73a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 740:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 742:	8b 4a 04             	mov    0x4(%edx),%ecx
- 745:	39 f1                	cmp    %esi,%ecx
- 747:	73 4f                	jae    798 <malloc+0xa8>
- 749:	8b 3d c4 0a 00 00    	mov    0xac4,%edi
- 74f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 751:	39 c7                	cmp    %eax,%edi
- 753:	75 eb                	jne    740 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 755:	83 ec 0c             	sub    $0xc,%esp
- 758:	ff 75 e4             	pushl  -0x1c(%ebp)
- 75b:	e8 fb fb ff ff       	call   35b <sbrk>
-  if(p == (char*)-1)
- 760:	83 c4 10             	add    $0x10,%esp
- 763:	83 f8 ff             	cmp    $0xffffffff,%eax
- 766:	74 1b                	je     783 <malloc+0x93>
-  hp->s.size = nu;
- 768:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 76b:	83 ec 0c             	sub    $0xc,%esp
- 76e:	83 c0 08             	add    $0x8,%eax
- 771:	50                   	push   %eax
- 772:	e8 e9 fe ff ff       	call   660 <free>
-  return freep;
- 777:	a1 c4 0a 00 00       	mov    0xac4,%eax
-      if((p = morecore(nunits)) == 0)
- 77c:	83 c4 10             	add    $0x10,%esp
- 77f:	85 c0                	test   %eax,%eax
- 781:	75 bd                	jne    740 <malloc+0x50>
-        return 0;
-  }
-}
- 783:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 786:	31 c0                	xor    %eax,%eax
-}
- 788:	5b                   	pop    %ebx
- 789:	5e                   	pop    %esi
- 78a:	5f                   	pop    %edi
- 78b:	5d                   	pop    %ebp
- 78c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 78d:	89 c2                	mov    %eax,%edx
- 78f:	89 f8                	mov    %edi,%eax
- 791:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 798:	39 ce                	cmp    %ecx,%esi
- 79a:	74 54                	je     7f0 <malloc+0x100>
-        p->s.size -= nunits;
- 79c:	29 f1                	sub    %esi,%ecx
- 79e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 7a1:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 7a4:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 7a7:	a3 c4 0a 00 00       	mov    %eax,0xac4
-}
- 7ac:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 7af:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 7b2:	5b                   	pop    %ebx
- 7b3:	5e                   	pop    %esi
- 7b4:	5f                   	pop    %edi
- 7b5:	5d                   	pop    %ebp
- 7b6:	c3                   	ret    
- 7b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 7be:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 7c0:	c7 05 c4 0a 00 00 c8 	movl   $0xac8,0xac4
- 7c7:	0a 00 00 
-    base.s.size = 0;
- 7ca:	bf c8 0a 00 00       	mov    $0xac8,%edi
-    base.s.ptr = freep = prevp = &base;
- 7cf:	c7 05 c8 0a 00 00 c8 	movl   $0xac8,0xac8
- 7d6:	0a 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7d9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 7db:	c7 05 cc 0a 00 00 00 	movl   $0x0,0xacc
- 7e2:	00 00 00 
-    if(p->s.size >= nunits){
- 7e5:	e9 36 ff ff ff       	jmp    720 <malloc+0x30>
- 7ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 7f0:	8b 0a                	mov    (%edx),%ecx
- 7f2:	89 08                	mov    %ecx,(%eax)
- 7f4:	eb b1                	jmp    7a7 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/kill.c b/xv6-public/Operating-System-Project/kill.c
deleted file mode 100644
index 364f6af..0000000
--- a/xv6-public/Operating-System-Project/kill.c
+++ /dev/null
@@ -1,17 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char **argv)
-{
-  int i;
-
-  if(argc < 2){
-    printf(2, "usage: kill pid...\n");
-    exit();
-  }
-  for(i=1; i<argc; i++)
-    kill(atoi(argv[i]));
-  exit();
-}
diff --git a/xv6-public/Operating-System-Project/kill.d b/xv6-public/Operating-System-Project/kill.d
deleted file mode 100644
index 078f4f8..0000000
--- a/xv6-public/Operating-System-Project/kill.d
+++ /dev/null
@@ -1 +0,0 @@
-kill.o: kill.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/kill.o b/xv6-public/Operating-System-Project/kill.o
deleted file mode 100644
index 0eabf75..0000000
Binary files a/xv6-public/Operating-System-Project/kill.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/kill.sym b/xv6-public/Operating-System-Project/kill.sym
deleted file mode 100644
index d93d955..0000000
--- a/xv6-public/Operating-System-Project/kill.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-000007f8 .rodata
-00000828 .eh_frame
-00000ac4 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 kill.c
-00000000 ulib.c
-00000000 printf.c
-000003e0 printint
-00000814 digits.1109
-00000000 umalloc.c
-00000ac4 freep
-00000ac8 base
-00000070 strcpy
-0000037b getChildren
-00000490 printf
-000002a0 memmove
-0000031b mknod
-00000190 gets
-00000353 getpid
-000003b3 customWait
-000003ab getCBT
-000006f0 malloc
-00000363 sleep
-000002e3 pipe
-00000393 changePolicy
-000002f3 write
-0000032b fstat
-00000303 kill
-00000343 chdir
-000003bb setQueue
-0000030b exec
-000002db wait
-000002eb read
-000003c3 getBurstTime
-00000323 unlink
-000002cb fork
-0000039b getTurnAroundTime
-0000035b sbrk
-0000036b uptime
-00000ac4 __bss_start
-00000130 memset
-00000000 main
-000000a0 strcmp
-0000034b dup
-00000383 getSyscallCounter
-00000373 getParentID
-00000210 stat
-00000ac4 _edata
-00000ad0 _end
-00000333 link
-000002d3 exit
-0000038b setPriority
-00000260 atoi
-000003cb getCreationTime
-000000f0 strlen
-00000313 open
-00000150 strchr
-0000033b mkdir
-000002fb close
-000003a3 getWaitingTime
-00000660 free
diff --git a/xv6-public/Operating-System-Project/lapic.c b/xv6-public/Operating-System-Project/lapic.c
deleted file mode 100644
index b22bbd7..0000000
--- a/xv6-public/Operating-System-Project/lapic.c
+++ /dev/null
@@ -1,229 +0,0 @@
-// The local APIC manages internal (non-I/O) interrupts.
-// See Chapter 8 & Appendix C of Intel processor manual volume 3.
-
-#include "param.h"
-#include "types.h"
-#include "defs.h"
-#include "date.h"
-#include "memlayout.h"
-#include "traps.h"
-#include "mmu.h"
-#include "x86.h"
-
-// Local APIC registers, divided by 4 for use as uint[] indices.
-#define ID      (0x0020/4)   // ID
-#define VER     (0x0030/4)   // Version
-#define TPR     (0x0080/4)   // Task Priority
-#define EOI     (0x00B0/4)   // EOI
-#define SVR     (0x00F0/4)   // Spurious Interrupt Vector
-  #define ENABLE     0x00000100   // Unit Enable
-#define ESR     (0x0280/4)   // Error Status
-#define ICRLO   (0x0300/4)   // Interrupt Command
-  #define INIT       0x00000500   // INIT/RESET
-  #define STARTUP    0x00000600   // Startup IPI
-  #define DELIVS     0x00001000   // Delivery status
-  #define ASSERT     0x00004000   // Assert interrupt (vs deassert)
-  #define DEASSERT   0x00000000
-  #define LEVEL      0x00008000   // Level triggered
-  #define BCAST      0x00080000   // Send to all APICs, including self.
-  #define BUSY       0x00001000
-  #define FIXED      0x00000000
-#define ICRHI   (0x0310/4)   // Interrupt Command [63:32]
-#define TIMER   (0x0320/4)   // Local Vector Table 0 (TIMER)
-  #define X1         0x0000000B   // divide counts by 1
-  #define PERIODIC   0x00020000   // Periodic
-#define PCINT   (0x0340/4)   // Performance Counter LVT
-#define LINT0   (0x0350/4)   // Local Vector Table 1 (LINT0)
-#define LINT1   (0x0360/4)   // Local Vector Table 2 (LINT1)
-#define ERROR   (0x0370/4)   // Local Vector Table 3 (ERROR)
-  #define MASKED     0x00010000   // Interrupt masked
-#define TICR    (0x0380/4)   // Timer Initial Count
-#define TCCR    (0x0390/4)   // Timer Current Count
-#define TDCR    (0x03E0/4)   // Timer Divide Configuration
-
-volatile uint *lapic;  // Initialized in mp.c
-
-//PAGEBREAK!
-static void
-lapicw(int index, int value)
-{
-  lapic[index] = value;
-  lapic[ID];  // wait for write to finish, by reading
-}
-
-void
-lapicinit(void)
-{
-  if(!lapic)
-    return;
-
-  // Enable local APIC; set spurious interrupt vector.
-  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
-
-  // The timer repeatedly counts down at bus frequency
-  // from lapic[TICR] and then issues an interrupt.
-  // If xv6 cared more about precise timekeeping,
-  // TICR would be calibrated using an external time source.
-  lapicw(TDCR, X1);
-  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
-  lapicw(TICR, 10000000);
-
-  // Disable logical interrupt lines.
-  lapicw(LINT0, MASKED);
-  lapicw(LINT1, MASKED);
-
-  // Disable performance counter overflow interrupts
-  // on machines that provide that interrupt entry.
-  if(((lapic[VER]>>16) & 0xFF) >= 4)
-    lapicw(PCINT, MASKED);
-
-  // Map error interrupt to IRQ_ERROR.
-  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
-
-  // Clear error status register (requires back-to-back writes).
-  lapicw(ESR, 0);
-  lapicw(ESR, 0);
-
-  // Ack any outstanding interrupts.
-  lapicw(EOI, 0);
-
-  // Send an Init Level De-Assert to synchronise arbitration ID's.
-  lapicw(ICRHI, 0);
-  lapicw(ICRLO, BCAST | INIT | LEVEL);
-  while(lapic[ICRLO] & DELIVS)
-    ;
-
-  // Enable interrupts on the APIC (but not on the processor).
-  lapicw(TPR, 0);
-}
-
-int
-lapicid(void)
-{
-  if (!lapic)
-    return 0;
-  return lapic[ID] >> 24;
-}
-
-// Acknowledge interrupt.
-void
-lapiceoi(void)
-{
-  if(lapic)
-    lapicw(EOI, 0);
-}
-
-// Spin for a given number of microseconds.
-// On real hardware would want to tune this dynamically.
-void
-microdelay(int us)
-{
-}
-
-#define CMOS_PORT    0x70
-#define CMOS_RETURN  0x71
-
-// Start additional processor running entry code at addr.
-// See Appendix B of MultiProcessor Specification.
-void
-lapicstartap(uchar apicid, uint addr)
-{
-  int i;
-  ushort *wrv;
-
-  // "The BSP must initialize CMOS shutdown code to 0AH
-  // and the warm reset vector (DWORD based at 40:67) to point at
-  // the AP startup code prior to the [universal startup algorithm]."
-  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
-  outb(CMOS_PORT+1, 0x0A);
-  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
-  wrv[0] = 0;
-  wrv[1] = addr >> 4;
-
-  // "Universal startup algorithm."
-  // Send INIT (level-triggered) interrupt to reset other CPU.
-  lapicw(ICRHI, apicid<<24);
-  lapicw(ICRLO, INIT | LEVEL | ASSERT);
-  microdelay(200);
-  lapicw(ICRLO, INIT | LEVEL);
-  microdelay(100);    // should be 10ms, but too slow in Bochs!
-
-  // Send startup IPI (twice!) to enter code.
-  // Regular hardware is supposed to only accept a STARTUP
-  // when it is in the halted state due to an INIT.  So the second
-  // should be ignored, but it is part of the official Intel algorithm.
-  // Bochs complains about the second one.  Too bad for Bochs.
-  for(i = 0; i < 2; i++){
-    lapicw(ICRHI, apicid<<24);
-    lapicw(ICRLO, STARTUP | (addr>>12));
-    microdelay(200);
-  }
-}
-
-#define CMOS_STATA   0x0a
-#define CMOS_STATB   0x0b
-#define CMOS_UIP    (1 << 7)        // RTC update in progress
-
-#define SECS    0x00
-#define MINS    0x02
-#define HOURS   0x04
-#define DAY     0x07
-#define MONTH   0x08
-#define YEAR    0x09
-
-static uint
-cmos_read(uint reg)
-{
-  outb(CMOS_PORT,  reg);
-  microdelay(200);
-
-  return inb(CMOS_RETURN);
-}
-
-static void
-fill_rtcdate(struct rtcdate *r)
-{
-  r->second = cmos_read(SECS);
-  r->minute = cmos_read(MINS);
-  r->hour   = cmos_read(HOURS);
-  r->day    = cmos_read(DAY);
-  r->month  = cmos_read(MONTH);
-  r->year   = cmos_read(YEAR);
-}
-
-// qemu seems to use 24-hour GWT and the values are BCD encoded
-void
-cmostime(struct rtcdate *r)
-{
-  struct rtcdate t1, t2;
-  int sb, bcd;
-
-  sb = cmos_read(CMOS_STATB);
-
-  bcd = (sb & (1 << 2)) == 0;
-
-  // make sure CMOS doesn't modify time while we read it
-  for(;;) {
-    fill_rtcdate(&t1);
-    if(cmos_read(CMOS_STATA) & CMOS_UIP)
-        continue;
-    fill_rtcdate(&t2);
-    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
-      break;
-  }
-
-  // convert
-  if(bcd) {
-#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
-    CONV(second);
-    CONV(minute);
-    CONV(hour  );
-    CONV(day   );
-    CONV(month );
-    CONV(year  );
-#undef     CONV
-  }
-
-  *r = t1;
-  r->year += 2000;
-}
diff --git a/xv6-public/Operating-System-Project/lapic.d b/xv6-public/Operating-System-Project/lapic.d
deleted file mode 100644
index 6e62387..0000000
--- a/xv6-public/Operating-System-Project/lapic.d
+++ /dev/null
@@ -1,2 +0,0 @@
-lapic.o: lapic.c /usr/include/stdc-predef.h param.h types.h defs.h date.h \
- memlayout.h traps.h mmu.h x86.h
diff --git a/xv6-public/Operating-System-Project/lapic.o b/xv6-public/Operating-System-Project/lapic.o
deleted file mode 100644
index 0bcd5b4..0000000
Binary files a/xv6-public/Operating-System-Project/lapic.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/ln.asm b/xv6-public/Operating-System-Project/ln.asm
deleted file mode 100644
index 5c7e3b0..0000000
--- a/xv6-public/Operating-System-Project/ln.asm
+++ /dev/null
@@ -1,1261 +0,0 @@
-
-_ln:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-  if(argc != 3){
-   e:	83 39 03             	cmpl   $0x3,(%ecx)
-{
-  11:	55                   	push   %ebp
-  12:	89 e5                	mov    %esp,%ebp
-  14:	53                   	push   %ebx
-  15:	51                   	push   %ecx
-  16:	8b 59 04             	mov    0x4(%ecx),%ebx
-  if(argc != 3){
-  19:	74 13                	je     2e <main+0x2e>
-    printf(2, "Usage: ln old new\n");
-  1b:	52                   	push   %edx
-  1c:	52                   	push   %edx
-  1d:	68 e8 07 00 00       	push   $0x7e8
-  22:	6a 02                	push   $0x2
-  24:	e8 57 04 00 00       	call   480 <printf>
-    exit();
-  29:	e8 95 02 00 00       	call   2c3 <exit>
-  }
-  if(link(argv[1], argv[2]) < 0)
-  2e:	50                   	push   %eax
-  2f:	50                   	push   %eax
-  30:	ff 73 08             	pushl  0x8(%ebx)
-  33:	ff 73 04             	pushl  0x4(%ebx)
-  36:	e8 e8 02 00 00       	call   323 <link>
-  3b:	83 c4 10             	add    $0x10,%esp
-  3e:	85 c0                	test   %eax,%eax
-  40:	78 05                	js     47 <main+0x47>
-    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
-  exit();
-  42:	e8 7c 02 00 00       	call   2c3 <exit>
-    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
-  47:	ff 73 08             	pushl  0x8(%ebx)
-  4a:	ff 73 04             	pushl  0x4(%ebx)
-  4d:	68 fb 07 00 00       	push   $0x7fb
-  52:	6a 02                	push   $0x2
-  54:	e8 27 04 00 00       	call   480 <printf>
-  59:	83 c4 10             	add    $0x10,%esp
-  5c:	eb e4                	jmp    42 <main+0x42>
-  5e:	66 90                	xchg   %ax,%ax
-
-00000060 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  60:	f3 0f 1e fb          	endbr32 
-  64:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  65:	31 c0                	xor    %eax,%eax
-{
-  67:	89 e5                	mov    %esp,%ebp
-  69:	53                   	push   %ebx
-  6a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  6d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-  70:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-  74:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-  77:	83 c0 01             	add    $0x1,%eax
-  7a:	84 d2                	test   %dl,%dl
-  7c:	75 f2                	jne    70 <strcpy+0x10>
-    ;
-  return os;
-}
-  7e:	89 c8                	mov    %ecx,%eax
-  80:	5b                   	pop    %ebx
-  81:	5d                   	pop    %ebp
-  82:	c3                   	ret    
-  83:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000090 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-  90:	f3 0f 1e fb          	endbr32 
-  94:	55                   	push   %ebp
-  95:	89 e5                	mov    %esp,%ebp
-  97:	53                   	push   %ebx
-  98:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  9b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-  9e:	0f b6 01             	movzbl (%ecx),%eax
-  a1:	0f b6 1a             	movzbl (%edx),%ebx
-  a4:	84 c0                	test   %al,%al
-  a6:	75 19                	jne    c1 <strcmp+0x31>
-  a8:	eb 26                	jmp    d0 <strcmp+0x40>
-  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  b0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-  b4:	83 c1 01             	add    $0x1,%ecx
-  b7:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-  ba:	0f b6 1a             	movzbl (%edx),%ebx
-  bd:	84 c0                	test   %al,%al
-  bf:	74 0f                	je     d0 <strcmp+0x40>
-  c1:	38 d8                	cmp    %bl,%al
-  c3:	74 eb                	je     b0 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-  c5:	29 d8                	sub    %ebx,%eax
-}
-  c7:	5b                   	pop    %ebx
-  c8:	5d                   	pop    %ebp
-  c9:	c3                   	ret    
-  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  d0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-  d2:	29 d8                	sub    %ebx,%eax
-}
-  d4:	5b                   	pop    %ebx
-  d5:	5d                   	pop    %ebp
-  d6:	c3                   	ret    
-  d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  de:	66 90                	xchg   %ax,%ax
-
-000000e0 <strlen>:
-
-uint
-strlen(const char *s)
-{
-  e0:	f3 0f 1e fb          	endbr32 
-  e4:	55                   	push   %ebp
-  e5:	89 e5                	mov    %esp,%ebp
-  e7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
-  ea:	80 3a 00             	cmpb   $0x0,(%edx)
-  ed:	74 21                	je     110 <strlen+0x30>
-  ef:	31 c0                	xor    %eax,%eax
-  f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  f8:	83 c0 01             	add    $0x1,%eax
-  fb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
-  ff:	89 c1                	mov    %eax,%ecx
- 101:	75 f5                	jne    f8 <strlen+0x18>
-    ;
-  return n;
-}
- 103:	89 c8                	mov    %ecx,%eax
- 105:	5d                   	pop    %ebp
- 106:	c3                   	ret    
- 107:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 10e:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 110:	31 c9                	xor    %ecx,%ecx
-}
- 112:	5d                   	pop    %ebp
- 113:	89 c8                	mov    %ecx,%eax
- 115:	c3                   	ret    
- 116:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 11d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000120 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 120:	f3 0f 1e fb          	endbr32 
- 124:	55                   	push   %ebp
- 125:	89 e5                	mov    %esp,%ebp
- 127:	57                   	push   %edi
- 128:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 12b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 12e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 131:	89 d7                	mov    %edx,%edi
- 133:	fc                   	cld    
- 134:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 136:	89 d0                	mov    %edx,%eax
- 138:	5f                   	pop    %edi
- 139:	5d                   	pop    %ebp
- 13a:	c3                   	ret    
- 13b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 13f:	90                   	nop
-
-00000140 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 140:	f3 0f 1e fb          	endbr32 
- 144:	55                   	push   %ebp
- 145:	89 e5                	mov    %esp,%ebp
- 147:	8b 45 08             	mov    0x8(%ebp),%eax
- 14a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 14e:	0f b6 10             	movzbl (%eax),%edx
- 151:	84 d2                	test   %dl,%dl
- 153:	75 16                	jne    16b <strchr+0x2b>
- 155:	eb 21                	jmp    178 <strchr+0x38>
- 157:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 15e:	66 90                	xchg   %ax,%ax
- 160:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 164:	83 c0 01             	add    $0x1,%eax
- 167:	84 d2                	test   %dl,%dl
- 169:	74 0d                	je     178 <strchr+0x38>
-    if(*s == c)
- 16b:	38 d1                	cmp    %dl,%cl
- 16d:	75 f1                	jne    160 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 16f:	5d                   	pop    %ebp
- 170:	c3                   	ret    
- 171:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 178:	31 c0                	xor    %eax,%eax
-}
- 17a:	5d                   	pop    %ebp
- 17b:	c3                   	ret    
- 17c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000180 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 180:	f3 0f 1e fb          	endbr32 
- 184:	55                   	push   %ebp
- 185:	89 e5                	mov    %esp,%ebp
- 187:	57                   	push   %edi
- 188:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 189:	31 f6                	xor    %esi,%esi
-{
- 18b:	53                   	push   %ebx
- 18c:	89 f3                	mov    %esi,%ebx
- 18e:	83 ec 1c             	sub    $0x1c,%esp
- 191:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 194:	eb 33                	jmp    1c9 <gets+0x49>
- 196:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 19d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 1a0:	83 ec 04             	sub    $0x4,%esp
- 1a3:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 1a6:	6a 01                	push   $0x1
- 1a8:	50                   	push   %eax
- 1a9:	6a 00                	push   $0x0
- 1ab:	e8 2b 01 00 00       	call   2db <read>
-    if(cc < 1)
- 1b0:	83 c4 10             	add    $0x10,%esp
- 1b3:	85 c0                	test   %eax,%eax
- 1b5:	7e 1c                	jle    1d3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 1b7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 1bb:	83 c7 01             	add    $0x1,%edi
- 1be:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 1c1:	3c 0a                	cmp    $0xa,%al
- 1c3:	74 23                	je     1e8 <gets+0x68>
- 1c5:	3c 0d                	cmp    $0xd,%al
- 1c7:	74 1f                	je     1e8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 1c9:	83 c3 01             	add    $0x1,%ebx
- 1cc:	89 fe                	mov    %edi,%esi
- 1ce:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 1d1:	7c cd                	jl     1a0 <gets+0x20>
- 1d3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 1d5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 1d8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1db:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1de:	5b                   	pop    %ebx
- 1df:	5e                   	pop    %esi
- 1e0:	5f                   	pop    %edi
- 1e1:	5d                   	pop    %ebp
- 1e2:	c3                   	ret    
- 1e3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 1e7:	90                   	nop
- 1e8:	8b 75 08             	mov    0x8(%ebp),%esi
- 1eb:	8b 45 08             	mov    0x8(%ebp),%eax
- 1ee:	01 de                	add    %ebx,%esi
- 1f0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 1f2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1f8:	5b                   	pop    %ebx
- 1f9:	5e                   	pop    %esi
- 1fa:	5f                   	pop    %edi
- 1fb:	5d                   	pop    %ebp
- 1fc:	c3                   	ret    
- 1fd:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000200 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 200:	f3 0f 1e fb          	endbr32 
- 204:	55                   	push   %ebp
- 205:	89 e5                	mov    %esp,%ebp
- 207:	56                   	push   %esi
- 208:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 209:	83 ec 08             	sub    $0x8,%esp
- 20c:	6a 00                	push   $0x0
- 20e:	ff 75 08             	pushl  0x8(%ebp)
- 211:	e8 ed 00 00 00       	call   303 <open>
-  if(fd < 0)
- 216:	83 c4 10             	add    $0x10,%esp
- 219:	85 c0                	test   %eax,%eax
- 21b:	78 2b                	js     248 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 21d:	83 ec 08             	sub    $0x8,%esp
- 220:	ff 75 0c             	pushl  0xc(%ebp)
- 223:	89 c3                	mov    %eax,%ebx
- 225:	50                   	push   %eax
- 226:	e8 f0 00 00 00       	call   31b <fstat>
-  close(fd);
- 22b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 22e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 230:	e8 b6 00 00 00       	call   2eb <close>
-  return r;
- 235:	83 c4 10             	add    $0x10,%esp
-}
- 238:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 23b:	89 f0                	mov    %esi,%eax
- 23d:	5b                   	pop    %ebx
- 23e:	5e                   	pop    %esi
- 23f:	5d                   	pop    %ebp
- 240:	c3                   	ret    
- 241:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 248:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 24d:	eb e9                	jmp    238 <stat+0x38>
- 24f:	90                   	nop
-
-00000250 <atoi>:
-
-int
-atoi(const char *s)
-{
- 250:	f3 0f 1e fb          	endbr32 
- 254:	55                   	push   %ebp
- 255:	89 e5                	mov    %esp,%ebp
- 257:	53                   	push   %ebx
- 258:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 25b:	0f be 02             	movsbl (%edx),%eax
- 25e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 261:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 264:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 269:	77 1a                	ja     285 <atoi+0x35>
- 26b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 26f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 270:	83 c2 01             	add    $0x1,%edx
- 273:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 276:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 27a:	0f be 02             	movsbl (%edx),%eax
- 27d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 280:	80 fb 09             	cmp    $0x9,%bl
- 283:	76 eb                	jbe    270 <atoi+0x20>
-  return n;
-}
- 285:	89 c8                	mov    %ecx,%eax
- 287:	5b                   	pop    %ebx
- 288:	5d                   	pop    %ebp
- 289:	c3                   	ret    
- 28a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000290 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 290:	f3 0f 1e fb          	endbr32 
- 294:	55                   	push   %ebp
- 295:	89 e5                	mov    %esp,%ebp
- 297:	57                   	push   %edi
- 298:	8b 45 10             	mov    0x10(%ebp),%eax
- 29b:	8b 55 08             	mov    0x8(%ebp),%edx
- 29e:	56                   	push   %esi
- 29f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 2a2:	85 c0                	test   %eax,%eax
- 2a4:	7e 0f                	jle    2b5 <memmove+0x25>
- 2a6:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 2a8:	89 d7                	mov    %edx,%edi
- 2aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 2b0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 2b1:	39 f8                	cmp    %edi,%eax
- 2b3:	75 fb                	jne    2b0 <memmove+0x20>
-  return vdst;
-}
- 2b5:	5e                   	pop    %esi
- 2b6:	89 d0                	mov    %edx,%eax
- 2b8:	5f                   	pop    %edi
- 2b9:	5d                   	pop    %ebp
- 2ba:	c3                   	ret    
-
-000002bb <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 2bb:	b8 01 00 00 00       	mov    $0x1,%eax
- 2c0:	cd 40                	int    $0x40
- 2c2:	c3                   	ret    
-
-000002c3 <exit>:
-SYSCALL(exit)
- 2c3:	b8 02 00 00 00       	mov    $0x2,%eax
- 2c8:	cd 40                	int    $0x40
- 2ca:	c3                   	ret    
-
-000002cb <wait>:
-SYSCALL(wait)
- 2cb:	b8 03 00 00 00       	mov    $0x3,%eax
- 2d0:	cd 40                	int    $0x40
- 2d2:	c3                   	ret    
-
-000002d3 <pipe>:
-SYSCALL(pipe)
- 2d3:	b8 04 00 00 00       	mov    $0x4,%eax
- 2d8:	cd 40                	int    $0x40
- 2da:	c3                   	ret    
-
-000002db <read>:
-SYSCALL(read)
- 2db:	b8 05 00 00 00       	mov    $0x5,%eax
- 2e0:	cd 40                	int    $0x40
- 2e2:	c3                   	ret    
-
-000002e3 <write>:
-SYSCALL(write)
- 2e3:	b8 10 00 00 00       	mov    $0x10,%eax
- 2e8:	cd 40                	int    $0x40
- 2ea:	c3                   	ret    
-
-000002eb <close>:
-SYSCALL(close)
- 2eb:	b8 15 00 00 00       	mov    $0x15,%eax
- 2f0:	cd 40                	int    $0x40
- 2f2:	c3                   	ret    
-
-000002f3 <kill>:
-SYSCALL(kill)
- 2f3:	b8 06 00 00 00       	mov    $0x6,%eax
- 2f8:	cd 40                	int    $0x40
- 2fa:	c3                   	ret    
-
-000002fb <exec>:
-SYSCALL(exec)
- 2fb:	b8 07 00 00 00       	mov    $0x7,%eax
- 300:	cd 40                	int    $0x40
- 302:	c3                   	ret    
-
-00000303 <open>:
-SYSCALL(open)
- 303:	b8 0f 00 00 00       	mov    $0xf,%eax
- 308:	cd 40                	int    $0x40
- 30a:	c3                   	ret    
-
-0000030b <mknod>:
-SYSCALL(mknod)
- 30b:	b8 11 00 00 00       	mov    $0x11,%eax
- 310:	cd 40                	int    $0x40
- 312:	c3                   	ret    
-
-00000313 <unlink>:
-SYSCALL(unlink)
- 313:	b8 12 00 00 00       	mov    $0x12,%eax
- 318:	cd 40                	int    $0x40
- 31a:	c3                   	ret    
-
-0000031b <fstat>:
-SYSCALL(fstat)
- 31b:	b8 08 00 00 00       	mov    $0x8,%eax
- 320:	cd 40                	int    $0x40
- 322:	c3                   	ret    
-
-00000323 <link>:
-SYSCALL(link)
- 323:	b8 13 00 00 00       	mov    $0x13,%eax
- 328:	cd 40                	int    $0x40
- 32a:	c3                   	ret    
-
-0000032b <mkdir>:
-SYSCALL(mkdir)
- 32b:	b8 14 00 00 00       	mov    $0x14,%eax
- 330:	cd 40                	int    $0x40
- 332:	c3                   	ret    
-
-00000333 <chdir>:
-SYSCALL(chdir)
- 333:	b8 09 00 00 00       	mov    $0x9,%eax
- 338:	cd 40                	int    $0x40
- 33a:	c3                   	ret    
-
-0000033b <dup>:
-SYSCALL(dup)
- 33b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 340:	cd 40                	int    $0x40
- 342:	c3                   	ret    
-
-00000343 <getpid>:
-SYSCALL(getpid)
- 343:	b8 0b 00 00 00       	mov    $0xb,%eax
- 348:	cd 40                	int    $0x40
- 34a:	c3                   	ret    
-
-0000034b <sbrk>:
-SYSCALL(sbrk)
- 34b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <sleep>:
-SYSCALL(sleep)
- 353:	b8 0d 00 00 00       	mov    $0xd,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <uptime>:
-SYSCALL(uptime)
- 35b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <getParentID>:
-SYSCALL(getParentID)
- 363:	b8 16 00 00 00       	mov    $0x16,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <getChildren>:
-SYSCALL(getChildren)
- 36b:	b8 17 00 00 00       	mov    $0x17,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 373:	b8 18 00 00 00       	mov    $0x18,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <setPriority>:
-SYSCALL(setPriority)
- 37b:	b8 19 00 00 00       	mov    $0x19,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <changePolicy>:
-SYSCALL(changePolicy)
- 383:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 38b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 393:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <getCBT>:
-SYSCALL(getCBT)
- 39b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
-
-000003a3 <customWait>:
-SYSCALL(customWait)
- 3a3:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 3a8:	cd 40                	int    $0x40
- 3aa:	c3                   	ret    
-
-000003ab <setQueue>:
-SYSCALL(setQueue)
- 3ab:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
-
-000003b3 <getBurstTime>:
-SYSCALL(getBurstTime)
- 3b3:	b8 20 00 00 00       	mov    $0x20,%eax
- 3b8:	cd 40                	int    $0x40
- 3ba:	c3                   	ret    
-
-000003bb <getCreationTime>:
- 3bb:	b8 21 00 00 00       	mov    $0x21,%eax
- 3c0:	cd 40                	int    $0x40
- 3c2:	c3                   	ret    
- 3c3:	66 90                	xchg   %ax,%ax
- 3c5:	66 90                	xchg   %ax,%ax
- 3c7:	66 90                	xchg   %ax,%ax
- 3c9:	66 90                	xchg   %ax,%ax
- 3cb:	66 90                	xchg   %ax,%ax
- 3cd:	66 90                	xchg   %ax,%ax
- 3cf:	90                   	nop
-
-000003d0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 3d0:	55                   	push   %ebp
- 3d1:	89 e5                	mov    %esp,%ebp
- 3d3:	57                   	push   %edi
- 3d4:	56                   	push   %esi
- 3d5:	53                   	push   %ebx
- 3d6:	83 ec 3c             	sub    $0x3c,%esp
- 3d9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 3dc:	89 d1                	mov    %edx,%ecx
-{
- 3de:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 3e1:	85 d2                	test   %edx,%edx
- 3e3:	0f 89 7f 00 00 00    	jns    468 <printint+0x98>
- 3e9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 3ed:	74 79                	je     468 <printint+0x98>
-    neg = 1;
- 3ef:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 3f6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 3f8:	31 db                	xor    %ebx,%ebx
- 3fa:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 3fd:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 400:	89 c8                	mov    %ecx,%eax
- 402:	31 d2                	xor    %edx,%edx
- 404:	89 cf                	mov    %ecx,%edi
- 406:	f7 75 c4             	divl   -0x3c(%ebp)
- 409:	0f b6 92 18 08 00 00 	movzbl 0x818(%edx),%edx
- 410:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 413:	89 d8                	mov    %ebx,%eax
- 415:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 418:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 41b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 41e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 421:	76 dd                	jbe    400 <printint+0x30>
-  if(neg)
- 423:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 426:	85 c9                	test   %ecx,%ecx
- 428:	74 0c                	je     436 <printint+0x66>
-    buf[i++] = '-';
- 42a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 42f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 431:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 436:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 439:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 43d:	eb 07                	jmp    446 <printint+0x76>
- 43f:	90                   	nop
- 440:	0f b6 13             	movzbl (%ebx),%edx
- 443:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 446:	83 ec 04             	sub    $0x4,%esp
- 449:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 44c:	6a 01                	push   $0x1
- 44e:	56                   	push   %esi
- 44f:	57                   	push   %edi
- 450:	e8 8e fe ff ff       	call   2e3 <write>
-  while(--i >= 0)
- 455:	83 c4 10             	add    $0x10,%esp
- 458:	39 de                	cmp    %ebx,%esi
- 45a:	75 e4                	jne    440 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 45c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 45f:	5b                   	pop    %ebx
- 460:	5e                   	pop    %esi
- 461:	5f                   	pop    %edi
- 462:	5d                   	pop    %ebp
- 463:	c3                   	ret    
- 464:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 468:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 46f:	eb 87                	jmp    3f8 <printint+0x28>
- 471:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 478:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 47f:	90                   	nop
-
-00000480 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 480:	f3 0f 1e fb          	endbr32 
- 484:	55                   	push   %ebp
- 485:	89 e5                	mov    %esp,%ebp
- 487:	57                   	push   %edi
- 488:	56                   	push   %esi
- 489:	53                   	push   %ebx
- 48a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 48d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 490:	0f b6 1e             	movzbl (%esi),%ebx
- 493:	84 db                	test   %bl,%bl
- 495:	0f 84 b4 00 00 00    	je     54f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 49b:	8d 45 10             	lea    0x10(%ebp),%eax
- 49e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 4a1:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 4a4:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 4a6:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 4a9:	eb 33                	jmp    4de <printf+0x5e>
- 4ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 4af:	90                   	nop
- 4b0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 4b3:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 4b8:	83 f8 25             	cmp    $0x25,%eax
- 4bb:	74 17                	je     4d4 <printf+0x54>
-  write(fd, &c, 1);
- 4bd:	83 ec 04             	sub    $0x4,%esp
- 4c0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 4c3:	6a 01                	push   $0x1
- 4c5:	57                   	push   %edi
- 4c6:	ff 75 08             	pushl  0x8(%ebp)
- 4c9:	e8 15 fe ff ff       	call   2e3 <write>
- 4ce:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 4d1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 4d4:	0f b6 1e             	movzbl (%esi),%ebx
- 4d7:	83 c6 01             	add    $0x1,%esi
- 4da:	84 db                	test   %bl,%bl
- 4dc:	74 71                	je     54f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 4de:	0f be cb             	movsbl %bl,%ecx
- 4e1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 4e4:	85 d2                	test   %edx,%edx
- 4e6:	74 c8                	je     4b0 <printf+0x30>
-      }
-    } else if(state == '%'){
- 4e8:	83 fa 25             	cmp    $0x25,%edx
- 4eb:	75 e7                	jne    4d4 <printf+0x54>
-      if(c == 'd'){
- 4ed:	83 f8 64             	cmp    $0x64,%eax
- 4f0:	0f 84 9a 00 00 00    	je     590 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 4f6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 4fc:	83 f9 70             	cmp    $0x70,%ecx
- 4ff:	74 5f                	je     560 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 501:	83 f8 73             	cmp    $0x73,%eax
- 504:	0f 84 d6 00 00 00    	je     5e0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 50a:	83 f8 63             	cmp    $0x63,%eax
- 50d:	0f 84 8d 00 00 00    	je     5a0 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 513:	83 f8 25             	cmp    $0x25,%eax
- 516:	0f 84 b4 00 00 00    	je     5d0 <printf+0x150>
-  write(fd, &c, 1);
- 51c:	83 ec 04             	sub    $0x4,%esp
- 51f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 523:	6a 01                	push   $0x1
- 525:	57                   	push   %edi
- 526:	ff 75 08             	pushl  0x8(%ebp)
- 529:	e8 b5 fd ff ff       	call   2e3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 52e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 531:	83 c4 0c             	add    $0xc,%esp
- 534:	6a 01                	push   $0x1
- 536:	83 c6 01             	add    $0x1,%esi
- 539:	57                   	push   %edi
- 53a:	ff 75 08             	pushl  0x8(%ebp)
- 53d:	e8 a1 fd ff ff       	call   2e3 <write>
-  for(i = 0; fmt[i]; i++){
- 542:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 546:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 549:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 54b:	84 db                	test   %bl,%bl
- 54d:	75 8f                	jne    4de <printf+0x5e>
-    }
-  }
-}
- 54f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 552:	5b                   	pop    %ebx
- 553:	5e                   	pop    %esi
- 554:	5f                   	pop    %edi
- 555:	5d                   	pop    %ebp
- 556:	c3                   	ret    
- 557:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 55e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 560:	83 ec 0c             	sub    $0xc,%esp
- 563:	b9 10 00 00 00       	mov    $0x10,%ecx
- 568:	6a 00                	push   $0x0
- 56a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 56d:	8b 45 08             	mov    0x8(%ebp),%eax
- 570:	8b 13                	mov    (%ebx),%edx
- 572:	e8 59 fe ff ff       	call   3d0 <printint>
-        ap++;
- 577:	89 d8                	mov    %ebx,%eax
- 579:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 57c:	31 d2                	xor    %edx,%edx
-        ap++;
- 57e:	83 c0 04             	add    $0x4,%eax
- 581:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 584:	e9 4b ff ff ff       	jmp    4d4 <printf+0x54>
- 589:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 590:	83 ec 0c             	sub    $0xc,%esp
- 593:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 598:	6a 01                	push   $0x1
- 59a:	eb ce                	jmp    56a <printf+0xea>
- 59c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 5a0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 5a3:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 5a6:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 5a8:	6a 01                	push   $0x1
-        ap++;
- 5aa:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 5ad:	57                   	push   %edi
- 5ae:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 5b1:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 5b4:	e8 2a fd ff ff       	call   2e3 <write>
-        ap++;
- 5b9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 5bc:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 5bf:	31 d2                	xor    %edx,%edx
- 5c1:	e9 0e ff ff ff       	jmp    4d4 <printf+0x54>
- 5c6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5cd:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 5d0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5d3:	83 ec 04             	sub    $0x4,%esp
- 5d6:	e9 59 ff ff ff       	jmp    534 <printf+0xb4>
- 5db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 5df:	90                   	nop
-        s = (char*)*ap;
- 5e0:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 5e3:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 5e5:	83 c0 04             	add    $0x4,%eax
- 5e8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 5eb:	85 db                	test   %ebx,%ebx
- 5ed:	74 17                	je     606 <printf+0x186>
-        while(*s != 0){
- 5ef:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 5f2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 5f4:	84 c0                	test   %al,%al
- 5f6:	0f 84 d8 fe ff ff    	je     4d4 <printf+0x54>
- 5fc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5ff:	89 de                	mov    %ebx,%esi
- 601:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 604:	eb 1a                	jmp    620 <printf+0x1a0>
-          s = "(null)";
- 606:	bb 0f 08 00 00       	mov    $0x80f,%ebx
-        while(*s != 0){
- 60b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 60e:	b8 28 00 00 00       	mov    $0x28,%eax
- 613:	89 de                	mov    %ebx,%esi
- 615:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 618:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 61f:	90                   	nop
-  write(fd, &c, 1);
- 620:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 623:	83 c6 01             	add    $0x1,%esi
- 626:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 629:	6a 01                	push   $0x1
- 62b:	57                   	push   %edi
- 62c:	53                   	push   %ebx
- 62d:	e8 b1 fc ff ff       	call   2e3 <write>
-        while(*s != 0){
- 632:	0f b6 06             	movzbl (%esi),%eax
- 635:	83 c4 10             	add    $0x10,%esp
- 638:	84 c0                	test   %al,%al
- 63a:	75 e4                	jne    620 <printf+0x1a0>
- 63c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 63f:	31 d2                	xor    %edx,%edx
- 641:	e9 8e fe ff ff       	jmp    4d4 <printf+0x54>
- 646:	66 90                	xchg   %ax,%ax
- 648:	66 90                	xchg   %ax,%ax
- 64a:	66 90                	xchg   %ax,%ax
- 64c:	66 90                	xchg   %ax,%ax
- 64e:	66 90                	xchg   %ax,%ax
-
-00000650 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 650:	f3 0f 1e fb          	endbr32 
- 654:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 655:	a1 c4 0a 00 00       	mov    0xac4,%eax
-{
- 65a:	89 e5                	mov    %esp,%ebp
- 65c:	57                   	push   %edi
- 65d:	56                   	push   %esi
- 65e:	53                   	push   %ebx
- 65f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 662:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 664:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 667:	39 c8                	cmp    %ecx,%eax
- 669:	73 15                	jae    680 <free+0x30>
- 66b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 66f:	90                   	nop
- 670:	39 d1                	cmp    %edx,%ecx
- 672:	72 14                	jb     688 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 674:	39 d0                	cmp    %edx,%eax
- 676:	73 10                	jae    688 <free+0x38>
-{
- 678:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 67a:	8b 10                	mov    (%eax),%edx
- 67c:	39 c8                	cmp    %ecx,%eax
- 67e:	72 f0                	jb     670 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 680:	39 d0                	cmp    %edx,%eax
- 682:	72 f4                	jb     678 <free+0x28>
- 684:	39 d1                	cmp    %edx,%ecx
- 686:	73 f0                	jae    678 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 688:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 68b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 68e:	39 fa                	cmp    %edi,%edx
- 690:	74 1e                	je     6b0 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 692:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 695:	8b 50 04             	mov    0x4(%eax),%edx
- 698:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 69b:	39 f1                	cmp    %esi,%ecx
- 69d:	74 28                	je     6c7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 69f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 6a1:	5b                   	pop    %ebx
-  freep = p;
- 6a2:	a3 c4 0a 00 00       	mov    %eax,0xac4
-}
- 6a7:	5e                   	pop    %esi
- 6a8:	5f                   	pop    %edi
- 6a9:	5d                   	pop    %ebp
- 6aa:	c3                   	ret    
- 6ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 6af:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 6b0:	03 72 04             	add    0x4(%edx),%esi
- 6b3:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 6b6:	8b 10                	mov    (%eax),%edx
- 6b8:	8b 12                	mov    (%edx),%edx
- 6ba:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 6bd:	8b 50 04             	mov    0x4(%eax),%edx
- 6c0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6c3:	39 f1                	cmp    %esi,%ecx
- 6c5:	75 d8                	jne    69f <free+0x4f>
-    p->s.size += bp->s.size;
- 6c7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 6ca:	a3 c4 0a 00 00       	mov    %eax,0xac4
-    p->s.size += bp->s.size;
- 6cf:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 6d2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 6d5:	89 10                	mov    %edx,(%eax)
-}
- 6d7:	5b                   	pop    %ebx
- 6d8:	5e                   	pop    %esi
- 6d9:	5f                   	pop    %edi
- 6da:	5d                   	pop    %ebp
- 6db:	c3                   	ret    
- 6dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000006e0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 6e0:	f3 0f 1e fb          	endbr32 
- 6e4:	55                   	push   %ebp
- 6e5:	89 e5                	mov    %esp,%ebp
- 6e7:	57                   	push   %edi
- 6e8:	56                   	push   %esi
- 6e9:	53                   	push   %ebx
- 6ea:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6ed:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 6f0:	8b 3d c4 0a 00 00    	mov    0xac4,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6f6:	8d 70 07             	lea    0x7(%eax),%esi
- 6f9:	c1 ee 03             	shr    $0x3,%esi
- 6fc:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 6ff:	85 ff                	test   %edi,%edi
- 701:	0f 84 a9 00 00 00    	je     7b0 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 707:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 709:	8b 48 04             	mov    0x4(%eax),%ecx
- 70c:	39 f1                	cmp    %esi,%ecx
- 70e:	73 6d                	jae    77d <malloc+0x9d>
- 710:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 716:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 71b:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 71e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 725:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 728:	eb 17                	jmp    741 <malloc+0x61>
- 72a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 730:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 732:	8b 4a 04             	mov    0x4(%edx),%ecx
- 735:	39 f1                	cmp    %esi,%ecx
- 737:	73 4f                	jae    788 <malloc+0xa8>
- 739:	8b 3d c4 0a 00 00    	mov    0xac4,%edi
- 73f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 741:	39 c7                	cmp    %eax,%edi
- 743:	75 eb                	jne    730 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 745:	83 ec 0c             	sub    $0xc,%esp
- 748:	ff 75 e4             	pushl  -0x1c(%ebp)
- 74b:	e8 fb fb ff ff       	call   34b <sbrk>
-  if(p == (char*)-1)
- 750:	83 c4 10             	add    $0x10,%esp
- 753:	83 f8 ff             	cmp    $0xffffffff,%eax
- 756:	74 1b                	je     773 <malloc+0x93>
-  hp->s.size = nu;
- 758:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 75b:	83 ec 0c             	sub    $0xc,%esp
- 75e:	83 c0 08             	add    $0x8,%eax
- 761:	50                   	push   %eax
- 762:	e8 e9 fe ff ff       	call   650 <free>
-  return freep;
- 767:	a1 c4 0a 00 00       	mov    0xac4,%eax
-      if((p = morecore(nunits)) == 0)
- 76c:	83 c4 10             	add    $0x10,%esp
- 76f:	85 c0                	test   %eax,%eax
- 771:	75 bd                	jne    730 <malloc+0x50>
-        return 0;
-  }
-}
- 773:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 776:	31 c0                	xor    %eax,%eax
-}
- 778:	5b                   	pop    %ebx
- 779:	5e                   	pop    %esi
- 77a:	5f                   	pop    %edi
- 77b:	5d                   	pop    %ebp
- 77c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 77d:	89 c2                	mov    %eax,%edx
- 77f:	89 f8                	mov    %edi,%eax
- 781:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 788:	39 ce                	cmp    %ecx,%esi
- 78a:	74 54                	je     7e0 <malloc+0x100>
-        p->s.size -= nunits;
- 78c:	29 f1                	sub    %esi,%ecx
- 78e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 791:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 794:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 797:	a3 c4 0a 00 00       	mov    %eax,0xac4
-}
- 79c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 79f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 7a2:	5b                   	pop    %ebx
- 7a3:	5e                   	pop    %esi
- 7a4:	5f                   	pop    %edi
- 7a5:	5d                   	pop    %ebp
- 7a6:	c3                   	ret    
- 7a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 7ae:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 7b0:	c7 05 c4 0a 00 00 c8 	movl   $0xac8,0xac4
- 7b7:	0a 00 00 
-    base.s.size = 0;
- 7ba:	bf c8 0a 00 00       	mov    $0xac8,%edi
-    base.s.ptr = freep = prevp = &base;
- 7bf:	c7 05 c8 0a 00 00 c8 	movl   $0xac8,0xac8
- 7c6:	0a 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7c9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 7cb:	c7 05 cc 0a 00 00 00 	movl   $0x0,0xacc
- 7d2:	00 00 00 
-    if(p->s.size >= nunits){
- 7d5:	e9 36 ff ff ff       	jmp    710 <malloc+0x30>
- 7da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 7e0:	8b 0a                	mov    (%edx),%ecx
- 7e2:	89 08                	mov    %ecx,(%eax)
- 7e4:	eb b1                	jmp    797 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/ln.c b/xv6-public/Operating-System-Project/ln.c
deleted file mode 100644
index cf8a64e..0000000
--- a/xv6-public/Operating-System-Project/ln.c
+++ /dev/null
@@ -1,15 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char *argv[])
-{
-  if(argc != 3){
-    printf(2, "Usage: ln old new\n");
-    exit();
-  }
-  if(link(argv[1], argv[2]) < 0)
-    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
-  exit();
-}
diff --git a/xv6-public/Operating-System-Project/ln.d b/xv6-public/Operating-System-Project/ln.d
deleted file mode 100644
index 6728be9..0000000
--- a/xv6-public/Operating-System-Project/ln.d
+++ /dev/null
@@ -1 +0,0 @@
-ln.o: ln.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/ln.o b/xv6-public/Operating-System-Project/ln.o
deleted file mode 100644
index cd7f01c..0000000
Binary files a/xv6-public/Operating-System-Project/ln.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/ln.sym b/xv6-public/Operating-System-Project/ln.sym
deleted file mode 100644
index 662a660..0000000
--- a/xv6-public/Operating-System-Project/ln.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-000007e8 .rodata
-0000082c .eh_frame
-00000ac4 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 ln.c
-00000000 ulib.c
-00000000 printf.c
-000003d0 printint
-00000818 digits.1109
-00000000 umalloc.c
-00000ac4 freep
-00000ac8 base
-00000060 strcpy
-0000036b getChildren
-00000480 printf
-00000290 memmove
-0000030b mknod
-00000180 gets
-00000343 getpid
-000003a3 customWait
-0000039b getCBT
-000006e0 malloc
-00000353 sleep
-000002d3 pipe
-00000383 changePolicy
-000002e3 write
-0000031b fstat
-000002f3 kill
-00000333 chdir
-000003ab setQueue
-000002fb exec
-000002cb wait
-000002db read
-000003b3 getBurstTime
-00000313 unlink
-000002bb fork
-0000038b getTurnAroundTime
-0000034b sbrk
-0000035b uptime
-00000ac4 __bss_start
-00000120 memset
-00000000 main
-00000090 strcmp
-0000033b dup
-00000373 getSyscallCounter
-00000363 getParentID
-00000200 stat
-00000ac4 _edata
-00000ad0 _end
-00000323 link
-000002c3 exit
-0000037b setPriority
-00000250 atoi
-000003bb getCreationTime
-000000e0 strlen
-00000303 open
-00000140 strchr
-0000032b mkdir
-000002eb close
-00000393 getWaitingTime
-00000650 free
diff --git a/xv6-public/Operating-System-Project/log.c b/xv6-public/Operating-System-Project/log.c
deleted file mode 100644
index a64c0f6..0000000
--- a/xv6-public/Operating-System-Project/log.c
+++ /dev/null
@@ -1,234 +0,0 @@
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "buf.h"
-
-// Simple logging that allows concurrent FS system calls.
-//
-// A log transaction contains the updates of multiple FS system
-// calls. The logging system only commits when there are
-// no FS system calls active. Thus there is never
-// any reasoning required about whether a commit might
-// write an uncommitted system call's updates to disk.
-//
-// A system call should call begin_op()/end_op() to mark
-// its start and end. Usually begin_op() just increments
-// the count of in-progress FS system calls and returns.
-// But if it thinks the log is close to running out, it
-// sleeps until the last outstanding end_op() commits.
-//
-// The log is a physical re-do log containing disk blocks.
-// The on-disk log format:
-//   header block, containing block #s for block A, B, C, ...
-//   block A
-//   block B
-//   block C
-//   ...
-// Log appends are synchronous.
-
-// Contents of the header block, used for both the on-disk header block
-// and to keep track in memory of logged block# before commit.
-struct logheader {
-  int n;
-  int block[LOGSIZE];
-};
-
-struct log {
-  struct spinlock lock;
-  int start;
-  int size;
-  int outstanding; // how many FS sys calls are executing.
-  int committing;  // in commit(), please wait.
-  int dev;
-  struct logheader lh;
-};
-struct log log;
-
-static void recover_from_log(void);
-static void commit();
-
-void
-initlog(int dev)
-{
-  if (sizeof(struct logheader) >= BSIZE)
-    panic("initlog: too big logheader");
-
-  struct superblock sb;
-  initlock(&log.lock, "log");
-  readsb(dev, &sb);
-  log.start = sb.logstart;
-  log.size = sb.nlog;
-  log.dev = dev;
-  recover_from_log();
-}
-
-// Copy committed blocks from log to their home location
-static void
-install_trans(void)
-{
-  int tail;
-
-  for (tail = 0; tail < log.lh.n; tail++) {
-    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
-    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
-    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
-    bwrite(dbuf);  // write dst to disk
-    brelse(lbuf);
-    brelse(dbuf);
-  }
-}
-
-// Read the log header from disk into the in-memory log header
-static void
-read_head(void)
-{
-  struct buf *buf = bread(log.dev, log.start);
-  struct logheader *lh = (struct logheader *) (buf->data);
-  int i;
-  log.lh.n = lh->n;
-  for (i = 0; i < log.lh.n; i++) {
-    log.lh.block[i] = lh->block[i];
-  }
-  brelse(buf);
-}
-
-// Write in-memory log header to disk.
-// This is the true point at which the
-// current transaction commits.
-static void
-write_head(void)
-{
-  struct buf *buf = bread(log.dev, log.start);
-  struct logheader *hb = (struct logheader *) (buf->data);
-  int i;
-  hb->n = log.lh.n;
-  for (i = 0; i < log.lh.n; i++) {
-    hb->block[i] = log.lh.block[i];
-  }
-  bwrite(buf);
-  brelse(buf);
-}
-
-static void
-recover_from_log(void)
-{
-  read_head();
-  install_trans(); // if committed, copy from log to disk
-  log.lh.n = 0;
-  write_head(); // clear the log
-}
-
-// called at the start of each FS system call.
-void
-begin_op(void)
-{
-  acquire(&log.lock);
-  while(1){
-    if(log.committing){
-      sleep(&log, &log.lock);
-    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
-      // this op might exhaust log space; wait for commit.
-      sleep(&log, &log.lock);
-    } else {
-      log.outstanding += 1;
-      release(&log.lock);
-      break;
-    }
-  }
-}
-
-// called at the end of each FS system call.
-// commits if this was the last outstanding operation.
-void
-end_op(void)
-{
-  int do_commit = 0;
-
-  acquire(&log.lock);
-  log.outstanding -= 1;
-  if(log.committing)
-    panic("log.committing");
-  if(log.outstanding == 0){
-    do_commit = 1;
-    log.committing = 1;
-  } else {
-    // begin_op() may be waiting for log space,
-    // and decrementing log.outstanding has decreased
-    // the amount of reserved space.
-    wakeup(&log);
-  }
-  release(&log.lock);
-
-  if(do_commit){
-    // call commit w/o holding locks, since not allowed
-    // to sleep with locks.
-    commit();
-    acquire(&log.lock);
-    log.committing = 0;
-    wakeup(&log);
-    release(&log.lock);
-  }
-}
-
-// Copy modified blocks from cache to log.
-static void
-write_log(void)
-{
-  int tail;
-
-  for (tail = 0; tail < log.lh.n; tail++) {
-    struct buf *to = bread(log.dev, log.start+tail+1); // log block
-    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
-    memmove(to->data, from->data, BSIZE);
-    bwrite(to);  // write the log
-    brelse(from);
-    brelse(to);
-  }
-}
-
-static void
-commit()
-{
-  if (log.lh.n > 0) {
-    write_log();     // Write modified blocks from cache to log
-    write_head();    // Write header to disk -- the real commit
-    install_trans(); // Now install writes to home locations
-    log.lh.n = 0;
-    write_head();    // Erase the transaction from the log
-  }
-}
-
-// Caller has modified b->data and is done with the buffer.
-// Record the block number and pin in the cache with B_DIRTY.
-// commit()/write_log() will do the disk write.
-//
-// log_write() replaces bwrite(); a typical use is:
-//   bp = bread(...)
-//   modify bp->data[]
-//   log_write(bp)
-//   brelse(bp)
-void
-log_write(struct buf *b)
-{
-  int i;
-
-  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
-    panic("too big a transaction");
-  if (log.outstanding < 1)
-    panic("log_write outside of trans");
-
-  acquire(&log.lock);
-  for (i = 0; i < log.lh.n; i++) {
-    if (log.lh.block[i] == b->blockno)   // log absorbtion
-      break;
-  }
-  log.lh.block[i] = b->blockno;
-  if (i == log.lh.n)
-    log.lh.n++;
-  b->flags |= B_DIRTY; // prevent eviction
-  release(&log.lock);
-}
-
diff --git a/xv6-public/Operating-System-Project/log.d b/xv6-public/Operating-System-Project/log.d
deleted file mode 100644
index 04c8930..0000000
--- a/xv6-public/Operating-System-Project/log.d
+++ /dev/null
@@ -1,2 +0,0 @@
-log.o: log.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h \
- sleeplock.h fs.h buf.h
diff --git a/xv6-public/Operating-System-Project/log.o b/xv6-public/Operating-System-Project/log.o
deleted file mode 100644
index 6a238bf..0000000
Binary files a/xv6-public/Operating-System-Project/log.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/ls.asm b/xv6-public/Operating-System-Project/ls.asm
deleted file mode 100644
index aac9e26..0000000
--- a/xv6-public/Operating-System-Project/ls.asm
+++ /dev/null
@@ -1,1542 +0,0 @@
-
-_ls:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-  close(fd);
-}
-
-int
-main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	56                   	push   %esi
-  12:	53                   	push   %ebx
-  13:	51                   	push   %ecx
-  14:	83 ec 0c             	sub    $0xc,%esp
-  17:	8b 01                	mov    (%ecx),%eax
-  19:	8b 51 04             	mov    0x4(%ecx),%edx
-  int i;
-
-  if(argc < 2){
-  1c:	83 f8 01             	cmp    $0x1,%eax
-  1f:	7e 28                	jle    49 <main+0x49>
-  21:	8d 5a 04             	lea    0x4(%edx),%ebx
-  24:	8d 34 82             	lea    (%edx,%eax,4),%esi
-  27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  2e:	66 90                	xchg   %ax,%ax
-    ls(".");
-    exit();
-  }
-  for(i=1; i<argc; i++)
-    ls(argv[i]);
-  30:	83 ec 0c             	sub    $0xc,%esp
-  33:	ff 33                	pushl  (%ebx)
-  35:	83 c3 04             	add    $0x4,%ebx
-  38:	e8 c3 00 00 00       	call   100 <ls>
-  for(i=1; i<argc; i++)
-  3d:	83 c4 10             	add    $0x10,%esp
-  40:	39 f3                	cmp    %esi,%ebx
-  42:	75 ec                	jne    30 <main+0x30>
-  exit();
-  44:	e8 5a 05 00 00       	call   5a3 <exit>
-    ls(".");
-  49:	83 ec 0c             	sub    $0xc,%esp
-  4c:	68 10 0b 00 00       	push   $0xb10
-  51:	e8 aa 00 00 00       	call   100 <ls>
-    exit();
-  56:	e8 48 05 00 00       	call   5a3 <exit>
-  5b:	66 90                	xchg   %ax,%ax
-  5d:	66 90                	xchg   %ax,%ax
-  5f:	90                   	nop
-
-00000060 <fmtname>:
-{
-  60:	f3 0f 1e fb          	endbr32 
-  64:	55                   	push   %ebp
-  65:	89 e5                	mov    %esp,%ebp
-  67:	56                   	push   %esi
-  68:	53                   	push   %ebx
-  69:	8b 75 08             	mov    0x8(%ebp),%esi
-  for(p=path+strlen(path); p >= path && *p != '/'; p--)
-  6c:	83 ec 0c             	sub    $0xc,%esp
-  6f:	56                   	push   %esi
-  70:	e8 4b 03 00 00       	call   3c0 <strlen>
-  75:	83 c4 10             	add    $0x10,%esp
-  78:	01 f0                	add    %esi,%eax
-  7a:	89 c3                	mov    %eax,%ebx
-  7c:	73 0b                	jae    89 <fmtname+0x29>
-  7e:	eb 0e                	jmp    8e <fmtname+0x2e>
-  80:	8d 43 ff             	lea    -0x1(%ebx),%eax
-  83:	39 c6                	cmp    %eax,%esi
-  85:	77 0a                	ja     91 <fmtname+0x31>
-  87:	89 c3                	mov    %eax,%ebx
-  89:	80 3b 2f             	cmpb   $0x2f,(%ebx)
-  8c:	75 f2                	jne    80 <fmtname+0x20>
-  8e:	83 c3 01             	add    $0x1,%ebx
-  if(strlen(p) >= DIRSIZ)
-  91:	83 ec 0c             	sub    $0xc,%esp
-  94:	53                   	push   %ebx
-  95:	e8 26 03 00 00       	call   3c0 <strlen>
-  9a:	83 c4 10             	add    $0x10,%esp
-  9d:	83 f8 0d             	cmp    $0xd,%eax
-  a0:	77 4a                	ja     ec <fmtname+0x8c>
-  memmove(buf, p, strlen(p));
-  a2:	83 ec 0c             	sub    $0xc,%esp
-  a5:	53                   	push   %ebx
-  a6:	e8 15 03 00 00       	call   3c0 <strlen>
-  ab:	83 c4 0c             	add    $0xc,%esp
-  ae:	50                   	push   %eax
-  af:	53                   	push   %ebx
-  b0:	68 44 0e 00 00       	push   $0xe44
-  b5:	e8 b6 04 00 00       	call   570 <memmove>
-  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
-  ba:	89 1c 24             	mov    %ebx,(%esp)
-  bd:	e8 fe 02 00 00       	call   3c0 <strlen>
-  c2:	89 1c 24             	mov    %ebx,(%esp)
-  return buf;
-  c5:	bb 44 0e 00 00       	mov    $0xe44,%ebx
-  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
-  ca:	89 c6                	mov    %eax,%esi
-  cc:	e8 ef 02 00 00       	call   3c0 <strlen>
-  d1:	ba 0e 00 00 00       	mov    $0xe,%edx
-  d6:	83 c4 0c             	add    $0xc,%esp
-  d9:	29 f2                	sub    %esi,%edx
-  db:	05 44 0e 00 00       	add    $0xe44,%eax
-  e0:	52                   	push   %edx
-  e1:	6a 20                	push   $0x20
-  e3:	50                   	push   %eax
-  e4:	e8 17 03 00 00       	call   400 <memset>
-  return buf;
-  e9:	83 c4 10             	add    $0x10,%esp
-}
-  ec:	8d 65 f8             	lea    -0x8(%ebp),%esp
-  ef:	89 d8                	mov    %ebx,%eax
-  f1:	5b                   	pop    %ebx
-  f2:	5e                   	pop    %esi
-  f3:	5d                   	pop    %ebp
-  f4:	c3                   	ret    
-  f5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000100 <ls>:
-{
- 100:	f3 0f 1e fb          	endbr32 
- 104:	55                   	push   %ebp
- 105:	89 e5                	mov    %esp,%ebp
- 107:	57                   	push   %edi
- 108:	56                   	push   %esi
- 109:	53                   	push   %ebx
- 10a:	81 ec 64 02 00 00    	sub    $0x264,%esp
- 110:	8b 7d 08             	mov    0x8(%ebp),%edi
-  if((fd = open(path, 0)) < 0){
- 113:	6a 00                	push   $0x0
- 115:	57                   	push   %edi
- 116:	e8 c8 04 00 00       	call   5e3 <open>
- 11b:	83 c4 10             	add    $0x10,%esp
- 11e:	85 c0                	test   %eax,%eax
- 120:	0f 88 9a 01 00 00    	js     2c0 <ls+0x1c0>
-  if(fstat(fd, &st) < 0){
- 126:	83 ec 08             	sub    $0x8,%esp
- 129:	8d b5 d4 fd ff ff    	lea    -0x22c(%ebp),%esi
- 12f:	89 c3                	mov    %eax,%ebx
- 131:	56                   	push   %esi
- 132:	50                   	push   %eax
- 133:	e8 c3 04 00 00       	call   5fb <fstat>
- 138:	83 c4 10             	add    $0x10,%esp
- 13b:	85 c0                	test   %eax,%eax
- 13d:	0f 88 bd 01 00 00    	js     300 <ls+0x200>
-  switch(st.type){
- 143:	0f b7 85 d4 fd ff ff 	movzwl -0x22c(%ebp),%eax
- 14a:	66 83 f8 01          	cmp    $0x1,%ax
- 14e:	74 60                	je     1b0 <ls+0xb0>
- 150:	66 83 f8 02          	cmp    $0x2,%ax
- 154:	74 1a                	je     170 <ls+0x70>
-  close(fd);
- 156:	83 ec 0c             	sub    $0xc,%esp
- 159:	53                   	push   %ebx
- 15a:	e8 6c 04 00 00       	call   5cb <close>
- 15f:	83 c4 10             	add    $0x10,%esp
-}
- 162:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 165:	5b                   	pop    %ebx
- 166:	5e                   	pop    %esi
- 167:	5f                   	pop    %edi
- 168:	5d                   	pop    %ebp
- 169:	c3                   	ret    
- 16a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
- 170:	83 ec 0c             	sub    $0xc,%esp
- 173:	8b 95 e4 fd ff ff    	mov    -0x21c(%ebp),%edx
- 179:	8b b5 dc fd ff ff    	mov    -0x224(%ebp),%esi
- 17f:	57                   	push   %edi
- 180:	89 95 b4 fd ff ff    	mov    %edx,-0x24c(%ebp)
- 186:	e8 d5 fe ff ff       	call   60 <fmtname>
- 18b:	8b 95 b4 fd ff ff    	mov    -0x24c(%ebp),%edx
- 191:	59                   	pop    %ecx
- 192:	5f                   	pop    %edi
- 193:	52                   	push   %edx
- 194:	56                   	push   %esi
- 195:	6a 02                	push   $0x2
- 197:	50                   	push   %eax
- 198:	68 f0 0a 00 00       	push   $0xaf0
- 19d:	6a 01                	push   $0x1
- 19f:	e8 bc 05 00 00       	call   760 <printf>
-    break;
- 1a4:	83 c4 20             	add    $0x20,%esp
- 1a7:	eb ad                	jmp    156 <ls+0x56>
- 1a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
- 1b0:	83 ec 0c             	sub    $0xc,%esp
- 1b3:	57                   	push   %edi
- 1b4:	e8 07 02 00 00       	call   3c0 <strlen>
- 1b9:	83 c4 10             	add    $0x10,%esp
- 1bc:	83 c0 10             	add    $0x10,%eax
- 1bf:	3d 00 02 00 00       	cmp    $0x200,%eax
- 1c4:	0f 87 16 01 00 00    	ja     2e0 <ls+0x1e0>
-    strcpy(buf, path);
- 1ca:	83 ec 08             	sub    $0x8,%esp
- 1cd:	57                   	push   %edi
- 1ce:	8d bd e8 fd ff ff    	lea    -0x218(%ebp),%edi
- 1d4:	57                   	push   %edi
- 1d5:	e8 66 01 00 00       	call   340 <strcpy>
-    p = buf+strlen(buf);
- 1da:	89 3c 24             	mov    %edi,(%esp)
- 1dd:	e8 de 01 00 00       	call   3c0 <strlen>
-    while(read(fd, &de, sizeof(de)) == sizeof(de)){
- 1e2:	83 c4 10             	add    $0x10,%esp
-    p = buf+strlen(buf);
- 1e5:	01 f8                	add    %edi,%eax
-    *p++ = '/';
- 1e7:	8d 48 01             	lea    0x1(%eax),%ecx
-    p = buf+strlen(buf);
- 1ea:	89 85 a8 fd ff ff    	mov    %eax,-0x258(%ebp)
-    *p++ = '/';
- 1f0:	89 8d a4 fd ff ff    	mov    %ecx,-0x25c(%ebp)
- 1f6:	c6 00 2f             	movb   $0x2f,(%eax)
-    while(read(fd, &de, sizeof(de)) == sizeof(de)){
- 1f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 200:	83 ec 04             	sub    $0x4,%esp
- 203:	8d 85 c4 fd ff ff    	lea    -0x23c(%ebp),%eax
- 209:	6a 10                	push   $0x10
- 20b:	50                   	push   %eax
- 20c:	53                   	push   %ebx
- 20d:	e8 a9 03 00 00       	call   5bb <read>
- 212:	83 c4 10             	add    $0x10,%esp
- 215:	83 f8 10             	cmp    $0x10,%eax
- 218:	0f 85 38 ff ff ff    	jne    156 <ls+0x56>
-      if(de.inum == 0)
- 21e:	66 83 bd c4 fd ff ff 	cmpw   $0x0,-0x23c(%ebp)
- 225:	00 
- 226:	74 d8                	je     200 <ls+0x100>
-      memmove(p, de.name, DIRSIZ);
- 228:	83 ec 04             	sub    $0x4,%esp
- 22b:	8d 85 c6 fd ff ff    	lea    -0x23a(%ebp),%eax
- 231:	6a 0e                	push   $0xe
- 233:	50                   	push   %eax
- 234:	ff b5 a4 fd ff ff    	pushl  -0x25c(%ebp)
- 23a:	e8 31 03 00 00       	call   570 <memmove>
-      p[DIRSIZ] = 0;
- 23f:	8b 85 a8 fd ff ff    	mov    -0x258(%ebp),%eax
- 245:	c6 40 0f 00          	movb   $0x0,0xf(%eax)
-      if(stat(buf, &st) < 0){
- 249:	58                   	pop    %eax
- 24a:	5a                   	pop    %edx
- 24b:	56                   	push   %esi
- 24c:	57                   	push   %edi
- 24d:	e8 8e 02 00 00       	call   4e0 <stat>
- 252:	83 c4 10             	add    $0x10,%esp
- 255:	85 c0                	test   %eax,%eax
- 257:	0f 88 cb 00 00 00    	js     328 <ls+0x228>
-      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
- 25d:	83 ec 0c             	sub    $0xc,%esp
- 260:	8b 8d e4 fd ff ff    	mov    -0x21c(%ebp),%ecx
- 266:	8b 95 dc fd ff ff    	mov    -0x224(%ebp),%edx
- 26c:	57                   	push   %edi
- 26d:	0f bf 85 d4 fd ff ff 	movswl -0x22c(%ebp),%eax
- 274:	89 8d ac fd ff ff    	mov    %ecx,-0x254(%ebp)
- 27a:	89 95 b0 fd ff ff    	mov    %edx,-0x250(%ebp)
- 280:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
- 286:	e8 d5 fd ff ff       	call   60 <fmtname>
- 28b:	5a                   	pop    %edx
- 28c:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
- 292:	59                   	pop    %ecx
- 293:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
- 299:	51                   	push   %ecx
- 29a:	52                   	push   %edx
- 29b:	ff b5 b4 fd ff ff    	pushl  -0x24c(%ebp)
- 2a1:	50                   	push   %eax
- 2a2:	68 f0 0a 00 00       	push   $0xaf0
- 2a7:	6a 01                	push   $0x1
- 2a9:	e8 b2 04 00 00       	call   760 <printf>
- 2ae:	83 c4 20             	add    $0x20,%esp
- 2b1:	e9 4a ff ff ff       	jmp    200 <ls+0x100>
- 2b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 2bd:	8d 76 00             	lea    0x0(%esi),%esi
-    printf(2, "ls: cannot open %s\n", path);
- 2c0:	83 ec 04             	sub    $0x4,%esp
- 2c3:	57                   	push   %edi
- 2c4:	68 c8 0a 00 00       	push   $0xac8
- 2c9:	6a 02                	push   $0x2
- 2cb:	e8 90 04 00 00       	call   760 <printf>
-    return;
- 2d0:	83 c4 10             	add    $0x10,%esp
-}
- 2d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 2d6:	5b                   	pop    %ebx
- 2d7:	5e                   	pop    %esi
- 2d8:	5f                   	pop    %edi
- 2d9:	5d                   	pop    %ebp
- 2da:	c3                   	ret    
- 2db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 2df:	90                   	nop
-      printf(1, "ls: path too long\n");
- 2e0:	83 ec 08             	sub    $0x8,%esp
- 2e3:	68 fd 0a 00 00       	push   $0xafd
- 2e8:	6a 01                	push   $0x1
- 2ea:	e8 71 04 00 00       	call   760 <printf>
-      break;
- 2ef:	83 c4 10             	add    $0x10,%esp
- 2f2:	e9 5f fe ff ff       	jmp    156 <ls+0x56>
- 2f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 2fe:	66 90                	xchg   %ax,%ax
-    printf(2, "ls: cannot stat %s\n", path);
- 300:	83 ec 04             	sub    $0x4,%esp
- 303:	57                   	push   %edi
- 304:	68 dc 0a 00 00       	push   $0xadc
- 309:	6a 02                	push   $0x2
- 30b:	e8 50 04 00 00       	call   760 <printf>
-    close(fd);
- 310:	89 1c 24             	mov    %ebx,(%esp)
- 313:	e8 b3 02 00 00       	call   5cb <close>
-    return;
- 318:	83 c4 10             	add    $0x10,%esp
-}
- 31b:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 31e:	5b                   	pop    %ebx
- 31f:	5e                   	pop    %esi
- 320:	5f                   	pop    %edi
- 321:	5d                   	pop    %ebp
- 322:	c3                   	ret    
- 323:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 327:	90                   	nop
-        printf(1, "ls: cannot stat %s\n", buf);
- 328:	83 ec 04             	sub    $0x4,%esp
- 32b:	57                   	push   %edi
- 32c:	68 dc 0a 00 00       	push   $0xadc
- 331:	6a 01                	push   $0x1
- 333:	e8 28 04 00 00       	call   760 <printf>
-        continue;
- 338:	83 c4 10             	add    $0x10,%esp
- 33b:	e9 c0 fe ff ff       	jmp    200 <ls+0x100>
-
-00000340 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
- 340:	f3 0f 1e fb          	endbr32 
- 344:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
- 345:	31 c0                	xor    %eax,%eax
-{
- 347:	89 e5                	mov    %esp,%ebp
- 349:	53                   	push   %ebx
- 34a:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 34d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
- 350:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
- 354:	88 14 01             	mov    %dl,(%ecx,%eax,1)
- 357:	83 c0 01             	add    $0x1,%eax
- 35a:	84 d2                	test   %dl,%dl
- 35c:	75 f2                	jne    350 <strcpy+0x10>
-    ;
-  return os;
-}
- 35e:	89 c8                	mov    %ecx,%eax
- 360:	5b                   	pop    %ebx
- 361:	5d                   	pop    %ebp
- 362:	c3                   	ret    
- 363:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 36a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000370 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
- 370:	f3 0f 1e fb          	endbr32 
- 374:	55                   	push   %ebp
- 375:	89 e5                	mov    %esp,%ebp
- 377:	53                   	push   %ebx
- 378:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 37b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
- 37e:	0f b6 01             	movzbl (%ecx),%eax
- 381:	0f b6 1a             	movzbl (%edx),%ebx
- 384:	84 c0                	test   %al,%al
- 386:	75 19                	jne    3a1 <strcmp+0x31>
- 388:	eb 26                	jmp    3b0 <strcmp+0x40>
- 38a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 390:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
- 394:	83 c1 01             	add    $0x1,%ecx
- 397:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
- 39a:	0f b6 1a             	movzbl (%edx),%ebx
- 39d:	84 c0                	test   %al,%al
- 39f:	74 0f                	je     3b0 <strcmp+0x40>
- 3a1:	38 d8                	cmp    %bl,%al
- 3a3:	74 eb                	je     390 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
- 3a5:	29 d8                	sub    %ebx,%eax
-}
- 3a7:	5b                   	pop    %ebx
- 3a8:	5d                   	pop    %ebp
- 3a9:	c3                   	ret    
- 3aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 3b0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
- 3b2:	29 d8                	sub    %ebx,%eax
-}
- 3b4:	5b                   	pop    %ebx
- 3b5:	5d                   	pop    %ebp
- 3b6:	c3                   	ret    
- 3b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3be:	66 90                	xchg   %ax,%ax
-
-000003c0 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 3c0:	f3 0f 1e fb          	endbr32 
- 3c4:	55                   	push   %ebp
- 3c5:	89 e5                	mov    %esp,%ebp
- 3c7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 3ca:	80 3a 00             	cmpb   $0x0,(%edx)
- 3cd:	74 21                	je     3f0 <strlen+0x30>
- 3cf:	31 c0                	xor    %eax,%eax
- 3d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3d8:	83 c0 01             	add    $0x1,%eax
- 3db:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 3df:	89 c1                	mov    %eax,%ecx
- 3e1:	75 f5                	jne    3d8 <strlen+0x18>
-    ;
-  return n;
-}
- 3e3:	89 c8                	mov    %ecx,%eax
- 3e5:	5d                   	pop    %ebp
- 3e6:	c3                   	ret    
- 3e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3ee:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 3f0:	31 c9                	xor    %ecx,%ecx
-}
- 3f2:	5d                   	pop    %ebp
- 3f3:	89 c8                	mov    %ecx,%eax
- 3f5:	c3                   	ret    
- 3f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3fd:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000400 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 400:	f3 0f 1e fb          	endbr32 
- 404:	55                   	push   %ebp
- 405:	89 e5                	mov    %esp,%ebp
- 407:	57                   	push   %edi
- 408:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 40b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 40e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 411:	89 d7                	mov    %edx,%edi
- 413:	fc                   	cld    
- 414:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 416:	89 d0                	mov    %edx,%eax
- 418:	5f                   	pop    %edi
- 419:	5d                   	pop    %ebp
- 41a:	c3                   	ret    
- 41b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 41f:	90                   	nop
-
-00000420 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 420:	f3 0f 1e fb          	endbr32 
- 424:	55                   	push   %ebp
- 425:	89 e5                	mov    %esp,%ebp
- 427:	8b 45 08             	mov    0x8(%ebp),%eax
- 42a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 42e:	0f b6 10             	movzbl (%eax),%edx
- 431:	84 d2                	test   %dl,%dl
- 433:	75 16                	jne    44b <strchr+0x2b>
- 435:	eb 21                	jmp    458 <strchr+0x38>
- 437:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 43e:	66 90                	xchg   %ax,%ax
- 440:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 444:	83 c0 01             	add    $0x1,%eax
- 447:	84 d2                	test   %dl,%dl
- 449:	74 0d                	je     458 <strchr+0x38>
-    if(*s == c)
- 44b:	38 d1                	cmp    %dl,%cl
- 44d:	75 f1                	jne    440 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 44f:	5d                   	pop    %ebp
- 450:	c3                   	ret    
- 451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 458:	31 c0                	xor    %eax,%eax
-}
- 45a:	5d                   	pop    %ebp
- 45b:	c3                   	ret    
- 45c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000460 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 460:	f3 0f 1e fb          	endbr32 
- 464:	55                   	push   %ebp
- 465:	89 e5                	mov    %esp,%ebp
- 467:	57                   	push   %edi
- 468:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 469:	31 f6                	xor    %esi,%esi
-{
- 46b:	53                   	push   %ebx
- 46c:	89 f3                	mov    %esi,%ebx
- 46e:	83 ec 1c             	sub    $0x1c,%esp
- 471:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 474:	eb 33                	jmp    4a9 <gets+0x49>
- 476:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 47d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 480:	83 ec 04             	sub    $0x4,%esp
- 483:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 486:	6a 01                	push   $0x1
- 488:	50                   	push   %eax
- 489:	6a 00                	push   $0x0
- 48b:	e8 2b 01 00 00       	call   5bb <read>
-    if(cc < 1)
- 490:	83 c4 10             	add    $0x10,%esp
- 493:	85 c0                	test   %eax,%eax
- 495:	7e 1c                	jle    4b3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 497:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 49b:	83 c7 01             	add    $0x1,%edi
- 49e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 4a1:	3c 0a                	cmp    $0xa,%al
- 4a3:	74 23                	je     4c8 <gets+0x68>
- 4a5:	3c 0d                	cmp    $0xd,%al
- 4a7:	74 1f                	je     4c8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 4a9:	83 c3 01             	add    $0x1,%ebx
- 4ac:	89 fe                	mov    %edi,%esi
- 4ae:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 4b1:	7c cd                	jl     480 <gets+0x20>
- 4b3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 4b5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 4b8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 4bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 4be:	5b                   	pop    %ebx
- 4bf:	5e                   	pop    %esi
- 4c0:	5f                   	pop    %edi
- 4c1:	5d                   	pop    %ebp
- 4c2:	c3                   	ret    
- 4c3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 4c7:	90                   	nop
- 4c8:	8b 75 08             	mov    0x8(%ebp),%esi
- 4cb:	8b 45 08             	mov    0x8(%ebp),%eax
- 4ce:	01 de                	add    %ebx,%esi
- 4d0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 4d2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 4d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 4d8:	5b                   	pop    %ebx
- 4d9:	5e                   	pop    %esi
- 4da:	5f                   	pop    %edi
- 4db:	5d                   	pop    %ebp
- 4dc:	c3                   	ret    
- 4dd:	8d 76 00             	lea    0x0(%esi),%esi
-
-000004e0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 4e0:	f3 0f 1e fb          	endbr32 
- 4e4:	55                   	push   %ebp
- 4e5:	89 e5                	mov    %esp,%ebp
- 4e7:	56                   	push   %esi
- 4e8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 4e9:	83 ec 08             	sub    $0x8,%esp
- 4ec:	6a 00                	push   $0x0
- 4ee:	ff 75 08             	pushl  0x8(%ebp)
- 4f1:	e8 ed 00 00 00       	call   5e3 <open>
-  if(fd < 0)
- 4f6:	83 c4 10             	add    $0x10,%esp
- 4f9:	85 c0                	test   %eax,%eax
- 4fb:	78 2b                	js     528 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 4fd:	83 ec 08             	sub    $0x8,%esp
- 500:	ff 75 0c             	pushl  0xc(%ebp)
- 503:	89 c3                	mov    %eax,%ebx
- 505:	50                   	push   %eax
- 506:	e8 f0 00 00 00       	call   5fb <fstat>
-  close(fd);
- 50b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 50e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 510:	e8 b6 00 00 00       	call   5cb <close>
-  return r;
- 515:	83 c4 10             	add    $0x10,%esp
-}
- 518:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 51b:	89 f0                	mov    %esi,%eax
- 51d:	5b                   	pop    %ebx
- 51e:	5e                   	pop    %esi
- 51f:	5d                   	pop    %ebp
- 520:	c3                   	ret    
- 521:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 528:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 52d:	eb e9                	jmp    518 <stat+0x38>
- 52f:	90                   	nop
-
-00000530 <atoi>:
-
-int
-atoi(const char *s)
-{
- 530:	f3 0f 1e fb          	endbr32 
- 534:	55                   	push   %ebp
- 535:	89 e5                	mov    %esp,%ebp
- 537:	53                   	push   %ebx
- 538:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 53b:	0f be 02             	movsbl (%edx),%eax
- 53e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 541:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 544:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 549:	77 1a                	ja     565 <atoi+0x35>
- 54b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 54f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 550:	83 c2 01             	add    $0x1,%edx
- 553:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 556:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 55a:	0f be 02             	movsbl (%edx),%eax
- 55d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 560:	80 fb 09             	cmp    $0x9,%bl
- 563:	76 eb                	jbe    550 <atoi+0x20>
-  return n;
-}
- 565:	89 c8                	mov    %ecx,%eax
- 567:	5b                   	pop    %ebx
- 568:	5d                   	pop    %ebp
- 569:	c3                   	ret    
- 56a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000570 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 570:	f3 0f 1e fb          	endbr32 
- 574:	55                   	push   %ebp
- 575:	89 e5                	mov    %esp,%ebp
- 577:	57                   	push   %edi
- 578:	8b 45 10             	mov    0x10(%ebp),%eax
- 57b:	8b 55 08             	mov    0x8(%ebp),%edx
- 57e:	56                   	push   %esi
- 57f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 582:	85 c0                	test   %eax,%eax
- 584:	7e 0f                	jle    595 <memmove+0x25>
- 586:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 588:	89 d7                	mov    %edx,%edi
- 58a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 590:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 591:	39 f8                	cmp    %edi,%eax
- 593:	75 fb                	jne    590 <memmove+0x20>
-  return vdst;
-}
- 595:	5e                   	pop    %esi
- 596:	89 d0                	mov    %edx,%eax
- 598:	5f                   	pop    %edi
- 599:	5d                   	pop    %ebp
- 59a:	c3                   	ret    
-
-0000059b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 59b:	b8 01 00 00 00       	mov    $0x1,%eax
- 5a0:	cd 40                	int    $0x40
- 5a2:	c3                   	ret    
-
-000005a3 <exit>:
-SYSCALL(exit)
- 5a3:	b8 02 00 00 00       	mov    $0x2,%eax
- 5a8:	cd 40                	int    $0x40
- 5aa:	c3                   	ret    
-
-000005ab <wait>:
-SYSCALL(wait)
- 5ab:	b8 03 00 00 00       	mov    $0x3,%eax
- 5b0:	cd 40                	int    $0x40
- 5b2:	c3                   	ret    
-
-000005b3 <pipe>:
-SYSCALL(pipe)
- 5b3:	b8 04 00 00 00       	mov    $0x4,%eax
- 5b8:	cd 40                	int    $0x40
- 5ba:	c3                   	ret    
-
-000005bb <read>:
-SYSCALL(read)
- 5bb:	b8 05 00 00 00       	mov    $0x5,%eax
- 5c0:	cd 40                	int    $0x40
- 5c2:	c3                   	ret    
-
-000005c3 <write>:
-SYSCALL(write)
- 5c3:	b8 10 00 00 00       	mov    $0x10,%eax
- 5c8:	cd 40                	int    $0x40
- 5ca:	c3                   	ret    
-
-000005cb <close>:
-SYSCALL(close)
- 5cb:	b8 15 00 00 00       	mov    $0x15,%eax
- 5d0:	cd 40                	int    $0x40
- 5d2:	c3                   	ret    
-
-000005d3 <kill>:
-SYSCALL(kill)
- 5d3:	b8 06 00 00 00       	mov    $0x6,%eax
- 5d8:	cd 40                	int    $0x40
- 5da:	c3                   	ret    
-
-000005db <exec>:
-SYSCALL(exec)
- 5db:	b8 07 00 00 00       	mov    $0x7,%eax
- 5e0:	cd 40                	int    $0x40
- 5e2:	c3                   	ret    
-
-000005e3 <open>:
-SYSCALL(open)
- 5e3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 5e8:	cd 40                	int    $0x40
- 5ea:	c3                   	ret    
-
-000005eb <mknod>:
-SYSCALL(mknod)
- 5eb:	b8 11 00 00 00       	mov    $0x11,%eax
- 5f0:	cd 40                	int    $0x40
- 5f2:	c3                   	ret    
-
-000005f3 <unlink>:
-SYSCALL(unlink)
- 5f3:	b8 12 00 00 00       	mov    $0x12,%eax
- 5f8:	cd 40                	int    $0x40
- 5fa:	c3                   	ret    
-
-000005fb <fstat>:
-SYSCALL(fstat)
- 5fb:	b8 08 00 00 00       	mov    $0x8,%eax
- 600:	cd 40                	int    $0x40
- 602:	c3                   	ret    
-
-00000603 <link>:
-SYSCALL(link)
- 603:	b8 13 00 00 00       	mov    $0x13,%eax
- 608:	cd 40                	int    $0x40
- 60a:	c3                   	ret    
-
-0000060b <mkdir>:
-SYSCALL(mkdir)
- 60b:	b8 14 00 00 00       	mov    $0x14,%eax
- 610:	cd 40                	int    $0x40
- 612:	c3                   	ret    
-
-00000613 <chdir>:
-SYSCALL(chdir)
- 613:	b8 09 00 00 00       	mov    $0x9,%eax
- 618:	cd 40                	int    $0x40
- 61a:	c3                   	ret    
-
-0000061b <dup>:
-SYSCALL(dup)
- 61b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 620:	cd 40                	int    $0x40
- 622:	c3                   	ret    
-
-00000623 <getpid>:
-SYSCALL(getpid)
- 623:	b8 0b 00 00 00       	mov    $0xb,%eax
- 628:	cd 40                	int    $0x40
- 62a:	c3                   	ret    
-
-0000062b <sbrk>:
-SYSCALL(sbrk)
- 62b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 630:	cd 40                	int    $0x40
- 632:	c3                   	ret    
-
-00000633 <sleep>:
-SYSCALL(sleep)
- 633:	b8 0d 00 00 00       	mov    $0xd,%eax
- 638:	cd 40                	int    $0x40
- 63a:	c3                   	ret    
-
-0000063b <uptime>:
-SYSCALL(uptime)
- 63b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 640:	cd 40                	int    $0x40
- 642:	c3                   	ret    
-
-00000643 <getParentID>:
-SYSCALL(getParentID)
- 643:	b8 16 00 00 00       	mov    $0x16,%eax
- 648:	cd 40                	int    $0x40
- 64a:	c3                   	ret    
-
-0000064b <getChildren>:
-SYSCALL(getChildren)
- 64b:	b8 17 00 00 00       	mov    $0x17,%eax
- 650:	cd 40                	int    $0x40
- 652:	c3                   	ret    
-
-00000653 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 653:	b8 18 00 00 00       	mov    $0x18,%eax
- 658:	cd 40                	int    $0x40
- 65a:	c3                   	ret    
-
-0000065b <setPriority>:
-SYSCALL(setPriority)
- 65b:	b8 19 00 00 00       	mov    $0x19,%eax
- 660:	cd 40                	int    $0x40
- 662:	c3                   	ret    
-
-00000663 <changePolicy>:
-SYSCALL(changePolicy)
- 663:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 668:	cd 40                	int    $0x40
- 66a:	c3                   	ret    
-
-0000066b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 66b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 670:	cd 40                	int    $0x40
- 672:	c3                   	ret    
-
-00000673 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 673:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 678:	cd 40                	int    $0x40
- 67a:	c3                   	ret    
-
-0000067b <getCBT>:
-SYSCALL(getCBT)
- 67b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 680:	cd 40                	int    $0x40
- 682:	c3                   	ret    
-
-00000683 <customWait>:
-SYSCALL(customWait)
- 683:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 688:	cd 40                	int    $0x40
- 68a:	c3                   	ret    
-
-0000068b <setQueue>:
-SYSCALL(setQueue)
- 68b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 690:	cd 40                	int    $0x40
- 692:	c3                   	ret    
-
-00000693 <getBurstTime>:
-SYSCALL(getBurstTime)
- 693:	b8 20 00 00 00       	mov    $0x20,%eax
- 698:	cd 40                	int    $0x40
- 69a:	c3                   	ret    
-
-0000069b <getCreationTime>:
- 69b:	b8 21 00 00 00       	mov    $0x21,%eax
- 6a0:	cd 40                	int    $0x40
- 6a2:	c3                   	ret    
- 6a3:	66 90                	xchg   %ax,%ax
- 6a5:	66 90                	xchg   %ax,%ax
- 6a7:	66 90                	xchg   %ax,%ax
- 6a9:	66 90                	xchg   %ax,%ax
- 6ab:	66 90                	xchg   %ax,%ax
- 6ad:	66 90                	xchg   %ax,%ax
- 6af:	90                   	nop
-
-000006b0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 6b0:	55                   	push   %ebp
- 6b1:	89 e5                	mov    %esp,%ebp
- 6b3:	57                   	push   %edi
- 6b4:	56                   	push   %esi
- 6b5:	53                   	push   %ebx
- 6b6:	83 ec 3c             	sub    $0x3c,%esp
- 6b9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 6bc:	89 d1                	mov    %edx,%ecx
-{
- 6be:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 6c1:	85 d2                	test   %edx,%edx
- 6c3:	0f 89 7f 00 00 00    	jns    748 <printint+0x98>
- 6c9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 6cd:	74 79                	je     748 <printint+0x98>
-    neg = 1;
- 6cf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 6d6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 6d8:	31 db                	xor    %ebx,%ebx
- 6da:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 6dd:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 6e0:	89 c8                	mov    %ecx,%eax
- 6e2:	31 d2                	xor    %edx,%edx
- 6e4:	89 cf                	mov    %ecx,%edi
- 6e6:	f7 75 c4             	divl   -0x3c(%ebp)
- 6e9:	0f b6 92 1c 0b 00 00 	movzbl 0xb1c(%edx),%edx
- 6f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 6f3:	89 d8                	mov    %ebx,%eax
- 6f5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 6f8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 6fb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 6fe:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 701:	76 dd                	jbe    6e0 <printint+0x30>
-  if(neg)
- 703:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 706:	85 c9                	test   %ecx,%ecx
- 708:	74 0c                	je     716 <printint+0x66>
-    buf[i++] = '-';
- 70a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 70f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 711:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 716:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 719:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 71d:	eb 07                	jmp    726 <printint+0x76>
- 71f:	90                   	nop
- 720:	0f b6 13             	movzbl (%ebx),%edx
- 723:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 726:	83 ec 04             	sub    $0x4,%esp
- 729:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 72c:	6a 01                	push   $0x1
- 72e:	56                   	push   %esi
- 72f:	57                   	push   %edi
- 730:	e8 8e fe ff ff       	call   5c3 <write>
-  while(--i >= 0)
- 735:	83 c4 10             	add    $0x10,%esp
- 738:	39 de                	cmp    %ebx,%esi
- 73a:	75 e4                	jne    720 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 73c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 73f:	5b                   	pop    %ebx
- 740:	5e                   	pop    %esi
- 741:	5f                   	pop    %edi
- 742:	5d                   	pop    %ebp
- 743:	c3                   	ret    
- 744:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 748:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 74f:	eb 87                	jmp    6d8 <printint+0x28>
- 751:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 758:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 75f:	90                   	nop
-
-00000760 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 760:	f3 0f 1e fb          	endbr32 
- 764:	55                   	push   %ebp
- 765:	89 e5                	mov    %esp,%ebp
- 767:	57                   	push   %edi
- 768:	56                   	push   %esi
- 769:	53                   	push   %ebx
- 76a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 76d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 770:	0f b6 1e             	movzbl (%esi),%ebx
- 773:	84 db                	test   %bl,%bl
- 775:	0f 84 b4 00 00 00    	je     82f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 77b:	8d 45 10             	lea    0x10(%ebp),%eax
- 77e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 781:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 784:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 786:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 789:	eb 33                	jmp    7be <printf+0x5e>
- 78b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 78f:	90                   	nop
- 790:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 793:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 798:	83 f8 25             	cmp    $0x25,%eax
- 79b:	74 17                	je     7b4 <printf+0x54>
-  write(fd, &c, 1);
- 79d:	83 ec 04             	sub    $0x4,%esp
- 7a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 7a3:	6a 01                	push   $0x1
- 7a5:	57                   	push   %edi
- 7a6:	ff 75 08             	pushl  0x8(%ebp)
- 7a9:	e8 15 fe ff ff       	call   5c3 <write>
- 7ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 7b1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 7b4:	0f b6 1e             	movzbl (%esi),%ebx
- 7b7:	83 c6 01             	add    $0x1,%esi
- 7ba:	84 db                	test   %bl,%bl
- 7bc:	74 71                	je     82f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 7be:	0f be cb             	movsbl %bl,%ecx
- 7c1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 7c4:	85 d2                	test   %edx,%edx
- 7c6:	74 c8                	je     790 <printf+0x30>
-      }
-    } else if(state == '%'){
- 7c8:	83 fa 25             	cmp    $0x25,%edx
- 7cb:	75 e7                	jne    7b4 <printf+0x54>
-      if(c == 'd'){
- 7cd:	83 f8 64             	cmp    $0x64,%eax
- 7d0:	0f 84 9a 00 00 00    	je     870 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 7d6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 7dc:	83 f9 70             	cmp    $0x70,%ecx
- 7df:	74 5f                	je     840 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 7e1:	83 f8 73             	cmp    $0x73,%eax
- 7e4:	0f 84 d6 00 00 00    	je     8c0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 7ea:	83 f8 63             	cmp    $0x63,%eax
- 7ed:	0f 84 8d 00 00 00    	je     880 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 7f3:	83 f8 25             	cmp    $0x25,%eax
- 7f6:	0f 84 b4 00 00 00    	je     8b0 <printf+0x150>
-  write(fd, &c, 1);
- 7fc:	83 ec 04             	sub    $0x4,%esp
- 7ff:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 803:	6a 01                	push   $0x1
- 805:	57                   	push   %edi
- 806:	ff 75 08             	pushl  0x8(%ebp)
- 809:	e8 b5 fd ff ff       	call   5c3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 80e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 811:	83 c4 0c             	add    $0xc,%esp
- 814:	6a 01                	push   $0x1
- 816:	83 c6 01             	add    $0x1,%esi
- 819:	57                   	push   %edi
- 81a:	ff 75 08             	pushl  0x8(%ebp)
- 81d:	e8 a1 fd ff ff       	call   5c3 <write>
-  for(i = 0; fmt[i]; i++){
- 822:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 826:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 829:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 82b:	84 db                	test   %bl,%bl
- 82d:	75 8f                	jne    7be <printf+0x5e>
-    }
-  }
-}
- 82f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 832:	5b                   	pop    %ebx
- 833:	5e                   	pop    %esi
- 834:	5f                   	pop    %edi
- 835:	5d                   	pop    %ebp
- 836:	c3                   	ret    
- 837:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 83e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 840:	83 ec 0c             	sub    $0xc,%esp
- 843:	b9 10 00 00 00       	mov    $0x10,%ecx
- 848:	6a 00                	push   $0x0
- 84a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 84d:	8b 45 08             	mov    0x8(%ebp),%eax
- 850:	8b 13                	mov    (%ebx),%edx
- 852:	e8 59 fe ff ff       	call   6b0 <printint>
-        ap++;
- 857:	89 d8                	mov    %ebx,%eax
- 859:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 85c:	31 d2                	xor    %edx,%edx
-        ap++;
- 85e:	83 c0 04             	add    $0x4,%eax
- 861:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 864:	e9 4b ff ff ff       	jmp    7b4 <printf+0x54>
- 869:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 870:	83 ec 0c             	sub    $0xc,%esp
- 873:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 878:	6a 01                	push   $0x1
- 87a:	eb ce                	jmp    84a <printf+0xea>
- 87c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 880:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 883:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 886:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 888:	6a 01                	push   $0x1
-        ap++;
- 88a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 88d:	57                   	push   %edi
- 88e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 891:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 894:	e8 2a fd ff ff       	call   5c3 <write>
-        ap++;
- 899:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 89c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 89f:	31 d2                	xor    %edx,%edx
- 8a1:	e9 0e ff ff ff       	jmp    7b4 <printf+0x54>
- 8a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 8ad:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 8b0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 8b3:	83 ec 04             	sub    $0x4,%esp
- 8b6:	e9 59 ff ff ff       	jmp    814 <printf+0xb4>
- 8bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 8bf:	90                   	nop
-        s = (char*)*ap;
- 8c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 8c3:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 8c5:	83 c0 04             	add    $0x4,%eax
- 8c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 8cb:	85 db                	test   %ebx,%ebx
- 8cd:	74 17                	je     8e6 <printf+0x186>
-        while(*s != 0){
- 8cf:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 8d2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 8d4:	84 c0                	test   %al,%al
- 8d6:	0f 84 d8 fe ff ff    	je     7b4 <printf+0x54>
- 8dc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 8df:	89 de                	mov    %ebx,%esi
- 8e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 8e4:	eb 1a                	jmp    900 <printf+0x1a0>
-          s = "(null)";
- 8e6:	bb 12 0b 00 00       	mov    $0xb12,%ebx
-        while(*s != 0){
- 8eb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 8ee:	b8 28 00 00 00       	mov    $0x28,%eax
- 8f3:	89 de                	mov    %ebx,%esi
- 8f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 8f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 8ff:	90                   	nop
-  write(fd, &c, 1);
- 900:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 903:	83 c6 01             	add    $0x1,%esi
- 906:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 909:	6a 01                	push   $0x1
- 90b:	57                   	push   %edi
- 90c:	53                   	push   %ebx
- 90d:	e8 b1 fc ff ff       	call   5c3 <write>
-        while(*s != 0){
- 912:	0f b6 06             	movzbl (%esi),%eax
- 915:	83 c4 10             	add    $0x10,%esp
- 918:	84 c0                	test   %al,%al
- 91a:	75 e4                	jne    900 <printf+0x1a0>
- 91c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 91f:	31 d2                	xor    %edx,%edx
- 921:	e9 8e fe ff ff       	jmp    7b4 <printf+0x54>
- 926:	66 90                	xchg   %ax,%ax
- 928:	66 90                	xchg   %ax,%ax
- 92a:	66 90                	xchg   %ax,%ax
- 92c:	66 90                	xchg   %ax,%ax
- 92e:	66 90                	xchg   %ax,%ax
-
-00000930 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 930:	f3 0f 1e fb          	endbr32 
- 934:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 935:	a1 54 0e 00 00       	mov    0xe54,%eax
-{
- 93a:	89 e5                	mov    %esp,%ebp
- 93c:	57                   	push   %edi
- 93d:	56                   	push   %esi
- 93e:	53                   	push   %ebx
- 93f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 942:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 944:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 947:	39 c8                	cmp    %ecx,%eax
- 949:	73 15                	jae    960 <free+0x30>
- 94b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 94f:	90                   	nop
- 950:	39 d1                	cmp    %edx,%ecx
- 952:	72 14                	jb     968 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 954:	39 d0                	cmp    %edx,%eax
- 956:	73 10                	jae    968 <free+0x38>
-{
- 958:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 95a:	8b 10                	mov    (%eax),%edx
- 95c:	39 c8                	cmp    %ecx,%eax
- 95e:	72 f0                	jb     950 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 960:	39 d0                	cmp    %edx,%eax
- 962:	72 f4                	jb     958 <free+0x28>
- 964:	39 d1                	cmp    %edx,%ecx
- 966:	73 f0                	jae    958 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 968:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 96b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 96e:	39 fa                	cmp    %edi,%edx
- 970:	74 1e                	je     990 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 972:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 975:	8b 50 04             	mov    0x4(%eax),%edx
- 978:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 97b:	39 f1                	cmp    %esi,%ecx
- 97d:	74 28                	je     9a7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 97f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 981:	5b                   	pop    %ebx
-  freep = p;
- 982:	a3 54 0e 00 00       	mov    %eax,0xe54
-}
- 987:	5e                   	pop    %esi
- 988:	5f                   	pop    %edi
- 989:	5d                   	pop    %ebp
- 98a:	c3                   	ret    
- 98b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 98f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 990:	03 72 04             	add    0x4(%edx),%esi
- 993:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 996:	8b 10                	mov    (%eax),%edx
- 998:	8b 12                	mov    (%edx),%edx
- 99a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 99d:	8b 50 04             	mov    0x4(%eax),%edx
- 9a0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 9a3:	39 f1                	cmp    %esi,%ecx
- 9a5:	75 d8                	jne    97f <free+0x4f>
-    p->s.size += bp->s.size;
- 9a7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 9aa:	a3 54 0e 00 00       	mov    %eax,0xe54
-    p->s.size += bp->s.size;
- 9af:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 9b2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 9b5:	89 10                	mov    %edx,(%eax)
-}
- 9b7:	5b                   	pop    %ebx
- 9b8:	5e                   	pop    %esi
- 9b9:	5f                   	pop    %edi
- 9ba:	5d                   	pop    %ebp
- 9bb:	c3                   	ret    
- 9bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000009c0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 9c0:	f3 0f 1e fb          	endbr32 
- 9c4:	55                   	push   %ebp
- 9c5:	89 e5                	mov    %esp,%ebp
- 9c7:	57                   	push   %edi
- 9c8:	56                   	push   %esi
- 9c9:	53                   	push   %ebx
- 9ca:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 9cd:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 9d0:	8b 3d 54 0e 00 00    	mov    0xe54,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 9d6:	8d 70 07             	lea    0x7(%eax),%esi
- 9d9:	c1 ee 03             	shr    $0x3,%esi
- 9dc:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 9df:	85 ff                	test   %edi,%edi
- 9e1:	0f 84 a9 00 00 00    	je     a90 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 9e7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 9e9:	8b 48 04             	mov    0x4(%eax),%ecx
- 9ec:	39 f1                	cmp    %esi,%ecx
- 9ee:	73 6d                	jae    a5d <malloc+0x9d>
- 9f0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 9f6:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 9fb:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 9fe:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- a05:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- a08:	eb 17                	jmp    a21 <malloc+0x61>
- a0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- a10:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- a12:	8b 4a 04             	mov    0x4(%edx),%ecx
- a15:	39 f1                	cmp    %esi,%ecx
- a17:	73 4f                	jae    a68 <malloc+0xa8>
- a19:	8b 3d 54 0e 00 00    	mov    0xe54,%edi
- a1f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- a21:	39 c7                	cmp    %eax,%edi
- a23:	75 eb                	jne    a10 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- a25:	83 ec 0c             	sub    $0xc,%esp
- a28:	ff 75 e4             	pushl  -0x1c(%ebp)
- a2b:	e8 fb fb ff ff       	call   62b <sbrk>
-  if(p == (char*)-1)
- a30:	83 c4 10             	add    $0x10,%esp
- a33:	83 f8 ff             	cmp    $0xffffffff,%eax
- a36:	74 1b                	je     a53 <malloc+0x93>
-  hp->s.size = nu;
- a38:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- a3b:	83 ec 0c             	sub    $0xc,%esp
- a3e:	83 c0 08             	add    $0x8,%eax
- a41:	50                   	push   %eax
- a42:	e8 e9 fe ff ff       	call   930 <free>
-  return freep;
- a47:	a1 54 0e 00 00       	mov    0xe54,%eax
-      if((p = morecore(nunits)) == 0)
- a4c:	83 c4 10             	add    $0x10,%esp
- a4f:	85 c0                	test   %eax,%eax
- a51:	75 bd                	jne    a10 <malloc+0x50>
-        return 0;
-  }
-}
- a53:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- a56:	31 c0                	xor    %eax,%eax
-}
- a58:	5b                   	pop    %ebx
- a59:	5e                   	pop    %esi
- a5a:	5f                   	pop    %edi
- a5b:	5d                   	pop    %ebp
- a5c:	c3                   	ret    
-    if(p->s.size >= nunits){
- a5d:	89 c2                	mov    %eax,%edx
- a5f:	89 f8                	mov    %edi,%eax
- a61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- a68:	39 ce                	cmp    %ecx,%esi
- a6a:	74 54                	je     ac0 <malloc+0x100>
-        p->s.size -= nunits;
- a6c:	29 f1                	sub    %esi,%ecx
- a6e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- a71:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- a74:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- a77:	a3 54 0e 00 00       	mov    %eax,0xe54
-}
- a7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- a7f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- a82:	5b                   	pop    %ebx
- a83:	5e                   	pop    %esi
- a84:	5f                   	pop    %edi
- a85:	5d                   	pop    %ebp
- a86:	c3                   	ret    
- a87:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- a8e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- a90:	c7 05 54 0e 00 00 58 	movl   $0xe58,0xe54
- a97:	0e 00 00 
-    base.s.size = 0;
- a9a:	bf 58 0e 00 00       	mov    $0xe58,%edi
-    base.s.ptr = freep = prevp = &base;
- a9f:	c7 05 58 0e 00 00 58 	movl   $0xe58,0xe58
- aa6:	0e 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- aa9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- aab:	c7 05 5c 0e 00 00 00 	movl   $0x0,0xe5c
- ab2:	00 00 00 
-    if(p->s.size >= nunits){
- ab5:	e9 36 ff ff ff       	jmp    9f0 <malloc+0x30>
- aba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- ac0:	8b 0a                	mov    (%edx),%ecx
- ac2:	89 08                	mov    %ecx,(%eax)
- ac4:	eb b1                	jmp    a77 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/ls.c b/xv6-public/Operating-System-Project/ls.c
deleted file mode 100644
index 2862913..0000000
--- a/xv6-public/Operating-System-Project/ls.c
+++ /dev/null
@@ -1,85 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-
-char*
-fmtname(char *path)
-{
-  static char buf[DIRSIZ+1];
-  char *p;
-
-  // Find first character after last slash.
-  for(p=path+strlen(path); p >= path && *p != '/'; p--)
-    ;
-  p++;
-
-  // Return blank-padded name.
-  if(strlen(p) >= DIRSIZ)
-    return p;
-  memmove(buf, p, strlen(p));
-  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
-  return buf;
-}
-
-void
-ls(char *path)
-{
-  char buf[512], *p;
-  int fd;
-  struct dirent de;
-  struct stat st;
-
-  if((fd = open(path, 0)) < 0){
-    printf(2, "ls: cannot open %s\n", path);
-    return;
-  }
-
-  if(fstat(fd, &st) < 0){
-    printf(2, "ls: cannot stat %s\n", path);
-    close(fd);
-    return;
-  }
-
-  switch(st.type){
-  case T_FILE:
-    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
-    break;
-
-  case T_DIR:
-    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
-      printf(1, "ls: path too long\n");
-      break;
-    }
-    strcpy(buf, path);
-    p = buf+strlen(buf);
-    *p++ = '/';
-    while(read(fd, &de, sizeof(de)) == sizeof(de)){
-      if(de.inum == 0)
-        continue;
-      memmove(p, de.name, DIRSIZ);
-      p[DIRSIZ] = 0;
-      if(stat(buf, &st) < 0){
-        printf(1, "ls: cannot stat %s\n", buf);
-        continue;
-      }
-      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
-    }
-    break;
-  }
-  close(fd);
-}
-
-int
-main(int argc, char *argv[])
-{
-  int i;
-
-  if(argc < 2){
-    ls(".");
-    exit();
-  }
-  for(i=1; i<argc; i++)
-    ls(argv[i]);
-  exit();
-}
diff --git a/xv6-public/Operating-System-Project/ls.d b/xv6-public/Operating-System-Project/ls.d
deleted file mode 100644
index a55b6d4..0000000
--- a/xv6-public/Operating-System-Project/ls.d
+++ /dev/null
@@ -1 +0,0 @@
-ls.o: ls.c /usr/include/stdc-predef.h types.h stat.h user.h fs.h
diff --git a/xv6-public/Operating-System-Project/ls.o b/xv6-public/Operating-System-Project/ls.o
deleted file mode 100644
index 30bb161..0000000
Binary files a/xv6-public/Operating-System-Project/ls.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/ls.sym b/xv6-public/Operating-System-Project/ls.sym
deleted file mode 100644
index 2ac3850..0000000
--- a/xv6-public/Operating-System-Project/ls.sym
+++ /dev/null
@@ -1,72 +0,0 @@
-00000000 .text
-00000ac8 .rodata
-00000b30 .eh_frame
-00000e44 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 ls.c
-00000e44 buf.1120
-00000000 ulib.c
-00000000 printf.c
-000006b0 printint
-00000b1c digits.1109
-00000000 umalloc.c
-00000e54 freep
-00000e58 base
-00000340 strcpy
-00000060 fmtname
-0000064b getChildren
-00000760 printf
-00000570 memmove
-000005eb mknod
-00000460 gets
-00000623 getpid
-00000683 customWait
-0000067b getCBT
-000009c0 malloc
-00000633 sleep
-000005b3 pipe
-00000663 changePolicy
-000005c3 write
-000005fb fstat
-000005d3 kill
-00000613 chdir
-0000068b setQueue
-000005db exec
-000005ab wait
-000005bb read
-00000693 getBurstTime
-000005f3 unlink
-0000059b fork
-0000066b getTurnAroundTime
-0000062b sbrk
-0000063b uptime
-00000e44 __bss_start
-00000400 memset
-00000000 main
-00000370 strcmp
-0000061b dup
-00000653 getSyscallCounter
-00000643 getParentID
-000004e0 stat
-00000e44 _edata
-00000e60 _end
-00000603 link
-00000100 ls
-000005a3 exit
-0000065b setPriority
-00000530 atoi
-0000069b getCreationTime
-000003c0 strlen
-000005e3 open
-00000420 strchr
-0000060b mkdir
-000005cb close
-00000673 getWaitingTime
-00000930 free
diff --git a/xv6-public/Operating-System-Project/main.c b/xv6-public/Operating-System-Project/main.c
deleted file mode 100644
index 9924e64..0000000
--- a/xv6-public/Operating-System-Project/main.c
+++ /dev/null
@@ -1,116 +0,0 @@
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-
-static void startothers(void);
-static void mpmain(void)  __attribute__((noreturn));
-extern pde_t *kpgdir;
-extern char end[]; // first address after kernel loaded from ELF file
-
-// Bootstrap processor starts running C code here.
-// Allocate a real stack and switch to it, first
-// doing some setup required for memory allocator to work.
-int
-main(void)
-{
-  kinit1(end, P2V(4*1024*1024)); // phys page allocator
-  kvmalloc();      // kernel page table
-  mpinit();        // detect other processors
-  lapicinit();     // interrupt controller
-  seginit();       // segment descriptors
-  picinit();       // disable pic
-  ioapicinit();    // another interrupt controller
-  consoleinit();   // console hardware
-  uartinit();      // serial port
-  pinit();         // process table
-  tvinit();        // trap vectors
-  binit();         // buffer cache
-  fileinit();      // file table
-  ideinit();       // disk 
-  startothers();   // start other processors
-  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
-  userinit();      // first user process
-  mpmain();        // finish this processor's setup
-}
-
-// Other CPUs jump here from entryother.S.
-static void
-mpenter(void)
-{
-  switchkvm();
-  seginit();
-  lapicinit();
-  mpmain();
-}
-
-// Common CPU setup code.
-static void
-mpmain(void)
-{
-  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
-  idtinit();       // load idt register
-  xchg(&(mycpu()->started), 1); // tell startothers() we're up
-  scheduler();     // start running processes
-}
-
-pde_t entrypgdir[];  // For entry.S
-
-// Start the non-boot (AP) processors.
-static void
-startothers(void)
-{
-  extern uchar _binary_entryother_start[], _binary_entryother_size[];
-  uchar *code;
-  struct cpu *c;
-  char *stack;
-
-  // Write entry code to unused memory at 0x7000.
-  // The linker has placed the image of entryother.S in
-  // _binary_entryother_start.
-  code = P2V(0x7000);
-  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
-
-  for(c = cpus; c < cpus+ncpu; c++){
-    if(c == mycpu())  // We've started already.
-      continue;
-
-    // Tell entryother.S what stack to use, where to enter, and what
-    // pgdir to use. We cannot use kpgdir yet, because the AP processor
-    // is running in low  memory, so we use entrypgdir for the APs too.
-    stack = kalloc();
-    *(void**)(code-4) = stack + KSTACKSIZE;
-    *(void(**)(void))(code-8) = mpenter;
-    *(int**)(code-12) = (void *) V2P(entrypgdir);
-
-    lapicstartap(c->apicid, V2P(code));
-
-    // wait for cpu to finish mpmain()
-    while(c->started == 0)
-      ;
-  }
-}
-
-// The boot page table used in entry.S and entryother.S.
-// Page directories (and page tables) must start on page boundaries,
-// hence the __aligned__ attribute.
-// PTE_PS in a page directory entry enables 4Mbyte pages.
-
-__attribute__((__aligned__(PGSIZE)))
-pde_t entrypgdir[NPDENTRIES] = {
-  // Map VA's [0, 4MB) to PA's [0, 4MB)
-  [0] = (0) | PTE_P | PTE_W | PTE_PS,
-  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
-  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
-};
-
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-
diff --git a/xv6-public/Operating-System-Project/main.d b/xv6-public/Operating-System-Project/main.d
deleted file mode 100644
index 354dab4..0000000
--- a/xv6-public/Operating-System-Project/main.d
+++ /dev/null
@@ -1,2 +0,0 @@
-main.o: main.c /usr/include/stdc-predef.h types.h defs.h param.h \
- memlayout.h mmu.h proc.h x86.h
diff --git a/xv6-public/Operating-System-Project/main.o b/xv6-public/Operating-System-Project/main.o
deleted file mode 100644
index a87c73c..0000000
Binary files a/xv6-public/Operating-System-Project/main.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/memide.c b/xv6-public/Operating-System-Project/memide.c
deleted file mode 100644
index ba267ac..0000000
--- a/xv6-public/Operating-System-Project/memide.c
+++ /dev/null
@@ -1,60 +0,0 @@
-// Fake IDE disk; stores blocks in memory.
-// Useful for running kernel without scratch disk.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-#include "traps.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "buf.h"
-
-extern uchar _binary_fs_img_start[], _binary_fs_img_size[];
-
-static int disksize;
-static uchar *memdisk;
-
-void
-ideinit(void)
-{
-  memdisk = _binary_fs_img_start;
-  disksize = (uint)_binary_fs_img_size/BSIZE;
-}
-
-// Interrupt handler.
-void
-ideintr(void)
-{
-  // no-op
-}
-
-// Sync buf with disk.
-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
-// Else if B_VALID is not set, read buf from disk, set B_VALID.
-void
-iderw(struct buf *b)
-{
-  uchar *p;
-
-  if(!holdingsleep(&b->lock))
-    panic("iderw: buf not locked");
-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
-    panic("iderw: nothing to do");
-  if(b->dev != 1)
-    panic("iderw: request not for disk 1");
-  if(b->blockno >= disksize)
-    panic("iderw: block out of range");
-
-  p = memdisk + b->blockno*BSIZE;
-
-  if(b->flags & B_DIRTY){
-    b->flags &= ~B_DIRTY;
-    memmove(p, b->data, BSIZE);
-  } else
-    memmove(b->data, p, BSIZE);
-  b->flags |= B_VALID;
-}
diff --git a/xv6-public/Operating-System-Project/memlayout.h b/xv6-public/Operating-System-Project/memlayout.h
deleted file mode 100644
index d1615f7..0000000
--- a/xv6-public/Operating-System-Project/memlayout.h
+++ /dev/null
@@ -1,15 +0,0 @@
-// Memory layout
-
-#define EXTMEM  0x100000            // Start of extended memory
-#define PHYSTOP 0xE000000           // Top physical memory
-#define DEVSPACE 0xFE000000         // Other devices are at high addresses
-
-// Key addresses for address space layout (see kmap in vm.c for layout)
-#define KERNBASE 0x80000000         // First kernel virtual address
-#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
-
-#define V2P(a) (((uint) (a)) - KERNBASE)
-#define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
-
-#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
-#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
diff --git a/xv6-public/Operating-System-Project/mkdir.asm b/xv6-public/Operating-System-Project/mkdir.asm
deleted file mode 100644
index 4d957cd..0000000
--- a/xv6-public/Operating-System-Project/mkdir.asm
+++ /dev/null
@@ -1,1284 +0,0 @@
-
-_mkdir:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	57                   	push   %edi
-  12:	bf 01 00 00 00       	mov    $0x1,%edi
-  17:	56                   	push   %esi
-  18:	53                   	push   %ebx
-  19:	51                   	push   %ecx
-  1a:	83 ec 08             	sub    $0x8,%esp
-  1d:	8b 59 04             	mov    0x4(%ecx),%ebx
-  20:	8b 31                	mov    (%ecx),%esi
-  22:	83 c3 04             	add    $0x4,%ebx
-  int i;
-
-  if(argc < 2){
-  25:	83 fe 01             	cmp    $0x1,%esi
-  28:	7e 3a                	jle    64 <main+0x64>
-  2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    printf(2, "Usage: mkdir files...\n");
-    exit();
-  }
-
-  for(i = 1; i < argc; i++){
-    if(mkdir(argv[i]) < 0){
-  30:	83 ec 0c             	sub    $0xc,%esp
-  33:	ff 33                	pushl  (%ebx)
-  35:	e8 11 03 00 00       	call   34b <mkdir>
-  3a:	83 c4 10             	add    $0x10,%esp
-  3d:	85 c0                	test   %eax,%eax
-  3f:	78 0f                	js     50 <main+0x50>
-  for(i = 1; i < argc; i++){
-  41:	83 c7 01             	add    $0x1,%edi
-  44:	83 c3 04             	add    $0x4,%ebx
-  47:	39 fe                	cmp    %edi,%esi
-  49:	75 e5                	jne    30 <main+0x30>
-      printf(2, "mkdir: %s failed to create\n", argv[i]);
-      break;
-    }
-  }
-
-  exit();
-  4b:	e8 93 02 00 00       	call   2e3 <exit>
-      printf(2, "mkdir: %s failed to create\n", argv[i]);
-  50:	50                   	push   %eax
-  51:	ff 33                	pushl  (%ebx)
-  53:	68 1f 08 00 00       	push   $0x81f
-  58:	6a 02                	push   $0x2
-  5a:	e8 41 04 00 00       	call   4a0 <printf>
-      break;
-  5f:	83 c4 10             	add    $0x10,%esp
-  62:	eb e7                	jmp    4b <main+0x4b>
-    printf(2, "Usage: mkdir files...\n");
-  64:	52                   	push   %edx
-  65:	52                   	push   %edx
-  66:	68 08 08 00 00       	push   $0x808
-  6b:	6a 02                	push   $0x2
-  6d:	e8 2e 04 00 00       	call   4a0 <printf>
-    exit();
-  72:	e8 6c 02 00 00       	call   2e3 <exit>
-  77:	66 90                	xchg   %ax,%ax
-  79:	66 90                	xchg   %ax,%ax
-  7b:	66 90                	xchg   %ax,%ax
-  7d:	66 90                	xchg   %ax,%ax
-  7f:	90                   	nop
-
-00000080 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  80:	f3 0f 1e fb          	endbr32 
-  84:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  85:	31 c0                	xor    %eax,%eax
-{
-  87:	89 e5                	mov    %esp,%ebp
-  89:	53                   	push   %ebx
-  8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  8d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-  90:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-  94:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-  97:	83 c0 01             	add    $0x1,%eax
-  9a:	84 d2                	test   %dl,%dl
-  9c:	75 f2                	jne    90 <strcpy+0x10>
-    ;
-  return os;
-}
-  9e:	89 c8                	mov    %ecx,%eax
-  a0:	5b                   	pop    %ebx
-  a1:	5d                   	pop    %ebp
-  a2:	c3                   	ret    
-  a3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-000000b0 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-  b0:	f3 0f 1e fb          	endbr32 
-  b4:	55                   	push   %ebp
-  b5:	89 e5                	mov    %esp,%ebp
-  b7:	53                   	push   %ebx
-  b8:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  bb:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-  be:	0f b6 01             	movzbl (%ecx),%eax
-  c1:	0f b6 1a             	movzbl (%edx),%ebx
-  c4:	84 c0                	test   %al,%al
-  c6:	75 19                	jne    e1 <strcmp+0x31>
-  c8:	eb 26                	jmp    f0 <strcmp+0x40>
-  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  d0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-  d4:	83 c1 01             	add    $0x1,%ecx
-  d7:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-  da:	0f b6 1a             	movzbl (%edx),%ebx
-  dd:	84 c0                	test   %al,%al
-  df:	74 0f                	je     f0 <strcmp+0x40>
-  e1:	38 d8                	cmp    %bl,%al
-  e3:	74 eb                	je     d0 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-  e5:	29 d8                	sub    %ebx,%eax
-}
-  e7:	5b                   	pop    %ebx
-  e8:	5d                   	pop    %ebp
-  e9:	c3                   	ret    
-  ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  f0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-  f2:	29 d8                	sub    %ebx,%eax
-}
-  f4:	5b                   	pop    %ebx
-  f5:	5d                   	pop    %ebp
-  f6:	c3                   	ret    
-  f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  fe:	66 90                	xchg   %ax,%ax
-
-00000100 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 100:	f3 0f 1e fb          	endbr32 
- 104:	55                   	push   %ebp
- 105:	89 e5                	mov    %esp,%ebp
- 107:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 10a:	80 3a 00             	cmpb   $0x0,(%edx)
- 10d:	74 21                	je     130 <strlen+0x30>
- 10f:	31 c0                	xor    %eax,%eax
- 111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 118:	83 c0 01             	add    $0x1,%eax
- 11b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 11f:	89 c1                	mov    %eax,%ecx
- 121:	75 f5                	jne    118 <strlen+0x18>
-    ;
-  return n;
-}
- 123:	89 c8                	mov    %ecx,%eax
- 125:	5d                   	pop    %ebp
- 126:	c3                   	ret    
- 127:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 12e:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 130:	31 c9                	xor    %ecx,%ecx
-}
- 132:	5d                   	pop    %ebp
- 133:	89 c8                	mov    %ecx,%eax
- 135:	c3                   	ret    
- 136:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 13d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000140 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 140:	f3 0f 1e fb          	endbr32 
- 144:	55                   	push   %ebp
- 145:	89 e5                	mov    %esp,%ebp
- 147:	57                   	push   %edi
- 148:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 14b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 14e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 151:	89 d7                	mov    %edx,%edi
- 153:	fc                   	cld    
- 154:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 156:	89 d0                	mov    %edx,%eax
- 158:	5f                   	pop    %edi
- 159:	5d                   	pop    %ebp
- 15a:	c3                   	ret    
- 15b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 15f:	90                   	nop
-
-00000160 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 160:	f3 0f 1e fb          	endbr32 
- 164:	55                   	push   %ebp
- 165:	89 e5                	mov    %esp,%ebp
- 167:	8b 45 08             	mov    0x8(%ebp),%eax
- 16a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 16e:	0f b6 10             	movzbl (%eax),%edx
- 171:	84 d2                	test   %dl,%dl
- 173:	75 16                	jne    18b <strchr+0x2b>
- 175:	eb 21                	jmp    198 <strchr+0x38>
- 177:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 17e:	66 90                	xchg   %ax,%ax
- 180:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 184:	83 c0 01             	add    $0x1,%eax
- 187:	84 d2                	test   %dl,%dl
- 189:	74 0d                	je     198 <strchr+0x38>
-    if(*s == c)
- 18b:	38 d1                	cmp    %dl,%cl
- 18d:	75 f1                	jne    180 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 18f:	5d                   	pop    %ebp
- 190:	c3                   	ret    
- 191:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 198:	31 c0                	xor    %eax,%eax
-}
- 19a:	5d                   	pop    %ebp
- 19b:	c3                   	ret    
- 19c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000001a0 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 1a0:	f3 0f 1e fb          	endbr32 
- 1a4:	55                   	push   %ebp
- 1a5:	89 e5                	mov    %esp,%ebp
- 1a7:	57                   	push   %edi
- 1a8:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 1a9:	31 f6                	xor    %esi,%esi
-{
- 1ab:	53                   	push   %ebx
- 1ac:	89 f3                	mov    %esi,%ebx
- 1ae:	83 ec 1c             	sub    $0x1c,%esp
- 1b1:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 1b4:	eb 33                	jmp    1e9 <gets+0x49>
- 1b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1bd:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 1c0:	83 ec 04             	sub    $0x4,%esp
- 1c3:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 1c6:	6a 01                	push   $0x1
- 1c8:	50                   	push   %eax
- 1c9:	6a 00                	push   $0x0
- 1cb:	e8 2b 01 00 00       	call   2fb <read>
-    if(cc < 1)
- 1d0:	83 c4 10             	add    $0x10,%esp
- 1d3:	85 c0                	test   %eax,%eax
- 1d5:	7e 1c                	jle    1f3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 1d7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 1db:	83 c7 01             	add    $0x1,%edi
- 1de:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 1e1:	3c 0a                	cmp    $0xa,%al
- 1e3:	74 23                	je     208 <gets+0x68>
- 1e5:	3c 0d                	cmp    $0xd,%al
- 1e7:	74 1f                	je     208 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 1e9:	83 c3 01             	add    $0x1,%ebx
- 1ec:	89 fe                	mov    %edi,%esi
- 1ee:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 1f1:	7c cd                	jl     1c0 <gets+0x20>
- 1f3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 1f5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 1f8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1fe:	5b                   	pop    %ebx
- 1ff:	5e                   	pop    %esi
- 200:	5f                   	pop    %edi
- 201:	5d                   	pop    %ebp
- 202:	c3                   	ret    
- 203:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 207:	90                   	nop
- 208:	8b 75 08             	mov    0x8(%ebp),%esi
- 20b:	8b 45 08             	mov    0x8(%ebp),%eax
- 20e:	01 de                	add    %ebx,%esi
- 210:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 212:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 215:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 218:	5b                   	pop    %ebx
- 219:	5e                   	pop    %esi
- 21a:	5f                   	pop    %edi
- 21b:	5d                   	pop    %ebp
- 21c:	c3                   	ret    
- 21d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000220 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 220:	f3 0f 1e fb          	endbr32 
- 224:	55                   	push   %ebp
- 225:	89 e5                	mov    %esp,%ebp
- 227:	56                   	push   %esi
- 228:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 229:	83 ec 08             	sub    $0x8,%esp
- 22c:	6a 00                	push   $0x0
- 22e:	ff 75 08             	pushl  0x8(%ebp)
- 231:	e8 ed 00 00 00       	call   323 <open>
-  if(fd < 0)
- 236:	83 c4 10             	add    $0x10,%esp
- 239:	85 c0                	test   %eax,%eax
- 23b:	78 2b                	js     268 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 23d:	83 ec 08             	sub    $0x8,%esp
- 240:	ff 75 0c             	pushl  0xc(%ebp)
- 243:	89 c3                	mov    %eax,%ebx
- 245:	50                   	push   %eax
- 246:	e8 f0 00 00 00       	call   33b <fstat>
-  close(fd);
- 24b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 24e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 250:	e8 b6 00 00 00       	call   30b <close>
-  return r;
- 255:	83 c4 10             	add    $0x10,%esp
-}
- 258:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 25b:	89 f0                	mov    %esi,%eax
- 25d:	5b                   	pop    %ebx
- 25e:	5e                   	pop    %esi
- 25f:	5d                   	pop    %ebp
- 260:	c3                   	ret    
- 261:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 268:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 26d:	eb e9                	jmp    258 <stat+0x38>
- 26f:	90                   	nop
-
-00000270 <atoi>:
-
-int
-atoi(const char *s)
-{
- 270:	f3 0f 1e fb          	endbr32 
- 274:	55                   	push   %ebp
- 275:	89 e5                	mov    %esp,%ebp
- 277:	53                   	push   %ebx
- 278:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 27b:	0f be 02             	movsbl (%edx),%eax
- 27e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 281:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 284:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 289:	77 1a                	ja     2a5 <atoi+0x35>
- 28b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 28f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 290:	83 c2 01             	add    $0x1,%edx
- 293:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 296:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 29a:	0f be 02             	movsbl (%edx),%eax
- 29d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 2a0:	80 fb 09             	cmp    $0x9,%bl
- 2a3:	76 eb                	jbe    290 <atoi+0x20>
-  return n;
-}
- 2a5:	89 c8                	mov    %ecx,%eax
- 2a7:	5b                   	pop    %ebx
- 2a8:	5d                   	pop    %ebp
- 2a9:	c3                   	ret    
- 2aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-000002b0 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 2b0:	f3 0f 1e fb          	endbr32 
- 2b4:	55                   	push   %ebp
- 2b5:	89 e5                	mov    %esp,%ebp
- 2b7:	57                   	push   %edi
- 2b8:	8b 45 10             	mov    0x10(%ebp),%eax
- 2bb:	8b 55 08             	mov    0x8(%ebp),%edx
- 2be:	56                   	push   %esi
- 2bf:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 2c2:	85 c0                	test   %eax,%eax
- 2c4:	7e 0f                	jle    2d5 <memmove+0x25>
- 2c6:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 2c8:	89 d7                	mov    %edx,%edi
- 2ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 2d0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 2d1:	39 f8                	cmp    %edi,%eax
- 2d3:	75 fb                	jne    2d0 <memmove+0x20>
-  return vdst;
-}
- 2d5:	5e                   	pop    %esi
- 2d6:	89 d0                	mov    %edx,%eax
- 2d8:	5f                   	pop    %edi
- 2d9:	5d                   	pop    %ebp
- 2da:	c3                   	ret    
-
-000002db <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 2db:	b8 01 00 00 00       	mov    $0x1,%eax
- 2e0:	cd 40                	int    $0x40
- 2e2:	c3                   	ret    
-
-000002e3 <exit>:
-SYSCALL(exit)
- 2e3:	b8 02 00 00 00       	mov    $0x2,%eax
- 2e8:	cd 40                	int    $0x40
- 2ea:	c3                   	ret    
-
-000002eb <wait>:
-SYSCALL(wait)
- 2eb:	b8 03 00 00 00       	mov    $0x3,%eax
- 2f0:	cd 40                	int    $0x40
- 2f2:	c3                   	ret    
-
-000002f3 <pipe>:
-SYSCALL(pipe)
- 2f3:	b8 04 00 00 00       	mov    $0x4,%eax
- 2f8:	cd 40                	int    $0x40
- 2fa:	c3                   	ret    
-
-000002fb <read>:
-SYSCALL(read)
- 2fb:	b8 05 00 00 00       	mov    $0x5,%eax
- 300:	cd 40                	int    $0x40
- 302:	c3                   	ret    
-
-00000303 <write>:
-SYSCALL(write)
- 303:	b8 10 00 00 00       	mov    $0x10,%eax
- 308:	cd 40                	int    $0x40
- 30a:	c3                   	ret    
-
-0000030b <close>:
-SYSCALL(close)
- 30b:	b8 15 00 00 00       	mov    $0x15,%eax
- 310:	cd 40                	int    $0x40
- 312:	c3                   	ret    
-
-00000313 <kill>:
-SYSCALL(kill)
- 313:	b8 06 00 00 00       	mov    $0x6,%eax
- 318:	cd 40                	int    $0x40
- 31a:	c3                   	ret    
-
-0000031b <exec>:
-SYSCALL(exec)
- 31b:	b8 07 00 00 00       	mov    $0x7,%eax
- 320:	cd 40                	int    $0x40
- 322:	c3                   	ret    
-
-00000323 <open>:
-SYSCALL(open)
- 323:	b8 0f 00 00 00       	mov    $0xf,%eax
- 328:	cd 40                	int    $0x40
- 32a:	c3                   	ret    
-
-0000032b <mknod>:
-SYSCALL(mknod)
- 32b:	b8 11 00 00 00       	mov    $0x11,%eax
- 330:	cd 40                	int    $0x40
- 332:	c3                   	ret    
-
-00000333 <unlink>:
-SYSCALL(unlink)
- 333:	b8 12 00 00 00       	mov    $0x12,%eax
- 338:	cd 40                	int    $0x40
- 33a:	c3                   	ret    
-
-0000033b <fstat>:
-SYSCALL(fstat)
- 33b:	b8 08 00 00 00       	mov    $0x8,%eax
- 340:	cd 40                	int    $0x40
- 342:	c3                   	ret    
-
-00000343 <link>:
-SYSCALL(link)
- 343:	b8 13 00 00 00       	mov    $0x13,%eax
- 348:	cd 40                	int    $0x40
- 34a:	c3                   	ret    
-
-0000034b <mkdir>:
-SYSCALL(mkdir)
- 34b:	b8 14 00 00 00       	mov    $0x14,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <chdir>:
-SYSCALL(chdir)
- 353:	b8 09 00 00 00       	mov    $0x9,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <dup>:
-SYSCALL(dup)
- 35b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <getpid>:
-SYSCALL(getpid)
- 363:	b8 0b 00 00 00       	mov    $0xb,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <sbrk>:
-SYSCALL(sbrk)
- 36b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <sleep>:
-SYSCALL(sleep)
- 373:	b8 0d 00 00 00       	mov    $0xd,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <uptime>:
-SYSCALL(uptime)
- 37b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <getParentID>:
-SYSCALL(getParentID)
- 383:	b8 16 00 00 00       	mov    $0x16,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <getChildren>:
-SYSCALL(getChildren)
- 38b:	b8 17 00 00 00       	mov    $0x17,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 393:	b8 18 00 00 00       	mov    $0x18,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <setPriority>:
-SYSCALL(setPriority)
- 39b:	b8 19 00 00 00       	mov    $0x19,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
-
-000003a3 <changePolicy>:
-SYSCALL(changePolicy)
- 3a3:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 3a8:	cd 40                	int    $0x40
- 3aa:	c3                   	ret    
-
-000003ab <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 3ab:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
-
-000003b3 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 3b3:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 3b8:	cd 40                	int    $0x40
- 3ba:	c3                   	ret    
-
-000003bb <getCBT>:
-SYSCALL(getCBT)
- 3bb:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 3c0:	cd 40                	int    $0x40
- 3c2:	c3                   	ret    
-
-000003c3 <customWait>:
-SYSCALL(customWait)
- 3c3:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 3c8:	cd 40                	int    $0x40
- 3ca:	c3                   	ret    
-
-000003cb <setQueue>:
-SYSCALL(setQueue)
- 3cb:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 3d0:	cd 40                	int    $0x40
- 3d2:	c3                   	ret    
-
-000003d3 <getBurstTime>:
-SYSCALL(getBurstTime)
- 3d3:	b8 20 00 00 00       	mov    $0x20,%eax
- 3d8:	cd 40                	int    $0x40
- 3da:	c3                   	ret    
-
-000003db <getCreationTime>:
- 3db:	b8 21 00 00 00       	mov    $0x21,%eax
- 3e0:	cd 40                	int    $0x40
- 3e2:	c3                   	ret    
- 3e3:	66 90                	xchg   %ax,%ax
- 3e5:	66 90                	xchg   %ax,%ax
- 3e7:	66 90                	xchg   %ax,%ax
- 3e9:	66 90                	xchg   %ax,%ax
- 3eb:	66 90                	xchg   %ax,%ax
- 3ed:	66 90                	xchg   %ax,%ax
- 3ef:	90                   	nop
-
-000003f0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 3f0:	55                   	push   %ebp
- 3f1:	89 e5                	mov    %esp,%ebp
- 3f3:	57                   	push   %edi
- 3f4:	56                   	push   %esi
- 3f5:	53                   	push   %ebx
- 3f6:	83 ec 3c             	sub    $0x3c,%esp
- 3f9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 3fc:	89 d1                	mov    %edx,%ecx
-{
- 3fe:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 401:	85 d2                	test   %edx,%edx
- 403:	0f 89 7f 00 00 00    	jns    488 <printint+0x98>
- 409:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 40d:	74 79                	je     488 <printint+0x98>
-    neg = 1;
- 40f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 416:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 418:	31 db                	xor    %ebx,%ebx
- 41a:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 41d:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 420:	89 c8                	mov    %ecx,%eax
- 422:	31 d2                	xor    %edx,%edx
- 424:	89 cf                	mov    %ecx,%edi
- 426:	f7 75 c4             	divl   -0x3c(%ebp)
- 429:	0f b6 92 44 08 00 00 	movzbl 0x844(%edx),%edx
- 430:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 433:	89 d8                	mov    %ebx,%eax
- 435:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 438:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 43b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 43e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 441:	76 dd                	jbe    420 <printint+0x30>
-  if(neg)
- 443:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 446:	85 c9                	test   %ecx,%ecx
- 448:	74 0c                	je     456 <printint+0x66>
-    buf[i++] = '-';
- 44a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 44f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 451:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 456:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 459:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 45d:	eb 07                	jmp    466 <printint+0x76>
- 45f:	90                   	nop
- 460:	0f b6 13             	movzbl (%ebx),%edx
- 463:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 466:	83 ec 04             	sub    $0x4,%esp
- 469:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 46c:	6a 01                	push   $0x1
- 46e:	56                   	push   %esi
- 46f:	57                   	push   %edi
- 470:	e8 8e fe ff ff       	call   303 <write>
-  while(--i >= 0)
- 475:	83 c4 10             	add    $0x10,%esp
- 478:	39 de                	cmp    %ebx,%esi
- 47a:	75 e4                	jne    460 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 47c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 47f:	5b                   	pop    %ebx
- 480:	5e                   	pop    %esi
- 481:	5f                   	pop    %edi
- 482:	5d                   	pop    %ebp
- 483:	c3                   	ret    
- 484:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 488:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 48f:	eb 87                	jmp    418 <printint+0x28>
- 491:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 498:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 49f:	90                   	nop
-
-000004a0 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 4a0:	f3 0f 1e fb          	endbr32 
- 4a4:	55                   	push   %ebp
- 4a5:	89 e5                	mov    %esp,%ebp
- 4a7:	57                   	push   %edi
- 4a8:	56                   	push   %esi
- 4a9:	53                   	push   %ebx
- 4aa:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 4ad:	8b 75 0c             	mov    0xc(%ebp),%esi
- 4b0:	0f b6 1e             	movzbl (%esi),%ebx
- 4b3:	84 db                	test   %bl,%bl
- 4b5:	0f 84 b4 00 00 00    	je     56f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 4bb:	8d 45 10             	lea    0x10(%ebp),%eax
- 4be:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 4c1:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 4c4:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 4c6:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 4c9:	eb 33                	jmp    4fe <printf+0x5e>
- 4cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 4cf:	90                   	nop
- 4d0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 4d3:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 4d8:	83 f8 25             	cmp    $0x25,%eax
- 4db:	74 17                	je     4f4 <printf+0x54>
-  write(fd, &c, 1);
- 4dd:	83 ec 04             	sub    $0x4,%esp
- 4e0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 4e3:	6a 01                	push   $0x1
- 4e5:	57                   	push   %edi
- 4e6:	ff 75 08             	pushl  0x8(%ebp)
- 4e9:	e8 15 fe ff ff       	call   303 <write>
- 4ee:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 4f1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 4f4:	0f b6 1e             	movzbl (%esi),%ebx
- 4f7:	83 c6 01             	add    $0x1,%esi
- 4fa:	84 db                	test   %bl,%bl
- 4fc:	74 71                	je     56f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 4fe:	0f be cb             	movsbl %bl,%ecx
- 501:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 504:	85 d2                	test   %edx,%edx
- 506:	74 c8                	je     4d0 <printf+0x30>
-      }
-    } else if(state == '%'){
- 508:	83 fa 25             	cmp    $0x25,%edx
- 50b:	75 e7                	jne    4f4 <printf+0x54>
-      if(c == 'd'){
- 50d:	83 f8 64             	cmp    $0x64,%eax
- 510:	0f 84 9a 00 00 00    	je     5b0 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 516:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 51c:	83 f9 70             	cmp    $0x70,%ecx
- 51f:	74 5f                	je     580 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 521:	83 f8 73             	cmp    $0x73,%eax
- 524:	0f 84 d6 00 00 00    	je     600 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 52a:	83 f8 63             	cmp    $0x63,%eax
- 52d:	0f 84 8d 00 00 00    	je     5c0 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 533:	83 f8 25             	cmp    $0x25,%eax
- 536:	0f 84 b4 00 00 00    	je     5f0 <printf+0x150>
-  write(fd, &c, 1);
- 53c:	83 ec 04             	sub    $0x4,%esp
- 53f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 543:	6a 01                	push   $0x1
- 545:	57                   	push   %edi
- 546:	ff 75 08             	pushl  0x8(%ebp)
- 549:	e8 b5 fd ff ff       	call   303 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 54e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 551:	83 c4 0c             	add    $0xc,%esp
- 554:	6a 01                	push   $0x1
- 556:	83 c6 01             	add    $0x1,%esi
- 559:	57                   	push   %edi
- 55a:	ff 75 08             	pushl  0x8(%ebp)
- 55d:	e8 a1 fd ff ff       	call   303 <write>
-  for(i = 0; fmt[i]; i++){
- 562:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 566:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 569:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 56b:	84 db                	test   %bl,%bl
- 56d:	75 8f                	jne    4fe <printf+0x5e>
-    }
-  }
-}
- 56f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 572:	5b                   	pop    %ebx
- 573:	5e                   	pop    %esi
- 574:	5f                   	pop    %edi
- 575:	5d                   	pop    %ebp
- 576:	c3                   	ret    
- 577:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 57e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 580:	83 ec 0c             	sub    $0xc,%esp
- 583:	b9 10 00 00 00       	mov    $0x10,%ecx
- 588:	6a 00                	push   $0x0
- 58a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 58d:	8b 45 08             	mov    0x8(%ebp),%eax
- 590:	8b 13                	mov    (%ebx),%edx
- 592:	e8 59 fe ff ff       	call   3f0 <printint>
-        ap++;
- 597:	89 d8                	mov    %ebx,%eax
- 599:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 59c:	31 d2                	xor    %edx,%edx
-        ap++;
- 59e:	83 c0 04             	add    $0x4,%eax
- 5a1:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 5a4:	e9 4b ff ff ff       	jmp    4f4 <printf+0x54>
- 5a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 5b0:	83 ec 0c             	sub    $0xc,%esp
- 5b3:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 5b8:	6a 01                	push   $0x1
- 5ba:	eb ce                	jmp    58a <printf+0xea>
- 5bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 5c0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 5c3:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 5c6:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 5c8:	6a 01                	push   $0x1
-        ap++;
- 5ca:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 5cd:	57                   	push   %edi
- 5ce:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 5d1:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 5d4:	e8 2a fd ff ff       	call   303 <write>
-        ap++;
- 5d9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 5dc:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 5df:	31 d2                	xor    %edx,%edx
- 5e1:	e9 0e ff ff ff       	jmp    4f4 <printf+0x54>
- 5e6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5ed:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 5f0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5f3:	83 ec 04             	sub    $0x4,%esp
- 5f6:	e9 59 ff ff ff       	jmp    554 <printf+0xb4>
- 5fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 5ff:	90                   	nop
-        s = (char*)*ap;
- 600:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 603:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 605:	83 c0 04             	add    $0x4,%eax
- 608:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 60b:	85 db                	test   %ebx,%ebx
- 60d:	74 17                	je     626 <printf+0x186>
-        while(*s != 0){
- 60f:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 612:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 614:	84 c0                	test   %al,%al
- 616:	0f 84 d8 fe ff ff    	je     4f4 <printf+0x54>
- 61c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 61f:	89 de                	mov    %ebx,%esi
- 621:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 624:	eb 1a                	jmp    640 <printf+0x1a0>
-          s = "(null)";
- 626:	bb 3b 08 00 00       	mov    $0x83b,%ebx
-        while(*s != 0){
- 62b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 62e:	b8 28 00 00 00       	mov    $0x28,%eax
- 633:	89 de                	mov    %ebx,%esi
- 635:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 638:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 63f:	90                   	nop
-  write(fd, &c, 1);
- 640:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 643:	83 c6 01             	add    $0x1,%esi
- 646:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 649:	6a 01                	push   $0x1
- 64b:	57                   	push   %edi
- 64c:	53                   	push   %ebx
- 64d:	e8 b1 fc ff ff       	call   303 <write>
-        while(*s != 0){
- 652:	0f b6 06             	movzbl (%esi),%eax
- 655:	83 c4 10             	add    $0x10,%esp
- 658:	84 c0                	test   %al,%al
- 65a:	75 e4                	jne    640 <printf+0x1a0>
- 65c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 65f:	31 d2                	xor    %edx,%edx
- 661:	e9 8e fe ff ff       	jmp    4f4 <printf+0x54>
- 666:	66 90                	xchg   %ax,%ax
- 668:	66 90                	xchg   %ax,%ax
- 66a:	66 90                	xchg   %ax,%ax
- 66c:	66 90                	xchg   %ax,%ax
- 66e:	66 90                	xchg   %ax,%ax
-
-00000670 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 670:	f3 0f 1e fb          	endbr32 
- 674:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 675:	a1 fc 0a 00 00       	mov    0xafc,%eax
-{
- 67a:	89 e5                	mov    %esp,%ebp
- 67c:	57                   	push   %edi
- 67d:	56                   	push   %esi
- 67e:	53                   	push   %ebx
- 67f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 682:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 684:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 687:	39 c8                	cmp    %ecx,%eax
- 689:	73 15                	jae    6a0 <free+0x30>
- 68b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 68f:	90                   	nop
- 690:	39 d1                	cmp    %edx,%ecx
- 692:	72 14                	jb     6a8 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 694:	39 d0                	cmp    %edx,%eax
- 696:	73 10                	jae    6a8 <free+0x38>
-{
- 698:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 69a:	8b 10                	mov    (%eax),%edx
- 69c:	39 c8                	cmp    %ecx,%eax
- 69e:	72 f0                	jb     690 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 6a0:	39 d0                	cmp    %edx,%eax
- 6a2:	72 f4                	jb     698 <free+0x28>
- 6a4:	39 d1                	cmp    %edx,%ecx
- 6a6:	73 f0                	jae    698 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 6a8:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 6ab:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 6ae:	39 fa                	cmp    %edi,%edx
- 6b0:	74 1e                	je     6d0 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 6b2:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 6b5:	8b 50 04             	mov    0x4(%eax),%edx
- 6b8:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6bb:	39 f1                	cmp    %esi,%ecx
- 6bd:	74 28                	je     6e7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 6bf:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 6c1:	5b                   	pop    %ebx
-  freep = p;
- 6c2:	a3 fc 0a 00 00       	mov    %eax,0xafc
-}
- 6c7:	5e                   	pop    %esi
- 6c8:	5f                   	pop    %edi
- 6c9:	5d                   	pop    %ebp
- 6ca:	c3                   	ret    
- 6cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 6cf:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 6d0:	03 72 04             	add    0x4(%edx),%esi
- 6d3:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 6d6:	8b 10                	mov    (%eax),%edx
- 6d8:	8b 12                	mov    (%edx),%edx
- 6da:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 6dd:	8b 50 04             	mov    0x4(%eax),%edx
- 6e0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6e3:	39 f1                	cmp    %esi,%ecx
- 6e5:	75 d8                	jne    6bf <free+0x4f>
-    p->s.size += bp->s.size;
- 6e7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 6ea:	a3 fc 0a 00 00       	mov    %eax,0xafc
-    p->s.size += bp->s.size;
- 6ef:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 6f2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 6f5:	89 10                	mov    %edx,(%eax)
-}
- 6f7:	5b                   	pop    %ebx
- 6f8:	5e                   	pop    %esi
- 6f9:	5f                   	pop    %edi
- 6fa:	5d                   	pop    %ebp
- 6fb:	c3                   	ret    
- 6fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000700 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 700:	f3 0f 1e fb          	endbr32 
- 704:	55                   	push   %ebp
- 705:	89 e5                	mov    %esp,%ebp
- 707:	57                   	push   %edi
- 708:	56                   	push   %esi
- 709:	53                   	push   %ebx
- 70a:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 70d:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 710:	8b 3d fc 0a 00 00    	mov    0xafc,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 716:	8d 70 07             	lea    0x7(%eax),%esi
- 719:	c1 ee 03             	shr    $0x3,%esi
- 71c:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 71f:	85 ff                	test   %edi,%edi
- 721:	0f 84 a9 00 00 00    	je     7d0 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 727:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 729:	8b 48 04             	mov    0x4(%eax),%ecx
- 72c:	39 f1                	cmp    %esi,%ecx
- 72e:	73 6d                	jae    79d <malloc+0x9d>
- 730:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 736:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 73b:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 73e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 745:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 748:	eb 17                	jmp    761 <malloc+0x61>
- 74a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 750:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 752:	8b 4a 04             	mov    0x4(%edx),%ecx
- 755:	39 f1                	cmp    %esi,%ecx
- 757:	73 4f                	jae    7a8 <malloc+0xa8>
- 759:	8b 3d fc 0a 00 00    	mov    0xafc,%edi
- 75f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 761:	39 c7                	cmp    %eax,%edi
- 763:	75 eb                	jne    750 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 765:	83 ec 0c             	sub    $0xc,%esp
- 768:	ff 75 e4             	pushl  -0x1c(%ebp)
- 76b:	e8 fb fb ff ff       	call   36b <sbrk>
-  if(p == (char*)-1)
- 770:	83 c4 10             	add    $0x10,%esp
- 773:	83 f8 ff             	cmp    $0xffffffff,%eax
- 776:	74 1b                	je     793 <malloc+0x93>
-  hp->s.size = nu;
- 778:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 77b:	83 ec 0c             	sub    $0xc,%esp
- 77e:	83 c0 08             	add    $0x8,%eax
- 781:	50                   	push   %eax
- 782:	e8 e9 fe ff ff       	call   670 <free>
-  return freep;
- 787:	a1 fc 0a 00 00       	mov    0xafc,%eax
-      if((p = morecore(nunits)) == 0)
- 78c:	83 c4 10             	add    $0x10,%esp
- 78f:	85 c0                	test   %eax,%eax
- 791:	75 bd                	jne    750 <malloc+0x50>
-        return 0;
-  }
-}
- 793:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 796:	31 c0                	xor    %eax,%eax
-}
- 798:	5b                   	pop    %ebx
- 799:	5e                   	pop    %esi
- 79a:	5f                   	pop    %edi
- 79b:	5d                   	pop    %ebp
- 79c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 79d:	89 c2                	mov    %eax,%edx
- 79f:	89 f8                	mov    %edi,%eax
- 7a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 7a8:	39 ce                	cmp    %ecx,%esi
- 7aa:	74 54                	je     800 <malloc+0x100>
-        p->s.size -= nunits;
- 7ac:	29 f1                	sub    %esi,%ecx
- 7ae:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 7b1:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 7b4:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 7b7:	a3 fc 0a 00 00       	mov    %eax,0xafc
-}
- 7bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 7bf:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 7c2:	5b                   	pop    %ebx
- 7c3:	5e                   	pop    %esi
- 7c4:	5f                   	pop    %edi
- 7c5:	5d                   	pop    %ebp
- 7c6:	c3                   	ret    
- 7c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 7ce:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 7d0:	c7 05 fc 0a 00 00 00 	movl   $0xb00,0xafc
- 7d7:	0b 00 00 
-    base.s.size = 0;
- 7da:	bf 00 0b 00 00       	mov    $0xb00,%edi
-    base.s.ptr = freep = prevp = &base;
- 7df:	c7 05 00 0b 00 00 00 	movl   $0xb00,0xb00
- 7e6:	0b 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7e9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 7eb:	c7 05 04 0b 00 00 00 	movl   $0x0,0xb04
- 7f2:	00 00 00 
-    if(p->s.size >= nunits){
- 7f5:	e9 36 ff ff ff       	jmp    730 <malloc+0x30>
- 7fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 800:	8b 0a                	mov    (%edx),%ecx
- 802:	89 08                	mov    %ecx,(%eax)
- 804:	eb b1                	jmp    7b7 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/mkdir.c b/xv6-public/Operating-System-Project/mkdir.c
deleted file mode 100644
index 6e4c954..0000000
--- a/xv6-public/Operating-System-Project/mkdir.c
+++ /dev/null
@@ -1,23 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char *argv[])
-{
-  int i;
-
-  if(argc < 2){
-    printf(2, "Usage: mkdir files...\n");
-    exit();
-  }
-
-  for(i = 1; i < argc; i++){
-    if(mkdir(argv[i]) < 0){
-      printf(2, "mkdir: %s failed to create\n", argv[i]);
-      break;
-    }
-  }
-
-  exit();
-}
diff --git a/xv6-public/Operating-System-Project/mkdir.d b/xv6-public/Operating-System-Project/mkdir.d
deleted file mode 100644
index 0c77808..0000000
--- a/xv6-public/Operating-System-Project/mkdir.d
+++ /dev/null
@@ -1 +0,0 @@
-mkdir.o: mkdir.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/mkdir.o b/xv6-public/Operating-System-Project/mkdir.o
deleted file mode 100644
index 9a39486..0000000
Binary files a/xv6-public/Operating-System-Project/mkdir.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/mkdir.sym b/xv6-public/Operating-System-Project/mkdir.sym
deleted file mode 100644
index 7c35710..0000000
--- a/xv6-public/Operating-System-Project/mkdir.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-00000808 .rodata
-00000858 .eh_frame
-00000afc .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 mkdir.c
-00000000 ulib.c
-00000000 printf.c
-000003f0 printint
-00000844 digits.1109
-00000000 umalloc.c
-00000afc freep
-00000b00 base
-00000080 strcpy
-0000038b getChildren
-000004a0 printf
-000002b0 memmove
-0000032b mknod
-000001a0 gets
-00000363 getpid
-000003c3 customWait
-000003bb getCBT
-00000700 malloc
-00000373 sleep
-000002f3 pipe
-000003a3 changePolicy
-00000303 write
-0000033b fstat
-00000313 kill
-00000353 chdir
-000003cb setQueue
-0000031b exec
-000002eb wait
-000002fb read
-000003d3 getBurstTime
-00000333 unlink
-000002db fork
-000003ab getTurnAroundTime
-0000036b sbrk
-0000037b uptime
-00000afc __bss_start
-00000140 memset
-00000000 main
-000000b0 strcmp
-0000035b dup
-00000393 getSyscallCounter
-00000383 getParentID
-00000220 stat
-00000afc _edata
-00000b08 _end
-00000343 link
-000002e3 exit
-0000039b setPriority
-00000270 atoi
-000003db getCreationTime
-00000100 strlen
-00000323 open
-00000160 strchr
-0000034b mkdir
-0000030b close
-000003b3 getWaitingTime
-00000670 free
diff --git a/xv6-public/Operating-System-Project/mkfs b/xv6-public/Operating-System-Project/mkfs
deleted file mode 100644
index 2fe0ef4..0000000
Binary files a/xv6-public/Operating-System-Project/mkfs and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/mkfs.c b/xv6-public/Operating-System-Project/mkfs.c
deleted file mode 100644
index 8e011a7..0000000
--- a/xv6-public/Operating-System-Project/mkfs.c
+++ /dev/null
@@ -1,297 +0,0 @@
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <fcntl.h>
-#include <assert.h>
-
-#define stat xv6_stat  // avoid clash with host struct stat
-#include "types.h"
-#include "fs.h"
-#include "stat.h"
-#include "param.h"
-
-#ifndef static_assert
-#define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
-#endif
-
-#define NINODES 200
-
-// Disk layout:
-// [ boot block | sb block | log | inode blocks | free bit map | data blocks ]
-
-int nbitmap = FSSIZE/(BSIZE*8) + 1;
-int ninodeblocks = NINODES / IPB + 1;
-int nlog = LOGSIZE;
-int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
-int nblocks;  // Number of data blocks
-
-int fsfd;
-struct superblock sb;
-char zeroes[BSIZE];
-uint freeinode = 1;
-uint freeblock;
-
-
-void balloc(int);
-void wsect(uint, void*);
-void winode(uint, struct dinode*);
-void rinode(uint inum, struct dinode *ip);
-void rsect(uint sec, void *buf);
-uint ialloc(ushort type);
-void iappend(uint inum, void *p, int n);
-
-// convert to intel byte order
-ushort
-xshort(ushort x)
-{
-  ushort y;
-  uchar *a = (uchar*)&y;
-  a[0] = x;
-  a[1] = x >> 8;
-  return y;
-}
-
-uint
-xint(uint x)
-{
-  uint y;
-  uchar *a = (uchar*)&y;
-  a[0] = x;
-  a[1] = x >> 8;
-  a[2] = x >> 16;
-  a[3] = x >> 24;
-  return y;
-}
-
-int
-main(int argc, char *argv[])
-{
-  int i, cc, fd;
-  uint rootino, inum, off;
-  struct dirent de;
-  char buf[BSIZE];
-  struct dinode din;
-
-
-  static_assert(sizeof(int) == 4, "Integers must be 4 bytes!");
-
-  if(argc < 2){
-    fprintf(stderr, "Usage: mkfs fs.img files...\n");
-    exit(1);
-  }
-
-  assert((BSIZE % sizeof(struct dinode)) == 0);
-  assert((BSIZE % sizeof(struct dirent)) == 0);
-
-  fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);
-  if(fsfd < 0){
-    perror(argv[1]);
-    exit(1);
-  }
-
-  // 1 fs block = 1 disk sector
-  nmeta = 2 + nlog + ninodeblocks + nbitmap;
-  nblocks = FSSIZE - nmeta;
-
-  sb.size = xint(FSSIZE);
-  sb.nblocks = xint(nblocks);
-  sb.ninodes = xint(NINODES);
-  sb.nlog = xint(nlog);
-  sb.logstart = xint(2);
-  sb.inodestart = xint(2+nlog);
-  sb.bmapstart = xint(2+nlog+ninodeblocks);
-
-  printf("nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks %u) blocks %d total %d\n",
-         nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);
-
-  freeblock = nmeta;     // the first free block that we can allocate
-
-  for(i = 0; i < FSSIZE; i++)
-    wsect(i, zeroes);
-
-  memset(buf, 0, sizeof(buf));
-  memmove(buf, &sb, sizeof(sb));
-  wsect(1, buf);
-
-  rootino = ialloc(T_DIR);
-  assert(rootino == ROOTINO);
-
-  bzero(&de, sizeof(de));
-  de.inum = xshort(rootino);
-  strcpy(de.name, ".");
-  iappend(rootino, &de, sizeof(de));
-
-  bzero(&de, sizeof(de));
-  de.inum = xshort(rootino);
-  strcpy(de.name, "..");
-  iappend(rootino, &de, sizeof(de));
-
-  for(i = 2; i < argc; i++){
-    assert(index(argv[i], '/') == 0);
-
-    if((fd = open(argv[i], 0)) < 0){
-      perror(argv[i]);
-      exit(1);
-    }
-
-    // Skip leading _ in name when writing to file system.
-    // The binaries are named _rm, _cat, etc. to keep the
-    // build operating system from trying to execute them
-    // in place of system binaries like rm and cat.
-    if(argv[i][0] == '_')
-      ++argv[i];
-
-    inum = ialloc(T_FILE);
-
-    bzero(&de, sizeof(de));
-    de.inum = xshort(inum);
-    strncpy(de.name, argv[i], DIRSIZ);
-    iappend(rootino, &de, sizeof(de));
-
-    while((cc = read(fd, buf, sizeof(buf))) > 0)
-      iappend(inum, buf, cc);
-
-    close(fd);
-  }
-
-  // fix size of root inode dir
-  rinode(rootino, &din);
-  off = xint(din.size);
-  off = ((off/BSIZE) + 1) * BSIZE;
-  din.size = xint(off);
-  winode(rootino, &din);
-
-  balloc(freeblock);
-
-  exit(0);
-}
-
-void
-wsect(uint sec, void *buf)
-{
-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
-    perror("lseek");
-    exit(1);
-  }
-  if(write(fsfd, buf, BSIZE) != BSIZE){
-    perror("write");
-    exit(1);
-  }
-}
-
-void
-winode(uint inum, struct dinode *ip)
-{
-  char buf[BSIZE];
-  uint bn;
-  struct dinode *dip;
-
-  bn = IBLOCK(inum, sb);
-  rsect(bn, buf);
-  dip = ((struct dinode*)buf) + (inum % IPB);
-  *dip = *ip;
-  wsect(bn, buf);
-}
-
-void
-rinode(uint inum, struct dinode *ip)
-{
-  char buf[BSIZE];
-  uint bn;
-  struct dinode *dip;
-
-  bn = IBLOCK(inum, sb);
-  rsect(bn, buf);
-  dip = ((struct dinode*)buf) + (inum % IPB);
-  *ip = *dip;
-}
-
-void
-rsect(uint sec, void *buf)
-{
-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
-    perror("lseek");
-    exit(1);
-  }
-  if(read(fsfd, buf, BSIZE) != BSIZE){
-    perror("read");
-    exit(1);
-  }
-}
-
-uint
-ialloc(ushort type)
-{
-  uint inum = freeinode++;
-  struct dinode din;
-
-  bzero(&din, sizeof(din));
-  din.type = xshort(type);
-  din.nlink = xshort(1);
-  din.size = xint(0);
-  winode(inum, &din);
-  return inum;
-}
-
-void
-balloc(int used)
-{
-  uchar buf[BSIZE];
-  int i;
-
-  printf("balloc: first %d blocks have been allocated\n", used);
-  assert(used < BSIZE*8);
-  bzero(buf, BSIZE);
-  for(i = 0; i < used; i++){
-    buf[i/8] = buf[i/8] | (0x1 << (i%8));
-  }
-  printf("balloc: write bitmap block at sector %d\n", sb.bmapstart);
-  wsect(sb.bmapstart, buf);
-}
-
-#define min(a, b) ((a) < (b) ? (a) : (b))
-
-void
-iappend(uint inum, void *xp, int n)
-{
-  char *p = (char*)xp;
-  uint fbn, off, n1;
-  struct dinode din;
-  char buf[BSIZE];
-  uint indirect[NINDIRECT];
-  uint x;
-
-  rinode(inum, &din);
-  off = xint(din.size);
-  // printf("append inum %d at off %d sz %d\n", inum, off, n);
-  while(n > 0){
-    fbn = off / BSIZE;
-    assert(fbn < MAXFILE);
-    if(fbn < NDIRECT){
-      if(xint(din.addrs[fbn]) == 0){
-        din.addrs[fbn] = xint(freeblock++);
-      }
-      x = xint(din.addrs[fbn]);
-    } else {
-      if(xint(din.addrs[NDIRECT]) == 0){
-        din.addrs[NDIRECT] = xint(freeblock++);
-      }
-      rsect(xint(din.addrs[NDIRECT]), (char*)indirect);
-      if(indirect[fbn - NDIRECT] == 0){
-        indirect[fbn - NDIRECT] = xint(freeblock++);
-        wsect(xint(din.addrs[NDIRECT]), (char*)indirect);
-      }
-      x = xint(indirect[fbn-NDIRECT]);
-    }
-    n1 = min(n, (fbn + 1) * BSIZE - off);
-    rsect(x, buf);
-    bcopy(p, buf + off - (fbn * BSIZE), n1);
-    wsect(x, buf);
-    n -= n1;
-    off += n1;
-    p += n1;
-  }
-  din.size = xint(off);
-  winode(inum, &din);
-}
diff --git a/xv6-public/Operating-System-Project/mmu.h b/xv6-public/Operating-System-Project/mmu.h
deleted file mode 100644
index a82d8e2..0000000
--- a/xv6-public/Operating-System-Project/mmu.h
+++ /dev/null
@@ -1,181 +0,0 @@
-// This file contains definitions for the
-// x86 memory management unit (MMU).
-
-// Eflags register
-#define FL_IF           0x00000200      // Interrupt Enable
-
-// Control Register flags
-#define CR0_PE          0x00000001      // Protection Enable
-#define CR0_WP          0x00010000      // Write Protect
-#define CR0_PG          0x80000000      // Paging
-
-#define CR4_PSE         0x00000010      // Page size extension
-
-// various segment selectors.
-#define SEG_KCODE 1  // kernel code
-#define SEG_KDATA 2  // kernel data+stack
-#define SEG_UCODE 3  // user code
-#define SEG_UDATA 4  // user data+stack
-#define SEG_TSS   5  // this process's task state
-
-// cpu->gdt[NSEGS] holds the above segments.
-#define NSEGS     6
-
-#ifndef __ASSEMBLER__
-// Segment Descriptor
-struct segdesc {
-  uint lim_15_0 : 16;  // Low bits of segment limit
-  uint base_15_0 : 16; // Low bits of segment base address
-  uint base_23_16 : 8; // Middle bits of segment base address
-  uint type : 4;       // Segment type (see STS_ constants)
-  uint s : 1;          // 0 = system, 1 = application
-  uint dpl : 2;        // Descriptor Privilege Level
-  uint p : 1;          // Present
-  uint lim_19_16 : 4;  // High bits of segment limit
-  uint avl : 1;        // Unused (available for software use)
-  uint rsv1 : 1;       // Reserved
-  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
-  uint g : 1;          // Granularity: limit scaled by 4K when set
-  uint base_31_24 : 8; // High bits of segment base address
-};
-
-// Normal segment
-#define SEG(type, base, lim, dpl) (struct segdesc)    \
-{ ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
-  (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
-#define SEG16(type, base, lim, dpl) (struct segdesc)  \
-{ (lim) & 0xffff, (uint)(base) & 0xffff,              \
-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
-  (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
-#endif
-
-#define DPL_USER    0x3     // User DPL
-
-// Application segment type bits
-#define STA_X       0x8     // Executable segment
-#define STA_W       0x2     // Writeable (non-executable segments)
-#define STA_R       0x2     // Readable (executable segments)
-
-// System segment type bits
-#define STS_T32A    0x9     // Available 32-bit TSS
-#define STS_IG32    0xE     // 32-bit Interrupt Gate
-#define STS_TG32    0xF     // 32-bit Trap Gate
-
-// A virtual address 'la' has a three-part structure as follows:
-//
-// +--------10------+-------10-------+---------12----------+
-// | Page Directory |   Page Table   | Offset within Page  |
-// |      Index     |      Index     |                     |
-// +----------------+----------------+---------------------+
-//  \--- PDX(va) --/ \--- PTX(va) --/
-
-// page directory index
-#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
-
-// page table index
-#define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
-
-// construct virtual address from indexes and offset
-#define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
-
-// Page directory and page table constants.
-#define NPDENTRIES      1024    // # directory entries per page directory
-#define NPTENTRIES      1024    // # PTEs per page table
-#define PGSIZE          4096    // bytes mapped by a page
-
-#define PTXSHIFT        12      // offset of PTX in a linear address
-#define PDXSHIFT        22      // offset of PDX in a linear address
-
-#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
-#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
-
-// Page table/directory entry flags.
-#define PTE_P           0x001   // Present
-#define PTE_W           0x002   // Writeable
-#define PTE_U           0x004   // User
-#define PTE_PS          0x080   // Page Size
-
-// Address in page table or page directory entry
-#define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
-#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
-
-#ifndef __ASSEMBLER__
-typedef uint pte_t;
-
-// Task state segment format
-struct taskstate {
-  uint link;         // Old ts selector
-  uint esp0;         // Stack pointers and segment selectors
-  ushort ss0;        //   after an increase in privilege level
-  ushort padding1;
-  uint *esp1;
-  ushort ss1;
-  ushort padding2;
-  uint *esp2;
-  ushort ss2;
-  ushort padding3;
-  void *cr3;         // Page directory base
-  uint *eip;         // Saved state from last task switch
-  uint eflags;
-  uint eax;          // More saved state (registers)
-  uint ecx;
-  uint edx;
-  uint ebx;
-  uint *esp;
-  uint *ebp;
-  uint esi;
-  uint edi;
-  ushort es;         // Even more saved state (segment selectors)
-  ushort padding4;
-  ushort cs;
-  ushort padding5;
-  ushort ss;
-  ushort padding6;
-  ushort ds;
-  ushort padding7;
-  ushort fs;
-  ushort padding8;
-  ushort gs;
-  ushort padding9;
-  ushort ldt;
-  ushort padding10;
-  ushort t;          // Trap on task switch
-  ushort iomb;       // I/O map base address
-};
-
-// Gate descriptors for interrupts and traps
-struct gatedesc {
-  uint off_15_0 : 16;   // low 16 bits of offset in segment
-  uint cs : 16;         // code segment selector
-  uint args : 5;        // # args, 0 for interrupt/trap gates
-  uint rsv1 : 3;        // reserved(should be zero I guess)
-  uint type : 4;        // type(STS_{IG32,TG32})
-  uint s : 1;           // must be 0 (system)
-  uint dpl : 2;         // descriptor(meaning new) privilege level
-  uint p : 1;           // Present
-  uint off_31_16 : 16;  // high bits of offset in segment
-};
-
-// Set up a normal interrupt/trap gate descriptor.
-// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
-//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
-// - sel: Code segment selector for interrupt/trap handler
-// - off: Offset in code segment for interrupt/trap handler
-// - dpl: Descriptor Privilege Level -
-//        the privilege level required for software to invoke
-//        this interrupt/trap gate explicitly using an int instruction.
-#define SETGATE(gate, istrap, sel, off, d)                \
-{                                                         \
-  (gate).off_15_0 = (uint)(off) & 0xffff;                \
-  (gate).cs = (sel);                                      \
-  (gate).args = 0;                                        \
-  (gate).rsv1 = 0;                                        \
-  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
-  (gate).s = 0;                                           \
-  (gate).dpl = (d);                                       \
-  (gate).p = 1;                                           \
-  (gate).off_31_16 = (uint)(off) >> 16;                  \
-}
-
-#endif
diff --git a/xv6-public/Operating-System-Project/mp.c b/xv6-public/Operating-System-Project/mp.c
deleted file mode 100644
index 79bb0ad..0000000
--- a/xv6-public/Operating-System-Project/mp.c
+++ /dev/null
@@ -1,139 +0,0 @@
-// Multiprocessor support
-// Search memory for MP description structures.
-// http://developer.intel.com/design/pentium/datashts/24201606.pdf
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mp.h"
-#include "x86.h"
-#include "mmu.h"
-#include "proc.h"
-
-struct cpu cpus[NCPU];
-int ncpu;
-uchar ioapicid;
-
-static uchar
-sum(uchar *addr, int len)
-{
-  int i, sum;
-
-  sum = 0;
-  for(i=0; i<len; i++)
-    sum += addr[i];
-  return sum;
-}
-
-// Look for an MP structure in the len bytes at addr.
-static struct mp*
-mpsearch1(uint a, int len)
-{
-  uchar *e, *p, *addr;
-
-  addr = P2V(a);
-  e = addr+len;
-  for(p = addr; p < e; p += sizeof(struct mp))
-    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
-      return (struct mp*)p;
-  return 0;
-}
-
-// Search for the MP Floating Pointer Structure, which according to the
-// spec is in one of the following three locations:
-// 1) in the first KB of the EBDA;
-// 2) in the last KB of system base memory;
-// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
-static struct mp*
-mpsearch(void)
-{
-  uchar *bda;
-  uint p;
-  struct mp *mp;
-
-  bda = (uchar *) P2V(0x400);
-  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
-    if((mp = mpsearch1(p, 1024)))
-      return mp;
-  } else {
-    p = ((bda[0x14]<<8)|bda[0x13])*1024;
-    if((mp = mpsearch1(p-1024, 1024)))
-      return mp;
-  }
-  return mpsearch1(0xF0000, 0x10000);
-}
-
-// Search for an MP configuration table.  For now,
-// don't accept the default configurations (physaddr == 0).
-// Check for correct signature, calculate the checksum and,
-// if correct, check the version.
-// To do: check extended table checksum.
-static struct mpconf*
-mpconfig(struct mp **pmp)
-{
-  struct mpconf *conf;
-  struct mp *mp;
-
-  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
-    return 0;
-  conf = (struct mpconf*) P2V((uint) mp->physaddr);
-  if(memcmp(conf, "PCMP", 4) != 0)
-    return 0;
-  if(conf->version != 1 && conf->version != 4)
-    return 0;
-  if(sum((uchar*)conf, conf->length) != 0)
-    return 0;
-  *pmp = mp;
-  return conf;
-}
-
-void
-mpinit(void)
-{
-  uchar *p, *e;
-  int ismp;
-  struct mp *mp;
-  struct mpconf *conf;
-  struct mpproc *proc;
-  struct mpioapic *ioapic;
-
-  if((conf = mpconfig(&mp)) == 0)
-    panic("Expect to run on an SMP");
-  ismp = 1;
-  lapic = (uint*)conf->lapicaddr;
-  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
-    switch(*p){
-    case MPPROC:
-      proc = (struct mpproc*)p;
-      if(ncpu < NCPU) {
-        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
-        ncpu++;
-      }
-      p += sizeof(struct mpproc);
-      continue;
-    case MPIOAPIC:
-      ioapic = (struct mpioapic*)p;
-      ioapicid = ioapic->apicno;
-      p += sizeof(struct mpioapic);
-      continue;
-    case MPBUS:
-    case MPIOINTR:
-    case MPLINTR:
-      p += 8;
-      continue;
-    default:
-      ismp = 0;
-      break;
-    }
-  }
-  if(!ismp)
-    panic("Didn't find a suitable machine");
-
-  if(mp->imcrp){
-    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
-    // But it would on real hardware.
-    outb(0x22, 0x70);   // Select IMCR
-    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
-  }
-}
diff --git a/xv6-public/Operating-System-Project/mp.d b/xv6-public/Operating-System-Project/mp.d
deleted file mode 100644
index 0714441..0000000
--- a/xv6-public/Operating-System-Project/mp.d
+++ /dev/null
@@ -1,2 +0,0 @@
-mp.o: mp.c /usr/include/stdc-predef.h types.h defs.h param.h memlayout.h \
- mp.h x86.h mmu.h proc.h
diff --git a/xv6-public/Operating-System-Project/mp.h b/xv6-public/Operating-System-Project/mp.h
deleted file mode 100644
index 4d17283..0000000
--- a/xv6-public/Operating-System-Project/mp.h
+++ /dev/null
@@ -1,56 +0,0 @@
-// See MultiProcessor Specification Version 1.[14]
-
-struct mp {             // floating pointer
-  uchar signature[4];           // "_MP_"
-  void *physaddr;               // phys addr of MP config table
-  uchar length;                 // 1
-  uchar specrev;                // [14]
-  uchar checksum;               // all bytes must add up to 0
-  uchar type;                   // MP system config type
-  uchar imcrp;
-  uchar reserved[3];
-};
-
-struct mpconf {         // configuration table header
-  uchar signature[4];           // "PCMP"
-  ushort length;                // total table length
-  uchar version;                // [14]
-  uchar checksum;               // all bytes must add up to 0
-  uchar product[20];            // product id
-  uint *oemtable;               // OEM table pointer
-  ushort oemlength;             // OEM table length
-  ushort entry;                 // entry count
-  uint *lapicaddr;              // address of local APIC
-  ushort xlength;               // extended table length
-  uchar xchecksum;              // extended table checksum
-  uchar reserved;
-};
-
-struct mpproc {         // processor table entry
-  uchar type;                   // entry type (0)
-  uchar apicid;                 // local APIC id
-  uchar version;                // local APIC verison
-  uchar flags;                  // CPU flags
-    #define MPBOOT 0x02           // This proc is the bootstrap processor.
-  uchar signature[4];           // CPU signature
-  uint feature;                 // feature flags from CPUID instruction
-  uchar reserved[8];
-};
-
-struct mpioapic {       // I/O APIC table entry
-  uchar type;                   // entry type (2)
-  uchar apicno;                 // I/O APIC id
-  uchar version;                // I/O APIC version
-  uchar flags;                  // I/O APIC flags
-  uint *addr;                  // I/O APIC address
-};
-
-// Table entry types
-#define MPPROC    0x00  // One per processor
-#define MPBUS     0x01  // One per bus
-#define MPIOAPIC  0x02  // One per I/O APIC
-#define MPIOINTR  0x03  // One per bus interrupt source
-#define MPLINTR   0x04  // One per system interrupt source
-
-//PAGEBREAK!
-// Blank page.
diff --git a/xv6-public/Operating-System-Project/mp.o b/xv6-public/Operating-System-Project/mp.o
deleted file mode 100644
index 183e934..0000000
Binary files a/xv6-public/Operating-System-Project/mp.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/multiLayeredQueuedTest.asm b/xv6-public/Operating-System-Project/multiLayeredQueuedTest.asm
deleted file mode 100644
index 9f9f3db..0000000
--- a/xv6-public/Operating-System-Project/multiLayeredQueuedTest.asm
+++ /dev/null
@@ -1,1575 +0,0 @@
-
-_multiLayeredQueuedTest:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-
-// number of children created
-#define NUM_CHILDREN 40
-
-int main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	57                   	push   %edi
-  12:	56                   	push   %esi
-  13:	53                   	push   %ebx
-  14:	51                   	push   %ecx
-  15:	81 ec d4 02 00 00    	sub    $0x2d4,%esp
-
-    int result = changePolicy(4);
-  1b:	6a 04                	push   $0x4
-  1d:	e8 31 06 00 00       	call   653 <changePolicy>
-    if (result == 4)
-  22:	83 c4 10             	add    $0x10,%esp
-  25:	83 f8 04             	cmp    $0x4,%eax
-  28:	0f 84 cc 00 00 00    	je     fa <main+0xfa>
-    {
-        printf(1, "Policy changed successfully!\n");
-    }
-    else
-    {
-        printf(1, "Policy change failed!\n");
-  2e:	50                   	push   %eax
-  2f:	50                   	push   %eax
-  30:	68 d6 0a 00 00       	push   $0xad6
-  35:	6a 01                	push   $0x1
-  37:	e8 14 07 00 00       	call   750 <printf>
-  3c:	83 c4 10             	add    $0x10,%esp
-    }
-
-    int original_pid = getpid();
-  3f:	e8 cf 05 00 00       	call   613 <getpid>
-    int child_num = -1;
-
-    for (int i = 0; i < NUM_CHILDREN; i++)
-  44:	31 f6                	xor    %esi,%esi
-    int original_pid = getpid();
-  46:	89 c3                	mov    %eax,%ebx
-    for (int i = 0; i < NUM_CHILDREN; i++)
-  48:	eb 0f                	jmp    59 <main+0x59>
-  4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  50:	83 fe 28             	cmp    $0x28,%esi
-  53:	0f 84 b7 00 00 00    	je     110 <main+0x110>
-    {
-        if (fork() == 0) // Child
-  59:	e8 2d 05 00 00       	call   58b <fork>
-  5e:	89 f7                	mov    %esi,%edi
-  60:	83 c6 01             	add    $0x1,%esi
-  63:	85 c0                	test   %eax,%eax
-  65:	75 e9                	jne    50 <main+0x50>
-        {
-            setQueue((i / 10) + 1);
-  67:	89 f8                	mov    %edi,%eax
-  69:	ba 67 66 66 66       	mov    $0x66666667,%edx
-  6e:	83 ec 0c             	sub    $0xc,%esp
-  71:	f7 ea                	imul   %edx
-  73:	89 f8                	mov    %edi,%eax
-  75:	c1 f8 1f             	sar    $0x1f,%eax
-  78:	c1 fa 02             	sar    $0x2,%edx
-  7b:	29 c2                	sub    %eax,%edx
-  7d:	8d 42 01             	lea    0x1(%edx),%eax
-  80:	50                   	push   %eax
-  81:	e8 f5 05 00 00       	call   67b <setQueue>
-            if (i > 9 && i < 20)
-  86:	8d 47 f6             	lea    -0xa(%edi),%eax
-  89:	83 c4 10             	add    $0x10,%esp
-  8c:	83 f8 09             	cmp    $0x9,%eax
-  8f:	76 4e                	jbe    df <main+0xdf>
-            {
-                setPriority(i % 6 + 1);
-            }
-            else if (i > 20 && i < 30)
-  91:	8d 47 eb             	lea    -0x15(%edi),%eax
-  94:	83 f8 08             	cmp    $0x8,%eax
-  97:	76 46                	jbe    df <main+0xdf>
-            child_num = i + 1;
-            break;
-        }
-    }
-
-    if (getpid() != original_pid)
-  99:	e8 75 05 00 00       	call   613 <getpid>
-  9e:	39 d8                	cmp    %ebx,%eax
-  a0:	74 73                	je     115 <main+0x115>
-    {
-        for (int i = 1; i <= 50; i++)
-  a2:	bb 01 00 00 00       	mov    $0x1,%ebx
-  a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  ae:	66 90                	xchg   %ax,%ax
-            printf(1, "/%d/: /%d/\n", child_num, i);
-  b0:	53                   	push   %ebx
-        for (int i = 1; i <= 50; i++)
-  b1:	83 c3 01             	add    $0x1,%ebx
-            printf(1, "/%d/: /%d/\n", child_num, i);
-  b4:	56                   	push   %esi
-  b5:	68 ed 0a 00 00       	push   $0xaed
-  ba:	6a 01                	push   $0x1
-  bc:	e8 8f 06 00 00       	call   750 <printf>
-        for (int i = 1; i <= 50; i++)
-  c1:	83 c4 10             	add    $0x10,%esp
-  c4:	83 fb 33             	cmp    $0x33,%ebx
-  c7:	75 e7                	jne    b0 <main+0xb0>
-  c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-               turnaroundsSum / NUM_CHILDREN,
-               waitingsSum / NUM_CHILDREN,
-               CBTsSum / NUM_CHILDREN);
-    }
-
-    while (wait() != -1)
-  d0:	e8 c6 04 00 00       	call   59b <wait>
-  d5:	83 f8 ff             	cmp    $0xffffffff,%eax
-  d8:	75 f6                	jne    d0 <main+0xd0>
-        ;
-
-    exit();
-  da:	e8 b4 04 00 00       	call   593 <exit>
-                setPriority(i % 6 + 1);
-  df:	89 f8                	mov    %edi,%eax
-  e1:	b9 06 00 00 00       	mov    $0x6,%ecx
-  e6:	83 ec 0c             	sub    $0xc,%esp
-  e9:	99                   	cltd   
-  ea:	f7 f9                	idiv   %ecx
-  ec:	83 c2 01             	add    $0x1,%edx
-  ef:	52                   	push   %edx
-  f0:	e8 56 05 00 00       	call   64b <setPriority>
-  f5:	83 c4 10             	add    $0x10,%esp
-            break;
-  f8:	eb 9f                	jmp    99 <main+0x99>
-        printf(1, "Policy changed successfully!\n");
-  fa:	50                   	push   %eax
-  fb:	50                   	push   %eax
-  fc:	68 b8 0a 00 00       	push   $0xab8
- 101:	6a 01                	push   $0x1
- 103:	e8 48 06 00 00       	call   750 <printf>
- 108:	83 c4 10             	add    $0x10,%esp
- 10b:	e9 2f ff ff ff       	jmp    3f <main+0x3f>
-    int child_num = -1;
- 110:	83 ce ff             	or     $0xffffffff,%esi
- 113:	eb 84                	jmp    99 <main+0x99>
-        int queues[NUM_CHILDREN] = {0};      // priorites for each child
- 115:	8d b5 68 fd ff ff    	lea    -0x298(%ebp),%esi
- 11b:	31 c0                	xor    %eax,%eax
- 11d:	b9 28 00 00 00       	mov    $0x28,%ecx
- 122:	89 f7                	mov    %esi,%edi
-        int turnarounds[NUM_CHILDREN] = {0}; // turnaround times for each child
- 124:	8d 9d 08 fe ff ff    	lea    -0x1f8(%ebp),%ebx
-        int queues[NUM_CHILDREN] = {0};      // priorites for each child
- 12a:	f3 ab                	rep stos %eax,%es:(%edi)
-        int turnarounds[NUM_CHILDREN] = {0}; // turnaround times for each child
- 12c:	b9 28 00 00 00       	mov    $0x28,%ecx
- 131:	89 df                	mov    %ebx,%edi
- 133:	f3 ab                	rep stos %eax,%es:(%edi)
-        int waitings[NUM_CHILDREN] = {0};    // waiting times for each child
- 135:	b9 28 00 00 00       	mov    $0x28,%ecx
- 13a:	8d bd a8 fe ff ff    	lea    -0x158(%ebp),%edi
- 140:	f3 ab                	rep stos %eax,%es:(%edi)
-        int CBTs[NUM_CHILDREN] = {0};        // CBTs for each child
- 142:	b9 28 00 00 00       	mov    $0x28,%ecx
- 147:	8d bd 48 ff ff ff    	lea    -0xb8(%ebp),%edi
- 14d:	f3 ab                	rep stos %eax,%es:(%edi)
-        printf(1, "\n\n\n*****Times for each child*****\n");
- 14f:	57                   	push   %edi
- 150:	57                   	push   %edi
-        int i = 0;
- 151:	31 ff                	xor    %edi,%edi
-        printf(1, "\n\n\n*****Times for each child*****\n");
- 153:	68 fc 0a 00 00       	push   $0xafc
- 158:	6a 01                	push   $0x1
- 15a:	e8 f1 05 00 00       	call   750 <printf>
-        int *procTimes = malloc(5 * sizeof(int));
- 15f:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
- 166:	e8 45 08 00 00       	call   9b0 <malloc>
-        while (customWait(procTimes) > 0)
- 16b:	83 c4 10             	add    $0x10,%esp
-        int *procTimes = malloc(5 * sizeof(int));
- 16e:	89 c2                	mov    %eax,%edx
-        while (customWait(procTimes) > 0)
- 170:	eb 28                	jmp    19a <main+0x19a>
- 172:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-            int childTurnaround = procTimes[0];
- 178:	8b 02                	mov    (%edx),%eax
-            queues[i] = childQueue;
- 17a:	8b 4a 0c             	mov    0xc(%edx),%ecx
-            turnarounds[i] = childTurnaround;
- 17d:	89 04 bb             	mov    %eax,(%ebx,%edi,4)
-            waitings[i] = childWaiting;
- 180:	8b 42 04             	mov    0x4(%edx),%eax
-            queues[i] = childQueue;
- 183:	89 0c be             	mov    %ecx,(%esi,%edi,4)
-            waitings[i] = childWaiting;
- 186:	89 84 bd a8 fe ff ff 	mov    %eax,-0x158(%ebp,%edi,4)
-            CBTs[i] = childCBT;
- 18d:	8b 42 08             	mov    0x8(%edx),%eax
- 190:	89 84 bd 48 ff ff ff 	mov    %eax,-0xb8(%ebp,%edi,4)
-            i++;
- 197:	83 c7 01             	add    $0x1,%edi
-        while (customWait(procTimes) > 0)
- 19a:	83 ec 0c             	sub    $0xc,%esp
- 19d:	89 95 34 fd ff ff    	mov    %edx,-0x2cc(%ebp)
- 1a3:	52                   	push   %edx
- 1a4:	e8 ca 04 00 00       	call   673 <customWait>
- 1a9:	83 c4 10             	add    $0x10,%esp
- 1ac:	8b 95 34 fd ff ff    	mov    -0x2cc(%ebp),%edx
- 1b2:	85 c0                	test   %eax,%eax
- 1b4:	7f c2                	jg     178 <main+0x178>
-        printf(1, "\n\n\n*****Times for each child*****\n");
- 1b6:	51                   	push   %ecx
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 1b7:	31 ff                	xor    %edi,%edi
-        printf(1, "\n\n\n*****Times for each child*****\n");
- 1b9:	51                   	push   %ecx
- 1ba:	68 fc 0a 00 00       	push   $0xafc
- 1bf:	6a 01                	push   $0x1
- 1c1:	e8 8a 05 00 00       	call   750 <printf>
- 1c6:	83 c4 10             	add    $0x10,%esp
- 1c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-            printf(1, "Child with priority %d -> Turnaround: %d, Waiting: %d, CBT: %d\n",
- 1d0:	83 ec 08             	sub    $0x8,%esp
- 1d3:	ff b4 bd 48 ff ff ff 	pushl  -0xb8(%ebp,%edi,4)
- 1da:	ff b4 bd a8 fe ff ff 	pushl  -0x158(%ebp,%edi,4)
- 1e1:	ff 34 bb             	pushl  (%ebx,%edi,4)
- 1e4:	ff 34 be             	pushl  (%esi,%edi,4)
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 1e7:	83 c7 01             	add    $0x1,%edi
-            printf(1, "Child with priority %d -> Turnaround: %d, Waiting: %d, CBT: %d\n",
- 1ea:	68 20 0b 00 00       	push   $0xb20
- 1ef:	6a 01                	push   $0x1
- 1f1:	e8 5a 05 00 00       	call   750 <printf>
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 1f6:	83 c4 20             	add    $0x20,%esp
- 1f9:	83 ff 28             	cmp    $0x28,%edi
- 1fc:	75 d2                	jne    1d0 <main+0x1d0>
-        printf(1, "\n\n\n*****AVG Times for each queue*****\n");
- 1fe:	52                   	push   %edx
-        int turnaroundsPerQueue[4] = {0};
- 1ff:	8d bd 38 fd ff ff    	lea    -0x2c8(%ebp),%edi
-        printf(1, "\n\n\n*****AVG Times for each queue*****\n");
- 205:	52                   	push   %edx
- 206:	68 60 0b 00 00       	push   $0xb60
- 20b:	6a 01                	push   $0x1
- 20d:	e8 3e 05 00 00       	call   750 <printf>
-        int turnaroundsPerQueue[4] = {0};
- 212:	31 c0                	xor    %eax,%eax
- 214:	b9 04 00 00 00       	mov    $0x4,%ecx
-        int CBTsPerQueue[4] = {0};
- 219:	83 c4 10             	add    $0x10,%esp
-        int turnaroundsPerQueue[4] = {0};
- 21c:	f3 ab                	rep stos %eax,%es:(%edi)
-        int waitingsPerQueue[4] = {0};
- 21e:	b9 04 00 00 00       	mov    $0x4,%ecx
- 223:	8d bd 48 fd ff ff    	lea    -0x2b8(%ebp),%edi
- 229:	f3 ab                	rep stos %eax,%es:(%edi)
-        int CBTsPerQueue[4] = {0};
- 22b:	b9 04 00 00 00       	mov    $0x4,%ecx
- 230:	8d bd 58 fd ff ff    	lea    -0x2a8(%ebp),%edi
- 236:	f3 ab                	rep stos %eax,%es:(%edi)
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 238:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 23f:	90                   	nop
-            turnaroundsPerQueue[childQueue - 1] += turnarounds[j];
- 240:	8b 14 86             	mov    (%esi,%eax,4),%edx
- 243:	8b 0c 83             	mov    (%ebx,%eax,4),%ecx
- 246:	01 8c 95 34 fd ff ff 	add    %ecx,-0x2cc(%ebp,%edx,4)
-            waitingsPerQueue[childQueue - 1] += waitings[j];
- 24d:	8b 8c 85 a8 fe ff ff 	mov    -0x158(%ebp,%eax,4),%ecx
- 254:	01 8c 95 44 fd ff ff 	add    %ecx,-0x2bc(%ebp,%edx,4)
-            CBTsPerQueue[childQueue - 1] += CBTs[j];
- 25b:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 262:	83 c0 01             	add    $0x1,%eax
-            CBTsPerQueue[childQueue - 1] += CBTs[j];
- 265:	01 8c 95 54 fd ff ff 	add    %ecx,-0x2ac(%ebp,%edx,4)
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 26c:	83 f8 28             	cmp    $0x28,%eax
- 26f:	75 cf                	jne    240 <main+0x240>
-        for (int j = 0; j < 4; j++)
- 271:	31 ff                	xor    %edi,%edi
-            printf(1, "Queue: %d -> AVG Turnaround: %d, AVG Waiting: %d, AVG CBT: %d\n",
- 273:	89 fe                	mov    %edi,%esi
- 275:	b8 67 66 66 66       	mov    $0x66666667,%eax
- 27a:	83 ec 08             	sub    $0x8,%esp
- 27d:	83 c7 01             	add    $0x1,%edi
- 280:	8b 8c b5 58 fd ff ff 	mov    -0x2a8(%ebp,%esi,4),%ecx
- 287:	f7 e9                	imul   %ecx
- 289:	c1 f9 1f             	sar    $0x1f,%ecx
- 28c:	b8 67 66 66 66       	mov    $0x66666667,%eax
- 291:	c1 fa 02             	sar    $0x2,%edx
- 294:	29 ca                	sub    %ecx,%edx
- 296:	8b 8c b5 48 fd ff ff 	mov    -0x2b8(%ebp,%esi,4),%ecx
- 29d:	52                   	push   %edx
- 29e:	f7 e9                	imul   %ecx
- 2a0:	c1 f9 1f             	sar    $0x1f,%ecx
- 2a3:	b8 67 66 66 66       	mov    $0x66666667,%eax
- 2a8:	c1 fa 02             	sar    $0x2,%edx
- 2ab:	29 ca                	sub    %ecx,%edx
- 2ad:	8b 8c b5 38 fd ff ff 	mov    -0x2c8(%ebp,%esi,4),%ecx
- 2b4:	52                   	push   %edx
- 2b5:	f7 e9                	imul   %ecx
- 2b7:	c1 f9 1f             	sar    $0x1f,%ecx
- 2ba:	c1 fa 02             	sar    $0x2,%edx
- 2bd:	29 ca                	sub    %ecx,%edx
- 2bf:	52                   	push   %edx
- 2c0:	57                   	push   %edi
- 2c1:	68 88 0b 00 00       	push   $0xb88
- 2c6:	6a 01                	push   $0x1
- 2c8:	e8 83 04 00 00       	call   750 <printf>
-        for (int j = 0; j < 4; j++)
- 2cd:	83 c4 20             	add    $0x20,%esp
- 2d0:	83 ff 04             	cmp    $0x4,%edi
- 2d3:	75 9e                	jne    273 <main+0x273>
-        printf(1, "\n\n\n*****AVG Times in total*****\n");
- 2d5:	50                   	push   %eax
-        int waitingsSum = 0;
- 2d6:	31 ff                	xor    %edi,%edi
-        int turnaroundsSum = 0;
- 2d8:	31 f6                	xor    %esi,%esi
-        printf(1, "\n\n\n*****AVG Times in total*****\n");
- 2da:	50                   	push   %eax
- 2db:	68 c8 0b 00 00       	push   $0xbc8
- 2e0:	6a 01                	push   $0x1
- 2e2:	e8 69 04 00 00       	call   750 <printf>
- 2e7:	83 c4 10             	add    $0x10,%esp
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 2ea:	31 c9                	xor    %ecx,%ecx
-        int CBTsSum = 0;
- 2ec:	31 c0                	xor    %eax,%eax
- 2ee:	66 90                	xchg   %ax,%ax
-            turnaroundsSum += turnarounds[j];
- 2f0:	03 34 8b             	add    (%ebx,%ecx,4),%esi
-            waitingsSum += waitings[j];
- 2f3:	03 bc 8d a8 fe ff ff 	add    -0x158(%ebp,%ecx,4),%edi
-            CBTsSum += CBTs[j];
- 2fa:	03 84 8d 48 ff ff ff 	add    -0xb8(%ebp,%ecx,4),%eax
-        for (int j = 0; j < NUM_CHILDREN; j++)
- 301:	83 c1 01             	add    $0x1,%ecx
- 304:	83 f9 28             	cmp    $0x28,%ecx
- 307:	75 e7                	jne    2f0 <main+0x2f0>
-        printf(1, "Total -> AVG Turnaround: %d, AVG Waiting: %d, AVG CBT: %d\n",
- 309:	99                   	cltd   
- 30a:	83 ec 0c             	sub    $0xc,%esp
- 30d:	f7 f9                	idiv   %ecx
- 30f:	50                   	push   %eax
- 310:	89 f8                	mov    %edi,%eax
- 312:	99                   	cltd   
- 313:	f7 f9                	idiv   %ecx
- 315:	50                   	push   %eax
- 316:	89 f0                	mov    %esi,%eax
- 318:	99                   	cltd   
- 319:	f7 f9                	idiv   %ecx
- 31b:	50                   	push   %eax
- 31c:	68 ec 0b 00 00       	push   $0xbec
- 321:	6a 01                	push   $0x1
- 323:	e8 28 04 00 00       	call   750 <printf>
- 328:	83 c4 20             	add    $0x20,%esp
- 32b:	e9 a0 fd ff ff       	jmp    d0 <main+0xd0>
-
-00000330 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
- 330:	f3 0f 1e fb          	endbr32 
- 334:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
- 335:	31 c0                	xor    %eax,%eax
-{
- 337:	89 e5                	mov    %esp,%ebp
- 339:	53                   	push   %ebx
- 33a:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 33d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
- 340:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
- 344:	88 14 01             	mov    %dl,(%ecx,%eax,1)
- 347:	83 c0 01             	add    $0x1,%eax
- 34a:	84 d2                	test   %dl,%dl
- 34c:	75 f2                	jne    340 <strcpy+0x10>
-    ;
-  return os;
-}
- 34e:	89 c8                	mov    %ecx,%eax
- 350:	5b                   	pop    %ebx
- 351:	5d                   	pop    %ebp
- 352:	c3                   	ret    
- 353:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 35a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000360 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
- 360:	f3 0f 1e fb          	endbr32 
- 364:	55                   	push   %ebp
- 365:	89 e5                	mov    %esp,%ebp
- 367:	53                   	push   %ebx
- 368:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 36b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
- 36e:	0f b6 01             	movzbl (%ecx),%eax
- 371:	0f b6 1a             	movzbl (%edx),%ebx
- 374:	84 c0                	test   %al,%al
- 376:	75 19                	jne    391 <strcmp+0x31>
- 378:	eb 26                	jmp    3a0 <strcmp+0x40>
- 37a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 380:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
- 384:	83 c1 01             	add    $0x1,%ecx
- 387:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
- 38a:	0f b6 1a             	movzbl (%edx),%ebx
- 38d:	84 c0                	test   %al,%al
- 38f:	74 0f                	je     3a0 <strcmp+0x40>
- 391:	38 d8                	cmp    %bl,%al
- 393:	74 eb                	je     380 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
- 395:	29 d8                	sub    %ebx,%eax
-}
- 397:	5b                   	pop    %ebx
- 398:	5d                   	pop    %ebp
- 399:	c3                   	ret    
- 39a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 3a0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
- 3a2:	29 d8                	sub    %ebx,%eax
-}
- 3a4:	5b                   	pop    %ebx
- 3a5:	5d                   	pop    %ebp
- 3a6:	c3                   	ret    
- 3a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3ae:	66 90                	xchg   %ax,%ax
-
-000003b0 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 3b0:	f3 0f 1e fb          	endbr32 
- 3b4:	55                   	push   %ebp
- 3b5:	89 e5                	mov    %esp,%ebp
- 3b7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 3ba:	80 3a 00             	cmpb   $0x0,(%edx)
- 3bd:	74 21                	je     3e0 <strlen+0x30>
- 3bf:	31 c0                	xor    %eax,%eax
- 3c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3c8:	83 c0 01             	add    $0x1,%eax
- 3cb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 3cf:	89 c1                	mov    %eax,%ecx
- 3d1:	75 f5                	jne    3c8 <strlen+0x18>
-    ;
-  return n;
-}
- 3d3:	89 c8                	mov    %ecx,%eax
- 3d5:	5d                   	pop    %ebp
- 3d6:	c3                   	ret    
- 3d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3de:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 3e0:	31 c9                	xor    %ecx,%ecx
-}
- 3e2:	5d                   	pop    %ebp
- 3e3:	89 c8                	mov    %ecx,%eax
- 3e5:	c3                   	ret    
- 3e6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 3ed:	8d 76 00             	lea    0x0(%esi),%esi
-
-000003f0 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 3f0:	f3 0f 1e fb          	endbr32 
- 3f4:	55                   	push   %ebp
- 3f5:	89 e5                	mov    %esp,%ebp
- 3f7:	57                   	push   %edi
- 3f8:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 3fb:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 3fe:	8b 45 0c             	mov    0xc(%ebp),%eax
- 401:	89 d7                	mov    %edx,%edi
- 403:	fc                   	cld    
- 404:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 406:	89 d0                	mov    %edx,%eax
- 408:	5f                   	pop    %edi
- 409:	5d                   	pop    %ebp
- 40a:	c3                   	ret    
- 40b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 40f:	90                   	nop
-
-00000410 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 410:	f3 0f 1e fb          	endbr32 
- 414:	55                   	push   %ebp
- 415:	89 e5                	mov    %esp,%ebp
- 417:	8b 45 08             	mov    0x8(%ebp),%eax
- 41a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 41e:	0f b6 10             	movzbl (%eax),%edx
- 421:	84 d2                	test   %dl,%dl
- 423:	75 16                	jne    43b <strchr+0x2b>
- 425:	eb 21                	jmp    448 <strchr+0x38>
- 427:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 42e:	66 90                	xchg   %ax,%ax
- 430:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 434:	83 c0 01             	add    $0x1,%eax
- 437:	84 d2                	test   %dl,%dl
- 439:	74 0d                	je     448 <strchr+0x38>
-    if(*s == c)
- 43b:	38 d1                	cmp    %dl,%cl
- 43d:	75 f1                	jne    430 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 43f:	5d                   	pop    %ebp
- 440:	c3                   	ret    
- 441:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 448:	31 c0                	xor    %eax,%eax
-}
- 44a:	5d                   	pop    %ebp
- 44b:	c3                   	ret    
- 44c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000450 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 450:	f3 0f 1e fb          	endbr32 
- 454:	55                   	push   %ebp
- 455:	89 e5                	mov    %esp,%ebp
- 457:	57                   	push   %edi
- 458:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 459:	31 f6                	xor    %esi,%esi
-{
- 45b:	53                   	push   %ebx
- 45c:	89 f3                	mov    %esi,%ebx
- 45e:	83 ec 1c             	sub    $0x1c,%esp
- 461:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 464:	eb 33                	jmp    499 <gets+0x49>
- 466:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 46d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 470:	83 ec 04             	sub    $0x4,%esp
- 473:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 476:	6a 01                	push   $0x1
- 478:	50                   	push   %eax
- 479:	6a 00                	push   $0x0
- 47b:	e8 2b 01 00 00       	call   5ab <read>
-    if(cc < 1)
- 480:	83 c4 10             	add    $0x10,%esp
- 483:	85 c0                	test   %eax,%eax
- 485:	7e 1c                	jle    4a3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 487:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 48b:	83 c7 01             	add    $0x1,%edi
- 48e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 491:	3c 0a                	cmp    $0xa,%al
- 493:	74 23                	je     4b8 <gets+0x68>
- 495:	3c 0d                	cmp    $0xd,%al
- 497:	74 1f                	je     4b8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 499:	83 c3 01             	add    $0x1,%ebx
- 49c:	89 fe                	mov    %edi,%esi
- 49e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 4a1:	7c cd                	jl     470 <gets+0x20>
- 4a3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 4a5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 4a8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 4ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 4ae:	5b                   	pop    %ebx
- 4af:	5e                   	pop    %esi
- 4b0:	5f                   	pop    %edi
- 4b1:	5d                   	pop    %ebp
- 4b2:	c3                   	ret    
- 4b3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 4b7:	90                   	nop
- 4b8:	8b 75 08             	mov    0x8(%ebp),%esi
- 4bb:	8b 45 08             	mov    0x8(%ebp),%eax
- 4be:	01 de                	add    %ebx,%esi
- 4c0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 4c2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 4c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 4c8:	5b                   	pop    %ebx
- 4c9:	5e                   	pop    %esi
- 4ca:	5f                   	pop    %edi
- 4cb:	5d                   	pop    %ebp
- 4cc:	c3                   	ret    
- 4cd:	8d 76 00             	lea    0x0(%esi),%esi
-
-000004d0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 4d0:	f3 0f 1e fb          	endbr32 
- 4d4:	55                   	push   %ebp
- 4d5:	89 e5                	mov    %esp,%ebp
- 4d7:	56                   	push   %esi
- 4d8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 4d9:	83 ec 08             	sub    $0x8,%esp
- 4dc:	6a 00                	push   $0x0
- 4de:	ff 75 08             	pushl  0x8(%ebp)
- 4e1:	e8 ed 00 00 00       	call   5d3 <open>
-  if(fd < 0)
- 4e6:	83 c4 10             	add    $0x10,%esp
- 4e9:	85 c0                	test   %eax,%eax
- 4eb:	78 2b                	js     518 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 4ed:	83 ec 08             	sub    $0x8,%esp
- 4f0:	ff 75 0c             	pushl  0xc(%ebp)
- 4f3:	89 c3                	mov    %eax,%ebx
- 4f5:	50                   	push   %eax
- 4f6:	e8 f0 00 00 00       	call   5eb <fstat>
-  close(fd);
- 4fb:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 4fe:	89 c6                	mov    %eax,%esi
-  close(fd);
- 500:	e8 b6 00 00 00       	call   5bb <close>
-  return r;
- 505:	83 c4 10             	add    $0x10,%esp
-}
- 508:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 50b:	89 f0                	mov    %esi,%eax
- 50d:	5b                   	pop    %ebx
- 50e:	5e                   	pop    %esi
- 50f:	5d                   	pop    %ebp
- 510:	c3                   	ret    
- 511:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 518:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 51d:	eb e9                	jmp    508 <stat+0x38>
- 51f:	90                   	nop
-
-00000520 <atoi>:
-
-int
-atoi(const char *s)
-{
- 520:	f3 0f 1e fb          	endbr32 
- 524:	55                   	push   %ebp
- 525:	89 e5                	mov    %esp,%ebp
- 527:	53                   	push   %ebx
- 528:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 52b:	0f be 02             	movsbl (%edx),%eax
- 52e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 531:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 534:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 539:	77 1a                	ja     555 <atoi+0x35>
- 53b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 53f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 540:	83 c2 01             	add    $0x1,%edx
- 543:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 546:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 54a:	0f be 02             	movsbl (%edx),%eax
- 54d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 550:	80 fb 09             	cmp    $0x9,%bl
- 553:	76 eb                	jbe    540 <atoi+0x20>
-  return n;
-}
- 555:	89 c8                	mov    %ecx,%eax
- 557:	5b                   	pop    %ebx
- 558:	5d                   	pop    %ebp
- 559:	c3                   	ret    
- 55a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000560 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 560:	f3 0f 1e fb          	endbr32 
- 564:	55                   	push   %ebp
- 565:	89 e5                	mov    %esp,%ebp
- 567:	57                   	push   %edi
- 568:	8b 45 10             	mov    0x10(%ebp),%eax
- 56b:	8b 55 08             	mov    0x8(%ebp),%edx
- 56e:	56                   	push   %esi
- 56f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 572:	85 c0                	test   %eax,%eax
- 574:	7e 0f                	jle    585 <memmove+0x25>
- 576:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 578:	89 d7                	mov    %edx,%edi
- 57a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 580:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 581:	39 f8                	cmp    %edi,%eax
- 583:	75 fb                	jne    580 <memmove+0x20>
-  return vdst;
-}
- 585:	5e                   	pop    %esi
- 586:	89 d0                	mov    %edx,%eax
- 588:	5f                   	pop    %edi
- 589:	5d                   	pop    %ebp
- 58a:	c3                   	ret    
-
-0000058b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 58b:	b8 01 00 00 00       	mov    $0x1,%eax
- 590:	cd 40                	int    $0x40
- 592:	c3                   	ret    
-
-00000593 <exit>:
-SYSCALL(exit)
- 593:	b8 02 00 00 00       	mov    $0x2,%eax
- 598:	cd 40                	int    $0x40
- 59a:	c3                   	ret    
-
-0000059b <wait>:
-SYSCALL(wait)
- 59b:	b8 03 00 00 00       	mov    $0x3,%eax
- 5a0:	cd 40                	int    $0x40
- 5a2:	c3                   	ret    
-
-000005a3 <pipe>:
-SYSCALL(pipe)
- 5a3:	b8 04 00 00 00       	mov    $0x4,%eax
- 5a8:	cd 40                	int    $0x40
- 5aa:	c3                   	ret    
-
-000005ab <read>:
-SYSCALL(read)
- 5ab:	b8 05 00 00 00       	mov    $0x5,%eax
- 5b0:	cd 40                	int    $0x40
- 5b2:	c3                   	ret    
-
-000005b3 <write>:
-SYSCALL(write)
- 5b3:	b8 10 00 00 00       	mov    $0x10,%eax
- 5b8:	cd 40                	int    $0x40
- 5ba:	c3                   	ret    
-
-000005bb <close>:
-SYSCALL(close)
- 5bb:	b8 15 00 00 00       	mov    $0x15,%eax
- 5c0:	cd 40                	int    $0x40
- 5c2:	c3                   	ret    
-
-000005c3 <kill>:
-SYSCALL(kill)
- 5c3:	b8 06 00 00 00       	mov    $0x6,%eax
- 5c8:	cd 40                	int    $0x40
- 5ca:	c3                   	ret    
-
-000005cb <exec>:
-SYSCALL(exec)
- 5cb:	b8 07 00 00 00       	mov    $0x7,%eax
- 5d0:	cd 40                	int    $0x40
- 5d2:	c3                   	ret    
-
-000005d3 <open>:
-SYSCALL(open)
- 5d3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 5d8:	cd 40                	int    $0x40
- 5da:	c3                   	ret    
-
-000005db <mknod>:
-SYSCALL(mknod)
- 5db:	b8 11 00 00 00       	mov    $0x11,%eax
- 5e0:	cd 40                	int    $0x40
- 5e2:	c3                   	ret    
-
-000005e3 <unlink>:
-SYSCALL(unlink)
- 5e3:	b8 12 00 00 00       	mov    $0x12,%eax
- 5e8:	cd 40                	int    $0x40
- 5ea:	c3                   	ret    
-
-000005eb <fstat>:
-SYSCALL(fstat)
- 5eb:	b8 08 00 00 00       	mov    $0x8,%eax
- 5f0:	cd 40                	int    $0x40
- 5f2:	c3                   	ret    
-
-000005f3 <link>:
-SYSCALL(link)
- 5f3:	b8 13 00 00 00       	mov    $0x13,%eax
- 5f8:	cd 40                	int    $0x40
- 5fa:	c3                   	ret    
-
-000005fb <mkdir>:
-SYSCALL(mkdir)
- 5fb:	b8 14 00 00 00       	mov    $0x14,%eax
- 600:	cd 40                	int    $0x40
- 602:	c3                   	ret    
-
-00000603 <chdir>:
-SYSCALL(chdir)
- 603:	b8 09 00 00 00       	mov    $0x9,%eax
- 608:	cd 40                	int    $0x40
- 60a:	c3                   	ret    
-
-0000060b <dup>:
-SYSCALL(dup)
- 60b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 610:	cd 40                	int    $0x40
- 612:	c3                   	ret    
-
-00000613 <getpid>:
-SYSCALL(getpid)
- 613:	b8 0b 00 00 00       	mov    $0xb,%eax
- 618:	cd 40                	int    $0x40
- 61a:	c3                   	ret    
-
-0000061b <sbrk>:
-SYSCALL(sbrk)
- 61b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 620:	cd 40                	int    $0x40
- 622:	c3                   	ret    
-
-00000623 <sleep>:
-SYSCALL(sleep)
- 623:	b8 0d 00 00 00       	mov    $0xd,%eax
- 628:	cd 40                	int    $0x40
- 62a:	c3                   	ret    
-
-0000062b <uptime>:
-SYSCALL(uptime)
- 62b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 630:	cd 40                	int    $0x40
- 632:	c3                   	ret    
-
-00000633 <getParentID>:
-SYSCALL(getParentID)
- 633:	b8 16 00 00 00       	mov    $0x16,%eax
- 638:	cd 40                	int    $0x40
- 63a:	c3                   	ret    
-
-0000063b <getChildren>:
-SYSCALL(getChildren)
- 63b:	b8 17 00 00 00       	mov    $0x17,%eax
- 640:	cd 40                	int    $0x40
- 642:	c3                   	ret    
-
-00000643 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 643:	b8 18 00 00 00       	mov    $0x18,%eax
- 648:	cd 40                	int    $0x40
- 64a:	c3                   	ret    
-
-0000064b <setPriority>:
-SYSCALL(setPriority)
- 64b:	b8 19 00 00 00       	mov    $0x19,%eax
- 650:	cd 40                	int    $0x40
- 652:	c3                   	ret    
-
-00000653 <changePolicy>:
-SYSCALL(changePolicy)
- 653:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 658:	cd 40                	int    $0x40
- 65a:	c3                   	ret    
-
-0000065b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 65b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 660:	cd 40                	int    $0x40
- 662:	c3                   	ret    
-
-00000663 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 663:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 668:	cd 40                	int    $0x40
- 66a:	c3                   	ret    
-
-0000066b <getCBT>:
-SYSCALL(getCBT)
- 66b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 670:	cd 40                	int    $0x40
- 672:	c3                   	ret    
-
-00000673 <customWait>:
-SYSCALL(customWait)
- 673:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 678:	cd 40                	int    $0x40
- 67a:	c3                   	ret    
-
-0000067b <setQueue>:
-SYSCALL(setQueue)
- 67b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 680:	cd 40                	int    $0x40
- 682:	c3                   	ret    
-
-00000683 <getBurstTime>:
-SYSCALL(getBurstTime)
- 683:	b8 20 00 00 00       	mov    $0x20,%eax
- 688:	cd 40                	int    $0x40
- 68a:	c3                   	ret    
-
-0000068b <getCreationTime>:
- 68b:	b8 21 00 00 00       	mov    $0x21,%eax
- 690:	cd 40                	int    $0x40
- 692:	c3                   	ret    
- 693:	66 90                	xchg   %ax,%ax
- 695:	66 90                	xchg   %ax,%ax
- 697:	66 90                	xchg   %ax,%ax
- 699:	66 90                	xchg   %ax,%ax
- 69b:	66 90                	xchg   %ax,%ax
- 69d:	66 90                	xchg   %ax,%ax
- 69f:	90                   	nop
-
-000006a0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 6a0:	55                   	push   %ebp
- 6a1:	89 e5                	mov    %esp,%ebp
- 6a3:	57                   	push   %edi
- 6a4:	56                   	push   %esi
- 6a5:	53                   	push   %ebx
- 6a6:	83 ec 3c             	sub    $0x3c,%esp
- 6a9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 6ac:	89 d1                	mov    %edx,%ecx
-{
- 6ae:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 6b1:	85 d2                	test   %edx,%edx
- 6b3:	0f 89 7f 00 00 00    	jns    738 <printint+0x98>
- 6b9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 6bd:	74 79                	je     738 <printint+0x98>
-    neg = 1;
- 6bf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 6c6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 6c8:	31 db                	xor    %ebx,%ebx
- 6ca:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 6cd:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 6d0:	89 c8                	mov    %ecx,%eax
- 6d2:	31 d2                	xor    %edx,%edx
- 6d4:	89 cf                	mov    %ecx,%edi
- 6d6:	f7 75 c4             	divl   -0x3c(%ebp)
- 6d9:	0f b6 92 30 0c 00 00 	movzbl 0xc30(%edx),%edx
- 6e0:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 6e3:	89 d8                	mov    %ebx,%eax
- 6e5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 6e8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 6eb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 6ee:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 6f1:	76 dd                	jbe    6d0 <printint+0x30>
-  if(neg)
- 6f3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 6f6:	85 c9                	test   %ecx,%ecx
- 6f8:	74 0c                	je     706 <printint+0x66>
-    buf[i++] = '-';
- 6fa:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 6ff:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 701:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 706:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 709:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 70d:	eb 07                	jmp    716 <printint+0x76>
- 70f:	90                   	nop
- 710:	0f b6 13             	movzbl (%ebx),%edx
- 713:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 716:	83 ec 04             	sub    $0x4,%esp
- 719:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 71c:	6a 01                	push   $0x1
- 71e:	56                   	push   %esi
- 71f:	57                   	push   %edi
- 720:	e8 8e fe ff ff       	call   5b3 <write>
-  while(--i >= 0)
- 725:	83 c4 10             	add    $0x10,%esp
- 728:	39 de                	cmp    %ebx,%esi
- 72a:	75 e4                	jne    710 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 72c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 72f:	5b                   	pop    %ebx
- 730:	5e                   	pop    %esi
- 731:	5f                   	pop    %edi
- 732:	5d                   	pop    %ebp
- 733:	c3                   	ret    
- 734:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 738:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 73f:	eb 87                	jmp    6c8 <printint+0x28>
- 741:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 748:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 74f:	90                   	nop
-
-00000750 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 750:	f3 0f 1e fb          	endbr32 
- 754:	55                   	push   %ebp
- 755:	89 e5                	mov    %esp,%ebp
- 757:	57                   	push   %edi
- 758:	56                   	push   %esi
- 759:	53                   	push   %ebx
- 75a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 75d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 760:	0f b6 1e             	movzbl (%esi),%ebx
- 763:	84 db                	test   %bl,%bl
- 765:	0f 84 b4 00 00 00    	je     81f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 76b:	8d 45 10             	lea    0x10(%ebp),%eax
- 76e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 771:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 774:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 776:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 779:	eb 33                	jmp    7ae <printf+0x5e>
- 77b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 77f:	90                   	nop
- 780:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 783:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 788:	83 f8 25             	cmp    $0x25,%eax
- 78b:	74 17                	je     7a4 <printf+0x54>
-  write(fd, &c, 1);
- 78d:	83 ec 04             	sub    $0x4,%esp
- 790:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 793:	6a 01                	push   $0x1
- 795:	57                   	push   %edi
- 796:	ff 75 08             	pushl  0x8(%ebp)
- 799:	e8 15 fe ff ff       	call   5b3 <write>
- 79e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 7a1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 7a4:	0f b6 1e             	movzbl (%esi),%ebx
- 7a7:	83 c6 01             	add    $0x1,%esi
- 7aa:	84 db                	test   %bl,%bl
- 7ac:	74 71                	je     81f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 7ae:	0f be cb             	movsbl %bl,%ecx
- 7b1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 7b4:	85 d2                	test   %edx,%edx
- 7b6:	74 c8                	je     780 <printf+0x30>
-      }
-    } else if(state == '%'){
- 7b8:	83 fa 25             	cmp    $0x25,%edx
- 7bb:	75 e7                	jne    7a4 <printf+0x54>
-      if(c == 'd'){
- 7bd:	83 f8 64             	cmp    $0x64,%eax
- 7c0:	0f 84 9a 00 00 00    	je     860 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 7c6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 7cc:	83 f9 70             	cmp    $0x70,%ecx
- 7cf:	74 5f                	je     830 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 7d1:	83 f8 73             	cmp    $0x73,%eax
- 7d4:	0f 84 d6 00 00 00    	je     8b0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 7da:	83 f8 63             	cmp    $0x63,%eax
- 7dd:	0f 84 8d 00 00 00    	je     870 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 7e3:	83 f8 25             	cmp    $0x25,%eax
- 7e6:	0f 84 b4 00 00 00    	je     8a0 <printf+0x150>
-  write(fd, &c, 1);
- 7ec:	83 ec 04             	sub    $0x4,%esp
- 7ef:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 7f3:	6a 01                	push   $0x1
- 7f5:	57                   	push   %edi
- 7f6:	ff 75 08             	pushl  0x8(%ebp)
- 7f9:	e8 b5 fd ff ff       	call   5b3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 7fe:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 801:	83 c4 0c             	add    $0xc,%esp
- 804:	6a 01                	push   $0x1
- 806:	83 c6 01             	add    $0x1,%esi
- 809:	57                   	push   %edi
- 80a:	ff 75 08             	pushl  0x8(%ebp)
- 80d:	e8 a1 fd ff ff       	call   5b3 <write>
-  for(i = 0; fmt[i]; i++){
- 812:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 816:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 819:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 81b:	84 db                	test   %bl,%bl
- 81d:	75 8f                	jne    7ae <printf+0x5e>
-    }
-  }
-}
- 81f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 822:	5b                   	pop    %ebx
- 823:	5e                   	pop    %esi
- 824:	5f                   	pop    %edi
- 825:	5d                   	pop    %ebp
- 826:	c3                   	ret    
- 827:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 82e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 830:	83 ec 0c             	sub    $0xc,%esp
- 833:	b9 10 00 00 00       	mov    $0x10,%ecx
- 838:	6a 00                	push   $0x0
- 83a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 83d:	8b 45 08             	mov    0x8(%ebp),%eax
- 840:	8b 13                	mov    (%ebx),%edx
- 842:	e8 59 fe ff ff       	call   6a0 <printint>
-        ap++;
- 847:	89 d8                	mov    %ebx,%eax
- 849:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 84c:	31 d2                	xor    %edx,%edx
-        ap++;
- 84e:	83 c0 04             	add    $0x4,%eax
- 851:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 854:	e9 4b ff ff ff       	jmp    7a4 <printf+0x54>
- 859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 860:	83 ec 0c             	sub    $0xc,%esp
- 863:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 868:	6a 01                	push   $0x1
- 86a:	eb ce                	jmp    83a <printf+0xea>
- 86c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 870:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 873:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 876:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 878:	6a 01                	push   $0x1
-        ap++;
- 87a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 87d:	57                   	push   %edi
- 87e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 881:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 884:	e8 2a fd ff ff       	call   5b3 <write>
-        ap++;
- 889:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 88c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 88f:	31 d2                	xor    %edx,%edx
- 891:	e9 0e ff ff ff       	jmp    7a4 <printf+0x54>
- 896:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 89d:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 8a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 8a3:	83 ec 04             	sub    $0x4,%esp
- 8a6:	e9 59 ff ff ff       	jmp    804 <printf+0xb4>
- 8ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 8af:	90                   	nop
-        s = (char*)*ap;
- 8b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 8b3:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 8b5:	83 c0 04             	add    $0x4,%eax
- 8b8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 8bb:	85 db                	test   %ebx,%ebx
- 8bd:	74 17                	je     8d6 <printf+0x186>
-        while(*s != 0){
- 8bf:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 8c2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 8c4:	84 c0                	test   %al,%al
- 8c6:	0f 84 d8 fe ff ff    	je     7a4 <printf+0x54>
- 8cc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 8cf:	89 de                	mov    %ebx,%esi
- 8d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 8d4:	eb 1a                	jmp    8f0 <printf+0x1a0>
-          s = "(null)";
- 8d6:	bb 27 0c 00 00       	mov    $0xc27,%ebx
-        while(*s != 0){
- 8db:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 8de:	b8 28 00 00 00       	mov    $0x28,%eax
- 8e3:	89 de                	mov    %ebx,%esi
- 8e5:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 8e8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 8ef:	90                   	nop
-  write(fd, &c, 1);
- 8f0:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 8f3:	83 c6 01             	add    $0x1,%esi
- 8f6:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 8f9:	6a 01                	push   $0x1
- 8fb:	57                   	push   %edi
- 8fc:	53                   	push   %ebx
- 8fd:	e8 b1 fc ff ff       	call   5b3 <write>
-        while(*s != 0){
- 902:	0f b6 06             	movzbl (%esi),%eax
- 905:	83 c4 10             	add    $0x10,%esp
- 908:	84 c0                	test   %al,%al
- 90a:	75 e4                	jne    8f0 <printf+0x1a0>
- 90c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 90f:	31 d2                	xor    %edx,%edx
- 911:	e9 8e fe ff ff       	jmp    7a4 <printf+0x54>
- 916:	66 90                	xchg   %ax,%ax
- 918:	66 90                	xchg   %ax,%ax
- 91a:	66 90                	xchg   %ax,%ax
- 91c:	66 90                	xchg   %ax,%ax
- 91e:	66 90                	xchg   %ax,%ax
-
-00000920 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 920:	f3 0f 1e fb          	endbr32 
- 924:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 925:	a1 e4 0e 00 00       	mov    0xee4,%eax
-{
- 92a:	89 e5                	mov    %esp,%ebp
- 92c:	57                   	push   %edi
- 92d:	56                   	push   %esi
- 92e:	53                   	push   %ebx
- 92f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 932:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 934:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 937:	39 c8                	cmp    %ecx,%eax
- 939:	73 15                	jae    950 <free+0x30>
- 93b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 93f:	90                   	nop
- 940:	39 d1                	cmp    %edx,%ecx
- 942:	72 14                	jb     958 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 944:	39 d0                	cmp    %edx,%eax
- 946:	73 10                	jae    958 <free+0x38>
-{
- 948:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 94a:	8b 10                	mov    (%eax),%edx
- 94c:	39 c8                	cmp    %ecx,%eax
- 94e:	72 f0                	jb     940 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 950:	39 d0                	cmp    %edx,%eax
- 952:	72 f4                	jb     948 <free+0x28>
- 954:	39 d1                	cmp    %edx,%ecx
- 956:	73 f0                	jae    948 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 958:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 95b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 95e:	39 fa                	cmp    %edi,%edx
- 960:	74 1e                	je     980 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 962:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 965:	8b 50 04             	mov    0x4(%eax),%edx
- 968:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 96b:	39 f1                	cmp    %esi,%ecx
- 96d:	74 28                	je     997 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 96f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 971:	5b                   	pop    %ebx
-  freep = p;
- 972:	a3 e4 0e 00 00       	mov    %eax,0xee4
-}
- 977:	5e                   	pop    %esi
- 978:	5f                   	pop    %edi
- 979:	5d                   	pop    %ebp
- 97a:	c3                   	ret    
- 97b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 97f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 980:	03 72 04             	add    0x4(%edx),%esi
- 983:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 986:	8b 10                	mov    (%eax),%edx
- 988:	8b 12                	mov    (%edx),%edx
- 98a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 98d:	8b 50 04             	mov    0x4(%eax),%edx
- 990:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 993:	39 f1                	cmp    %esi,%ecx
- 995:	75 d8                	jne    96f <free+0x4f>
-    p->s.size += bp->s.size;
- 997:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 99a:	a3 e4 0e 00 00       	mov    %eax,0xee4
-    p->s.size += bp->s.size;
- 99f:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 9a2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 9a5:	89 10                	mov    %edx,(%eax)
-}
- 9a7:	5b                   	pop    %ebx
- 9a8:	5e                   	pop    %esi
- 9a9:	5f                   	pop    %edi
- 9aa:	5d                   	pop    %ebp
- 9ab:	c3                   	ret    
- 9ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000009b0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 9b0:	f3 0f 1e fb          	endbr32 
- 9b4:	55                   	push   %ebp
- 9b5:	89 e5                	mov    %esp,%ebp
- 9b7:	57                   	push   %edi
- 9b8:	56                   	push   %esi
- 9b9:	53                   	push   %ebx
- 9ba:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 9bd:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 9c0:	8b 3d e4 0e 00 00    	mov    0xee4,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 9c6:	8d 70 07             	lea    0x7(%eax),%esi
- 9c9:	c1 ee 03             	shr    $0x3,%esi
- 9cc:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 9cf:	85 ff                	test   %edi,%edi
- 9d1:	0f 84 a9 00 00 00    	je     a80 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 9d7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 9d9:	8b 48 04             	mov    0x4(%eax),%ecx
- 9dc:	39 f1                	cmp    %esi,%ecx
- 9de:	73 6d                	jae    a4d <malloc+0x9d>
- 9e0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 9e6:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 9eb:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 9ee:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 9f5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 9f8:	eb 17                	jmp    a11 <malloc+0x61>
- 9fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- a00:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- a02:	8b 4a 04             	mov    0x4(%edx),%ecx
- a05:	39 f1                	cmp    %esi,%ecx
- a07:	73 4f                	jae    a58 <malloc+0xa8>
- a09:	8b 3d e4 0e 00 00    	mov    0xee4,%edi
- a0f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- a11:	39 c7                	cmp    %eax,%edi
- a13:	75 eb                	jne    a00 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- a15:	83 ec 0c             	sub    $0xc,%esp
- a18:	ff 75 e4             	pushl  -0x1c(%ebp)
- a1b:	e8 fb fb ff ff       	call   61b <sbrk>
-  if(p == (char*)-1)
- a20:	83 c4 10             	add    $0x10,%esp
- a23:	83 f8 ff             	cmp    $0xffffffff,%eax
- a26:	74 1b                	je     a43 <malloc+0x93>
-  hp->s.size = nu;
- a28:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- a2b:	83 ec 0c             	sub    $0xc,%esp
- a2e:	83 c0 08             	add    $0x8,%eax
- a31:	50                   	push   %eax
- a32:	e8 e9 fe ff ff       	call   920 <free>
-  return freep;
- a37:	a1 e4 0e 00 00       	mov    0xee4,%eax
-      if((p = morecore(nunits)) == 0)
- a3c:	83 c4 10             	add    $0x10,%esp
- a3f:	85 c0                	test   %eax,%eax
- a41:	75 bd                	jne    a00 <malloc+0x50>
-        return 0;
-  }
-}
- a43:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- a46:	31 c0                	xor    %eax,%eax
-}
- a48:	5b                   	pop    %ebx
- a49:	5e                   	pop    %esi
- a4a:	5f                   	pop    %edi
- a4b:	5d                   	pop    %ebp
- a4c:	c3                   	ret    
-    if(p->s.size >= nunits){
- a4d:	89 c2                	mov    %eax,%edx
- a4f:	89 f8                	mov    %edi,%eax
- a51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- a58:	39 ce                	cmp    %ecx,%esi
- a5a:	74 54                	je     ab0 <malloc+0x100>
-        p->s.size -= nunits;
- a5c:	29 f1                	sub    %esi,%ecx
- a5e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- a61:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- a64:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- a67:	a3 e4 0e 00 00       	mov    %eax,0xee4
-}
- a6c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- a6f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- a72:	5b                   	pop    %ebx
- a73:	5e                   	pop    %esi
- a74:	5f                   	pop    %edi
- a75:	5d                   	pop    %ebp
- a76:	c3                   	ret    
- a77:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- a7e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- a80:	c7 05 e4 0e 00 00 e8 	movl   $0xee8,0xee4
- a87:	0e 00 00 
-    base.s.size = 0;
- a8a:	bf e8 0e 00 00       	mov    $0xee8,%edi
-    base.s.ptr = freep = prevp = &base;
- a8f:	c7 05 e8 0e 00 00 e8 	movl   $0xee8,0xee8
- a96:	0e 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- a99:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- a9b:	c7 05 ec 0e 00 00 00 	movl   $0x0,0xeec
- aa2:	00 00 00 
-    if(p->s.size >= nunits){
- aa5:	e9 36 ff ff ff       	jmp    9e0 <malloc+0x30>
- aaa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- ab0:	8b 0a                	mov    (%edx),%ecx
- ab2:	89 08                	mov    %ecx,(%eax)
- ab4:	eb b1                	jmp    a67 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/multiLayeredQueuedTest.c b/xv6-public/Operating-System-Project/multiLayeredQueuedTest.c
deleted file mode 100644
index ab115f6..0000000
--- a/xv6-public/Operating-System-Project/multiLayeredQueuedTest.c
+++ /dev/null
@@ -1,119 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-// number of children created
-#define NUM_CHILDREN 40
-
-int main(int argc, char *argv[])
-{
-
-    int result = changePolicy(4);
-    if (result == 4)
-    {
-        printf(1, "Policy changed successfully!\n");
-    }
-    else
-    {
-        printf(1, "Policy change failed!\n");
-    }
-
-    int original_pid = getpid();
-    int child_num = -1;
-
-    for (int i = 0; i < NUM_CHILDREN; i++)
-    {
-        if (fork() == 0) // Child
-        {
-            setQueue((i / 10) + 1);
-            if (i > 9 && i < 20)
-            {
-                setPriority(i % 6 + 1);
-            }
-            else if (i > 20 && i < 30)
-            {
-                setPriority(i % 6 + 1);
-            }
-            child_num = i + 1;
-            break;
-        }
-    }
-
-    if (getpid() != original_pid)
-    {
-        for (int i = 1; i <= 50; i++)
-            printf(1, "/%d/: /%d/\n", child_num, i);
-    }
-
-    else
-    {
-        int queues[NUM_CHILDREN] = {0};      // priorites for each child
-        int turnarounds[NUM_CHILDREN] = {0}; // turnaround times for each child
-        int waitings[NUM_CHILDREN] = {0};    // waiting times for each child
-        int CBTs[NUM_CHILDREN] = {0};        // CBTs for each child
-
-        printf(1, "\n\n\n*****Times for each child*****\n");
-        int *procTimes = malloc(5 * sizeof(int));
-        int i = 0;
-        while (customWait(procTimes) > 0)
-        {
-            int childQueue = procTimes[3];
-            int childTurnaround = procTimes[0];
-            int childWaiting = procTimes[1];
-            int childCBT = procTimes[2];
-
-            queues[i] = childQueue;
-            turnarounds[i] = childTurnaround;
-            waitings[i] = childWaiting;
-            CBTs[i] = childCBT;
-            i++;
-        }
-
-        printf(1, "\n\n\n*****Times for each child*****\n");
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            printf(1, "Child with priority %d -> Turnaround: %d, Waiting: %d, CBT: %d\n",
-                   queues[j], turnarounds[j], waitings[j], CBTs[j]);
-        }
-
-        printf(1, "\n\n\n*****AVG Times for each queue*****\n");
-        int turnaroundsPerQueue[4] = {0};
-        int waitingsPerQueue[4] = {0};
-        int CBTsPerQueue[4] = {0};
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            int childQueue = queues[j];
-            turnaroundsPerQueue[childQueue - 1] += turnarounds[j];
-            waitingsPerQueue[childQueue - 1] += waitings[j];
-            CBTsPerQueue[childQueue - 1] += CBTs[j];
-        }
-        for (int j = 0; j < 4; j++)
-        {
-            printf(1, "Queue: %d -> AVG Turnaround: %d, AVG Waiting: %d, AVG CBT: %d\n",
-                   j + 1,
-                   turnaroundsPerQueue[j] / (NUM_CHILDREN / 4),
-                   waitingsPerQueue[j] / (NUM_CHILDREN / 4),
-                   CBTsPerQueue[j] / (NUM_CHILDREN / 4));
-        }
-
-        printf(1, "\n\n\n*****AVG Times in total*****\n");
-        int turnaroundsSum = 0;
-        int waitingsSum = 0;
-        int CBTsSum = 0;
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            turnaroundsSum += turnarounds[j];
-            waitingsSum += waitings[j];
-            CBTsSum += CBTs[j];
-        }
-        printf(1, "Total -> AVG Turnaround: %d, AVG Waiting: %d, AVG CBT: %d\n",
-               turnaroundsSum / NUM_CHILDREN,
-               waitingsSum / NUM_CHILDREN,
-               CBTsSum / NUM_CHILDREN);
-    }
-
-    while (wait() != -1)
-        ;
-
-    exit();
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/multiLayeredQueuedTest.d b/xv6-public/Operating-System-Project/multiLayeredQueuedTest.d
deleted file mode 100644
index 4eb056a..0000000
--- a/xv6-public/Operating-System-Project/multiLayeredQueuedTest.d
+++ /dev/null
@@ -1,2 +0,0 @@
-multiLayeredQueuedTest.o: multiLayeredQueuedTest.c \
- /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/multiLayeredQueuedTest.o b/xv6-public/Operating-System-Project/multiLayeredQueuedTest.o
deleted file mode 100644
index baebf4e..0000000
Binary files a/xv6-public/Operating-System-Project/multiLayeredQueuedTest.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/multiLayeredQueuedTest.sym b/xv6-public/Operating-System-Project/multiLayeredQueuedTest.sym
deleted file mode 100644
index 1dccb3c..0000000
--- a/xv6-public/Operating-System-Project/multiLayeredQueuedTest.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-00000ab8 .rodata
-00000c44 .eh_frame
-00000ee4 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 multiLayeredQueuedTest.c
-00000000 ulib.c
-00000000 printf.c
-000006a0 printint
-00000c30 digits.1109
-00000000 umalloc.c
-00000ee4 freep
-00000ee8 base
-00000330 strcpy
-0000063b getChildren
-00000750 printf
-00000560 memmove
-000005db mknod
-00000450 gets
-00000613 getpid
-00000673 customWait
-0000066b getCBT
-000009b0 malloc
-00000623 sleep
-000005a3 pipe
-00000653 changePolicy
-000005b3 write
-000005eb fstat
-000005c3 kill
-00000603 chdir
-0000067b setQueue
-000005cb exec
-0000059b wait
-000005ab read
-00000683 getBurstTime
-000005e3 unlink
-0000058b fork
-0000065b getTurnAroundTime
-0000061b sbrk
-0000062b uptime
-00000ee4 __bss_start
-000003f0 memset
-00000000 main
-00000360 strcmp
-0000060b dup
-00000643 getSyscallCounter
-00000633 getParentID
-000004d0 stat
-00000ee4 _edata
-00000ef0 _end
-000005f3 link
-00000593 exit
-0000064b setPriority
-00000520 atoi
-0000068b getCreationTime
-000003b0 strlen
-000005d3 open
-00000410 strchr
-000005fb mkdir
-000005bb close
-00000663 getWaitingTime
-00000920 free
diff --git a/xv6-public/Operating-System-Project/param.h b/xv6-public/Operating-System-Project/param.h
deleted file mode 100644
index 9e5dd63..0000000
--- a/xv6-public/Operating-System-Project/param.h
+++ /dev/null
@@ -1,16 +0,0 @@
-#define NPROC 64                  // maximum number of processes
-#define KSTACKSIZE 4096           // size of per-process kernel stack
-#define NCPU 8                    // maximum number of CPUs
-#define NOFILE 16                 // open files per process
-#define NFILE 100                 // open files per system
-#define NINODE 50                 // maximum number of active i-nodes
-#define NDEV 10                   // maximum major device number
-#define ROOTDEV 1                 // device number of file system root disk
-#define MAXARG 32                 // max exec arguments
-#define MAXOPBLOCKS 10            // max # of blocks any FS op writes
-#define LOGSIZE (MAXOPBLOCKS * 3) // max data blocks in on-disk log
-#define NBUF (MAXOPBLOCKS * 3)    // size of disk block cache
-#define FSSIZE 1000               // size of file system in blocks
-#define NSYSCALLS 29              // number of system calls
-#define QUANTUM 100               // RR scheduling time quantum
-#define DEFAULT_PRIORITY 3        // priority scheduling default priority
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/picirq.c b/xv6-public/Operating-System-Project/picirq.c
deleted file mode 100644
index e26957f..0000000
--- a/xv6-public/Operating-System-Project/picirq.c
+++ /dev/null
@@ -1,19 +0,0 @@
-#include "types.h"
-#include "x86.h"
-#include "traps.h"
-
-// I/O Addresses of the two programmable interrupt controllers
-#define IO_PIC1         0x20    // Master (IRQs 0-7)
-#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
-
-// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
-void
-picinit(void)
-{
-  // mask all interrupts
-  outb(IO_PIC1+1, 0xFF);
-  outb(IO_PIC2+1, 0xFF);
-}
-
-//PAGEBREAK!
-// Blank page.
diff --git a/xv6-public/Operating-System-Project/picirq.d b/xv6-public/Operating-System-Project/picirq.d
deleted file mode 100644
index 5233e7e..0000000
--- a/xv6-public/Operating-System-Project/picirq.d
+++ /dev/null
@@ -1 +0,0 @@
-picirq.o: picirq.c /usr/include/stdc-predef.h types.h x86.h traps.h
diff --git a/xv6-public/Operating-System-Project/picirq.o b/xv6-public/Operating-System-Project/picirq.o
deleted file mode 100644
index 142c6a5..0000000
Binary files a/xv6-public/Operating-System-Project/picirq.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/pipe.c b/xv6-public/Operating-System-Project/pipe.c
deleted file mode 100644
index e9abe7f..0000000
--- a/xv6-public/Operating-System-Project/pipe.c
+++ /dev/null
@@ -1,121 +0,0 @@
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "mmu.h"
-#include "proc.h"
-#include "fs.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "file.h"
-
-#define PIPESIZE 512
-
-struct pipe {
-  struct spinlock lock;
-  char data[PIPESIZE];
-  uint nread;     // number of bytes read
-  uint nwrite;    // number of bytes written
-  int readopen;   // read fd is still open
-  int writeopen;  // write fd is still open
-};
-
-int
-pipealloc(struct file **f0, struct file **f1)
-{
-  struct pipe *p;
-
-  p = 0;
-  *f0 = *f1 = 0;
-  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
-    goto bad;
-  if((p = (struct pipe*)kalloc()) == 0)
-    goto bad;
-  p->readopen = 1;
-  p->writeopen = 1;
-  p->nwrite = 0;
-  p->nread = 0;
-  initlock(&p->lock, "pipe");
-  (*f0)->type = FD_PIPE;
-  (*f0)->readable = 1;
-  (*f0)->writable = 0;
-  (*f0)->pipe = p;
-  (*f1)->type = FD_PIPE;
-  (*f1)->readable = 0;
-  (*f1)->writable = 1;
-  (*f1)->pipe = p;
-  return 0;
-
-//PAGEBREAK: 20
- bad:
-  if(p)
-    kfree((char*)p);
-  if(*f0)
-    fileclose(*f0);
-  if(*f1)
-    fileclose(*f1);
-  return -1;
-}
-
-void
-pipeclose(struct pipe *p, int writable)
-{
-  acquire(&p->lock);
-  if(writable){
-    p->writeopen = 0;
-    wakeup(&p->nread);
-  } else {
-    p->readopen = 0;
-    wakeup(&p->nwrite);
-  }
-  if(p->readopen == 0 && p->writeopen == 0){
-    release(&p->lock);
-    kfree((char*)p);
-  } else
-    release(&p->lock);
-}
-
-//PAGEBREAK: 40
-int
-pipewrite(struct pipe *p, char *addr, int n)
-{
-  int i;
-
-  acquire(&p->lock);
-  for(i = 0; i < n; i++){
-    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
-      if(p->readopen == 0 || myproc()->killed){
-        release(&p->lock);
-        return -1;
-      }
-      wakeup(&p->nread);
-      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
-    }
-    p->data[p->nwrite++ % PIPESIZE] = addr[i];
-  }
-  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
-  release(&p->lock);
-  return n;
-}
-
-int
-piperead(struct pipe *p, char *addr, int n)
-{
-  int i;
-
-  acquire(&p->lock);
-  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
-    if(myproc()->killed){
-      release(&p->lock);
-      return -1;
-    }
-    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
-  }
-  for(i = 0; i < n; i++){  //DOC: piperead-copy
-    if(p->nread == p->nwrite)
-      break;
-    addr[i] = p->data[p->nread++ % PIPESIZE];
-  }
-  wakeup(&p->nwrite);  //DOC: piperead-wakeup
-  release(&p->lock);
-  return i;
-}
diff --git a/xv6-public/Operating-System-Project/pipe.d b/xv6-public/Operating-System-Project/pipe.d
deleted file mode 100644
index 3d0eac9..0000000
--- a/xv6-public/Operating-System-Project/pipe.d
+++ /dev/null
@@ -1,2 +0,0 @@
-pipe.o: pipe.c /usr/include/stdc-predef.h types.h defs.h param.h mmu.h \
- proc.h fs.h spinlock.h sleeplock.h file.h
diff --git a/xv6-public/Operating-System-Project/pipe.o b/xv6-public/Operating-System-Project/pipe.o
deleted file mode 100644
index acbdd2d..0000000
Binary files a/xv6-public/Operating-System-Project/pipe.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/pr.pl b/xv6-public/Operating-System-Project/pr.pl
deleted file mode 100644
index 46905bd..0000000
--- a/xv6-public/Operating-System-Project/pr.pl
+++ /dev/null
@@ -1,36 +0,0 @@
-#!/usr/bin/perl
-
-use POSIX qw(strftime);
-
-if($ARGV[0] eq "-h"){
-	shift @ARGV;
-	$h = $ARGV[0];
-	shift @ARGV;
-}else{
-	$h = $ARGV[0];
-}
-
-$page = 0;
-$now = strftime "%b %e %H:%M %Y", localtime;
-
-@lines = <>;
-for($i=0; $i<@lines; $i+=50){
-	print "\n\n";
-	++$page;
-	print "$now  $h  Page $page\n";
-	print "\n\n";
-	for($j=$i; $j<@lines && $j<$i +50; $j++){
-		$lines[$j] =~ s!//DOC.*!!;
-		print $lines[$j];
-	}
-	for(; $j<$i+50; $j++){
-		print "\n";
-	}
-	$sheet = "";
-	if($lines[$i] =~ /^([0-9][0-9])[0-9][0-9] /){
-		$sheet = "Sheet $1";
-	}
-	print "\n\n";
-	print "$sheet\n";
-	print "\n\n";
-}
diff --git a/xv6-public/Operating-System-Project/printf.c b/xv6-public/Operating-System-Project/printf.c
deleted file mode 100644
index b3298aa..0000000
--- a/xv6-public/Operating-System-Project/printf.c
+++ /dev/null
@@ -1,85 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-static void
-putc(int fd, char c)
-{
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
-  static char digits[] = "0123456789ABCDEF";
-  char buf[16];
-  int i, neg;
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
-  } else {
-    x = xx;
-  }
-
-  i = 0;
-  do{
-    buf[i++] = digits[x % base];
-  }while((x /= base) != 0);
-  if(neg)
-    buf[i++] = '-';
-
-  while(--i >= 0)
-    putc(fd, buf[i]);
-}
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
-  char *s;
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
-      } else {
-        putc(fd, c);
-      }
-    } else if(state == '%'){
-      if(c == 'd'){
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
-        s = (char*)*ap;
-        ap++;
-        if(s == 0)
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
-      }
-      state = 0;
-    }
-  }
-}
diff --git a/xv6-public/Operating-System-Project/printf.d b/xv6-public/Operating-System-Project/printf.d
deleted file mode 100644
index ddd3a8d..0000000
--- a/xv6-public/Operating-System-Project/printf.d
+++ /dev/null
@@ -1 +0,0 @@
-printf.o: printf.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/printf.o b/xv6-public/Operating-System-Project/printf.o
deleted file mode 100644
index d6cb906..0000000
Binary files a/xv6-public/Operating-System-Project/printf.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/printpcs b/xv6-public/Operating-System-Project/printpcs
deleted file mode 100644
index 81d039b..0000000
--- a/xv6-public/Operating-System-Project/printpcs
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/sh
-
-# Decode the symbols from a panic EIP list
-
-# Find a working addr2line
-for p in i386-jos-elf-addr2line addr2line; do
-    if which $p 2>&1 >/dev/null && \
-       $p -h 2>&1 | grep -q '\belf32-i386\b'; then
-        break
-    fi
-done
-
-# Enable as much pretty-printing as this addr2line can do
-$p $($p -h | grep ' -[aipsf] ' | awk '{print $1}') -e kernel "$@"
diff --git a/xv6-public/Operating-System-Project/prioritySchedTest copy.c b/xv6-public/Operating-System-Project/prioritySchedTest copy.c
deleted file mode 100644
index 468c48e..0000000
--- a/xv6-public/Operating-System-Project/prioritySchedTest copy.c	
+++ /dev/null
@@ -1,116 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-// number of children created
-#define NUM_CHILDREN 30
-
-int main(int argc, char *argv[])
-{
-    int result = changePolicy(2);
-    if (result == 0)
-    {
-        printf(1, "Policy changed successfully!\n");
-    }
-    else
-    {
-        printf(1, "Policy change failed!\n");
-    }
-
-    int original_pid = getpid();
-    int child_num = -1;
-    int priority = -1;
-
-    for (int i = 0; i < NUM_CHILDREN; i++)
-    {
-        if (fork() == 0) // Child
-        {
-            child_num = i + 1;
-            // priority = 6 - (i / 5);
-            priority = (i / 5) + 1;
-            printf(1, "i: %d, priority: %d\n", i, priority);
-            setPriority(priority);
-            break;
-        }
-    }
-
-    if (getpid() != original_pid)
-    {
-        for (int i = 1; i <= 50; i++)
-            printf(1, "/%d/: /%d/\n", child_num, i);
-    }
-
-    else
-    {
-       // int pid[NUM_CHILDREN] = {0};  // priorites for each child
-        int creation[NUM_CHILDREN] = {0}; // turnaround times for each child
-        int waitings[NUM_CHILDREN] = {0};    // waiting times for each child
-        int CBTs[NUM_CHILDREN] = {0};        // CBTs for each child
-
-        printf(1, "\n\n\n*****Times for each child*****\n");
-        int *procTimes = malloc(4 * sizeof(int));
-        int i = 0;
-        while (customWait(procTimes) > 0)
-        {
-            //int childPriority = procTimes[3];
-            int creation_t = procTimes[0];
-            //int childTurnaround = procTimes[3];
-            int waitingtime = procTimes[1];
-            int bursttimes = procTimes[2];
-
-            creation[i] = creation_t;
-            //turnarounds[i] = childTurnaround;
-            waitings[i] = waitingtime;
-            CBTs[i] = bursttimes;
-            i++;
-        }
-
-        printf(1, "\n\n\n*****Processes summary*****\n");
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            printf(1, "Process: %d -> Arrival: %d, Waiting: %d, Burst time: %d\n",
-                   j, creation[j], waitings[j], CBTs[j]);
-        }
-/*
-        printf(1, "\n\n\n*****AVG Times for each priority class*****\n");
-        int turnaroundsPerClass[6] = {0};
-        int waitingsPerClass[6] = {0};
-        int CBTsPerClass[6] = {0};
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            int childPriority = priorities[j];
-            turnaroundsPerClass[childPriority - 1] += turnarounds[j];
-            waitingsPerClass[childPriority - 1] += waitings[j];
-            CBTsPerClass[childPriority - 1] += CBTs[j];
-        }
-        for (int j = 0; j < 6; j++)
-        {
-            printf(1, "Priority class: %d -> AVG Turnaround: %d, AVG Waiting: %d, AVG CBT: %d\n",
-                   j + 1,
-                   turnaroundsPerClass[j] / (NUM_CHILDREN / 6),
-                   waitingsPerClass[j] / (NUM_CHILDREN / 6),
-                   CBTsPerClass[j] / (NUM_CHILDREN / 6));
-        }
-
-        printf(1, "\n\n\n*****AVG Times in total*****\n");
-        int turnaroundsSum = 0;
-        int waitingsSum = 0;
-        int CBTsSum = 0;
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            turnaroundsSum += turnarounds[j];
-            waitingsSum += waitings[j];
-            CBTsSum += CBTs[j];
-        }
-        printf(1, "Total -> AVG Turnaround: %d, AVG Waiting: %d, AVG CBT: %d\n",
-               turnaroundsSum / NUM_CHILDREN,
-               waitingsSum / NUM_CHILDREN,
-               CBTsSum / NUM_CHILDREN);
-    }
-*/
-    while (wait() != -1)
-        ;
-
-    exit();
-    }
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/prioritySchedTest.c b/xv6-public/Operating-System-Project/prioritySchedTest.c
deleted file mode 100644
index 2d73c77..0000000
--- a/xv6-public/Operating-System-Project/prioritySchedTest.c
+++ /dev/null
@@ -1,356 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-// number of children created
-#define NUM_CHILDREN 10
-void swap(int a, int b)
-{
-    int temp = a;
-    a =b;
-    b = temp;
-}
- 
-void arrangeArrival(int num, int mat[][6])
-{
-    for (int i = 0; i < num; i++) {
-        for (int j = 0; j < num - i - 1; j++) {
-            if (mat[j][1] > mat[j + 1][1]) {
-                for (int k = 0; k < 5; k++) {
-                    swap(mat[j][k], mat[j + 1][k]);
-                }
-            }
-        }
-    }
-}
- 
-void completionTime(int num, int mat[][6])
-{
-    int temp=0, val=0;
-    mat[0][3] = mat[0][1] + mat[0][2];
-    mat[0][5] = mat[0][3] - mat[0][1];
-    mat[0][4] = mat[0][5] - mat[0][2];
- 
-    for (int i = 1; i < num; i++) {
-        temp = mat[i - 1][3];
-        int low = mat[i][2];
-        for (int j = i; j < num; j++) {
-            if (temp >= mat[j][1] && low >= mat[j][2]) {
-                low = mat[j][2];
-                val = j;
-            }
-        }
-        mat[val][3] = temp + mat[val][2];
-        mat[val][5] = mat[val][3] - mat[val][1];
-        mat[val][4] = mat[val][5] - mat[val][2];
-        for (int k = 0; k < 6; k++) {
-            swap(mat[val][k], mat[i][k]);
-        }
-    }
-}
- 
-int main(int argc, char *argv[])
-{
-    int result = changePolicy(2);
-    if (result == 0)
-    {
-        printf(1, "Policy changed successfully!\n");
-    }
-    else
-    {
-        printf(1, "Policy change failed!\n");
-    }
-
-    int original_pid = getpid();
-    int child_num = -1;
-    int priority = -1;
-
-    for (int i = 0; i < NUM_CHILDREN; i++)
-    {
-        if (fork() == 0) // Child
-        {
-            child_num = i + 1;
-            // priority = 6 - (i / 5);
-            priority = (i / 5) + 1;
-            printf(1, "i: %d, priority: %d\n", i, priority);
-            setPriority(priority);
-            break;
-        }
-    }
-
-    if (getpid() != original_pid)
-    {
-        for (int i = 1; i <= 50; i++)
-            printf(1, "/%d/: /%d/\n", child_num, i);
-    }
-
-    else
-    {
-       // int pid[NUM_CHILDREN] = {0};  // priorites for each child
-        int creation[NUM_CHILDREN] = {0}; // turnaround times for each child
-        int waitings[NUM_CHILDREN] = {0};    // waiting times for each child
-        int CBTs[NUM_CHILDREN] = {0};        // CBTs for each child
-
-        printf(1, "\n\n\n*****Times for each child*****\n");
-        int *procTimes = malloc(4 * sizeof(int));
-        int i = 0;
-        while (customWait(procTimes) > 0)
-        {
-         //   int childPriority = procTimes[3];
-            int creation_t = procTimes[0];
-           // int childTurnaround = procTimes[3];
-            int waitingtime = procTimes[1];
-            int bursttimes = procTimes[2];
-
-            creation[i] = creation_t;
-            //turnarounds[i] = childTurnaround;
-            waitings[i] = waitingtime;
-            CBTs[i] = bursttimes;
-            i++;
-        }
-//int H_J = 0 ;
-// int c_j = 0;
- //int tmp = 0;
- //int btmp=0;
- //int cotmp=0;
-        int pda[NUM_CHILDREN][6] = {0} ;
-        //int so
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-         pda[j][0] = j;
-         pda[j][1] = creation[j];
-         pda[j][2] = CBTs[j];
-        }
-         for (int i = 0; i < NUM_CHILDREN; i++) {
-        printf(1, "Process: %d -> Arrival: %d, Burst time: %d\n", pda[i][0]  , pda[i][1] 
-            , pda[i][2], "\n");
-    }
-        arrangeArrival(NUM_CHILDREN, pda);
-    completionTime(NUM_CHILDREN, pda);
-     printf(1, "\n\n\n*****Processes summary*****\n");
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            
-            printf(1, "Process: %d -> Arrival: %d, Waiting: %d, Burst time: %d\n",
-                   pda[j][0], pda[j][1],waitings[pda[j][0]],pda[j][2]);
-                    //CBTs[pda[j][0]], creation
-        }
-       /* for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            
-            if(j==0){
-                    H_J = j;
-               c_j = j;
-                pda[j] = j;
-                }
-                if (CBTs[j]<= CBTs[H_J])
-                {
-                   
-                   */
-                  /* for (int co = 0; co < j; co++)
-                    {
-                        if (creation[j] <= creation[co]&&CBTs[j]<=CBTs[co])
-                        {
-                            continue;
-                        }
-                        else {
-                            H_J = co;
-
-                        }
-                    } 
-                 //  H_J  = j;*/
-                    /*for (int co = 0; co < j; co++)
-                    {
-                        if (creation[j] <= creation[co])
-                        {
-                            H_J = j;;
-                        }
-                        else {
-                            H_J = co;
-
-                        }
-                    }
-*/
-// H_J = 1--->2
-//c_J =1-->2
-
-//H_J = 2-->1
-//c_J = 2-->1
-               // H_J = j;
-               //c_j = j;//2
-               //pda[j] = c_j;
-                // continue;
-               /* if (j!=0)
-                {
-              
-                for (int co =j-1; co >0; co--)
-                    {
-                     if (CBTs[c_j] < CBTs[co])
-                        {
-                            tmp = pda[co]; //
-                            c_j = pda[co];//
-                            pda[co] = j;//
-                            pda[co-1] = tmp;//
-                        }
-                        else {
-                           continue;
-                        }
-                    }
-                }*/
-                /*for (int co = 0; co < j; co++)
-                    {
-                        if (CBTs[c_j] < CBTs[co])
-                        {
-                            tmp = pda[co]; //0
-                            c_j = pda[co];//0
-                            pda[co] = j;//2
-                            pda[j] = tmp;//1
-                        }
-                        else {
-                             if (co==j-1)
-                              {
-                                  pda[j] = c_j;
-
-
-                                 
-                              }
-
-                        }
-                    }*/
-              //  }
-                //2,1,3,0
-                //2,0,1
-                 
-           //     else
-               // {
-                    
-                 //   c_j = j;
-                //jc = 5
-                //coc = 5
-                //jb = 2
-                //cob = 3
-                //co = 4
-                //j=5
-                    /* for (int co = 0; co < j; co++)
-                    {
-                     if (CBTs[c_j] < CBTs[co])
-                        {
-                            tmp = pda[co]; //
-                            c_j = pda[co];//
-                            pda[co] = j;//
-                            pda[co+1] = tmp;//
-                        }
-                        else {
-                           continue;
-                        }
-                    }
-*/
-/*for (int co = 0; co < j; co++)
-                    {
-                        if (creation[j] < creation[co])
-                        {
-                            tmp = pda[co]; //
-                            c_j = pda[co];//
-                            pda[co] = j;//
-                        }
-                        else {
-                            continue;
-
-                        }
-                    } 
-pda[j] = j;*/
-                    /* if (CBTs[c_j] == CBTs[co]){
-                          if (creation[c_j]< creation[co]){
-                             tmp = pda[co];
-                             btmp = pda[co];
-                             //c_j = pda[co];
-                             pda[co] = c_j;
-                             c_j = btmp;
-                            // pda[j] = tmp;
-                          }
-                          else if (creation[c_j]== creation[co])
-                          { 
-                              tmp = pda[co+1];
-                              pda[co+1] = c_j;
-                              c_j = tmp;
-                          
-                          }*/
-                          
-                         /* else{
-                             // cotmp = co;
-                              if (co==j-1)
-                              {
-                                  pda[j] = c_j;
-
-                                 
-                              }
-                              else{
-                                  tmp = pda[co];
-                             c_j = pda[co+1];
-                            // pda[co] = j;
-                             //pda[j] = tmp;
-                             }
-                            
-                          }
-                     }
-                     else{*/
-                        
-                       
-                     //}
-                    
-                     
-                     
-                    // c_J = j;
-                    
-                //}
-               // pda[j] = c_j;
-               
-       // }
-      /*  H_J = 0;
-        tmp = 0;
-        c_j = 0;*/
-       
-// printf(1,"Waiting: %d",waitings[2]);
-
-      /*  printf(1, "\n\n\n*****AVG Times for each priority class*****\n");
-        int turnaroundsPerClass[6] = {0};
-        int waitingsPerClass[6] = {0};
-        int CBTsPerClass[6] = {0};
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            int childPriority = priorities[j];
-            turnaroundsPerClass[childPriority - 1] += turnarounds[j];
-            waitingsPerClass[childPriority - 1] += waitings[j];
-            CBTsPerClass[childPriority - 1] += CBTs[j];
-        }
-        for (int j = 0; j < 6; j++)
-        {
-            printf(1, "Priority class: %d -> AVG Turnaround: %d, AVG Waiting: %d, AVG CBT: %d\n",
-                   j + 1,
-                   turnaroundsPerClass[j] / (NUM_CHILDREN / 6),
-                   waitingsPerClass[j] / (NUM_CHILDREN / 6),
-                   CBTsPerClass[j] / (NUM_CHILDREN / 6));
-        }
-
-        printf(1, "\n\n\n*****AVG Times in total*****\n");
-        int turnaroundsSum = 0;
-        int waitingsSum = 0;
-        int CBTsSum = 0;
-        for (int j = 0; j < NUM_CHILDREN; j++)
-        {
-            turnaroundsSum += turnarounds[j];
-            waitingsSum += waitings[j];
-            CBTsSum += CBTs[j];
-        }
-        printf(1, "Total -> AVG Turnaround: %d, AVG Waiting: %d, AVG CBT: %d\n",
-               turnaroundsSum / NUM_CHILDREN,
-               waitingsSum / NUM_CHILDREN,
-               CBTsSum / NUM_CHILDREN);*/
-    }
-
-    while (wait() != -1)
-        ;
-
-    exit();
-   // }
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/proc.c b/xv6-public/Operating-System-Project/proc.c
deleted file mode 100644
index 9f36566..0000000
--- a/xv6-public/Operating-System-Project/proc.c
+++ /dev/null
@@ -1,954 +0,0 @@
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "x86.h"
-#include "proc.h"
-#include "spinlock.h"
-// An enum default value is always zero
-enum schedPolicy policy;
-
-struct
-{
-  struct spinlock lock;
-  struct proc proc[NPROC];
-} ptable;
-
-static struct proc *initproc;
-
-int nextpid = 1;
-extern void forkret(void);
-extern void trapret(void);
-
-static void wakeup1(void *chan);
-
-void pinit(void)
-{
-  initlock(&ptable.lock, "ptable");
-}
-
-// Must be called with interrupts disabled
-int cpuid()
-{
-  return mycpu() - cpus;
-}
-
-// Must be called with interrupts disabled to avoid the caller being
-// rescheduled between reading lapicid and running through the loop.
-struct cpu *
-mycpu(void)
-{
-  int apicid, i;
-
-  if (readeflags() & FL_IF)
-    panic("mycpu called with interrupts enabled\n");
-
-  apicid = lapicid();
-  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
-  // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i)
-  {
-    if (cpus[i].apicid == apicid)
-      return &cpus[i];
-  }
-  panic("unknown apicid\n");
-}
-
-// Disable interrupts so that we are not rescheduled
-// while reading proc from the cpu structure
-struct proc *
-myproc(void)
-{
-  struct cpu *c;
-  struct proc *p;
-  pushcli();
-  c = mycpu();
-  p = c->proc;
-  popcli();
-  return p;
-}
-
-//PAGEBREAK: 32
-// Look in the process table for an UNUSED proc.
-// If found, change state to EMBRYO and initialize
-// state required to run in the kernel.
-// Otherwise return 0.
-int total_t = 0;
-static struct proc *
-allocproc(void)
-{
-  struct proc *p;
-  char *sp;
-
-  acquire(&ptable.lock);
-
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if (p->state == UNUSED)
-      goto found;
-
-  release(&ptable.lock);
-  return 0;
-
-found:
-  p->state = EMBRYO;
-  p->pid = nextpid++;
-
-  release(&ptable.lock);
-
-  // Allocate kernel stack.
-  if ((p->kstack = kalloc()) == 0)
-  {
-    p->state = UNUSED;
-    return 0;
-  }
-  sp = p->kstack + KSTACKSIZE;
-
-  // Leave room for trap frame.
-  sp -= sizeof *p->tf;
-  p->tf = (struct trapframe *)sp;
-
-  // Set up new context to start executing at forkret,
-  // which returns to trapret.
-  sp -= 4;
-  *(uint *)sp = (uint)trapret;
-
-  sp -= sizeof *p->context;
-  p->context = (struct context *)sp;
-  memset(p->context, 0, sizeof *p->context);
-  p->context->eip = (uint)forkret;
-
-  p->sleeping_t = 0;
-  p->runnable_t = 0;
-  p->running_t = 0;
-  p->queue = 0; // by default each process is in the 0 queue
-
-  p->rr_remaining_t = QUANTUM;
-  p->state = EMBRYO;
-  p->priority = DEFAULT_PRIORITY;
-  //p->creation_t= total_t;
-
-
-  return p;
-}
-
-//PAGEBREAK: 32
-// Set up first user process.
-void userinit(void)
-{
-  struct proc *p;
-  extern char _binary_initcode_start[], _binary_initcode_size[];
-
-  p = allocproc();
-
-  initproc = p;
-  if ((p->pgdir = setupkvm()) == 0)
-    panic("userinit: out of memory?");
-  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
-  p->sz = PGSIZE;
-  memset(p->tf, 0, sizeof(*p->tf));
-  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
-  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
-  p->tf->es = p->tf->ds;
-  p->tf->ss = p->tf->ds;
-  p->tf->eflags = FL_IF;
-  p->tf->esp = PGSIZE;
-  p->tf->eip = 0; // beginning of initcode.S
-
-  safestrcpy(p->name, "initcode", sizeof(p->name));
-  p->cwd = namei("/");
-
-  // this assignment to p->state lets other cores
-  // run this process. the acquire forces the above
-  // writes to be visible, and the lock is also needed
-  // because the assignment might not be atomic.
-  acquire(&ptable.lock);
-
-  p->state = RUNNABLE;
-
-  release(&ptable.lock);
-}
-
-// Grow current process's memory by n bytes.
-// Return 0 on success, -1 on failure.
-int growproc(int n)
-{
-  uint sz;
-  struct proc *curproc = myproc();
-
-  sz = curproc->sz;
-  if (n > 0)
-  {
-    if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
-  }
-  else if (n < 0)
-  {
-    if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
-  }
-  curproc->sz = sz;
-  switchuvm(curproc);
-  return 0;
-}
-
-// Create a new process copying p as the parent.
-// Sets up stack to return as if from system call.
-// Caller must set state of returned proc to RUNNABLE.
-int fork(void)
-{
-  int i, pid;
-  struct proc *np;
-  struct proc *curproc = myproc();
-
-  // Allocate process.
-  if ((np = allocproc()) == 0)
-  {
-    return -1;
-  }
-
-  // Copy process state from proc.
-  if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0)
-  {
-    kfree(np->kstack);
-    np->kstack = 0;
-    np->state = UNUSED;
-    return -1;
-  }
-  np->sz = curproc->sz;
-  np->parent = curproc;
-  *np->tf = *curproc->tf;
-
-  // Clear %eax so that fork returns 0 in the child.
-  np->tf->eax = 0;
-
-  for (i = 0; i < NOFILE; i++)
-    if (curproc->ofile[i])
-      np->ofile[i] = filedup(curproc->ofile[i]);
-  np->cwd = idup(curproc->cwd);
-
-  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
-
-  pid = np->pid;
-
-  acquire(&ptable.lock);
-
-  np->state = RUNNABLE;
-
-  release(&ptable.lock);
-
-  return pid;
-}
-
-// Exit the current process.  Does not return.
-// An exited process remains in the zombie state
-// until its parent calls wait() to find out it exited.
-void exit(void)
-{
-  struct proc *curproc = myproc();
-  struct proc *p;
-  int fd;
-
-  if (curproc == initproc)
-    panic("init exiting");
-
-  // Close all open files.
-  for (fd = 0; fd < NOFILE; fd++)
-  {
-    if (curproc->ofile[fd])
-    {
-      fileclose(curproc->ofile[fd]);
-      curproc->ofile[fd] = 0;
-    }
-    nextpid = 1;
-  }
-
-  begin_op();
-  iput(curproc->cwd);
-  end_op();
-  curproc->cwd = 0;
-
-  acquire(&ptable.lock);
-
-  // Parent might be sleeping in wait().
-  wakeup1(curproc->parent);
-
-  // Pass abandoned children to init.
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-  {
-    if (p->parent == curproc)
-    {
-      p->parent = initproc;
-      if (p->state == ZOMBIE)
-        wakeup1(initproc);
-    }
-  }
-
-  // Jump into the scheduler, never to return.
-  curproc->state = ZOMBIE;
-  sched();
-  panic("zombie exit");
-}
-
-// Wait for a child process to exit and return its pid.
-// Return -1 if this process has no children.
-int wait(void)
-{
-  struct proc *p;
-  int havekids, pid;
-  struct proc *curproc = myproc();
-
-  acquire(&ptable.lock);
-  for (;;)
-  {
-    // Scan through table looking for exited children.
-    havekids = 0;
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    {
-      if (p->parent != curproc)
-        continue;
-      havekids = 1;
-      if (p->state == ZOMBIE)
-      {
-        // Found one.
-        pid = p->pid;
-        kfree(p->kstack);
-        p->kstack = 0;
-        freevm(p->pgdir);
-        p->pid = 0;
-        p->parent = 0;
-        p->name[0] = 0;
-        p->killed = 0;
-        p->state = UNUSED;
-
-        // // Reset time spent in each state, for the next call.
-        // p->sleeping_t = 0;
-        // p->runnable_t = 0;
-        // p->running_t = 0;
-        release(&ptable.lock);
-        return pid;
-      }
-    }
-
-    // No point waiting if we don't have any children.
-    if (!havekids || curproc->killed)
-    {
-      release(&ptable.lock);
-      return -1;
-    }
-
-    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock); //DOC: wait-sleep
-  }
-}
-
-void switch_process(struct cpu *c, struct proc *p)
-{
-  // Switch to chosen process.  It is the process's job
-  // to release ptable.lock and then reacquire it
-  // before jumping back to us.
-  c->proc = p;
-  switchuvm(p);
-  p->state = RUNNING;
-
-  swtch(&(c->scheduler), p->context);
-  switchkvm();
-
-  // Process is done running for now.
-  // It should have changed its p->state before coming back.
-  c->proc = 0;
-}
-
-void *findHighestInQueue(void)
-{
-  struct proc *p = 0;
-  struct proc *highest_p = 0;
-  int hasRunnable = 0;
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-  {
-    if (p->state == RUNNABLE && p->queue == 2)
-    {
-      highest_p = p;
-      hasRunnable = 1;
-      break;
-    }
-  }
-
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with highest priority
-  {
-    if (p->state != RUNNABLE || p->queue != 2)
-      continue;
-    if (p->priority < highest_p->priority)
-      highest_p = p;
-  }
-
-  if (hasRunnable)
-    return highest_p;
-  else
-    return (void *)-1;
-}
-
-void *findLowestInQueue(void)
-{
-  struct proc *p = 0;
-  struct proc *lowest_p = 0;
-  int hasRunnable = 0;
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-  {
-    if (p->state == RUNNABLE && p->state == 3)
-    {
-      lowest_p = p;
-      hasRunnable = 1;
-      break;
-    }
-  }
-
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with lowest priority
-  {
-    if (p->state != RUNNABLE || p->state != 3)
-      continue;
-    if (p->priority > lowest_p->priority)
-      lowest_p = p;
-  }
-
-  if (hasRunnable)
-    return lowest_p;
-  else
-    return (void *)-1;
-}
-
-//PAGEBREAK: 42
-// Per-CPU process scheduler.
-// Each CPU calls scheduler() after setting itself up.
-// Scheduler never returns.  It loops, doing:
-//  - choose a process to run
-//  - swtch to start running that process
-//  - eventually that process transfers control
-//      via swtch back to the scheduler.
-
-void scheduler(void)
-{
-  struct proc *p;
-
-  struct proc *highest_p = 0; // runnable process with highest priority
-  struct proc *lowest_p = 0;  // runnable process with lowest priority
-  int hasRunnable = 0;        // Whether there exists a runnable process or not
-
-  struct cpu *c = mycpu();
-  c->proc = 0;
-
-  for (;;)
-  {
-    // Enable interrupts on this processor.
-    sti();
-
-    acquire(&ptable.lock);
-    switch (policy)
-    {
-    case DEFAULT:
-    case ROUND_ROBIN:
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-      {
-        if (p->state != RUNNABLE)
-          continue;
-        switch_process(c, p);
-      }
-      break;
-
-    case PRIORITY:
-      hasRunnable = 0;
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-      {
-        if (p->state == RUNNABLE)
-        {
-          highest_p = p;
-          hasRunnable = 1;
-          break;
-        }
-      }
-
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with highest priority
-      {
-        if (p->state != RUNNABLE)
-          continue;
-        //if (p->priority < highest_p->creation_t)
-        //p->creation_t < highest_p->creation_t && 
-        if ((p->running_t < highest_p->running_t )){
-          if  (p->creation_t<=highest_p->creation_t);
-          highest_p = p;
-      }
-      }
-
-      if (hasRunnable)
-      {
-        switch_process(c, highest_p);
-      }
-      break;
-
-    case INVERSE_PRIORITY:
-      hasRunnable = 0;
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-      {
-        if (p->state == RUNNABLE)
-        {
-          lowest_p = p;
-          hasRunnable = 1;
-          break;
-        }
-      }
-
-      for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) // finding the process with lowest priority
-      {
-        if (p->state != RUNNABLE)
-          continue;
-        if (p->priority > lowest_p->priority)
-          lowest_p = p;
-      }
-
-      if (hasRunnable)
-      {
-        switch_process(c, lowest_p);
-      }
-      break;
-
-    case MULTILAYRED_PRIORITY:
-      for (int currentQueue = 1; currentQueue < 5; currentQueue++)
-      {
-        {
-          switch (currentQueue)
-          {
-          case 2:
-            while (1)
-            {
-              highest_p = findHighestInQueue();
-              if ((int)highest_p == -1)
-                break;
-              else
-              {
-                highest_p = (struct proc *)highest_p;
-                switch_process(c, highest_p);
-              }
-            }
-            break;
-
-          case 3:
-            while (1)
-            {
-              lowest_p = findLowestInQueue();
-              if ((int)lowest_p == -1)
-                break;
-              else
-                lowest_p = (struct proc *)lowest_p;
-              switch_process(c, lowest_p);
-            }
-            break;
-
-          case 1:
-          case 4:
-            for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-            {
-              if (p->queue == currentQueue && p->state == RUNNABLE)
-              {
-                switch_process(c, p);
-                break;
-              }
-            }
-          }
-        }
-      }
-      break;
-    }
-    release(&ptable.lock);
-  }
-}
-
-// Enter scheduler.  Must hold only ptable.lock
-// and have changed proc->state. Saves and restores
-// intena because intena is a property of this
-// kernel thread, not this CPU. It should
-// be proc->intena and proc->ncli, but that would
-// break in the few places where a lock is held but
-// there's no process.
-void sched(void)
-{
-  int intena;
-  struct proc *p = myproc();
-
-  if (!holding(&ptable.lock))
-    panic("sched ptable.lock");
-  if (mycpu()->ncli != 1)
-    panic("sched locks");
-  if (p->state == RUNNING)
-    panic("sched running");
-  if (readeflags() & FL_IF)
-    panic("sched interruptible");
-  intena = mycpu()->intena;
-  swtch(&p->context, mycpu()->scheduler);
-  mycpu()->intena = intena;
-}
-
-// Give up the CPU for one scheduling round.
-void yield(void)
-{
-  acquire(&ptable.lock); //DOC: yieldlock
-  myproc()->state = RUNNABLE;
-  sched();
-  release(&ptable.lock);
-}
-
-// A fork child's very first scheduling by scheduler()
-// will swtch here.  "Return" to user space.
-void forkret(void)
-{
-  static int first = 1;
-  // Still holding ptable.lock from scheduler.
-  release(&ptable.lock);
-
-  if (first)
-  {
-    // Some initialization functions must be run in the context
-    // of a regular process (e.g., they call sleep), and thus cannot
-    // be run from main().
-    first = 0;
-    iinit(ROOTDEV);
-    initlog(ROOTDEV);
-  }
-
-  // Return to "caller", actually trapret (see allocproc).
-}
-
-// Atomically release lock and sleep on chan.
-// Reacquires lock when awakened.
-void sleep(void *chan, struct spinlock *lk)
-{
-  struct proc *p = myproc();
-
-  if (p == 0)
-    panic("sleep");
-
-  if (lk == 0)
-    panic("sleep without lk");
-
-  // Must acquire ptable.lock in order to
-  // change p->state and then call sched.
-  // Once we hold ptable.lock, we can be
-  // guaranteed that we won't miss any wakeup
-  // (wakeup runs with ptable.lock locked),
-  // so it's okay to release lk.
-  if (lk != &ptable.lock)
-  {                        //DOC: sleeplock0
-    acquire(&ptable.lock); //DOC: sleeplock1
-    release(lk);
-  }
-  // Go to sleep.
-  p->chan = chan;
-  p->state = SLEEPING;
-
-  sched();
-
-  // Tidy up.
-  p->chan = 0;
-
-  // Reacquire original lock.
-  if (lk != &ptable.lock)
-  { //DOC: sleeplock2
-    release(&ptable.lock);
-    acquire(lk);
-  }
-}
-
-//PAGEBREAK!
-// Wake up all processes sleeping on chan.
-// The ptable lock must be held.
-static void
-wakeup1(void *chan)
-{
-  struct proc *p;
-
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if (p->state == SLEEPING && p->chan == chan)
-      p->state = RUNNABLE;
-}
-
-// Wake up all processes sleeping on chan.
-void wakeup(void *chan)
-{
-  acquire(&ptable.lock);
-  wakeup1(chan);
-  release(&ptable.lock);
-}
-
-// Kill the process with the given pid.
-// Process won't exit until it returns
-// to user space (see trap in trap.c).
-int kill(int pid)
-{
-  struct proc *p;
-
-  acquire(&ptable.lock);
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-  {
-    if (p->pid == pid)
-    {
-      p->killed = 1;
-      // Wake process from sleep if necessary.
-      if (p->state == SLEEPING)
-        p->state = RUNNABLE;
-      release(&ptable.lock);
-      return 0;
-    }
-  }
-  release(&ptable.lock);
-  return -1;
-}
-
-//PAGEBREAK: 36
-// Print a process listing to console.  For debugging.
-// Runs when user types ^P on console.
-// No lock to avoid wedging a stuck machine further.
-void procdump(void)
-{
-  static char *states[] = {
-      [UNUSED] "unused",
-      [EMBRYO] "embryo",
-      [SLEEPING] "sleep ",
-      [RUNNABLE] "runble",
-      [RUNNING] "run   ",
-      [ZOMBIE] "zombie"};
-  int i;
-  struct proc *p;
-  char *state;
-  uint pc[10];
-
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-  {
-    if (p->state == UNUSED)
-      continue;
-    if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
-      state = states[p->state];
-    else
-      state = "???";
-    cprintf("%d %s %s", p->pid, state, p->name);
-    if (p->state == SLEEPING)
-    {
-      getcallerpcs((uint *)p->context->ebp + 2, pc);
-      for (i = 0; i < 10 && pc[i] != 0; i++)
-        cprintf(" %p", pc[i]);
-    }
-    cprintf("\n");
-  }
-}
-int create_t = 0;
-void updateStateDurations()
-{
-  struct proc *p;
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-  {
-    switch (p->state)
-    {
-      case EMBRYO:
-      create_t = total_t;
-      total_t++;
-        p->creation_t=create_t ;
-        
-    case SLEEPING:
-      p->sleeping_t++;
-      break;
-
-    case RUNNABLE:
-      p->runnable_t++;
-      break;
-
-    case RUNNING:
-      p->running_t++;
-      break;
-
-    default:
-      break;
-    }
-  }
-}
-
-int getParentID(void)
-{
-  acquire(&ptable.lock);
-  struct proc *curproc = myproc();
-  int parent_pid = curproc->parent->pid;
-  release(&ptable.lock);
-  return parent_pid;
-}
-
-int getChildren(int *children_pid)
-{
-  // current proccess
-  struct proc *curproc = myproc();
-  int curpid = curproc->pid;
-
-  // to iterate over proccesses
-  struct proc *p;
-  int num_children = 0;
-
-  acquire(&ptable.lock);
-  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-  {
-    if (p->parent->pid == curpid)
-      children_pid[num_children++] = p->pid;
-  }
-  release(&ptable.lock);
-
-  return num_children;
-}
-
-int getSyscallCounter(int syscall_num)
-{
-  struct proc *curproc = myproc();
-  if (syscall_num > 0 && syscall_num < NSYSCALLS)
-    return curproc->syscallsCount[syscall_num - 1];
-  else
-    return -1;
-}
-
-int setPriority(int newPriority)
-{
-  struct proc *p = myproc();
-  if (newPriority > 0 && newPriority < 7)
-  {
-    p->priority = newPriority;
-    return 0;
-  }
-  else
-    return -1;
-}
-
-int changePolicy(int newPolicy)
-{
-  if (newPolicy >= 0 && newPolicy < 6)
-  {
-    policy = newPolicy;
-    return 0;
-  }
-  else
-    return -1;
-}
-
-int getTurnAroundTime(int pid)
-{//
-  // struct proc *p;
-
-  
-  // if ((&ptable.proc[pid])->state == ZOMBIE)
-  return (&ptable.proc[pid])->sleeping_t + (&ptable.proc[pid])->runnable_t + (&ptable.proc[pid])->running_t;
-  // else
-  //   return -1;
-}
-int getBurstTime(int pid){
-  int cb = 0;
-  cb =(&ptable.proc[pid])->running_t ;
-  //(&ptable.proc[pid])->running_t = 0;
- // *p->running_t = 0;
-
-  return cb ;
-  //return (&ptable.proc[pid])->creation_t ;
-}
-int getCreationTime(int pid){
-  return (&ptable.proc[pid])->runnable_t ;
-}
-
-int getWaitingTime(int pid)
-{
-  return (&ptable.proc[pid])->sleeping_t + (&ptable.proc[pid])->runnable_t;
-}
-
-int getCBT(int pid)
-{
-   // struct proc *p;
-
-  /*int cb = 0;
-  cb =(&ptable.proc[pid])->running_t ;
-  (&ptable.proc[pid])->running_t = 0;*/
-   return (&ptable.proc[pid])->running_t;
- // *p->running_t = 0;
-
-  //return cb ;
-}
-  int order = 0;
-
-// it is almost the same as wait but it gets process differents time such as turnAroundTime and waitingTime and CBT
-int customWait(int *procTimes)
-{
-  struct proc *p;
-  int havekids, pid;
-  struct proc *curproc = myproc();
-
-  acquire(&ptable.lock);
-  for (;;)
-  {
-    // Scan through table looking for exited children.
-    havekids = 0;
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    {
-      if (p->parent != curproc)
-        continue;
-      havekids = 1;
-      if (p->state == ZOMBIE)
-      {
-        // Found one.
-        // store process times for further calculations
-        int turnAroundTime = getTurnAroundTime(p->pid);
-        int waitingTime = getWaitingTime(p->pid);
-        int cbt = getCBT(p->pid);
-        int creationTime = getCreationTime(p->pid);
-        //getTurnAroundTime(p->pid);
-
-        procTimes[0] =turnAroundTime ;
-        procTimes[1] = waitingTime;
-        procTimes[2] = cbt;
-        procTimes[3] = p->priority;
-        procTimes[4] = creationTime;
-//total_t = 0;
-        create_t = 0;
-        pid = p->pid;
-        kfree(p->kstack);
-        p->kstack = 0;
-        freevm(p->pgdir);
-        p->pid = 0;
-        p->parent = 0;
-        p->name[0] = 0;
-        p->killed = 0;
-        p->state = UNUSED;
-        
-        // // Reset time spent in each state, for the next call.
-         //p->sleeping_t = 0;
-        // p->runnable_t = 0;
-        // p->running_t = 0;
-       // p->creation_t = 0;
-        release(&ptable.lock);
-        return pid;
-      }
-    }
-
-    // No point waiting if we don't have any children.
-    if (!havekids || curproc->killed)
-    {
-      release(&ptable.lock);
-      return -1;
-    }
-
-    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock); //DOC: wait-sleep
-  }
-}
-
-int setQueue(int queueNumber)
-{
-  struct proc *curproc = myproc();
-  if (queueNumber > 4 || queueNumber < 1)
-  {
-    return -1;
-  }
-  else
-  {
-    curproc->queue = queueNumber;
-    return 0;
-  }
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/proc.d b/xv6-public/Operating-System-Project/proc.d
deleted file mode 100644
index 9396fef..0000000
--- a/xv6-public/Operating-System-Project/proc.d
+++ /dev/null
@@ -1,2 +0,0 @@
-proc.o: proc.c /usr/include/stdc-predef.h types.h defs.h param.h \
- memlayout.h mmu.h x86.h proc.h spinlock.h
diff --git a/xv6-public/Operating-System-Project/proc.h b/xv6-public/Operating-System-Project/proc.h
deleted file mode 100644
index 14b244c..0000000
--- a/xv6-public/Operating-System-Project/proc.h
+++ /dev/null
@@ -1,94 +0,0 @@
-// Per-CPU state
-struct cpu
-{
-  uchar apicid;              // Local APIC ID
-  struct context *scheduler; // swtch() here to enter scheduler
-  struct taskstate ts;       // Used by x86 to find stack for interrupt
-  struct segdesc gdt[NSEGS]; // x86 global descriptor table
-  volatile uint started;     // Has the CPU started?
-  int ncli;                  // Depth of pushcli nesting.
-  int intena;                // Were interrupts enabled before pushcli?
-  struct proc *proc;         // The process running on this cpu or null
-};
-
-extern struct cpu cpus[NCPU];
-extern int ncpu;
-
-//PAGEBREAK: 17
-// Saved registers for kernel context switches.
-// Don't need to save all the segment registers (%cs, etc),
-// because they are constant across kernel contexts.
-// Don't need to save %eax, %ecx, %edx, because the
-// x86 convention is that the caller has saved them.
-// Contexts are stored at the bottom of the stack they
-// describe; the stack pointer is the address of the context.
-// The layout of the context matches the layout of the stack in swtch.S
-// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
-// but it is on the stack and allocproc() manipulates it.
-struct context
-{
-  uint edi;
-  uint esi;
-  uint ebx;
-  uint ebp;
-  uint eip;
-};
-
-enum procstate
-{
-  UNUSED,
-  EMBRYO,
-  SLEEPING,
-  RUNNABLE,
-  RUNNING,
-  ZOMBIE
-};
-
-// Per-process state
-struct proc
-{
-  uint sz;                    // Size of process memory (bytes)
-  pde_t *pgdir;               // Page table
-  char *kstack;               // Bottom of kernel stack for this process
-  enum procstate state;       // Process state
-  int pid;                    // Process ID
-  struct proc *parent;        // Parent process
-  struct trapframe *tf;       // Trap frame for current syscall
-  struct context *context;    // swtch() here to run process
-  void *chan;                 // If non-zero, sleeping on chan
-  int killed;                 // If non-zero, have been killed
-  struct file *ofile[NOFILE]; // Open files
-  struct inode *cwd;          // Current directory
-  char name[16];              // Process name (debugging)
-  int queue;                  // Defines in which queue the process belongs
-
-  // stores how many times each of the syscalls has been called
-  int syscallsCount[NSYSCALLS];
-
-  int rr_remaining_t; // Remaining time left for RR scheduling
-  int priority;       // Process priority, 1 being the highest, 6 lowest.
-
-  int creation_t;    // Time which this process was created (turn into EMBRYO)
-  int sleeping_t;    // Time spent being in SLEEPING state
-  int runnable_t;    // Time spent being in RUNNABLE state
-  int running_t;     // Time spent being in RUNNING state
-  int termination_t; // Time which this process was terminated (turn into ZOMBIE)
-};
-
-// Scheduling options
-enum schedPolicy
-{
-  DEFAULT = 0,
-  ROUND_ROBIN = 1,
-  PRIORITY = 2,
-  INVERSE_PRIORITY = 3,
-  MULTILAYRED_PRIORITY = 4
-};
-
-extern enum schedPolicy policy;
-
-// Process memory is laid out contiguously, low addresses first:
-//   text
-//   original data and bss
-//   fixed-size stack
-//   expandable heap
diff --git a/xv6-public/Operating-System-Project/proc.o b/xv6-public/Operating-System-Project/proc.o
deleted file mode 100644
index e67ad5e..0000000
Binary files a/xv6-public/Operating-System-Project/proc.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/rm.asm b/xv6-public/Operating-System-Project/rm.asm
deleted file mode 100644
index 4b74e80..0000000
--- a/xv6-public/Operating-System-Project/rm.asm
+++ /dev/null
@@ -1,1284 +0,0 @@
-
-_rm:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	57                   	push   %edi
-  12:	bf 01 00 00 00       	mov    $0x1,%edi
-  17:	56                   	push   %esi
-  18:	53                   	push   %ebx
-  19:	51                   	push   %ecx
-  1a:	83 ec 08             	sub    $0x8,%esp
-  1d:	8b 59 04             	mov    0x4(%ecx),%ebx
-  20:	8b 31                	mov    (%ecx),%esi
-  22:	83 c3 04             	add    $0x4,%ebx
-  int i;
-
-  if(argc < 2){
-  25:	83 fe 01             	cmp    $0x1,%esi
-  28:	7e 3a                	jle    64 <main+0x64>
-  2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    printf(2, "Usage: rm files...\n");
-    exit();
-  }
-
-  for(i = 1; i < argc; i++){
-    if(unlink(argv[i]) < 0){
-  30:	83 ec 0c             	sub    $0xc,%esp
-  33:	ff 33                	pushl  (%ebx)
-  35:	e8 f9 02 00 00       	call   333 <unlink>
-  3a:	83 c4 10             	add    $0x10,%esp
-  3d:	85 c0                	test   %eax,%eax
-  3f:	78 0f                	js     50 <main+0x50>
-  for(i = 1; i < argc; i++){
-  41:	83 c7 01             	add    $0x1,%edi
-  44:	83 c3 04             	add    $0x4,%ebx
-  47:	39 fe                	cmp    %edi,%esi
-  49:	75 e5                	jne    30 <main+0x30>
-      printf(2, "rm: %s failed to delete\n", argv[i]);
-      break;
-    }
-  }
-
-  exit();
-  4b:	e8 93 02 00 00       	call   2e3 <exit>
-      printf(2, "rm: %s failed to delete\n", argv[i]);
-  50:	50                   	push   %eax
-  51:	ff 33                	pushl  (%ebx)
-  53:	68 1c 08 00 00       	push   $0x81c
-  58:	6a 02                	push   $0x2
-  5a:	e8 41 04 00 00       	call   4a0 <printf>
-      break;
-  5f:	83 c4 10             	add    $0x10,%esp
-  62:	eb e7                	jmp    4b <main+0x4b>
-    printf(2, "Usage: rm files...\n");
-  64:	52                   	push   %edx
-  65:	52                   	push   %edx
-  66:	68 08 08 00 00       	push   $0x808
-  6b:	6a 02                	push   $0x2
-  6d:	e8 2e 04 00 00       	call   4a0 <printf>
-    exit();
-  72:	e8 6c 02 00 00       	call   2e3 <exit>
-  77:	66 90                	xchg   %ax,%ax
-  79:	66 90                	xchg   %ax,%ax
-  7b:	66 90                	xchg   %ax,%ax
-  7d:	66 90                	xchg   %ax,%ax
-  7f:	90                   	nop
-
-00000080 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  80:	f3 0f 1e fb          	endbr32 
-  84:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  85:	31 c0                	xor    %eax,%eax
-{
-  87:	89 e5                	mov    %esp,%ebp
-  89:	53                   	push   %ebx
-  8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  8d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-  90:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-  94:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-  97:	83 c0 01             	add    $0x1,%eax
-  9a:	84 d2                	test   %dl,%dl
-  9c:	75 f2                	jne    90 <strcpy+0x10>
-    ;
-  return os;
-}
-  9e:	89 c8                	mov    %ecx,%eax
-  a0:	5b                   	pop    %ebx
-  a1:	5d                   	pop    %ebp
-  a2:	c3                   	ret    
-  a3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-000000b0 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-  b0:	f3 0f 1e fb          	endbr32 
-  b4:	55                   	push   %ebp
-  b5:	89 e5                	mov    %esp,%ebp
-  b7:	53                   	push   %ebx
-  b8:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  bb:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-  be:	0f b6 01             	movzbl (%ecx),%eax
-  c1:	0f b6 1a             	movzbl (%edx),%ebx
-  c4:	84 c0                	test   %al,%al
-  c6:	75 19                	jne    e1 <strcmp+0x31>
-  c8:	eb 26                	jmp    f0 <strcmp+0x40>
-  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  d0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-  d4:	83 c1 01             	add    $0x1,%ecx
-  d7:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-  da:	0f b6 1a             	movzbl (%edx),%ebx
-  dd:	84 c0                	test   %al,%al
-  df:	74 0f                	je     f0 <strcmp+0x40>
-  e1:	38 d8                	cmp    %bl,%al
-  e3:	74 eb                	je     d0 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-  e5:	29 d8                	sub    %ebx,%eax
-}
-  e7:	5b                   	pop    %ebx
-  e8:	5d                   	pop    %ebp
-  e9:	c3                   	ret    
-  ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  f0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-  f2:	29 d8                	sub    %ebx,%eax
-}
-  f4:	5b                   	pop    %ebx
-  f5:	5d                   	pop    %ebp
-  f6:	c3                   	ret    
-  f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  fe:	66 90                	xchg   %ax,%ax
-
-00000100 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 100:	f3 0f 1e fb          	endbr32 
- 104:	55                   	push   %ebp
- 105:	89 e5                	mov    %esp,%ebp
- 107:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 10a:	80 3a 00             	cmpb   $0x0,(%edx)
- 10d:	74 21                	je     130 <strlen+0x30>
- 10f:	31 c0                	xor    %eax,%eax
- 111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 118:	83 c0 01             	add    $0x1,%eax
- 11b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 11f:	89 c1                	mov    %eax,%ecx
- 121:	75 f5                	jne    118 <strlen+0x18>
-    ;
-  return n;
-}
- 123:	89 c8                	mov    %ecx,%eax
- 125:	5d                   	pop    %ebp
- 126:	c3                   	ret    
- 127:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 12e:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 130:	31 c9                	xor    %ecx,%ecx
-}
- 132:	5d                   	pop    %ebp
- 133:	89 c8                	mov    %ecx,%eax
- 135:	c3                   	ret    
- 136:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 13d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000140 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 140:	f3 0f 1e fb          	endbr32 
- 144:	55                   	push   %ebp
- 145:	89 e5                	mov    %esp,%ebp
- 147:	57                   	push   %edi
- 148:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 14b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 14e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 151:	89 d7                	mov    %edx,%edi
- 153:	fc                   	cld    
- 154:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 156:	89 d0                	mov    %edx,%eax
- 158:	5f                   	pop    %edi
- 159:	5d                   	pop    %ebp
- 15a:	c3                   	ret    
- 15b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 15f:	90                   	nop
-
-00000160 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 160:	f3 0f 1e fb          	endbr32 
- 164:	55                   	push   %ebp
- 165:	89 e5                	mov    %esp,%ebp
- 167:	8b 45 08             	mov    0x8(%ebp),%eax
- 16a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 16e:	0f b6 10             	movzbl (%eax),%edx
- 171:	84 d2                	test   %dl,%dl
- 173:	75 16                	jne    18b <strchr+0x2b>
- 175:	eb 21                	jmp    198 <strchr+0x38>
- 177:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 17e:	66 90                	xchg   %ax,%ax
- 180:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 184:	83 c0 01             	add    $0x1,%eax
- 187:	84 d2                	test   %dl,%dl
- 189:	74 0d                	je     198 <strchr+0x38>
-    if(*s == c)
- 18b:	38 d1                	cmp    %dl,%cl
- 18d:	75 f1                	jne    180 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 18f:	5d                   	pop    %ebp
- 190:	c3                   	ret    
- 191:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 198:	31 c0                	xor    %eax,%eax
-}
- 19a:	5d                   	pop    %ebp
- 19b:	c3                   	ret    
- 19c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000001a0 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 1a0:	f3 0f 1e fb          	endbr32 
- 1a4:	55                   	push   %ebp
- 1a5:	89 e5                	mov    %esp,%ebp
- 1a7:	57                   	push   %edi
- 1a8:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 1a9:	31 f6                	xor    %esi,%esi
-{
- 1ab:	53                   	push   %ebx
- 1ac:	89 f3                	mov    %esi,%ebx
- 1ae:	83 ec 1c             	sub    $0x1c,%esp
- 1b1:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 1b4:	eb 33                	jmp    1e9 <gets+0x49>
- 1b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1bd:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 1c0:	83 ec 04             	sub    $0x4,%esp
- 1c3:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 1c6:	6a 01                	push   $0x1
- 1c8:	50                   	push   %eax
- 1c9:	6a 00                	push   $0x0
- 1cb:	e8 2b 01 00 00       	call   2fb <read>
-    if(cc < 1)
- 1d0:	83 c4 10             	add    $0x10,%esp
- 1d3:	85 c0                	test   %eax,%eax
- 1d5:	7e 1c                	jle    1f3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 1d7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 1db:	83 c7 01             	add    $0x1,%edi
- 1de:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 1e1:	3c 0a                	cmp    $0xa,%al
- 1e3:	74 23                	je     208 <gets+0x68>
- 1e5:	3c 0d                	cmp    $0xd,%al
- 1e7:	74 1f                	je     208 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 1e9:	83 c3 01             	add    $0x1,%ebx
- 1ec:	89 fe                	mov    %edi,%esi
- 1ee:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 1f1:	7c cd                	jl     1c0 <gets+0x20>
- 1f3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 1f5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 1f8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1fe:	5b                   	pop    %ebx
- 1ff:	5e                   	pop    %esi
- 200:	5f                   	pop    %edi
- 201:	5d                   	pop    %ebp
- 202:	c3                   	ret    
- 203:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 207:	90                   	nop
- 208:	8b 75 08             	mov    0x8(%ebp),%esi
- 20b:	8b 45 08             	mov    0x8(%ebp),%eax
- 20e:	01 de                	add    %ebx,%esi
- 210:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 212:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 215:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 218:	5b                   	pop    %ebx
- 219:	5e                   	pop    %esi
- 21a:	5f                   	pop    %edi
- 21b:	5d                   	pop    %ebp
- 21c:	c3                   	ret    
- 21d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000220 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 220:	f3 0f 1e fb          	endbr32 
- 224:	55                   	push   %ebp
- 225:	89 e5                	mov    %esp,%ebp
- 227:	56                   	push   %esi
- 228:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 229:	83 ec 08             	sub    $0x8,%esp
- 22c:	6a 00                	push   $0x0
- 22e:	ff 75 08             	pushl  0x8(%ebp)
- 231:	e8 ed 00 00 00       	call   323 <open>
-  if(fd < 0)
- 236:	83 c4 10             	add    $0x10,%esp
- 239:	85 c0                	test   %eax,%eax
- 23b:	78 2b                	js     268 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 23d:	83 ec 08             	sub    $0x8,%esp
- 240:	ff 75 0c             	pushl  0xc(%ebp)
- 243:	89 c3                	mov    %eax,%ebx
- 245:	50                   	push   %eax
- 246:	e8 f0 00 00 00       	call   33b <fstat>
-  close(fd);
- 24b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 24e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 250:	e8 b6 00 00 00       	call   30b <close>
-  return r;
- 255:	83 c4 10             	add    $0x10,%esp
-}
- 258:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 25b:	89 f0                	mov    %esi,%eax
- 25d:	5b                   	pop    %ebx
- 25e:	5e                   	pop    %esi
- 25f:	5d                   	pop    %ebp
- 260:	c3                   	ret    
- 261:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 268:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 26d:	eb e9                	jmp    258 <stat+0x38>
- 26f:	90                   	nop
-
-00000270 <atoi>:
-
-int
-atoi(const char *s)
-{
- 270:	f3 0f 1e fb          	endbr32 
- 274:	55                   	push   %ebp
- 275:	89 e5                	mov    %esp,%ebp
- 277:	53                   	push   %ebx
- 278:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 27b:	0f be 02             	movsbl (%edx),%eax
- 27e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 281:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 284:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 289:	77 1a                	ja     2a5 <atoi+0x35>
- 28b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 28f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 290:	83 c2 01             	add    $0x1,%edx
- 293:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 296:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 29a:	0f be 02             	movsbl (%edx),%eax
- 29d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 2a0:	80 fb 09             	cmp    $0x9,%bl
- 2a3:	76 eb                	jbe    290 <atoi+0x20>
-  return n;
-}
- 2a5:	89 c8                	mov    %ecx,%eax
- 2a7:	5b                   	pop    %ebx
- 2a8:	5d                   	pop    %ebp
- 2a9:	c3                   	ret    
- 2aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-000002b0 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 2b0:	f3 0f 1e fb          	endbr32 
- 2b4:	55                   	push   %ebp
- 2b5:	89 e5                	mov    %esp,%ebp
- 2b7:	57                   	push   %edi
- 2b8:	8b 45 10             	mov    0x10(%ebp),%eax
- 2bb:	8b 55 08             	mov    0x8(%ebp),%edx
- 2be:	56                   	push   %esi
- 2bf:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 2c2:	85 c0                	test   %eax,%eax
- 2c4:	7e 0f                	jle    2d5 <memmove+0x25>
- 2c6:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 2c8:	89 d7                	mov    %edx,%edi
- 2ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 2d0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 2d1:	39 f8                	cmp    %edi,%eax
- 2d3:	75 fb                	jne    2d0 <memmove+0x20>
-  return vdst;
-}
- 2d5:	5e                   	pop    %esi
- 2d6:	89 d0                	mov    %edx,%eax
- 2d8:	5f                   	pop    %edi
- 2d9:	5d                   	pop    %ebp
- 2da:	c3                   	ret    
-
-000002db <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 2db:	b8 01 00 00 00       	mov    $0x1,%eax
- 2e0:	cd 40                	int    $0x40
- 2e2:	c3                   	ret    
-
-000002e3 <exit>:
-SYSCALL(exit)
- 2e3:	b8 02 00 00 00       	mov    $0x2,%eax
- 2e8:	cd 40                	int    $0x40
- 2ea:	c3                   	ret    
-
-000002eb <wait>:
-SYSCALL(wait)
- 2eb:	b8 03 00 00 00       	mov    $0x3,%eax
- 2f0:	cd 40                	int    $0x40
- 2f2:	c3                   	ret    
-
-000002f3 <pipe>:
-SYSCALL(pipe)
- 2f3:	b8 04 00 00 00       	mov    $0x4,%eax
- 2f8:	cd 40                	int    $0x40
- 2fa:	c3                   	ret    
-
-000002fb <read>:
-SYSCALL(read)
- 2fb:	b8 05 00 00 00       	mov    $0x5,%eax
- 300:	cd 40                	int    $0x40
- 302:	c3                   	ret    
-
-00000303 <write>:
-SYSCALL(write)
- 303:	b8 10 00 00 00       	mov    $0x10,%eax
- 308:	cd 40                	int    $0x40
- 30a:	c3                   	ret    
-
-0000030b <close>:
-SYSCALL(close)
- 30b:	b8 15 00 00 00       	mov    $0x15,%eax
- 310:	cd 40                	int    $0x40
- 312:	c3                   	ret    
-
-00000313 <kill>:
-SYSCALL(kill)
- 313:	b8 06 00 00 00       	mov    $0x6,%eax
- 318:	cd 40                	int    $0x40
- 31a:	c3                   	ret    
-
-0000031b <exec>:
-SYSCALL(exec)
- 31b:	b8 07 00 00 00       	mov    $0x7,%eax
- 320:	cd 40                	int    $0x40
- 322:	c3                   	ret    
-
-00000323 <open>:
-SYSCALL(open)
- 323:	b8 0f 00 00 00       	mov    $0xf,%eax
- 328:	cd 40                	int    $0x40
- 32a:	c3                   	ret    
-
-0000032b <mknod>:
-SYSCALL(mknod)
- 32b:	b8 11 00 00 00       	mov    $0x11,%eax
- 330:	cd 40                	int    $0x40
- 332:	c3                   	ret    
-
-00000333 <unlink>:
-SYSCALL(unlink)
- 333:	b8 12 00 00 00       	mov    $0x12,%eax
- 338:	cd 40                	int    $0x40
- 33a:	c3                   	ret    
-
-0000033b <fstat>:
-SYSCALL(fstat)
- 33b:	b8 08 00 00 00       	mov    $0x8,%eax
- 340:	cd 40                	int    $0x40
- 342:	c3                   	ret    
-
-00000343 <link>:
-SYSCALL(link)
- 343:	b8 13 00 00 00       	mov    $0x13,%eax
- 348:	cd 40                	int    $0x40
- 34a:	c3                   	ret    
-
-0000034b <mkdir>:
-SYSCALL(mkdir)
- 34b:	b8 14 00 00 00       	mov    $0x14,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <chdir>:
-SYSCALL(chdir)
- 353:	b8 09 00 00 00       	mov    $0x9,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <dup>:
-SYSCALL(dup)
- 35b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <getpid>:
-SYSCALL(getpid)
- 363:	b8 0b 00 00 00       	mov    $0xb,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <sbrk>:
-SYSCALL(sbrk)
- 36b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <sleep>:
-SYSCALL(sleep)
- 373:	b8 0d 00 00 00       	mov    $0xd,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <uptime>:
-SYSCALL(uptime)
- 37b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <getParentID>:
-SYSCALL(getParentID)
- 383:	b8 16 00 00 00       	mov    $0x16,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <getChildren>:
-SYSCALL(getChildren)
- 38b:	b8 17 00 00 00       	mov    $0x17,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 393:	b8 18 00 00 00       	mov    $0x18,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <setPriority>:
-SYSCALL(setPriority)
- 39b:	b8 19 00 00 00       	mov    $0x19,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
-
-000003a3 <changePolicy>:
-SYSCALL(changePolicy)
- 3a3:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 3a8:	cd 40                	int    $0x40
- 3aa:	c3                   	ret    
-
-000003ab <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 3ab:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
-
-000003b3 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 3b3:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 3b8:	cd 40                	int    $0x40
- 3ba:	c3                   	ret    
-
-000003bb <getCBT>:
-SYSCALL(getCBT)
- 3bb:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 3c0:	cd 40                	int    $0x40
- 3c2:	c3                   	ret    
-
-000003c3 <customWait>:
-SYSCALL(customWait)
- 3c3:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 3c8:	cd 40                	int    $0x40
- 3ca:	c3                   	ret    
-
-000003cb <setQueue>:
-SYSCALL(setQueue)
- 3cb:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 3d0:	cd 40                	int    $0x40
- 3d2:	c3                   	ret    
-
-000003d3 <getBurstTime>:
-SYSCALL(getBurstTime)
- 3d3:	b8 20 00 00 00       	mov    $0x20,%eax
- 3d8:	cd 40                	int    $0x40
- 3da:	c3                   	ret    
-
-000003db <getCreationTime>:
- 3db:	b8 21 00 00 00       	mov    $0x21,%eax
- 3e0:	cd 40                	int    $0x40
- 3e2:	c3                   	ret    
- 3e3:	66 90                	xchg   %ax,%ax
- 3e5:	66 90                	xchg   %ax,%ax
- 3e7:	66 90                	xchg   %ax,%ax
- 3e9:	66 90                	xchg   %ax,%ax
- 3eb:	66 90                	xchg   %ax,%ax
- 3ed:	66 90                	xchg   %ax,%ax
- 3ef:	90                   	nop
-
-000003f0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 3f0:	55                   	push   %ebp
- 3f1:	89 e5                	mov    %esp,%ebp
- 3f3:	57                   	push   %edi
- 3f4:	56                   	push   %esi
- 3f5:	53                   	push   %ebx
- 3f6:	83 ec 3c             	sub    $0x3c,%esp
- 3f9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 3fc:	89 d1                	mov    %edx,%ecx
-{
- 3fe:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 401:	85 d2                	test   %edx,%edx
- 403:	0f 89 7f 00 00 00    	jns    488 <printint+0x98>
- 409:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 40d:	74 79                	je     488 <printint+0x98>
-    neg = 1;
- 40f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 416:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 418:	31 db                	xor    %ebx,%ebx
- 41a:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 41d:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 420:	89 c8                	mov    %ecx,%eax
- 422:	31 d2                	xor    %edx,%edx
- 424:	89 cf                	mov    %ecx,%edi
- 426:	f7 75 c4             	divl   -0x3c(%ebp)
- 429:	0f b6 92 3c 08 00 00 	movzbl 0x83c(%edx),%edx
- 430:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 433:	89 d8                	mov    %ebx,%eax
- 435:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 438:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 43b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 43e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 441:	76 dd                	jbe    420 <printint+0x30>
-  if(neg)
- 443:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 446:	85 c9                	test   %ecx,%ecx
- 448:	74 0c                	je     456 <printint+0x66>
-    buf[i++] = '-';
- 44a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 44f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 451:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 456:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 459:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 45d:	eb 07                	jmp    466 <printint+0x76>
- 45f:	90                   	nop
- 460:	0f b6 13             	movzbl (%ebx),%edx
- 463:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 466:	83 ec 04             	sub    $0x4,%esp
- 469:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 46c:	6a 01                	push   $0x1
- 46e:	56                   	push   %esi
- 46f:	57                   	push   %edi
- 470:	e8 8e fe ff ff       	call   303 <write>
-  while(--i >= 0)
- 475:	83 c4 10             	add    $0x10,%esp
- 478:	39 de                	cmp    %ebx,%esi
- 47a:	75 e4                	jne    460 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 47c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 47f:	5b                   	pop    %ebx
- 480:	5e                   	pop    %esi
- 481:	5f                   	pop    %edi
- 482:	5d                   	pop    %ebp
- 483:	c3                   	ret    
- 484:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 488:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 48f:	eb 87                	jmp    418 <printint+0x28>
- 491:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 498:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 49f:	90                   	nop
-
-000004a0 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 4a0:	f3 0f 1e fb          	endbr32 
- 4a4:	55                   	push   %ebp
- 4a5:	89 e5                	mov    %esp,%ebp
- 4a7:	57                   	push   %edi
- 4a8:	56                   	push   %esi
- 4a9:	53                   	push   %ebx
- 4aa:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 4ad:	8b 75 0c             	mov    0xc(%ebp),%esi
- 4b0:	0f b6 1e             	movzbl (%esi),%ebx
- 4b3:	84 db                	test   %bl,%bl
- 4b5:	0f 84 b4 00 00 00    	je     56f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 4bb:	8d 45 10             	lea    0x10(%ebp),%eax
- 4be:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 4c1:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 4c4:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 4c6:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 4c9:	eb 33                	jmp    4fe <printf+0x5e>
- 4cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 4cf:	90                   	nop
- 4d0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 4d3:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 4d8:	83 f8 25             	cmp    $0x25,%eax
- 4db:	74 17                	je     4f4 <printf+0x54>
-  write(fd, &c, 1);
- 4dd:	83 ec 04             	sub    $0x4,%esp
- 4e0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 4e3:	6a 01                	push   $0x1
- 4e5:	57                   	push   %edi
- 4e6:	ff 75 08             	pushl  0x8(%ebp)
- 4e9:	e8 15 fe ff ff       	call   303 <write>
- 4ee:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 4f1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 4f4:	0f b6 1e             	movzbl (%esi),%ebx
- 4f7:	83 c6 01             	add    $0x1,%esi
- 4fa:	84 db                	test   %bl,%bl
- 4fc:	74 71                	je     56f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 4fe:	0f be cb             	movsbl %bl,%ecx
- 501:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 504:	85 d2                	test   %edx,%edx
- 506:	74 c8                	je     4d0 <printf+0x30>
-      }
-    } else if(state == '%'){
- 508:	83 fa 25             	cmp    $0x25,%edx
- 50b:	75 e7                	jne    4f4 <printf+0x54>
-      if(c == 'd'){
- 50d:	83 f8 64             	cmp    $0x64,%eax
- 510:	0f 84 9a 00 00 00    	je     5b0 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 516:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 51c:	83 f9 70             	cmp    $0x70,%ecx
- 51f:	74 5f                	je     580 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 521:	83 f8 73             	cmp    $0x73,%eax
- 524:	0f 84 d6 00 00 00    	je     600 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 52a:	83 f8 63             	cmp    $0x63,%eax
- 52d:	0f 84 8d 00 00 00    	je     5c0 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 533:	83 f8 25             	cmp    $0x25,%eax
- 536:	0f 84 b4 00 00 00    	je     5f0 <printf+0x150>
-  write(fd, &c, 1);
- 53c:	83 ec 04             	sub    $0x4,%esp
- 53f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 543:	6a 01                	push   $0x1
- 545:	57                   	push   %edi
- 546:	ff 75 08             	pushl  0x8(%ebp)
- 549:	e8 b5 fd ff ff       	call   303 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 54e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 551:	83 c4 0c             	add    $0xc,%esp
- 554:	6a 01                	push   $0x1
- 556:	83 c6 01             	add    $0x1,%esi
- 559:	57                   	push   %edi
- 55a:	ff 75 08             	pushl  0x8(%ebp)
- 55d:	e8 a1 fd ff ff       	call   303 <write>
-  for(i = 0; fmt[i]; i++){
- 562:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 566:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 569:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 56b:	84 db                	test   %bl,%bl
- 56d:	75 8f                	jne    4fe <printf+0x5e>
-    }
-  }
-}
- 56f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 572:	5b                   	pop    %ebx
- 573:	5e                   	pop    %esi
- 574:	5f                   	pop    %edi
- 575:	5d                   	pop    %ebp
- 576:	c3                   	ret    
- 577:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 57e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 580:	83 ec 0c             	sub    $0xc,%esp
- 583:	b9 10 00 00 00       	mov    $0x10,%ecx
- 588:	6a 00                	push   $0x0
- 58a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 58d:	8b 45 08             	mov    0x8(%ebp),%eax
- 590:	8b 13                	mov    (%ebx),%edx
- 592:	e8 59 fe ff ff       	call   3f0 <printint>
-        ap++;
- 597:	89 d8                	mov    %ebx,%eax
- 599:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 59c:	31 d2                	xor    %edx,%edx
-        ap++;
- 59e:	83 c0 04             	add    $0x4,%eax
- 5a1:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 5a4:	e9 4b ff ff ff       	jmp    4f4 <printf+0x54>
- 5a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 5b0:	83 ec 0c             	sub    $0xc,%esp
- 5b3:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 5b8:	6a 01                	push   $0x1
- 5ba:	eb ce                	jmp    58a <printf+0xea>
- 5bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 5c0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 5c3:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 5c6:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 5c8:	6a 01                	push   $0x1
-        ap++;
- 5ca:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 5cd:	57                   	push   %edi
- 5ce:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 5d1:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 5d4:	e8 2a fd ff ff       	call   303 <write>
-        ap++;
- 5d9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 5dc:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 5df:	31 d2                	xor    %edx,%edx
- 5e1:	e9 0e ff ff ff       	jmp    4f4 <printf+0x54>
- 5e6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5ed:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 5f0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5f3:	83 ec 04             	sub    $0x4,%esp
- 5f6:	e9 59 ff ff ff       	jmp    554 <printf+0xb4>
- 5fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 5ff:	90                   	nop
-        s = (char*)*ap;
- 600:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 603:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 605:	83 c0 04             	add    $0x4,%eax
- 608:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 60b:	85 db                	test   %ebx,%ebx
- 60d:	74 17                	je     626 <printf+0x186>
-        while(*s != 0){
- 60f:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 612:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 614:	84 c0                	test   %al,%al
- 616:	0f 84 d8 fe ff ff    	je     4f4 <printf+0x54>
- 61c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 61f:	89 de                	mov    %ebx,%esi
- 621:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 624:	eb 1a                	jmp    640 <printf+0x1a0>
-          s = "(null)";
- 626:	bb 35 08 00 00       	mov    $0x835,%ebx
-        while(*s != 0){
- 62b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 62e:	b8 28 00 00 00       	mov    $0x28,%eax
- 633:	89 de                	mov    %ebx,%esi
- 635:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 638:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 63f:	90                   	nop
-  write(fd, &c, 1);
- 640:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 643:	83 c6 01             	add    $0x1,%esi
- 646:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 649:	6a 01                	push   $0x1
- 64b:	57                   	push   %edi
- 64c:	53                   	push   %ebx
- 64d:	e8 b1 fc ff ff       	call   303 <write>
-        while(*s != 0){
- 652:	0f b6 06             	movzbl (%esi),%eax
- 655:	83 c4 10             	add    $0x10,%esp
- 658:	84 c0                	test   %al,%al
- 65a:	75 e4                	jne    640 <printf+0x1a0>
- 65c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 65f:	31 d2                	xor    %edx,%edx
- 661:	e9 8e fe ff ff       	jmp    4f4 <printf+0x54>
- 666:	66 90                	xchg   %ax,%ax
- 668:	66 90                	xchg   %ax,%ax
- 66a:	66 90                	xchg   %ax,%ax
- 66c:	66 90                	xchg   %ax,%ax
- 66e:	66 90                	xchg   %ax,%ax
-
-00000670 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 670:	f3 0f 1e fb          	endbr32 
- 674:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 675:	a1 f4 0a 00 00       	mov    0xaf4,%eax
-{
- 67a:	89 e5                	mov    %esp,%ebp
- 67c:	57                   	push   %edi
- 67d:	56                   	push   %esi
- 67e:	53                   	push   %ebx
- 67f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 682:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 684:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 687:	39 c8                	cmp    %ecx,%eax
- 689:	73 15                	jae    6a0 <free+0x30>
- 68b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 68f:	90                   	nop
- 690:	39 d1                	cmp    %edx,%ecx
- 692:	72 14                	jb     6a8 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 694:	39 d0                	cmp    %edx,%eax
- 696:	73 10                	jae    6a8 <free+0x38>
-{
- 698:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 69a:	8b 10                	mov    (%eax),%edx
- 69c:	39 c8                	cmp    %ecx,%eax
- 69e:	72 f0                	jb     690 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 6a0:	39 d0                	cmp    %edx,%eax
- 6a2:	72 f4                	jb     698 <free+0x28>
- 6a4:	39 d1                	cmp    %edx,%ecx
- 6a6:	73 f0                	jae    698 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 6a8:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 6ab:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 6ae:	39 fa                	cmp    %edi,%edx
- 6b0:	74 1e                	je     6d0 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 6b2:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 6b5:	8b 50 04             	mov    0x4(%eax),%edx
- 6b8:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6bb:	39 f1                	cmp    %esi,%ecx
- 6bd:	74 28                	je     6e7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 6bf:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 6c1:	5b                   	pop    %ebx
-  freep = p;
- 6c2:	a3 f4 0a 00 00       	mov    %eax,0xaf4
-}
- 6c7:	5e                   	pop    %esi
- 6c8:	5f                   	pop    %edi
- 6c9:	5d                   	pop    %ebp
- 6ca:	c3                   	ret    
- 6cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 6cf:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 6d0:	03 72 04             	add    0x4(%edx),%esi
- 6d3:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 6d6:	8b 10                	mov    (%eax),%edx
- 6d8:	8b 12                	mov    (%edx),%edx
- 6da:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 6dd:	8b 50 04             	mov    0x4(%eax),%edx
- 6e0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 6e3:	39 f1                	cmp    %esi,%ecx
- 6e5:	75 d8                	jne    6bf <free+0x4f>
-    p->s.size += bp->s.size;
- 6e7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 6ea:	a3 f4 0a 00 00       	mov    %eax,0xaf4
-    p->s.size += bp->s.size;
- 6ef:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 6f2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 6f5:	89 10                	mov    %edx,(%eax)
-}
- 6f7:	5b                   	pop    %ebx
- 6f8:	5e                   	pop    %esi
- 6f9:	5f                   	pop    %edi
- 6fa:	5d                   	pop    %ebp
- 6fb:	c3                   	ret    
- 6fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000700 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 700:	f3 0f 1e fb          	endbr32 
- 704:	55                   	push   %ebp
- 705:	89 e5                	mov    %esp,%ebp
- 707:	57                   	push   %edi
- 708:	56                   	push   %esi
- 709:	53                   	push   %ebx
- 70a:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 70d:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 710:	8b 3d f4 0a 00 00    	mov    0xaf4,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 716:	8d 70 07             	lea    0x7(%eax),%esi
- 719:	c1 ee 03             	shr    $0x3,%esi
- 71c:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 71f:	85 ff                	test   %edi,%edi
- 721:	0f 84 a9 00 00 00    	je     7d0 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 727:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 729:	8b 48 04             	mov    0x4(%eax),%ecx
- 72c:	39 f1                	cmp    %esi,%ecx
- 72e:	73 6d                	jae    79d <malloc+0x9d>
- 730:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 736:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 73b:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 73e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 745:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 748:	eb 17                	jmp    761 <malloc+0x61>
- 74a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 750:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 752:	8b 4a 04             	mov    0x4(%edx),%ecx
- 755:	39 f1                	cmp    %esi,%ecx
- 757:	73 4f                	jae    7a8 <malloc+0xa8>
- 759:	8b 3d f4 0a 00 00    	mov    0xaf4,%edi
- 75f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 761:	39 c7                	cmp    %eax,%edi
- 763:	75 eb                	jne    750 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 765:	83 ec 0c             	sub    $0xc,%esp
- 768:	ff 75 e4             	pushl  -0x1c(%ebp)
- 76b:	e8 fb fb ff ff       	call   36b <sbrk>
-  if(p == (char*)-1)
- 770:	83 c4 10             	add    $0x10,%esp
- 773:	83 f8 ff             	cmp    $0xffffffff,%eax
- 776:	74 1b                	je     793 <malloc+0x93>
-  hp->s.size = nu;
- 778:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 77b:	83 ec 0c             	sub    $0xc,%esp
- 77e:	83 c0 08             	add    $0x8,%eax
- 781:	50                   	push   %eax
- 782:	e8 e9 fe ff ff       	call   670 <free>
-  return freep;
- 787:	a1 f4 0a 00 00       	mov    0xaf4,%eax
-      if((p = morecore(nunits)) == 0)
- 78c:	83 c4 10             	add    $0x10,%esp
- 78f:	85 c0                	test   %eax,%eax
- 791:	75 bd                	jne    750 <malloc+0x50>
-        return 0;
-  }
-}
- 793:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 796:	31 c0                	xor    %eax,%eax
-}
- 798:	5b                   	pop    %ebx
- 799:	5e                   	pop    %esi
- 79a:	5f                   	pop    %edi
- 79b:	5d                   	pop    %ebp
- 79c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 79d:	89 c2                	mov    %eax,%edx
- 79f:	89 f8                	mov    %edi,%eax
- 7a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 7a8:	39 ce                	cmp    %ecx,%esi
- 7aa:	74 54                	je     800 <malloc+0x100>
-        p->s.size -= nunits;
- 7ac:	29 f1                	sub    %esi,%ecx
- 7ae:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 7b1:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 7b4:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 7b7:	a3 f4 0a 00 00       	mov    %eax,0xaf4
-}
- 7bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 7bf:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 7c2:	5b                   	pop    %ebx
- 7c3:	5e                   	pop    %esi
- 7c4:	5f                   	pop    %edi
- 7c5:	5d                   	pop    %ebp
- 7c6:	c3                   	ret    
- 7c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 7ce:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 7d0:	c7 05 f4 0a 00 00 f8 	movl   $0xaf8,0xaf4
- 7d7:	0a 00 00 
-    base.s.size = 0;
- 7da:	bf f8 0a 00 00       	mov    $0xaf8,%edi
-    base.s.ptr = freep = prevp = &base;
- 7df:	c7 05 f8 0a 00 00 f8 	movl   $0xaf8,0xaf8
- 7e6:	0a 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7e9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 7eb:	c7 05 fc 0a 00 00 00 	movl   $0x0,0xafc
- 7f2:	00 00 00 
-    if(p->s.size >= nunits){
- 7f5:	e9 36 ff ff ff       	jmp    730 <malloc+0x30>
- 7fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 800:	8b 0a                	mov    (%edx),%ecx
- 802:	89 08                	mov    %ecx,(%eax)
- 804:	eb b1                	jmp    7b7 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/rm.c b/xv6-public/Operating-System-Project/rm.c
deleted file mode 100644
index 4fd33c8..0000000
--- a/xv6-public/Operating-System-Project/rm.c
+++ /dev/null
@@ -1,23 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char *argv[])
-{
-  int i;
-
-  if(argc < 2){
-    printf(2, "Usage: rm files...\n");
-    exit();
-  }
-
-  for(i = 1; i < argc; i++){
-    if(unlink(argv[i]) < 0){
-      printf(2, "rm: %s failed to delete\n", argv[i]);
-      break;
-    }
-  }
-
-  exit();
-}
diff --git a/xv6-public/Operating-System-Project/rm.d b/xv6-public/Operating-System-Project/rm.d
deleted file mode 100644
index ba50b6b..0000000
--- a/xv6-public/Operating-System-Project/rm.d
+++ /dev/null
@@ -1 +0,0 @@
-rm.o: rm.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/rm.o b/xv6-public/Operating-System-Project/rm.o
deleted file mode 100644
index dec4ed2..0000000
Binary files a/xv6-public/Operating-System-Project/rm.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/rm.sym b/xv6-public/Operating-System-Project/rm.sym
deleted file mode 100644
index 3fdc47e..0000000
--- a/xv6-public/Operating-System-Project/rm.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-00000808 .rodata
-00000850 .eh_frame
-00000af4 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 rm.c
-00000000 ulib.c
-00000000 printf.c
-000003f0 printint
-0000083c digits.1109
-00000000 umalloc.c
-00000af4 freep
-00000af8 base
-00000080 strcpy
-0000038b getChildren
-000004a0 printf
-000002b0 memmove
-0000032b mknod
-000001a0 gets
-00000363 getpid
-000003c3 customWait
-000003bb getCBT
-00000700 malloc
-00000373 sleep
-000002f3 pipe
-000003a3 changePolicy
-00000303 write
-0000033b fstat
-00000313 kill
-00000353 chdir
-000003cb setQueue
-0000031b exec
-000002eb wait
-000002fb read
-000003d3 getBurstTime
-00000333 unlink
-000002db fork
-000003ab getTurnAroundTime
-0000036b sbrk
-0000037b uptime
-00000af4 __bss_start
-00000140 memset
-00000000 main
-000000b0 strcmp
-0000035b dup
-00000393 getSyscallCounter
-00000383 getParentID
-00000220 stat
-00000af4 _edata
-00000b00 _end
-00000343 link
-000002e3 exit
-0000039b setPriority
-00000270 atoi
-000003db getCreationTime
-00000100 strlen
-00000323 open
-00000160 strchr
-0000034b mkdir
-0000030b close
-000003b3 getWaitingTime
-00000670 free
diff --git a/xv6-public/Operating-System-Project/roundRobinTest.asm b/xv6-public/Operating-System-Project/roundRobinTest.asm
deleted file mode 100644
index ef22053..0000000
--- a/xv6-public/Operating-System-Project/roundRobinTest.asm
+++ /dev/null
@@ -1,1338 +0,0 @@
-
-_roundRobinTest:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	57                   	push   %edi
-  12:	56                   	push   %esi
-  13:	53                   	push   %ebx
-    changePolicy(1);
-
-    int main_pid = getpid();
-  14:	bb 0a 00 00 00       	mov    $0xa,%ebx
-{
-  19:	51                   	push   %ecx
-  1a:	83 ec 14             	sub    $0x14,%esp
-    changePolicy(1);
-  1d:	6a 01                	push   $0x1
-  1f:	e8 ff 03 00 00       	call   423 <changePolicy>
-    int main_pid = getpid();
-  24:	e8 ba 03 00 00       	call   3e3 <getpid>
-  29:	83 c4 10             	add    $0x10,%esp
-  2c:	89 c6                	mov    %eax,%esi
-    for (int i = 0; i < 10; i++)
-  2e:	66 90                	xchg   %ax,%ax
-    {
-        if (fork() > 0)
-  30:	e8 26 03 00 00       	call   35b <fork>
-  35:	85 c0                	test   %eax,%eax
-  37:	7f 05                	jg     3e <main+0x3e>
-    for (int i = 0; i < 10; i++)
-  39:	83 eb 01             	sub    $0x1,%ebx
-  3c:	75 f2                	jne    30 <main+0x30>
-            break;
-    }
-
-    if (main_pid != getpid())
-  3e:	e8 a0 03 00 00       	call   3e3 <getpid>
-  43:	39 f0                	cmp    %esi,%eax
-  45:	0f 84 a5 00 00 00    	je     f0 <main+0xf0>
-    {
-        for (int i = 0; i < 100; i++)
-  4b:	31 db                	xor    %ebx,%ebx
-  4d:	8d 76 00             	lea    0x0(%esi),%esi
-            printf(1, "/%d/: %d\n", getpid(), i);
-  50:	e8 8e 03 00 00       	call   3e3 <getpid>
-  55:	53                   	push   %ebx
-        for (int i = 0; i < 100; i++)
-  56:	83 c3 01             	add    $0x1,%ebx
-            printf(1, "/%d/: %d\n", getpid(), i);
-  59:	50                   	push   %eax
-  5a:	68 88 08 00 00       	push   $0x888
-  5f:	6a 01                	push   $0x1
-  61:	e8 ba 04 00 00       	call   520 <printf>
-        for (int i = 0; i < 100; i++)
-  66:	83 c4 10             	add    $0x10,%esp
-  69:	83 fb 64             	cmp    $0x64,%ebx
-  6c:	75 e2                	jne    50 <main+0x50>
-
-        int turnAroundTime = getTurnAroundTime(getpid());
-  6e:	e8 70 03 00 00       	call   3e3 <getpid>
-  73:	83 ec 0c             	sub    $0xc,%esp
-  76:	50                   	push   %eax
-  77:	e8 af 03 00 00       	call   42b <getTurnAroundTime>
-  7c:	89 c7                	mov    %eax,%edi
-        int waitingTime = getWaitingTime(getpid());
-  7e:	e8 60 03 00 00       	call   3e3 <getpid>
-  83:	89 04 24             	mov    %eax,(%esp)
-  86:	e8 a8 03 00 00       	call   433 <getWaitingTime>
-  8b:	89 c6                	mov    %eax,%esi
-        int CBT = getCBT(getpid());
-  8d:	e8 51 03 00 00       	call   3e3 <getpid>
-  92:	89 04 24             	mov    %eax,(%esp)
-  95:	e8 a1 03 00 00       	call   43b <getCBT>
-  9a:	89 c3                	mov    %eax,%ebx
-
-        wait();
-  9c:	e8 ca 02 00 00       	call   36b <wait>
-
-        printf(1, "turnAroundTime for process /%d/ is :%d\n", getpid(), turnAroundTime);
-  a1:	e8 3d 03 00 00       	call   3e3 <getpid>
-  a6:	57                   	push   %edi
-  a7:	50                   	push   %eax
-  a8:	68 b4 08 00 00       	push   $0x8b4
-  ad:	6a 01                	push   $0x1
-  af:	e8 6c 04 00 00       	call   520 <printf>
-        printf(1, "waitingTime for process /%d/ is :%d\n", getpid(), waitingTime);
-  b4:	83 c4 20             	add    $0x20,%esp
-  b7:	e8 27 03 00 00       	call   3e3 <getpid>
-  bc:	56                   	push   %esi
-  bd:	50                   	push   %eax
-  be:	68 dc 08 00 00       	push   $0x8dc
-  c3:	6a 01                	push   $0x1
-  c5:	e8 56 04 00 00       	call   520 <printf>
-        printf(1, "CBT for process /%d/ is :%d\n", getpid(), CBT);
-  ca:	e8 14 03 00 00       	call   3e3 <getpid>
-  cf:	53                   	push   %ebx
-  d0:	50                   	push   %eax
-  d1:	68 92 08 00 00       	push   $0x892
-  d6:	6a 01                	push   $0x1
-  d8:	e8 43 04 00 00       	call   520 <printf>
-        printf(1, "\n\n");
-  dd:	83 c4 18             	add    $0x18,%esp
-  e0:	68 af 08 00 00       	push   $0x8af
-  e5:	6a 01                	push   $0x1
-  e7:	e8 34 04 00 00       	call   520 <printf>
-  ec:	83 c4 10             	add    $0x10,%esp
-  ef:	90                   	nop
-    }
-
-    while (wait() != -1)
-  f0:	e8 76 02 00 00       	call   36b <wait>
-  f5:	83 f8 ff             	cmp    $0xffffffff,%eax
-  f8:	75 f6                	jne    f0 <main+0xf0>
-    {
-        ;
-    }
-
-    exit();
-  fa:	e8 64 02 00 00       	call   363 <exit>
-  ff:	90                   	nop
-
-00000100 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
- 100:	f3 0f 1e fb          	endbr32 
- 104:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
- 105:	31 c0                	xor    %eax,%eax
-{
- 107:	89 e5                	mov    %esp,%ebp
- 109:	53                   	push   %ebx
- 10a:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 10d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
- 110:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
- 114:	88 14 01             	mov    %dl,(%ecx,%eax,1)
- 117:	83 c0 01             	add    $0x1,%eax
- 11a:	84 d2                	test   %dl,%dl
- 11c:	75 f2                	jne    110 <strcpy+0x10>
-    ;
-  return os;
-}
- 11e:	89 c8                	mov    %ecx,%eax
- 120:	5b                   	pop    %ebx
- 121:	5d                   	pop    %ebp
- 122:	c3                   	ret    
- 123:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 12a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000130 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
- 130:	f3 0f 1e fb          	endbr32 
- 134:	55                   	push   %ebp
- 135:	89 e5                	mov    %esp,%ebp
- 137:	53                   	push   %ebx
- 138:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 13b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
- 13e:	0f b6 01             	movzbl (%ecx),%eax
- 141:	0f b6 1a             	movzbl (%edx),%ebx
- 144:	84 c0                	test   %al,%al
- 146:	75 19                	jne    161 <strcmp+0x31>
- 148:	eb 26                	jmp    170 <strcmp+0x40>
- 14a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 150:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
- 154:	83 c1 01             	add    $0x1,%ecx
- 157:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
- 15a:	0f b6 1a             	movzbl (%edx),%ebx
- 15d:	84 c0                	test   %al,%al
- 15f:	74 0f                	je     170 <strcmp+0x40>
- 161:	38 d8                	cmp    %bl,%al
- 163:	74 eb                	je     150 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
- 165:	29 d8                	sub    %ebx,%eax
-}
- 167:	5b                   	pop    %ebx
- 168:	5d                   	pop    %ebp
- 169:	c3                   	ret    
- 16a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 170:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
- 172:	29 d8                	sub    %ebx,%eax
-}
- 174:	5b                   	pop    %ebx
- 175:	5d                   	pop    %ebp
- 176:	c3                   	ret    
- 177:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 17e:	66 90                	xchg   %ax,%ax
-
-00000180 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 180:	f3 0f 1e fb          	endbr32 
- 184:	55                   	push   %ebp
- 185:	89 e5                	mov    %esp,%ebp
- 187:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 18a:	80 3a 00             	cmpb   $0x0,(%edx)
- 18d:	74 21                	je     1b0 <strlen+0x30>
- 18f:	31 c0                	xor    %eax,%eax
- 191:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 198:	83 c0 01             	add    $0x1,%eax
- 19b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 19f:	89 c1                	mov    %eax,%ecx
- 1a1:	75 f5                	jne    198 <strlen+0x18>
-    ;
-  return n;
-}
- 1a3:	89 c8                	mov    %ecx,%eax
- 1a5:	5d                   	pop    %ebp
- 1a6:	c3                   	ret    
- 1a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1ae:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 1b0:	31 c9                	xor    %ecx,%ecx
-}
- 1b2:	5d                   	pop    %ebp
- 1b3:	89 c8                	mov    %ecx,%eax
- 1b5:	c3                   	ret    
- 1b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1bd:	8d 76 00             	lea    0x0(%esi),%esi
-
-000001c0 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 1c0:	f3 0f 1e fb          	endbr32 
- 1c4:	55                   	push   %ebp
- 1c5:	89 e5                	mov    %esp,%ebp
- 1c7:	57                   	push   %edi
- 1c8:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 1cb:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 1ce:	8b 45 0c             	mov    0xc(%ebp),%eax
- 1d1:	89 d7                	mov    %edx,%edi
- 1d3:	fc                   	cld    
- 1d4:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 1d6:	89 d0                	mov    %edx,%eax
- 1d8:	5f                   	pop    %edi
- 1d9:	5d                   	pop    %ebp
- 1da:	c3                   	ret    
- 1db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 1df:	90                   	nop
-
-000001e0 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 1e0:	f3 0f 1e fb          	endbr32 
- 1e4:	55                   	push   %ebp
- 1e5:	89 e5                	mov    %esp,%ebp
- 1e7:	8b 45 08             	mov    0x8(%ebp),%eax
- 1ea:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 1ee:	0f b6 10             	movzbl (%eax),%edx
- 1f1:	84 d2                	test   %dl,%dl
- 1f3:	75 16                	jne    20b <strchr+0x2b>
- 1f5:	eb 21                	jmp    218 <strchr+0x38>
- 1f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1fe:	66 90                	xchg   %ax,%ax
- 200:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 204:	83 c0 01             	add    $0x1,%eax
- 207:	84 d2                	test   %dl,%dl
- 209:	74 0d                	je     218 <strchr+0x38>
-    if(*s == c)
- 20b:	38 d1                	cmp    %dl,%cl
- 20d:	75 f1                	jne    200 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 20f:	5d                   	pop    %ebp
- 210:	c3                   	ret    
- 211:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 218:	31 c0                	xor    %eax,%eax
-}
- 21a:	5d                   	pop    %ebp
- 21b:	c3                   	ret    
- 21c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000220 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 220:	f3 0f 1e fb          	endbr32 
- 224:	55                   	push   %ebp
- 225:	89 e5                	mov    %esp,%ebp
- 227:	57                   	push   %edi
- 228:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 229:	31 f6                	xor    %esi,%esi
-{
- 22b:	53                   	push   %ebx
- 22c:	89 f3                	mov    %esi,%ebx
- 22e:	83 ec 1c             	sub    $0x1c,%esp
- 231:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 234:	eb 33                	jmp    269 <gets+0x49>
- 236:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 23d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 240:	83 ec 04             	sub    $0x4,%esp
- 243:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 246:	6a 01                	push   $0x1
- 248:	50                   	push   %eax
- 249:	6a 00                	push   $0x0
- 24b:	e8 2b 01 00 00       	call   37b <read>
-    if(cc < 1)
- 250:	83 c4 10             	add    $0x10,%esp
- 253:	85 c0                	test   %eax,%eax
- 255:	7e 1c                	jle    273 <gets+0x53>
-      break;
-    buf[i++] = c;
- 257:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 25b:	83 c7 01             	add    $0x1,%edi
- 25e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 261:	3c 0a                	cmp    $0xa,%al
- 263:	74 23                	je     288 <gets+0x68>
- 265:	3c 0d                	cmp    $0xd,%al
- 267:	74 1f                	je     288 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 269:	83 c3 01             	add    $0x1,%ebx
- 26c:	89 fe                	mov    %edi,%esi
- 26e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 271:	7c cd                	jl     240 <gets+0x20>
- 273:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 275:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 278:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 27b:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 27e:	5b                   	pop    %ebx
- 27f:	5e                   	pop    %esi
- 280:	5f                   	pop    %edi
- 281:	5d                   	pop    %ebp
- 282:	c3                   	ret    
- 283:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 287:	90                   	nop
- 288:	8b 75 08             	mov    0x8(%ebp),%esi
- 28b:	8b 45 08             	mov    0x8(%ebp),%eax
- 28e:	01 de                	add    %ebx,%esi
- 290:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 292:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 295:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 298:	5b                   	pop    %ebx
- 299:	5e                   	pop    %esi
- 29a:	5f                   	pop    %edi
- 29b:	5d                   	pop    %ebp
- 29c:	c3                   	ret    
- 29d:	8d 76 00             	lea    0x0(%esi),%esi
-
-000002a0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 2a0:	f3 0f 1e fb          	endbr32 
- 2a4:	55                   	push   %ebp
- 2a5:	89 e5                	mov    %esp,%ebp
- 2a7:	56                   	push   %esi
- 2a8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 2a9:	83 ec 08             	sub    $0x8,%esp
- 2ac:	6a 00                	push   $0x0
- 2ae:	ff 75 08             	pushl  0x8(%ebp)
- 2b1:	e8 ed 00 00 00       	call   3a3 <open>
-  if(fd < 0)
- 2b6:	83 c4 10             	add    $0x10,%esp
- 2b9:	85 c0                	test   %eax,%eax
- 2bb:	78 2b                	js     2e8 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 2bd:	83 ec 08             	sub    $0x8,%esp
- 2c0:	ff 75 0c             	pushl  0xc(%ebp)
- 2c3:	89 c3                	mov    %eax,%ebx
- 2c5:	50                   	push   %eax
- 2c6:	e8 f0 00 00 00       	call   3bb <fstat>
-  close(fd);
- 2cb:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 2ce:	89 c6                	mov    %eax,%esi
-  close(fd);
- 2d0:	e8 b6 00 00 00       	call   38b <close>
-  return r;
- 2d5:	83 c4 10             	add    $0x10,%esp
-}
- 2d8:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 2db:	89 f0                	mov    %esi,%eax
- 2dd:	5b                   	pop    %ebx
- 2de:	5e                   	pop    %esi
- 2df:	5d                   	pop    %ebp
- 2e0:	c3                   	ret    
- 2e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 2e8:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 2ed:	eb e9                	jmp    2d8 <stat+0x38>
- 2ef:	90                   	nop
-
-000002f0 <atoi>:
-
-int
-atoi(const char *s)
-{
- 2f0:	f3 0f 1e fb          	endbr32 
- 2f4:	55                   	push   %ebp
- 2f5:	89 e5                	mov    %esp,%ebp
- 2f7:	53                   	push   %ebx
- 2f8:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 2fb:	0f be 02             	movsbl (%edx),%eax
- 2fe:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 301:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 304:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 309:	77 1a                	ja     325 <atoi+0x35>
- 30b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 30f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 310:	83 c2 01             	add    $0x1,%edx
- 313:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 316:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 31a:	0f be 02             	movsbl (%edx),%eax
- 31d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 320:	80 fb 09             	cmp    $0x9,%bl
- 323:	76 eb                	jbe    310 <atoi+0x20>
-  return n;
-}
- 325:	89 c8                	mov    %ecx,%eax
- 327:	5b                   	pop    %ebx
- 328:	5d                   	pop    %ebp
- 329:	c3                   	ret    
- 32a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000330 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 330:	f3 0f 1e fb          	endbr32 
- 334:	55                   	push   %ebp
- 335:	89 e5                	mov    %esp,%ebp
- 337:	57                   	push   %edi
- 338:	8b 45 10             	mov    0x10(%ebp),%eax
- 33b:	8b 55 08             	mov    0x8(%ebp),%edx
- 33e:	56                   	push   %esi
- 33f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 342:	85 c0                	test   %eax,%eax
- 344:	7e 0f                	jle    355 <memmove+0x25>
- 346:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 348:	89 d7                	mov    %edx,%edi
- 34a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 350:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 351:	39 f8                	cmp    %edi,%eax
- 353:	75 fb                	jne    350 <memmove+0x20>
-  return vdst;
-}
- 355:	5e                   	pop    %esi
- 356:	89 d0                	mov    %edx,%eax
- 358:	5f                   	pop    %edi
- 359:	5d                   	pop    %ebp
- 35a:	c3                   	ret    
-
-0000035b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 35b:	b8 01 00 00 00       	mov    $0x1,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <exit>:
-SYSCALL(exit)
- 363:	b8 02 00 00 00       	mov    $0x2,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <wait>:
-SYSCALL(wait)
- 36b:	b8 03 00 00 00       	mov    $0x3,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <pipe>:
-SYSCALL(pipe)
- 373:	b8 04 00 00 00       	mov    $0x4,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <read>:
-SYSCALL(read)
- 37b:	b8 05 00 00 00       	mov    $0x5,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <write>:
-SYSCALL(write)
- 383:	b8 10 00 00 00       	mov    $0x10,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <close>:
-SYSCALL(close)
- 38b:	b8 15 00 00 00       	mov    $0x15,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
-
-00000393 <kill>:
-SYSCALL(kill)
- 393:	b8 06 00 00 00       	mov    $0x6,%eax
- 398:	cd 40                	int    $0x40
- 39a:	c3                   	ret    
-
-0000039b <exec>:
-SYSCALL(exec)
- 39b:	b8 07 00 00 00       	mov    $0x7,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
-
-000003a3 <open>:
-SYSCALL(open)
- 3a3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 3a8:	cd 40                	int    $0x40
- 3aa:	c3                   	ret    
-
-000003ab <mknod>:
-SYSCALL(mknod)
- 3ab:	b8 11 00 00 00       	mov    $0x11,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
-
-000003b3 <unlink>:
-SYSCALL(unlink)
- 3b3:	b8 12 00 00 00       	mov    $0x12,%eax
- 3b8:	cd 40                	int    $0x40
- 3ba:	c3                   	ret    
-
-000003bb <fstat>:
-SYSCALL(fstat)
- 3bb:	b8 08 00 00 00       	mov    $0x8,%eax
- 3c0:	cd 40                	int    $0x40
- 3c2:	c3                   	ret    
-
-000003c3 <link>:
-SYSCALL(link)
- 3c3:	b8 13 00 00 00       	mov    $0x13,%eax
- 3c8:	cd 40                	int    $0x40
- 3ca:	c3                   	ret    
-
-000003cb <mkdir>:
-SYSCALL(mkdir)
- 3cb:	b8 14 00 00 00       	mov    $0x14,%eax
- 3d0:	cd 40                	int    $0x40
- 3d2:	c3                   	ret    
-
-000003d3 <chdir>:
-SYSCALL(chdir)
- 3d3:	b8 09 00 00 00       	mov    $0x9,%eax
- 3d8:	cd 40                	int    $0x40
- 3da:	c3                   	ret    
-
-000003db <dup>:
-SYSCALL(dup)
- 3db:	b8 0a 00 00 00       	mov    $0xa,%eax
- 3e0:	cd 40                	int    $0x40
- 3e2:	c3                   	ret    
-
-000003e3 <getpid>:
-SYSCALL(getpid)
- 3e3:	b8 0b 00 00 00       	mov    $0xb,%eax
- 3e8:	cd 40                	int    $0x40
- 3ea:	c3                   	ret    
-
-000003eb <sbrk>:
-SYSCALL(sbrk)
- 3eb:	b8 0c 00 00 00       	mov    $0xc,%eax
- 3f0:	cd 40                	int    $0x40
- 3f2:	c3                   	ret    
-
-000003f3 <sleep>:
-SYSCALL(sleep)
- 3f3:	b8 0d 00 00 00       	mov    $0xd,%eax
- 3f8:	cd 40                	int    $0x40
- 3fa:	c3                   	ret    
-
-000003fb <uptime>:
-SYSCALL(uptime)
- 3fb:	b8 0e 00 00 00       	mov    $0xe,%eax
- 400:	cd 40                	int    $0x40
- 402:	c3                   	ret    
-
-00000403 <getParentID>:
-SYSCALL(getParentID)
- 403:	b8 16 00 00 00       	mov    $0x16,%eax
- 408:	cd 40                	int    $0x40
- 40a:	c3                   	ret    
-
-0000040b <getChildren>:
-SYSCALL(getChildren)
- 40b:	b8 17 00 00 00       	mov    $0x17,%eax
- 410:	cd 40                	int    $0x40
- 412:	c3                   	ret    
-
-00000413 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 413:	b8 18 00 00 00       	mov    $0x18,%eax
- 418:	cd 40                	int    $0x40
- 41a:	c3                   	ret    
-
-0000041b <setPriority>:
-SYSCALL(setPriority)
- 41b:	b8 19 00 00 00       	mov    $0x19,%eax
- 420:	cd 40                	int    $0x40
- 422:	c3                   	ret    
-
-00000423 <changePolicy>:
-SYSCALL(changePolicy)
- 423:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 428:	cd 40                	int    $0x40
- 42a:	c3                   	ret    
-
-0000042b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 42b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 430:	cd 40                	int    $0x40
- 432:	c3                   	ret    
-
-00000433 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 433:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 438:	cd 40                	int    $0x40
- 43a:	c3                   	ret    
-
-0000043b <getCBT>:
-SYSCALL(getCBT)
- 43b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 440:	cd 40                	int    $0x40
- 442:	c3                   	ret    
-
-00000443 <customWait>:
-SYSCALL(customWait)
- 443:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 448:	cd 40                	int    $0x40
- 44a:	c3                   	ret    
-
-0000044b <setQueue>:
-SYSCALL(setQueue)
- 44b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 450:	cd 40                	int    $0x40
- 452:	c3                   	ret    
-
-00000453 <getBurstTime>:
-SYSCALL(getBurstTime)
- 453:	b8 20 00 00 00       	mov    $0x20,%eax
- 458:	cd 40                	int    $0x40
- 45a:	c3                   	ret    
-
-0000045b <getCreationTime>:
- 45b:	b8 21 00 00 00       	mov    $0x21,%eax
- 460:	cd 40                	int    $0x40
- 462:	c3                   	ret    
- 463:	66 90                	xchg   %ax,%ax
- 465:	66 90                	xchg   %ax,%ax
- 467:	66 90                	xchg   %ax,%ax
- 469:	66 90                	xchg   %ax,%ax
- 46b:	66 90                	xchg   %ax,%ax
- 46d:	66 90                	xchg   %ax,%ax
- 46f:	90                   	nop
-
-00000470 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 470:	55                   	push   %ebp
- 471:	89 e5                	mov    %esp,%ebp
- 473:	57                   	push   %edi
- 474:	56                   	push   %esi
- 475:	53                   	push   %ebx
- 476:	83 ec 3c             	sub    $0x3c,%esp
- 479:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 47c:	89 d1                	mov    %edx,%ecx
-{
- 47e:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 481:	85 d2                	test   %edx,%edx
- 483:	0f 89 7f 00 00 00    	jns    508 <printint+0x98>
- 489:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 48d:	74 79                	je     508 <printint+0x98>
-    neg = 1;
- 48f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 496:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 498:	31 db                	xor    %ebx,%ebx
- 49a:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 49d:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 4a0:	89 c8                	mov    %ecx,%eax
- 4a2:	31 d2                	xor    %edx,%edx
- 4a4:	89 cf                	mov    %ecx,%edi
- 4a6:	f7 75 c4             	divl   -0x3c(%ebp)
- 4a9:	0f b6 92 08 09 00 00 	movzbl 0x908(%edx),%edx
- 4b0:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 4b3:	89 d8                	mov    %ebx,%eax
- 4b5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 4b8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 4bb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 4be:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 4c1:	76 dd                	jbe    4a0 <printint+0x30>
-  if(neg)
- 4c3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 4c6:	85 c9                	test   %ecx,%ecx
- 4c8:	74 0c                	je     4d6 <printint+0x66>
-    buf[i++] = '-';
- 4ca:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 4cf:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 4d1:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 4d6:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 4d9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 4dd:	eb 07                	jmp    4e6 <printint+0x76>
- 4df:	90                   	nop
- 4e0:	0f b6 13             	movzbl (%ebx),%edx
- 4e3:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 4e6:	83 ec 04             	sub    $0x4,%esp
- 4e9:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 4ec:	6a 01                	push   $0x1
- 4ee:	56                   	push   %esi
- 4ef:	57                   	push   %edi
- 4f0:	e8 8e fe ff ff       	call   383 <write>
-  while(--i >= 0)
- 4f5:	83 c4 10             	add    $0x10,%esp
- 4f8:	39 de                	cmp    %ebx,%esi
- 4fa:	75 e4                	jne    4e0 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 4fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 4ff:	5b                   	pop    %ebx
- 500:	5e                   	pop    %esi
- 501:	5f                   	pop    %edi
- 502:	5d                   	pop    %ebp
- 503:	c3                   	ret    
- 504:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 508:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 50f:	eb 87                	jmp    498 <printint+0x28>
- 511:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 518:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 51f:	90                   	nop
-
-00000520 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 520:	f3 0f 1e fb          	endbr32 
- 524:	55                   	push   %ebp
- 525:	89 e5                	mov    %esp,%ebp
- 527:	57                   	push   %edi
- 528:	56                   	push   %esi
- 529:	53                   	push   %ebx
- 52a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 52d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 530:	0f b6 1e             	movzbl (%esi),%ebx
- 533:	84 db                	test   %bl,%bl
- 535:	0f 84 b4 00 00 00    	je     5ef <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 53b:	8d 45 10             	lea    0x10(%ebp),%eax
- 53e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 541:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 544:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 546:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 549:	eb 33                	jmp    57e <printf+0x5e>
- 54b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 54f:	90                   	nop
- 550:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 553:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 558:	83 f8 25             	cmp    $0x25,%eax
- 55b:	74 17                	je     574 <printf+0x54>
-  write(fd, &c, 1);
- 55d:	83 ec 04             	sub    $0x4,%esp
- 560:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 563:	6a 01                	push   $0x1
- 565:	57                   	push   %edi
- 566:	ff 75 08             	pushl  0x8(%ebp)
- 569:	e8 15 fe ff ff       	call   383 <write>
- 56e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 571:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 574:	0f b6 1e             	movzbl (%esi),%ebx
- 577:	83 c6 01             	add    $0x1,%esi
- 57a:	84 db                	test   %bl,%bl
- 57c:	74 71                	je     5ef <printf+0xcf>
-    c = fmt[i] & 0xff;
- 57e:	0f be cb             	movsbl %bl,%ecx
- 581:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 584:	85 d2                	test   %edx,%edx
- 586:	74 c8                	je     550 <printf+0x30>
-      }
-    } else if(state == '%'){
- 588:	83 fa 25             	cmp    $0x25,%edx
- 58b:	75 e7                	jne    574 <printf+0x54>
-      if(c == 'd'){
- 58d:	83 f8 64             	cmp    $0x64,%eax
- 590:	0f 84 9a 00 00 00    	je     630 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 596:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 59c:	83 f9 70             	cmp    $0x70,%ecx
- 59f:	74 5f                	je     600 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 5a1:	83 f8 73             	cmp    $0x73,%eax
- 5a4:	0f 84 d6 00 00 00    	je     680 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 5aa:	83 f8 63             	cmp    $0x63,%eax
- 5ad:	0f 84 8d 00 00 00    	je     640 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 5b3:	83 f8 25             	cmp    $0x25,%eax
- 5b6:	0f 84 b4 00 00 00    	je     670 <printf+0x150>
-  write(fd, &c, 1);
- 5bc:	83 ec 04             	sub    $0x4,%esp
- 5bf:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 5c3:	6a 01                	push   $0x1
- 5c5:	57                   	push   %edi
- 5c6:	ff 75 08             	pushl  0x8(%ebp)
- 5c9:	e8 b5 fd ff ff       	call   383 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 5ce:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5d1:	83 c4 0c             	add    $0xc,%esp
- 5d4:	6a 01                	push   $0x1
- 5d6:	83 c6 01             	add    $0x1,%esi
- 5d9:	57                   	push   %edi
- 5da:	ff 75 08             	pushl  0x8(%ebp)
- 5dd:	e8 a1 fd ff ff       	call   383 <write>
-  for(i = 0; fmt[i]; i++){
- 5e2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 5e6:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 5e9:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 5eb:	84 db                	test   %bl,%bl
- 5ed:	75 8f                	jne    57e <printf+0x5e>
-    }
-  }
-}
- 5ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 5f2:	5b                   	pop    %ebx
- 5f3:	5e                   	pop    %esi
- 5f4:	5f                   	pop    %edi
- 5f5:	5d                   	pop    %ebp
- 5f6:	c3                   	ret    
- 5f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5fe:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 600:	83 ec 0c             	sub    $0xc,%esp
- 603:	b9 10 00 00 00       	mov    $0x10,%ecx
- 608:	6a 00                	push   $0x0
- 60a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 60d:	8b 45 08             	mov    0x8(%ebp),%eax
- 610:	8b 13                	mov    (%ebx),%edx
- 612:	e8 59 fe ff ff       	call   470 <printint>
-        ap++;
- 617:	89 d8                	mov    %ebx,%eax
- 619:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 61c:	31 d2                	xor    %edx,%edx
-        ap++;
- 61e:	83 c0 04             	add    $0x4,%eax
- 621:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 624:	e9 4b ff ff ff       	jmp    574 <printf+0x54>
- 629:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 630:	83 ec 0c             	sub    $0xc,%esp
- 633:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 638:	6a 01                	push   $0x1
- 63a:	eb ce                	jmp    60a <printf+0xea>
- 63c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 640:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 643:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 646:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 648:	6a 01                	push   $0x1
-        ap++;
- 64a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 64d:	57                   	push   %edi
- 64e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 651:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 654:	e8 2a fd ff ff       	call   383 <write>
-        ap++;
- 659:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 65c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 65f:	31 d2                	xor    %edx,%edx
- 661:	e9 0e ff ff ff       	jmp    574 <printf+0x54>
- 666:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 66d:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 670:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 673:	83 ec 04             	sub    $0x4,%esp
- 676:	e9 59 ff ff ff       	jmp    5d4 <printf+0xb4>
- 67b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 67f:	90                   	nop
-        s = (char*)*ap;
- 680:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 683:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 685:	83 c0 04             	add    $0x4,%eax
- 688:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 68b:	85 db                	test   %ebx,%ebx
- 68d:	74 17                	je     6a6 <printf+0x186>
-        while(*s != 0){
- 68f:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 692:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 694:	84 c0                	test   %al,%al
- 696:	0f 84 d8 fe ff ff    	je     574 <printf+0x54>
- 69c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 69f:	89 de                	mov    %ebx,%esi
- 6a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 6a4:	eb 1a                	jmp    6c0 <printf+0x1a0>
-          s = "(null)";
- 6a6:	bb 01 09 00 00       	mov    $0x901,%ebx
-        while(*s != 0){
- 6ab:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 6ae:	b8 28 00 00 00       	mov    $0x28,%eax
- 6b3:	89 de                	mov    %ebx,%esi
- 6b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 6b8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 6bf:	90                   	nop
-  write(fd, &c, 1);
- 6c0:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 6c3:	83 c6 01             	add    $0x1,%esi
- 6c6:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 6c9:	6a 01                	push   $0x1
- 6cb:	57                   	push   %edi
- 6cc:	53                   	push   %ebx
- 6cd:	e8 b1 fc ff ff       	call   383 <write>
-        while(*s != 0){
- 6d2:	0f b6 06             	movzbl (%esi),%eax
- 6d5:	83 c4 10             	add    $0x10,%esp
- 6d8:	84 c0                	test   %al,%al
- 6da:	75 e4                	jne    6c0 <printf+0x1a0>
- 6dc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 6df:	31 d2                	xor    %edx,%edx
- 6e1:	e9 8e fe ff ff       	jmp    574 <printf+0x54>
- 6e6:	66 90                	xchg   %ax,%ax
- 6e8:	66 90                	xchg   %ax,%ax
- 6ea:	66 90                	xchg   %ax,%ax
- 6ec:	66 90                	xchg   %ax,%ax
- 6ee:	66 90                	xchg   %ax,%ax
-
-000006f0 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 6f0:	f3 0f 1e fb          	endbr32 
- 6f4:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 6f5:	a1 c0 0b 00 00       	mov    0xbc0,%eax
-{
- 6fa:	89 e5                	mov    %esp,%ebp
- 6fc:	57                   	push   %edi
- 6fd:	56                   	push   %esi
- 6fe:	53                   	push   %ebx
- 6ff:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 702:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 704:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 707:	39 c8                	cmp    %ecx,%eax
- 709:	73 15                	jae    720 <free+0x30>
- 70b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 70f:	90                   	nop
- 710:	39 d1                	cmp    %edx,%ecx
- 712:	72 14                	jb     728 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 714:	39 d0                	cmp    %edx,%eax
- 716:	73 10                	jae    728 <free+0x38>
-{
- 718:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 71a:	8b 10                	mov    (%eax),%edx
- 71c:	39 c8                	cmp    %ecx,%eax
- 71e:	72 f0                	jb     710 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 720:	39 d0                	cmp    %edx,%eax
- 722:	72 f4                	jb     718 <free+0x28>
- 724:	39 d1                	cmp    %edx,%ecx
- 726:	73 f0                	jae    718 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 728:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 72b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 72e:	39 fa                	cmp    %edi,%edx
- 730:	74 1e                	je     750 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 732:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 735:	8b 50 04             	mov    0x4(%eax),%edx
- 738:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 73b:	39 f1                	cmp    %esi,%ecx
- 73d:	74 28                	je     767 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 73f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 741:	5b                   	pop    %ebx
-  freep = p;
- 742:	a3 c0 0b 00 00       	mov    %eax,0xbc0
-}
- 747:	5e                   	pop    %esi
- 748:	5f                   	pop    %edi
- 749:	5d                   	pop    %ebp
- 74a:	c3                   	ret    
- 74b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 74f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 750:	03 72 04             	add    0x4(%edx),%esi
- 753:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 756:	8b 10                	mov    (%eax),%edx
- 758:	8b 12                	mov    (%edx),%edx
- 75a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 75d:	8b 50 04             	mov    0x4(%eax),%edx
- 760:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 763:	39 f1                	cmp    %esi,%ecx
- 765:	75 d8                	jne    73f <free+0x4f>
-    p->s.size += bp->s.size;
- 767:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 76a:	a3 c0 0b 00 00       	mov    %eax,0xbc0
-    p->s.size += bp->s.size;
- 76f:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 772:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 775:	89 10                	mov    %edx,(%eax)
-}
- 777:	5b                   	pop    %ebx
- 778:	5e                   	pop    %esi
- 779:	5f                   	pop    %edi
- 77a:	5d                   	pop    %ebp
- 77b:	c3                   	ret    
- 77c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000780 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 780:	f3 0f 1e fb          	endbr32 
- 784:	55                   	push   %ebp
- 785:	89 e5                	mov    %esp,%ebp
- 787:	57                   	push   %edi
- 788:	56                   	push   %esi
- 789:	53                   	push   %ebx
- 78a:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 78d:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 790:	8b 3d c0 0b 00 00    	mov    0xbc0,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 796:	8d 70 07             	lea    0x7(%eax),%esi
- 799:	c1 ee 03             	shr    $0x3,%esi
- 79c:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 79f:	85 ff                	test   %edi,%edi
- 7a1:	0f 84 a9 00 00 00    	je     850 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7a7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 7a9:	8b 48 04             	mov    0x4(%eax),%ecx
- 7ac:	39 f1                	cmp    %esi,%ecx
- 7ae:	73 6d                	jae    81d <malloc+0x9d>
- 7b0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 7b6:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 7bb:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 7be:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 7c5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 7c8:	eb 17                	jmp    7e1 <malloc+0x61>
- 7ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7d0:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 7d2:	8b 4a 04             	mov    0x4(%edx),%ecx
- 7d5:	39 f1                	cmp    %esi,%ecx
- 7d7:	73 4f                	jae    828 <malloc+0xa8>
- 7d9:	8b 3d c0 0b 00 00    	mov    0xbc0,%edi
- 7df:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 7e1:	39 c7                	cmp    %eax,%edi
- 7e3:	75 eb                	jne    7d0 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 7e5:	83 ec 0c             	sub    $0xc,%esp
- 7e8:	ff 75 e4             	pushl  -0x1c(%ebp)
- 7eb:	e8 fb fb ff ff       	call   3eb <sbrk>
-  if(p == (char*)-1)
- 7f0:	83 c4 10             	add    $0x10,%esp
- 7f3:	83 f8 ff             	cmp    $0xffffffff,%eax
- 7f6:	74 1b                	je     813 <malloc+0x93>
-  hp->s.size = nu;
- 7f8:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 7fb:	83 ec 0c             	sub    $0xc,%esp
- 7fe:	83 c0 08             	add    $0x8,%eax
- 801:	50                   	push   %eax
- 802:	e8 e9 fe ff ff       	call   6f0 <free>
-  return freep;
- 807:	a1 c0 0b 00 00       	mov    0xbc0,%eax
-      if((p = morecore(nunits)) == 0)
- 80c:	83 c4 10             	add    $0x10,%esp
- 80f:	85 c0                	test   %eax,%eax
- 811:	75 bd                	jne    7d0 <malloc+0x50>
-        return 0;
-  }
-}
- 813:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 816:	31 c0                	xor    %eax,%eax
-}
- 818:	5b                   	pop    %ebx
- 819:	5e                   	pop    %esi
- 81a:	5f                   	pop    %edi
- 81b:	5d                   	pop    %ebp
- 81c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 81d:	89 c2                	mov    %eax,%edx
- 81f:	89 f8                	mov    %edi,%eax
- 821:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 828:	39 ce                	cmp    %ecx,%esi
- 82a:	74 54                	je     880 <malloc+0x100>
-        p->s.size -= nunits;
- 82c:	29 f1                	sub    %esi,%ecx
- 82e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 831:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 834:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 837:	a3 c0 0b 00 00       	mov    %eax,0xbc0
-}
- 83c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 83f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 842:	5b                   	pop    %ebx
- 843:	5e                   	pop    %esi
- 844:	5f                   	pop    %edi
- 845:	5d                   	pop    %ebp
- 846:	c3                   	ret    
- 847:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 84e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 850:	c7 05 c0 0b 00 00 c4 	movl   $0xbc4,0xbc0
- 857:	0b 00 00 
-    base.s.size = 0;
- 85a:	bf c4 0b 00 00       	mov    $0xbc4,%edi
-    base.s.ptr = freep = prevp = &base;
- 85f:	c7 05 c4 0b 00 00 c4 	movl   $0xbc4,0xbc4
- 866:	0b 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 869:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 86b:	c7 05 c8 0b 00 00 00 	movl   $0x0,0xbc8
- 872:	00 00 00 
-    if(p->s.size >= nunits){
- 875:	e9 36 ff ff ff       	jmp    7b0 <malloc+0x30>
- 87a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 880:	8b 0a                	mov    (%edx),%ecx
- 882:	89 08                	mov    %ecx,(%eax)
- 884:	eb b1                	jmp    837 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/roundRobinTest.c b/xv6-public/Operating-System-Project/roundRobinTest.c
deleted file mode 100644
index 955172a..0000000
--- a/xv6-public/Operating-System-Project/roundRobinTest.c
+++ /dev/null
@@ -1,39 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int main(int argc, char *argv[])
-{
-    changePolicy(1);
-
-    int main_pid = getpid();
-    for (int i = 0; i < 10; i++)
-    {
-        if (fork() > 0)
-            break;
-    }
-
-    if (main_pid != getpid())
-    {
-        for (int i = 0; i < 100; i++)
-            printf(1, "/%d/: %d\n", getpid(), i);
-
-        int turnAroundTime = getTurnAroundTime(getpid());
-        int waitingTime = getWaitingTime(getpid());
-        int CBT = getCBT(getpid());
-
-        wait();
-
-        printf(1, "turnAroundTime for process /%d/ is :%d\n", getpid(), turnAroundTime);
-        printf(1, "waitingTime for process /%d/ is :%d\n", getpid(), waitingTime);
-        printf(1, "CBT for process /%d/ is :%d\n", getpid(), CBT);
-        printf(1, "\n\n");
-    }
-
-    while (wait() != -1)
-    {
-        ;
-    }
-
-    exit();
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/roundRobinTest.d b/xv6-public/Operating-System-Project/roundRobinTest.d
deleted file mode 100644
index bf91841..0000000
--- a/xv6-public/Operating-System-Project/roundRobinTest.d
+++ /dev/null
@@ -1,2 +0,0 @@
-roundRobinTest.o: roundRobinTest.c /usr/include/stdc-predef.h types.h \
- stat.h user.h
diff --git a/xv6-public/Operating-System-Project/roundRobinTest.o b/xv6-public/Operating-System-Project/roundRobinTest.o
deleted file mode 100644
index c2ec2b5..0000000
Binary files a/xv6-public/Operating-System-Project/roundRobinTest.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/roundRobinTest.sym b/xv6-public/Operating-System-Project/roundRobinTest.sym
deleted file mode 100644
index e12cd3b..0000000
--- a/xv6-public/Operating-System-Project/roundRobinTest.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-00000888 .rodata
-0000091c .eh_frame
-00000bc0 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 roundRobinTest.c
-00000000 ulib.c
-00000000 printf.c
-00000470 printint
-00000908 digits.1109
-00000000 umalloc.c
-00000bc0 freep
-00000bc4 base
-00000100 strcpy
-0000040b getChildren
-00000520 printf
-00000330 memmove
-000003ab mknod
-00000220 gets
-000003e3 getpid
-00000443 customWait
-0000043b getCBT
-00000780 malloc
-000003f3 sleep
-00000373 pipe
-00000423 changePolicy
-00000383 write
-000003bb fstat
-00000393 kill
-000003d3 chdir
-0000044b setQueue
-0000039b exec
-0000036b wait
-0000037b read
-00000453 getBurstTime
-000003b3 unlink
-0000035b fork
-0000042b getTurnAroundTime
-000003eb sbrk
-000003fb uptime
-00000bc0 __bss_start
-000001c0 memset
-00000000 main
-00000130 strcmp
-000003db dup
-00000413 getSyscallCounter
-00000403 getParentID
-000002a0 stat
-00000bc0 _edata
-00000bcc _end
-000003c3 link
-00000363 exit
-0000041b setPriority
-000002f0 atoi
-0000045b getCreationTime
-00000180 strlen
-000003a3 open
-000001e0 strchr
-000003cb mkdir
-0000038b close
-00000433 getWaitingTime
-000006f0 free
diff --git a/xv6-public/Operating-System-Project/runoff b/xv6-public/Operating-System-Project/runoff
deleted file mode 100644
index be362d0..0000000
--- a/xv6-public/Operating-System-Project/runoff
+++ /dev/null
@@ -1,246 +0,0 @@
-#!/bin/sh
-
-echo This script takes a minute to run.  Be patient. 1>&2
-
-LC_CTYPE=C export LC_CTYPE
-
-# pad stdin to multiple of 120 lines
-pad()
-{
-	awk '{print} END{for(; NR%120!=0; NR++) print ""}'
-}
-
-# create formatted (numbered) files
-mkdir -p fmt
-rm -f fmt/*
-cp README fmt
-echo > fmt/blank
-files=`grep -v '^#' runoff.list | awk '{print $1}'`
-n=99
-for i in $files
-do
-	./runoff1 -n $n $i >fmt/$i
-	nn=`tail -1 fmt/$i | sed 's/ .*//; s/^0*//'`
-	if [ "x$nn" != x ]; then
-		n=$nn
-	fi
-done
-
-# create table of contents
-cat toc.hdr >fmt/toc
-pr -e8 -t runoff.list | awk '
-/^[a-z0-9]/ {
-	s=$0
-	f="fmt/"$1
-	getline<f
-	close(f)
-	n=$1
-	printf("%02d %s\n", n/100, s);
-	printf("TOC: %04d %s\n", n, s) >"fmt/tocdata"
-	next
-}
-{
-	print
-}' | pr -3 -t >>fmt/toc
-cat toc.ftr >>fmt/toc
-
-# check for bad alignments
-perl -e '
-	$leftwarn = 0;
-	while(<>){
-		chomp;
-		s!#.*!!;
-		s!\s+! !g;
-		s! +$!!;
-		next if /^$/;
-		
-		if(/TOC: (\d+) (.*)/){
-			$toc{$2} = $1;
-			next;
-		}
-		
-		if(/sheet1: (left|right)$/){
-			print STDERR "assuming that sheet 1 is a $1 page.  double-check!\n";
-			$left = $1 eq "left" ? "13579" : "02468";
-			$right = $1 eq "left" ? "02468" : "13579";
-			next;
-		}
-		
-		if(/even: (.*)/){
-			$file = $1;
-			if(!defined($toc{$file})){
-				print STDERR "Have no toc for $file\n";
-				next;
-			}
-			if($toc{$file} =~ /^\d\d[^0]/){
-				print STDERR "$file does not start on a fresh page.\n";
-			}
-			next;
-		}
-		
-		if(/odd: (.*)/){
-			$file = $1;
-			if(!defined($toc{$file})){
-				print STDERR "Have no toc for $file\n";
-				next;
-			}
-			if($toc{$file} !~ /^\d\d5/){
-				print STDERR "$file does not start on a second half page.\n";
-			}
-			next;
-		}
-		
-		if(/(left|right): (.*)/){
-			$what = $1;
-			$file = $2;
-			if(!defined($toc{$file})){
-				print STDERR "Have no toc for $file\n";
-				next;
-			}
-			if($what eq "left" && !($toc{$file} =~ /^\d[$left][05]/)){
-				print STDERR "$file does not start on a left page [$toc{$file}]\n";
-			}
-			# why does this not work if I inline $x in the if?
-			$x = ($toc{$file} =~ /^\d[$right][05]/);
-			if($what eq "right" && !$x){
-				print STDERR "$file does not start on a right page [$toc{$file}] [$x]\n";
-			}
-			next;
-		}
-		
-		print STDERR "Unknown spec: $_\n";
-	}
-' fmt/tocdata runoff.spec
-
-# make definition list
-cd fmt
-perl -e '
-	while(<>) {
-		chomp;
-
-		s!//.*!!;
-		s!/\*([^*]|[*][^/])*\*/!!g;
-		s!\s! !g;
-		s! +$!!;
-
-		# look for declarations like char* x;
-		if (/^[0-9]+ typedef .* u(int|short|long|char);/) {
-			next;
-		}
-		if (/^[0-9]+ extern/) {
-			next;
-		}
-		if (/^[0-9]+ struct [a-zA-Z0-9_]+;/) {
-			next;
-		}
-		if (/^([0-9]+) #define +([A-za-z0-9_]+) +?\(.*/) {
-			print "$1 $2\n"
-		}
-		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+) +([^ ]+)/) {
-			print "$1 $2 $3\n";
-		}
-		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+)/) {
-			print "$1 $2\n";
-		}
-		
-		if(/^^([0-9]+) \.globl ([a-zA-Z0-9_]+)/){
-			$isglobl{$2} = 1;
-		}
-		if(/^^([0-9]+) ([a-zA-Z0-9_]+):$/ && $isglobl{$2}){
-			print "$1 $2\n";
-		}
-		
-		if (/\(/) {
-			next;
-		}
-
-		if (/^([0-9]+) (((static|struct|extern|union|enum) +)*([A-Za-z0-9_]+))( .*)? +([A-Za-z_][A-Za-z0-9_]*)(,|;|=| =)/) {
-			print "$1 $7\n";
-		}
-		
-		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){ 
-			print "$1 $3\n";
-		}
-		# TODO: enum members
-	}
-' $files >defs
-
-(for i in $files
-do
-	case "$i" in
-	*.S)
-		cat $i | sed 's;#.*;;; s;//.*;;;'
-		;;
-	*)
-		cat $i | sed 's;//.*;;; s;"([^"\\]|\\.)*";;;'
-	esac
-done
-) >alltext
-
-perl -n -e 'print if s/^([0-9]+ [a-zA-Z0-9_]+)\(.*$/\1/;' alltext |
-	egrep -v ' (STUB|usage|main|if|for)$' >>defs
-#perl -n -e 'print if s/^([0-9]+) STUB\(([a-zA-Z0-9_]+)\)$/\1 \2/;' alltext \
-#	>>defs
-(
->s.defs
-
-# make reference list
-for i in `awk '{print $2}' defs | sort -f | uniq`
-do
-	defs=`egrep '^[0-9]+ '$i'( |$)' defs | awk '{print $1}'`
-	echo $i $defs >>s.defs
-	uses=`egrep -h '([^a-zA-Z_0-9])'$i'($|[^a-zA-Z_0-9])' alltext | awk '{print $1}'`
-	if [ "x$defs" != "x$uses" ]; then
-		echo $i $defs
-		echo $uses |fmt -29 | sed 's/^/    /'
-#	else
-#		echo $i defined but not used >&2
-	fi
-done
-) >refs
-
-# build defs list
-awk '
-{
-	printf("%04d %s\n", $2, $1);
-	for(i=3; i<=NF; i++)
-		printf("%04d    \" \n", $i);
-}
-' s.defs > t.defs
-
-# format the whole thing
-(
-	../pr.pl README
-	../pr.pl -h "table of contents" toc
-	# pr -t -2 t.defs | ../pr.pl -h "definitions" | pad
-	pr -t -l50 -2 refs | ../pr.pl -h "cross-references" | pad
-	# pr.pl -h "definitions" -2 t.defs | pad
-	# pr.pl -h "cross-references" -2 refs | pad
-	../pr.pl blank  # make sheet 1 start on left page
-	../pr.pl blank
-	for i in $files
-	do
-		../pr.pl -h "xv6/$i" $i
-	done
-) | mpage -m50t50b -o -bLetter -T -t -2 -FCourier -L60 >all.ps
-grep Pages: all.ps
-
-# if we have the nice font, use it
-nicefont=LucidaSans-Typewriter83
-if [ ! -f ../$nicefont ]
-then
-	if git cat-file blob font:$nicefont > ../$nicefont~; then
-		mv ../$nicefont~ ../$nicefont
-	fi
-fi
-if [ -f ../$nicefont ]
-then
-	echo nicefont
-	(sed 1q all.ps; cat ../$nicefont; sed "1d; s/Courier/$nicefont/" all.ps) >allf.ps
-else
-	echo ugly font!
-	cp all.ps allf.ps
-fi
-ps2pdf allf.ps ../xv6.pdf
-# cd ..
-# pdftops xv6.pdf xv6.ps
diff --git a/xv6-public/Operating-System-Project/runoff.list b/xv6-public/Operating-System-Project/runoff.list
deleted file mode 100644
index 2df9b81..0000000
--- a/xv6-public/Operating-System-Project/runoff.list
+++ /dev/null
@@ -1,80 +0,0 @@
-# basic headers
-types.h
-param.h
-memlayout.h
-defs.h
-x86.h
-asm.h
-mmu.h
-elf.h
-date.h
-
-# entering xv6
-entry.S
-entryother.S
-main.c
-
-# locks
-spinlock.h
-spinlock.c
-
-# processes
-vm.c
-proc.h
-proc.c
-swtch.S
-kalloc.c
-
-# system calls
-traps.h
-vectors.pl
-trapasm.S
-trap.c
-syscall.h
-syscall.c
-sysproc.c
-
-# file system
-buf.h
-sleeplock.h
-fcntl.h
-stat.h
-fs.h
-file.h
-ide.c
-bio.c
-sleeplock.c
-log.c
-fs.c
-file.c
-sysfile.c
-exec.c
-
-# pipes
-pipe.c
-
-# string operations
-string.c
-
-# low-level hardware
-mp.h
-mp.c
-lapic.c
-ioapic.c
-kbd.h
-kbd.c
-console.c
-uart.c
-
-# user-level
-initcode.S
-usys.S
-init.c
-sh.c
-
-# bootloader
-bootasm.S
-bootmain.c
-
-# link
-kernel.ld
diff --git a/xv6-public/Operating-System-Project/runoff.spec b/xv6-public/Operating-System-Project/runoff.spec
deleted file mode 100644
index 9247948..0000000
--- a/xv6-public/Operating-System-Project/runoff.spec
+++ /dev/null
@@ -1,102 +0,0 @@
-# Is sheet 01 (after the TOC) a left sheet or a right sheet?
-sheet1: left
-
-# "left" and "right" specify which page of a two-page spread a file
-# must start on.  "left" means that a file must start on the first of
-# the two pages.  "right" means it must start on the second of the two
-# pages.  The file may start in either column.
-#
-# "even" and "odd" specify which column a file must start on.  "even"
-# means it must start in the left of the two columns (00).  "odd" means it
-# must start in the right of the two columns (50).
-#
-# You'd think these would be the other way around.
-
-# types.h either
-# param.h either
-# defs.h either
-# x86.h either
-# asm.h either
-# mmu.h either
-# elf.h either
-# mp.h either
-
-even: entry.S  # mild preference
-even: entryother.S  # mild preference
-even: main.c
-# mp.c don't care at all
-# even: initcode.S
-# odd: init.c
-
-left: spinlock.h
-even: spinlock.h
-
-# This gets struct proc and allocproc on the same spread
-left: proc.h
-even: proc.h
-
-# goal is to have two action-packed 2-page spreads,
-# one with
-#     userinit growproc fork exit wait
-# and another with
-#     scheduler sched yield forkret sleep wakeup1 wakeup
-right: proc.c   # VERY important
-even: proc.c   # VERY important
-
-# A few more action packed spreads
-# page table creation and process loading
-#     walkpgdir mappages setupkvm switch[ku]vm inituvm (loaduvm)
-# process memory management
-#     allocuvm deallocuvm freevm
-left: vm.c
-
-even: kalloc.c  # mild preference
-
-# syscall.h either
-# trapasm.S either
-# traps.h either
-# even: trap.c
-# vectors.pl either
-# syscall.c either
-# sysproc.c either
-
-# buf.h either
-# dev.h either
-# fcntl.h either
-# stat.h either
-# file.h either
-# fs.h either
-# fsvar.h either
-# left: ide.c # mild preference
-even: ide.c
-# odd: bio.c
-
-# log.c fits nicely in a spread
-even: log.c
-left: log.c
-
-# with fs.c starting on 2nd column of a left page, we get these 2-page spreads:
-#	ialloc iupdate iget idup ilock iunlock iput iunlockput
-#	bmap itrunc stati readi writei
-#	namecmp dirlookup dirlink skipelem namex namei
-#	fileinit filealloc filedup fileclose filestat fileread filewrite
-# starting on 2nd column of a right page is not terrible either
-odd: fs.c   # VERY important
-left: fs.c  # mild preference
-# file.c either
-# exec.c either
-# sysfile.c either
-
-# Mild preference, but makes spreads of mp.c, lapic.c, and ioapic.c+picirq.c
-even: mp.c
-left: mp.c
-
-# even: pipe.c  # mild preference
-# string.c either
-# left: kbd.h  # mild preference
-even: kbd.h
-even: console.c
-odd: sh.c
-
-even: bootasm.S   # mild preference
-even: bootmain.c  # mild preference
diff --git a/xv6-public/Operating-System-Project/runoff1 b/xv6-public/Operating-System-Project/runoff1
deleted file mode 100644
index 532f844..0000000
--- a/xv6-public/Operating-System-Project/runoff1
+++ /dev/null
@@ -1,108 +0,0 @@
-#!/usr/bin/perl
-
-$n = 0;
-$v = 0;
-if($ARGV[0] eq "-v") {
-	$v = 1;
-	shift @ARGV;
-}
-if($ARGV[0] eq "-n") {
-	$n = $ARGV[1];
-	shift @ARGV;
-	shift @ARGV;
-}
-$n = int(($n+49)/50)*50 - 1;
-
-$file = $ARGV[0];
-@lines = <>;
-$linenum = 0;
-foreach (@lines) {
-	$linenum++;
-	chomp;
-	s/\s+$//;
-	if(length() >= 75){
-		print STDERR "$file:$linenum: line too long\n";
-	}
-}
-@outlines = ();
-$nextout = 0;
-
-for($i=0; $i<@lines; ){
-	# Skip leading blank lines.
-	$i++ while $i<@lines && $lines[$i] =~ /^$/;
-	last if $i>=@lines;
-
-	# If the rest of the file fits, use the whole thing.
-	if(@lines <= $i+50 && !grep { /PAGEBREAK/ } @lines){
-		$breakbefore = @lines;
-	}else{
-		# Find a good next page break;
-		# Hope for end of function.
-		# but settle for a blank line (but not first blank line
-		# in function, which comes after variable declarations).
-		$breakbefore = $i;
-		$lastblank = $i;
-		$sawbrace = 0;
-		$breaksize = 15;  # 15 lines to get to function
-		for($j=$i; $j<$i+50 && $j < @lines; $j++){
-			if($lines[$j] =~ /PAGEBREAK!/){
-				$lines[$j] = "";
-				$breakbefore = $j;
-				$breaksize = 100;
-				last;
-			}
-			if($lines[$j] =~ /PAGEBREAK:\s*([0-9]+)/){
-				$breaksize = $1;
-				$breakbefore = $j;
-				$lines[$j] = "";
-			}
-			if($lines[$j] =~ /^};?$/){
-				$breakbefore = $j+1;
-				$breaksize = 15;
-			}
-			if($lines[$j] =~ /^{$/){
-				$sawbrace = 1;
-			}
-			if($lines[$j] =~ /^$/){
-				if($sawbrace){
-					$sawbrace = 0;
-				}else{
-					$lastblank = $j;
-				}
-			}
-		}
-		if($j<@lines && $lines[$j] =~ /^$/){
-			$lastblank = $j;
-		}
-
-		# If we are not putting enough on a page, try a blank line.
-		if($breakbefore - $i < 50 - $breaksize && $lastblank > $breakbefore && $lastblank >= $i+50 - 5){
-			if($v){
-				print STDERR "breakbefore $breakbefore i $i breaksize $breaksize\n";
-			}
-			$breakbefore = $lastblank;
-			$breaksize = 5;  # only 5 lines to get to blank line
-		}
-
-		# If we are not putting enough on a page, force a full page.
-		if($breakbefore - $i < 50 - $breaksize && $breakbefore != @lines){
-			$breakbefore = $i + 50;
-			$breakbefore = @lines if @lines < $breakbefore;
-		}
-
-		if($breakbefore < $i+2){
-			$breakbefore = $i+2;
-		}
-	}
-
-	# Emit the page.
-	$i50 = $i + 50;
-	for(; $i<$breakbefore; $i++){
-		printf "%04d %s\n", ++$n, $lines[$i];
-	}
-
-	# Finish page
-	for($j=$i; $j<$i50; $j++){
-		printf "%04d \n", ++$n;
-	}
-}
diff --git a/xv6-public/Operating-System-Project/sh.asm b/xv6-public/Operating-System-Project/sh.asm
deleted file mode 100644
index edd4a3f..0000000
--- a/xv6-public/Operating-System-Project/sh.asm
+++ /dev/null
@@ -1,2688 +0,0 @@
-
-_sh:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-  return 0;
-}
-
-int
-main(void)
-{
-       0:	f3 0f 1e fb          	endbr32 
-       4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-       8:	83 e4 f0             	and    $0xfffffff0,%esp
-       b:	ff 71 fc             	pushl  -0x4(%ecx)
-       e:	55                   	push   %ebp
-       f:	89 e5                	mov    %esp,%ebp
-      11:	51                   	push   %ecx
-      12:	83 ec 04             	sub    $0x4,%esp
-  static char buf[100];
-  int fd;
-
-  // Ensure that three file descriptors are open.
-  while((fd = open("console", O_RDWR)) >= 0){
-      15:	eb 12                	jmp    29 <main+0x29>
-      17:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      1e:	66 90                	xchg   %ax,%ax
-    if(fd >= 3){
-      20:	83 f8 02             	cmp    $0x2,%eax
-      23:	0f 8f b7 00 00 00    	jg     e0 <main+0xe0>
-  while((fd = open("console", O_RDWR)) >= 0){
-      29:	83 ec 08             	sub    $0x8,%esp
-      2c:	6a 02                	push   $0x2
-      2e:	68 59 13 00 00       	push   $0x1359
-      33:	e8 9b 0d 00 00       	call   dd3 <open>
-      38:	83 c4 10             	add    $0x10,%esp
-      3b:	85 c0                	test   %eax,%eax
-      3d:	79 e1                	jns    20 <main+0x20>
-      3f:	eb 32                	jmp    73 <main+0x73>
-      41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    }
-  }
-
-  // Read and run input commands.
-  while(getcmd(buf, sizeof(buf)) >= 0){
-    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
-      48:	80 3d a2 19 00 00 20 	cmpb   $0x20,0x19a2
-      4f:	74 51                	je     a2 <main+0xa2>
-      51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-int
-fork1(void)
-{
-  int pid;
-
-  pid = fork();
-      58:	e8 2e 0d 00 00       	call   d8b <fork>
-  if(pid == -1)
-      5d:	83 f8 ff             	cmp    $0xffffffff,%eax
-      60:	0f 84 9d 00 00 00    	je     103 <main+0x103>
-    if(fork1() == 0)
-      66:	85 c0                	test   %eax,%eax
-      68:	0f 84 80 00 00 00    	je     ee <main+0xee>
-    wait();
-      6e:	e8 28 0d 00 00       	call   d9b <wait>
-  while(getcmd(buf, sizeof(buf)) >= 0){
-      73:	83 ec 08             	sub    $0x8,%esp
-      76:	6a 64                	push   $0x64
-      78:	68 a0 19 00 00       	push   $0x19a0
-      7d:	e8 8e 00 00 00       	call   110 <getcmd>
-      82:	83 c4 10             	add    $0x10,%esp
-      85:	85 c0                	test   %eax,%eax
-      87:	78 14                	js     9d <main+0x9d>
-    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
-      89:	80 3d a0 19 00 00 63 	cmpb   $0x63,0x19a0
-      90:	75 c6                	jne    58 <main+0x58>
-      92:	80 3d a1 19 00 00 64 	cmpb   $0x64,0x19a1
-      99:	75 bd                	jne    58 <main+0x58>
-      9b:	eb ab                	jmp    48 <main+0x48>
-  exit();
-      9d:	e8 f1 0c 00 00       	call   d93 <exit>
-      buf[strlen(buf)-1] = 0;  // chop \n
-      a2:	83 ec 0c             	sub    $0xc,%esp
-      a5:	68 a0 19 00 00       	push   $0x19a0
-      aa:	e8 01 0b 00 00       	call   bb0 <strlen>
-      if(chdir(buf+3) < 0)
-      af:	c7 04 24 a3 19 00 00 	movl   $0x19a3,(%esp)
-      buf[strlen(buf)-1] = 0;  // chop \n
-      b6:	c6 80 9f 19 00 00 00 	movb   $0x0,0x199f(%eax)
-      if(chdir(buf+3) < 0)
-      bd:	e8 41 0d 00 00       	call   e03 <chdir>
-      c2:	83 c4 10             	add    $0x10,%esp
-      c5:	85 c0                	test   %eax,%eax
-      c7:	79 aa                	jns    73 <main+0x73>
-        printf(2, "cannot cd %s\n", buf+3);
-      c9:	50                   	push   %eax
-      ca:	68 a3 19 00 00       	push   $0x19a3
-      cf:	68 61 13 00 00       	push   $0x1361
-      d4:	6a 02                	push   $0x2
-      d6:	e8 75 0e 00 00       	call   f50 <printf>
-      db:	83 c4 10             	add    $0x10,%esp
-      de:	eb 93                	jmp    73 <main+0x73>
-      close(fd);
-      e0:	83 ec 0c             	sub    $0xc,%esp
-      e3:	50                   	push   %eax
-      e4:	e8 d2 0c 00 00       	call   dbb <close>
-      break;
-      e9:	83 c4 10             	add    $0x10,%esp
-      ec:	eb 85                	jmp    73 <main+0x73>
-      runcmd(parsecmd(buf));
-      ee:	83 ec 0c             	sub    $0xc,%esp
-      f1:	68 a0 19 00 00       	push   $0x19a0
-      f6:	e8 c5 09 00 00       	call   ac0 <parsecmd>
-      fb:	89 04 24             	mov    %eax,(%esp)
-      fe:	e8 7d 00 00 00       	call   180 <runcmd>
-    panic("fork");
-     103:	83 ec 0c             	sub    $0xc,%esp
-     106:	68 e2 12 00 00       	push   $0x12e2
-     10b:	e8 50 00 00 00       	call   160 <panic>
-
-00000110 <getcmd>:
-{
-     110:	f3 0f 1e fb          	endbr32 
-     114:	55                   	push   %ebp
-     115:	89 e5                	mov    %esp,%ebp
-     117:	56                   	push   %esi
-     118:	53                   	push   %ebx
-     119:	8b 75 0c             	mov    0xc(%ebp),%esi
-     11c:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  printf(2, "$ ");
-     11f:	83 ec 08             	sub    $0x8,%esp
-     122:	68 b8 12 00 00       	push   $0x12b8
-     127:	6a 02                	push   $0x2
-     129:	e8 22 0e 00 00       	call   f50 <printf>
-  memset(buf, 0, nbuf);
-     12e:	83 c4 0c             	add    $0xc,%esp
-     131:	56                   	push   %esi
-     132:	6a 00                	push   $0x0
-     134:	53                   	push   %ebx
-     135:	e8 b6 0a 00 00       	call   bf0 <memset>
-  gets(buf, nbuf);
-     13a:	58                   	pop    %eax
-     13b:	5a                   	pop    %edx
-     13c:	56                   	push   %esi
-     13d:	53                   	push   %ebx
-     13e:	e8 0d 0b 00 00       	call   c50 <gets>
-  if(buf[0] == 0) // EOF
-     143:	83 c4 10             	add    $0x10,%esp
-     146:	31 c0                	xor    %eax,%eax
-     148:	80 3b 00             	cmpb   $0x0,(%ebx)
-     14b:	0f 94 c0             	sete   %al
-}
-     14e:	8d 65 f8             	lea    -0x8(%ebp),%esp
-     151:	5b                   	pop    %ebx
-  if(buf[0] == 0) // EOF
-     152:	f7 d8                	neg    %eax
-}
-     154:	5e                   	pop    %esi
-     155:	5d                   	pop    %ebp
-     156:	c3                   	ret    
-     157:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     15e:	66 90                	xchg   %ax,%ax
-
-00000160 <panic>:
-{
-     160:	f3 0f 1e fb          	endbr32 
-     164:	55                   	push   %ebp
-     165:	89 e5                	mov    %esp,%ebp
-     167:	83 ec 0c             	sub    $0xc,%esp
-  printf(2, "%s\n", s);
-     16a:	ff 75 08             	pushl  0x8(%ebp)
-     16d:	68 55 13 00 00       	push   $0x1355
-     172:	6a 02                	push   $0x2
-     174:	e8 d7 0d 00 00       	call   f50 <printf>
-  exit();
-     179:	e8 15 0c 00 00       	call   d93 <exit>
-     17e:	66 90                	xchg   %ax,%ax
-
-00000180 <runcmd>:
-{
-     180:	f3 0f 1e fb          	endbr32 
-     184:	55                   	push   %ebp
-     185:	89 e5                	mov    %esp,%ebp
-     187:	53                   	push   %ebx
-     188:	83 ec 14             	sub    $0x14,%esp
-     18b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  if(cmd == 0)
-     18e:	85 db                	test   %ebx,%ebx
-     190:	74 7e                	je     210 <runcmd+0x90>
-  switch(cmd->type){
-     192:	83 3b 05             	cmpl   $0x5,(%ebx)
-     195:	0f 87 04 01 00 00    	ja     29f <runcmd+0x11f>
-     19b:	8b 03                	mov    (%ebx),%eax
-     19d:	3e ff 24 85 70 13 00 	notrack jmp *0x1370(,%eax,4)
-     1a4:	00 
-    if(pipe(p) < 0)
-     1a5:	83 ec 0c             	sub    $0xc,%esp
-     1a8:	8d 45 f0             	lea    -0x10(%ebp),%eax
-     1ab:	50                   	push   %eax
-     1ac:	e8 f2 0b 00 00       	call   da3 <pipe>
-     1b1:	83 c4 10             	add    $0x10,%esp
-     1b4:	85 c0                	test   %eax,%eax
-     1b6:	0f 88 05 01 00 00    	js     2c1 <runcmd+0x141>
-  pid = fork();
-     1bc:	e8 ca 0b 00 00       	call   d8b <fork>
-  if(pid == -1)
-     1c1:	83 f8 ff             	cmp    $0xffffffff,%eax
-     1c4:	0f 84 60 01 00 00    	je     32a <runcmd+0x1aa>
-    if(fork1() == 0){
-     1ca:	85 c0                	test   %eax,%eax
-     1cc:	0f 84 fc 00 00 00    	je     2ce <runcmd+0x14e>
-  pid = fork();
-     1d2:	e8 b4 0b 00 00       	call   d8b <fork>
-  if(pid == -1)
-     1d7:	83 f8 ff             	cmp    $0xffffffff,%eax
-     1da:	0f 84 4a 01 00 00    	je     32a <runcmd+0x1aa>
-    if(fork1() == 0){
-     1e0:	85 c0                	test   %eax,%eax
-     1e2:	0f 84 14 01 00 00    	je     2fc <runcmd+0x17c>
-    close(p[0]);
-     1e8:	83 ec 0c             	sub    $0xc,%esp
-     1eb:	ff 75 f0             	pushl  -0x10(%ebp)
-     1ee:	e8 c8 0b 00 00       	call   dbb <close>
-    close(p[1]);
-     1f3:	58                   	pop    %eax
-     1f4:	ff 75 f4             	pushl  -0xc(%ebp)
-     1f7:	e8 bf 0b 00 00       	call   dbb <close>
-    wait();
-     1fc:	e8 9a 0b 00 00       	call   d9b <wait>
-    wait();
-     201:	e8 95 0b 00 00       	call   d9b <wait>
-    break;
-     206:	83 c4 10             	add    $0x10,%esp
-     209:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    exit();
-     210:	e8 7e 0b 00 00       	call   d93 <exit>
-  pid = fork();
-     215:	e8 71 0b 00 00       	call   d8b <fork>
-  if(pid == -1)
-     21a:	83 f8 ff             	cmp    $0xffffffff,%eax
-     21d:	0f 84 07 01 00 00    	je     32a <runcmd+0x1aa>
-    if(fork1() == 0)
-     223:	85 c0                	test   %eax,%eax
-     225:	75 e9                	jne    210 <runcmd+0x90>
-     227:	eb 6b                	jmp    294 <runcmd+0x114>
-    if(ecmd->argv[0] == 0)
-     229:	8b 43 04             	mov    0x4(%ebx),%eax
-     22c:	85 c0                	test   %eax,%eax
-     22e:	74 e0                	je     210 <runcmd+0x90>
-    exec(ecmd->argv[0], ecmd->argv);
-     230:	8d 53 04             	lea    0x4(%ebx),%edx
-     233:	51                   	push   %ecx
-     234:	51                   	push   %ecx
-     235:	52                   	push   %edx
-     236:	50                   	push   %eax
-     237:	e8 8f 0b 00 00       	call   dcb <exec>
-    printf(2, "exec %s failed\n", ecmd->argv[0]);
-     23c:	83 c4 0c             	add    $0xc,%esp
-     23f:	ff 73 04             	pushl  0x4(%ebx)
-     242:	68 c2 12 00 00       	push   $0x12c2
-     247:	6a 02                	push   $0x2
-     249:	e8 02 0d 00 00       	call   f50 <printf>
-    break;
-     24e:	83 c4 10             	add    $0x10,%esp
-     251:	eb bd                	jmp    210 <runcmd+0x90>
-  pid = fork();
-     253:	e8 33 0b 00 00       	call   d8b <fork>
-  if(pid == -1)
-     258:	83 f8 ff             	cmp    $0xffffffff,%eax
-     25b:	0f 84 c9 00 00 00    	je     32a <runcmd+0x1aa>
-    if(fork1() == 0)
-     261:	85 c0                	test   %eax,%eax
-     263:	74 2f                	je     294 <runcmd+0x114>
-    wait();
-     265:	e8 31 0b 00 00       	call   d9b <wait>
-    runcmd(lcmd->right);
-     26a:	83 ec 0c             	sub    $0xc,%esp
-     26d:	ff 73 08             	pushl  0x8(%ebx)
-     270:	e8 0b ff ff ff       	call   180 <runcmd>
-    close(rcmd->fd);
-     275:	83 ec 0c             	sub    $0xc,%esp
-     278:	ff 73 14             	pushl  0x14(%ebx)
-     27b:	e8 3b 0b 00 00       	call   dbb <close>
-    if(open(rcmd->file, rcmd->mode) < 0){
-     280:	58                   	pop    %eax
-     281:	5a                   	pop    %edx
-     282:	ff 73 10             	pushl  0x10(%ebx)
-     285:	ff 73 08             	pushl  0x8(%ebx)
-     288:	e8 46 0b 00 00       	call   dd3 <open>
-     28d:	83 c4 10             	add    $0x10,%esp
-     290:	85 c0                	test   %eax,%eax
-     292:	78 18                	js     2ac <runcmd+0x12c>
-      runcmd(bcmd->cmd);
-     294:	83 ec 0c             	sub    $0xc,%esp
-     297:	ff 73 04             	pushl  0x4(%ebx)
-     29a:	e8 e1 fe ff ff       	call   180 <runcmd>
-    panic("runcmd");
-     29f:	83 ec 0c             	sub    $0xc,%esp
-     2a2:	68 bb 12 00 00       	push   $0x12bb
-     2a7:	e8 b4 fe ff ff       	call   160 <panic>
-      printf(2, "open %s failed\n", rcmd->file);
-     2ac:	51                   	push   %ecx
-     2ad:	ff 73 08             	pushl  0x8(%ebx)
-     2b0:	68 d2 12 00 00       	push   $0x12d2
-     2b5:	6a 02                	push   $0x2
-     2b7:	e8 94 0c 00 00       	call   f50 <printf>
-      exit();
-     2bc:	e8 d2 0a 00 00       	call   d93 <exit>
-      panic("pipe");
-     2c1:	83 ec 0c             	sub    $0xc,%esp
-     2c4:	68 e7 12 00 00       	push   $0x12e7
-     2c9:	e8 92 fe ff ff       	call   160 <panic>
-      close(1);
-     2ce:	83 ec 0c             	sub    $0xc,%esp
-     2d1:	6a 01                	push   $0x1
-     2d3:	e8 e3 0a 00 00       	call   dbb <close>
-      dup(p[1]);
-     2d8:	58                   	pop    %eax
-     2d9:	ff 75 f4             	pushl  -0xc(%ebp)
-     2dc:	e8 2a 0b 00 00       	call   e0b <dup>
-      close(p[0]);
-     2e1:	58                   	pop    %eax
-     2e2:	ff 75 f0             	pushl  -0x10(%ebp)
-     2e5:	e8 d1 0a 00 00       	call   dbb <close>
-      close(p[1]);
-     2ea:	58                   	pop    %eax
-     2eb:	ff 75 f4             	pushl  -0xc(%ebp)
-     2ee:	e8 c8 0a 00 00       	call   dbb <close>
-      runcmd(pcmd->left);
-     2f3:	5a                   	pop    %edx
-     2f4:	ff 73 04             	pushl  0x4(%ebx)
-     2f7:	e8 84 fe ff ff       	call   180 <runcmd>
-      close(0);
-     2fc:	83 ec 0c             	sub    $0xc,%esp
-     2ff:	6a 00                	push   $0x0
-     301:	e8 b5 0a 00 00       	call   dbb <close>
-      dup(p[0]);
-     306:	5a                   	pop    %edx
-     307:	ff 75 f0             	pushl  -0x10(%ebp)
-     30a:	e8 fc 0a 00 00       	call   e0b <dup>
-      close(p[0]);
-     30f:	59                   	pop    %ecx
-     310:	ff 75 f0             	pushl  -0x10(%ebp)
-     313:	e8 a3 0a 00 00       	call   dbb <close>
-      close(p[1]);
-     318:	58                   	pop    %eax
-     319:	ff 75 f4             	pushl  -0xc(%ebp)
-     31c:	e8 9a 0a 00 00       	call   dbb <close>
-      runcmd(pcmd->right);
-     321:	58                   	pop    %eax
-     322:	ff 73 08             	pushl  0x8(%ebx)
-     325:	e8 56 fe ff ff       	call   180 <runcmd>
-    panic("fork");
-     32a:	83 ec 0c             	sub    $0xc,%esp
-     32d:	68 e2 12 00 00       	push   $0x12e2
-     332:	e8 29 fe ff ff       	call   160 <panic>
-     337:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     33e:	66 90                	xchg   %ax,%ax
-
-00000340 <fork1>:
-{
-     340:	f3 0f 1e fb          	endbr32 
-     344:	55                   	push   %ebp
-     345:	89 e5                	mov    %esp,%ebp
-     347:	83 ec 08             	sub    $0x8,%esp
-  pid = fork();
-     34a:	e8 3c 0a 00 00       	call   d8b <fork>
-  if(pid == -1)
-     34f:	83 f8 ff             	cmp    $0xffffffff,%eax
-     352:	74 02                	je     356 <fork1+0x16>
-  return pid;
-}
-     354:	c9                   	leave  
-     355:	c3                   	ret    
-    panic("fork");
-     356:	83 ec 0c             	sub    $0xc,%esp
-     359:	68 e2 12 00 00       	push   $0x12e2
-     35e:	e8 fd fd ff ff       	call   160 <panic>
-     363:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     36a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000370 <execcmd>:
-//PAGEBREAK!
-// Constructors
-
-struct cmd*
-execcmd(void)
-{
-     370:	f3 0f 1e fb          	endbr32 
-     374:	55                   	push   %ebp
-     375:	89 e5                	mov    %esp,%ebp
-     377:	53                   	push   %ebx
-     378:	83 ec 10             	sub    $0x10,%esp
-  struct execcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-     37b:	6a 54                	push   $0x54
-     37d:	e8 2e 0e 00 00       	call   11b0 <malloc>
-  memset(cmd, 0, sizeof(*cmd));
-     382:	83 c4 0c             	add    $0xc,%esp
-     385:	6a 54                	push   $0x54
-  cmd = malloc(sizeof(*cmd));
-     387:	89 c3                	mov    %eax,%ebx
-  memset(cmd, 0, sizeof(*cmd));
-     389:	6a 00                	push   $0x0
-     38b:	50                   	push   %eax
-     38c:	e8 5f 08 00 00       	call   bf0 <memset>
-  cmd->type = EXEC;
-     391:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
-  return (struct cmd*)cmd;
-}
-     397:	89 d8                	mov    %ebx,%eax
-     399:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-     39c:	c9                   	leave  
-     39d:	c3                   	ret    
-     39e:	66 90                	xchg   %ax,%ax
-
-000003a0 <redircmd>:
-
-struct cmd*
-redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
-{
-     3a0:	f3 0f 1e fb          	endbr32 
-     3a4:	55                   	push   %ebp
-     3a5:	89 e5                	mov    %esp,%ebp
-     3a7:	53                   	push   %ebx
-     3a8:	83 ec 10             	sub    $0x10,%esp
-  struct redircmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-     3ab:	6a 18                	push   $0x18
-     3ad:	e8 fe 0d 00 00       	call   11b0 <malloc>
-  memset(cmd, 0, sizeof(*cmd));
-     3b2:	83 c4 0c             	add    $0xc,%esp
-     3b5:	6a 18                	push   $0x18
-  cmd = malloc(sizeof(*cmd));
-     3b7:	89 c3                	mov    %eax,%ebx
-  memset(cmd, 0, sizeof(*cmd));
-     3b9:	6a 00                	push   $0x0
-     3bb:	50                   	push   %eax
-     3bc:	e8 2f 08 00 00       	call   bf0 <memset>
-  cmd->type = REDIR;
-  cmd->cmd = subcmd;
-     3c1:	8b 45 08             	mov    0x8(%ebp),%eax
-  cmd->type = REDIR;
-     3c4:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
-  cmd->cmd = subcmd;
-     3ca:	89 43 04             	mov    %eax,0x4(%ebx)
-  cmd->file = file;
-     3cd:	8b 45 0c             	mov    0xc(%ebp),%eax
-     3d0:	89 43 08             	mov    %eax,0x8(%ebx)
-  cmd->efile = efile;
-     3d3:	8b 45 10             	mov    0x10(%ebp),%eax
-     3d6:	89 43 0c             	mov    %eax,0xc(%ebx)
-  cmd->mode = mode;
-     3d9:	8b 45 14             	mov    0x14(%ebp),%eax
-     3dc:	89 43 10             	mov    %eax,0x10(%ebx)
-  cmd->fd = fd;
-     3df:	8b 45 18             	mov    0x18(%ebp),%eax
-     3e2:	89 43 14             	mov    %eax,0x14(%ebx)
-  return (struct cmd*)cmd;
-}
-     3e5:	89 d8                	mov    %ebx,%eax
-     3e7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-     3ea:	c9                   	leave  
-     3eb:	c3                   	ret    
-     3ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000003f0 <pipecmd>:
-
-struct cmd*
-pipecmd(struct cmd *left, struct cmd *right)
-{
-     3f0:	f3 0f 1e fb          	endbr32 
-     3f4:	55                   	push   %ebp
-     3f5:	89 e5                	mov    %esp,%ebp
-     3f7:	53                   	push   %ebx
-     3f8:	83 ec 10             	sub    $0x10,%esp
-  struct pipecmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-     3fb:	6a 0c                	push   $0xc
-     3fd:	e8 ae 0d 00 00       	call   11b0 <malloc>
-  memset(cmd, 0, sizeof(*cmd));
-     402:	83 c4 0c             	add    $0xc,%esp
-     405:	6a 0c                	push   $0xc
-  cmd = malloc(sizeof(*cmd));
-     407:	89 c3                	mov    %eax,%ebx
-  memset(cmd, 0, sizeof(*cmd));
-     409:	6a 00                	push   $0x0
-     40b:	50                   	push   %eax
-     40c:	e8 df 07 00 00       	call   bf0 <memset>
-  cmd->type = PIPE;
-  cmd->left = left;
-     411:	8b 45 08             	mov    0x8(%ebp),%eax
-  cmd->type = PIPE;
-     414:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
-  cmd->left = left;
-     41a:	89 43 04             	mov    %eax,0x4(%ebx)
-  cmd->right = right;
-     41d:	8b 45 0c             	mov    0xc(%ebp),%eax
-     420:	89 43 08             	mov    %eax,0x8(%ebx)
-  return (struct cmd*)cmd;
-}
-     423:	89 d8                	mov    %ebx,%eax
-     425:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-     428:	c9                   	leave  
-     429:	c3                   	ret    
-     42a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000430 <listcmd>:
-
-struct cmd*
-listcmd(struct cmd *left, struct cmd *right)
-{
-     430:	f3 0f 1e fb          	endbr32 
-     434:	55                   	push   %ebp
-     435:	89 e5                	mov    %esp,%ebp
-     437:	53                   	push   %ebx
-     438:	83 ec 10             	sub    $0x10,%esp
-  struct listcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-     43b:	6a 0c                	push   $0xc
-     43d:	e8 6e 0d 00 00       	call   11b0 <malloc>
-  memset(cmd, 0, sizeof(*cmd));
-     442:	83 c4 0c             	add    $0xc,%esp
-     445:	6a 0c                	push   $0xc
-  cmd = malloc(sizeof(*cmd));
-     447:	89 c3                	mov    %eax,%ebx
-  memset(cmd, 0, sizeof(*cmd));
-     449:	6a 00                	push   $0x0
-     44b:	50                   	push   %eax
-     44c:	e8 9f 07 00 00       	call   bf0 <memset>
-  cmd->type = LIST;
-  cmd->left = left;
-     451:	8b 45 08             	mov    0x8(%ebp),%eax
-  cmd->type = LIST;
-     454:	c7 03 04 00 00 00    	movl   $0x4,(%ebx)
-  cmd->left = left;
-     45a:	89 43 04             	mov    %eax,0x4(%ebx)
-  cmd->right = right;
-     45d:	8b 45 0c             	mov    0xc(%ebp),%eax
-     460:	89 43 08             	mov    %eax,0x8(%ebx)
-  return (struct cmd*)cmd;
-}
-     463:	89 d8                	mov    %ebx,%eax
-     465:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-     468:	c9                   	leave  
-     469:	c3                   	ret    
-     46a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000470 <backcmd>:
-
-struct cmd*
-backcmd(struct cmd *subcmd)
-{
-     470:	f3 0f 1e fb          	endbr32 
-     474:	55                   	push   %ebp
-     475:	89 e5                	mov    %esp,%ebp
-     477:	53                   	push   %ebx
-     478:	83 ec 10             	sub    $0x10,%esp
-  struct backcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-     47b:	6a 08                	push   $0x8
-     47d:	e8 2e 0d 00 00       	call   11b0 <malloc>
-  memset(cmd, 0, sizeof(*cmd));
-     482:	83 c4 0c             	add    $0xc,%esp
-     485:	6a 08                	push   $0x8
-  cmd = malloc(sizeof(*cmd));
-     487:	89 c3                	mov    %eax,%ebx
-  memset(cmd, 0, sizeof(*cmd));
-     489:	6a 00                	push   $0x0
-     48b:	50                   	push   %eax
-     48c:	e8 5f 07 00 00       	call   bf0 <memset>
-  cmd->type = BACK;
-  cmd->cmd = subcmd;
-     491:	8b 45 08             	mov    0x8(%ebp),%eax
-  cmd->type = BACK;
-     494:	c7 03 05 00 00 00    	movl   $0x5,(%ebx)
-  cmd->cmd = subcmd;
-     49a:	89 43 04             	mov    %eax,0x4(%ebx)
-  return (struct cmd*)cmd;
-}
-     49d:	89 d8                	mov    %ebx,%eax
-     49f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-     4a2:	c9                   	leave  
-     4a3:	c3                   	ret    
-     4a4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     4ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     4af:	90                   	nop
-
-000004b0 <gettoken>:
-char whitespace[] = " \t\r\n\v";
-char symbols[] = "<|>&;()";
-
-int
-gettoken(char **ps, char *es, char **q, char **eq)
-{
-     4b0:	f3 0f 1e fb          	endbr32 
-     4b4:	55                   	push   %ebp
-     4b5:	89 e5                	mov    %esp,%ebp
-     4b7:	57                   	push   %edi
-     4b8:	56                   	push   %esi
-     4b9:	53                   	push   %ebx
-     4ba:	83 ec 0c             	sub    $0xc,%esp
-  char *s;
-  int ret;
-
-  s = *ps;
-     4bd:	8b 45 08             	mov    0x8(%ebp),%eax
-{
-     4c0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-     4c3:	8b 75 10             	mov    0x10(%ebp),%esi
-  s = *ps;
-     4c6:	8b 38                	mov    (%eax),%edi
-  while(s < es && strchr(whitespace, *s))
-     4c8:	39 df                	cmp    %ebx,%edi
-     4ca:	72 0b                	jb     4d7 <gettoken+0x27>
-     4cc:	eb 21                	jmp    4ef <gettoken+0x3f>
-     4ce:	66 90                	xchg   %ax,%ax
-    s++;
-     4d0:	83 c7 01             	add    $0x1,%edi
-  while(s < es && strchr(whitespace, *s))
-     4d3:	39 fb                	cmp    %edi,%ebx
-     4d5:	74 18                	je     4ef <gettoken+0x3f>
-     4d7:	0f be 07             	movsbl (%edi),%eax
-     4da:	83 ec 08             	sub    $0x8,%esp
-     4dd:	50                   	push   %eax
-     4de:	68 80 19 00 00       	push   $0x1980
-     4e3:	e8 28 07 00 00       	call   c10 <strchr>
-     4e8:	83 c4 10             	add    $0x10,%esp
-     4eb:	85 c0                	test   %eax,%eax
-     4ed:	75 e1                	jne    4d0 <gettoken+0x20>
-  if(q)
-     4ef:	85 f6                	test   %esi,%esi
-     4f1:	74 02                	je     4f5 <gettoken+0x45>
-    *q = s;
-     4f3:	89 3e                	mov    %edi,(%esi)
-  ret = *s;
-     4f5:	0f b6 07             	movzbl (%edi),%eax
-  switch(*s){
-     4f8:	3c 3c                	cmp    $0x3c,%al
-     4fa:	0f 8f d0 00 00 00    	jg     5d0 <gettoken+0x120>
-     500:	3c 3a                	cmp    $0x3a,%al
-     502:	0f 8f b4 00 00 00    	jg     5bc <gettoken+0x10c>
-     508:	84 c0                	test   %al,%al
-     50a:	75 44                	jne    550 <gettoken+0xa0>
-     50c:	31 f6                	xor    %esi,%esi
-    ret = 'a';
-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
-      s++;
-    break;
-  }
-  if(eq)
-     50e:	8b 55 14             	mov    0x14(%ebp),%edx
-     511:	85 d2                	test   %edx,%edx
-     513:	74 05                	je     51a <gettoken+0x6a>
-    *eq = s;
-     515:	8b 45 14             	mov    0x14(%ebp),%eax
-     518:	89 38                	mov    %edi,(%eax)
-
-  while(s < es && strchr(whitespace, *s))
-     51a:	39 df                	cmp    %ebx,%edi
-     51c:	72 09                	jb     527 <gettoken+0x77>
-     51e:	eb 1f                	jmp    53f <gettoken+0x8f>
-    s++;
-     520:	83 c7 01             	add    $0x1,%edi
-  while(s < es && strchr(whitespace, *s))
-     523:	39 fb                	cmp    %edi,%ebx
-     525:	74 18                	je     53f <gettoken+0x8f>
-     527:	0f be 07             	movsbl (%edi),%eax
-     52a:	83 ec 08             	sub    $0x8,%esp
-     52d:	50                   	push   %eax
-     52e:	68 80 19 00 00       	push   $0x1980
-     533:	e8 d8 06 00 00       	call   c10 <strchr>
-     538:	83 c4 10             	add    $0x10,%esp
-     53b:	85 c0                	test   %eax,%eax
-     53d:	75 e1                	jne    520 <gettoken+0x70>
-  *ps = s;
-     53f:	8b 45 08             	mov    0x8(%ebp),%eax
-     542:	89 38                	mov    %edi,(%eax)
-  return ret;
-}
-     544:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     547:	89 f0                	mov    %esi,%eax
-     549:	5b                   	pop    %ebx
-     54a:	5e                   	pop    %esi
-     54b:	5f                   	pop    %edi
-     54c:	5d                   	pop    %ebp
-     54d:	c3                   	ret    
-     54e:	66 90                	xchg   %ax,%ax
-  switch(*s){
-     550:	79 5e                	jns    5b0 <gettoken+0x100>
-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
-     552:	39 fb                	cmp    %edi,%ebx
-     554:	77 34                	ja     58a <gettoken+0xda>
-  if(eq)
-     556:	8b 45 14             	mov    0x14(%ebp),%eax
-     559:	be 61 00 00 00       	mov    $0x61,%esi
-     55e:	85 c0                	test   %eax,%eax
-     560:	75 b3                	jne    515 <gettoken+0x65>
-     562:	eb db                	jmp    53f <gettoken+0x8f>
-     564:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
-     568:	0f be 07             	movsbl (%edi),%eax
-     56b:	83 ec 08             	sub    $0x8,%esp
-     56e:	50                   	push   %eax
-     56f:	68 78 19 00 00       	push   $0x1978
-     574:	e8 97 06 00 00       	call   c10 <strchr>
-     579:	83 c4 10             	add    $0x10,%esp
-     57c:	85 c0                	test   %eax,%eax
-     57e:	75 22                	jne    5a2 <gettoken+0xf2>
-      s++;
-     580:	83 c7 01             	add    $0x1,%edi
-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
-     583:	39 fb                	cmp    %edi,%ebx
-     585:	74 cf                	je     556 <gettoken+0xa6>
-     587:	0f b6 07             	movzbl (%edi),%eax
-     58a:	83 ec 08             	sub    $0x8,%esp
-     58d:	0f be f0             	movsbl %al,%esi
-     590:	56                   	push   %esi
-     591:	68 80 19 00 00       	push   $0x1980
-     596:	e8 75 06 00 00       	call   c10 <strchr>
-     59b:	83 c4 10             	add    $0x10,%esp
-     59e:	85 c0                	test   %eax,%eax
-     5a0:	74 c6                	je     568 <gettoken+0xb8>
-    ret = 'a';
-     5a2:	be 61 00 00 00       	mov    $0x61,%esi
-     5a7:	e9 62 ff ff ff       	jmp    50e <gettoken+0x5e>
-     5ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  switch(*s){
-     5b0:	3c 26                	cmp    $0x26,%al
-     5b2:	74 08                	je     5bc <gettoken+0x10c>
-     5b4:	8d 48 d8             	lea    -0x28(%eax),%ecx
-     5b7:	80 f9 01             	cmp    $0x1,%cl
-     5ba:	77 96                	ja     552 <gettoken+0xa2>
-  ret = *s;
-     5bc:	0f be f0             	movsbl %al,%esi
-    s++;
-     5bf:	83 c7 01             	add    $0x1,%edi
-    break;
-     5c2:	e9 47 ff ff ff       	jmp    50e <gettoken+0x5e>
-     5c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     5ce:	66 90                	xchg   %ax,%ax
-  switch(*s){
-     5d0:	3c 3e                	cmp    $0x3e,%al
-     5d2:	75 1c                	jne    5f0 <gettoken+0x140>
-    if(*s == '>'){
-     5d4:	80 7f 01 3e          	cmpb   $0x3e,0x1(%edi)
-    s++;
-     5d8:	8d 47 01             	lea    0x1(%edi),%eax
-    if(*s == '>'){
-     5db:	74 1c                	je     5f9 <gettoken+0x149>
-    s++;
-     5dd:	89 c7                	mov    %eax,%edi
-     5df:	be 3e 00 00 00       	mov    $0x3e,%esi
-     5e4:	e9 25 ff ff ff       	jmp    50e <gettoken+0x5e>
-     5e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  switch(*s){
-     5f0:	3c 7c                	cmp    $0x7c,%al
-     5f2:	74 c8                	je     5bc <gettoken+0x10c>
-     5f4:	e9 59 ff ff ff       	jmp    552 <gettoken+0xa2>
-      s++;
-     5f9:	83 c7 02             	add    $0x2,%edi
-      ret = '+';
-     5fc:	be 2b 00 00 00       	mov    $0x2b,%esi
-     601:	e9 08 ff ff ff       	jmp    50e <gettoken+0x5e>
-     606:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     60d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000610 <peek>:
-
-int
-peek(char **ps, char *es, char *toks)
-{
-     610:	f3 0f 1e fb          	endbr32 
-     614:	55                   	push   %ebp
-     615:	89 e5                	mov    %esp,%ebp
-     617:	57                   	push   %edi
-     618:	56                   	push   %esi
-     619:	53                   	push   %ebx
-     61a:	83 ec 0c             	sub    $0xc,%esp
-     61d:	8b 7d 08             	mov    0x8(%ebp),%edi
-     620:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *s;
-
-  s = *ps;
-     623:	8b 1f                	mov    (%edi),%ebx
-  while(s < es && strchr(whitespace, *s))
-     625:	39 f3                	cmp    %esi,%ebx
-     627:	72 0e                	jb     637 <peek+0x27>
-     629:	eb 24                	jmp    64f <peek+0x3f>
-     62b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     62f:	90                   	nop
-    s++;
-     630:	83 c3 01             	add    $0x1,%ebx
-  while(s < es && strchr(whitespace, *s))
-     633:	39 de                	cmp    %ebx,%esi
-     635:	74 18                	je     64f <peek+0x3f>
-     637:	0f be 03             	movsbl (%ebx),%eax
-     63a:	83 ec 08             	sub    $0x8,%esp
-     63d:	50                   	push   %eax
-     63e:	68 80 19 00 00       	push   $0x1980
-     643:	e8 c8 05 00 00       	call   c10 <strchr>
-     648:	83 c4 10             	add    $0x10,%esp
-     64b:	85 c0                	test   %eax,%eax
-     64d:	75 e1                	jne    630 <peek+0x20>
-  *ps = s;
-     64f:	89 1f                	mov    %ebx,(%edi)
-  return *s && strchr(toks, *s);
-     651:	0f be 03             	movsbl (%ebx),%eax
-     654:	31 d2                	xor    %edx,%edx
-     656:	84 c0                	test   %al,%al
-     658:	75 0e                	jne    668 <peek+0x58>
-}
-     65a:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     65d:	89 d0                	mov    %edx,%eax
-     65f:	5b                   	pop    %ebx
-     660:	5e                   	pop    %esi
-     661:	5f                   	pop    %edi
-     662:	5d                   	pop    %ebp
-     663:	c3                   	ret    
-     664:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  return *s && strchr(toks, *s);
-     668:	83 ec 08             	sub    $0x8,%esp
-     66b:	50                   	push   %eax
-     66c:	ff 75 10             	pushl  0x10(%ebp)
-     66f:	e8 9c 05 00 00       	call   c10 <strchr>
-     674:	83 c4 10             	add    $0x10,%esp
-     677:	31 d2                	xor    %edx,%edx
-     679:	85 c0                	test   %eax,%eax
-     67b:	0f 95 c2             	setne  %dl
-}
-     67e:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     681:	5b                   	pop    %ebx
-     682:	89 d0                	mov    %edx,%eax
-     684:	5e                   	pop    %esi
-     685:	5f                   	pop    %edi
-     686:	5d                   	pop    %ebp
-     687:	c3                   	ret    
-     688:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     68f:	90                   	nop
-
-00000690 <parseredirs>:
-  return cmd;
-}
-
-struct cmd*
-parseredirs(struct cmd *cmd, char **ps, char *es)
-{
-     690:	f3 0f 1e fb          	endbr32 
-     694:	55                   	push   %ebp
-     695:	89 e5                	mov    %esp,%ebp
-     697:	57                   	push   %edi
-     698:	56                   	push   %esi
-     699:	53                   	push   %ebx
-     69a:	83 ec 1c             	sub    $0x1c,%esp
-     69d:	8b 75 0c             	mov    0xc(%ebp),%esi
-     6a0:	8b 5d 10             	mov    0x10(%ebp),%ebx
-  int tok;
-  char *q, *eq;
-
-  while(peek(ps, es, "<>")){
-     6a3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     6a7:	90                   	nop
-     6a8:	83 ec 04             	sub    $0x4,%esp
-     6ab:	68 09 13 00 00       	push   $0x1309
-     6b0:	53                   	push   %ebx
-     6b1:	56                   	push   %esi
-     6b2:	e8 59 ff ff ff       	call   610 <peek>
-     6b7:	83 c4 10             	add    $0x10,%esp
-     6ba:	85 c0                	test   %eax,%eax
-     6bc:	74 6a                	je     728 <parseredirs+0x98>
-    tok = gettoken(ps, es, 0, 0);
-     6be:	6a 00                	push   $0x0
-     6c0:	6a 00                	push   $0x0
-     6c2:	53                   	push   %ebx
-     6c3:	56                   	push   %esi
-     6c4:	e8 e7 fd ff ff       	call   4b0 <gettoken>
-     6c9:	89 c7                	mov    %eax,%edi
-    if(gettoken(ps, es, &q, &eq) != 'a')
-     6cb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
-     6ce:	50                   	push   %eax
-     6cf:	8d 45 e0             	lea    -0x20(%ebp),%eax
-     6d2:	50                   	push   %eax
-     6d3:	53                   	push   %ebx
-     6d4:	56                   	push   %esi
-     6d5:	e8 d6 fd ff ff       	call   4b0 <gettoken>
-     6da:	83 c4 20             	add    $0x20,%esp
-     6dd:	83 f8 61             	cmp    $0x61,%eax
-     6e0:	75 51                	jne    733 <parseredirs+0xa3>
-      panic("missing file for redirection");
-    switch(tok){
-     6e2:	83 ff 3c             	cmp    $0x3c,%edi
-     6e5:	74 31                	je     718 <parseredirs+0x88>
-     6e7:	83 ff 3e             	cmp    $0x3e,%edi
-     6ea:	74 05                	je     6f1 <parseredirs+0x61>
-     6ec:	83 ff 2b             	cmp    $0x2b,%edi
-     6ef:	75 b7                	jne    6a8 <parseredirs+0x18>
-      break;
-    case '>':
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
-      break;
-    case '+':  // >>
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
-     6f1:	83 ec 0c             	sub    $0xc,%esp
-     6f4:	6a 01                	push   $0x1
-     6f6:	68 01 02 00 00       	push   $0x201
-     6fb:	ff 75 e4             	pushl  -0x1c(%ebp)
-     6fe:	ff 75 e0             	pushl  -0x20(%ebp)
-     701:	ff 75 08             	pushl  0x8(%ebp)
-     704:	e8 97 fc ff ff       	call   3a0 <redircmd>
-      break;
-     709:	83 c4 20             	add    $0x20,%esp
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
-     70c:	89 45 08             	mov    %eax,0x8(%ebp)
-      break;
-     70f:	eb 97                	jmp    6a8 <parseredirs+0x18>
-     711:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
-     718:	83 ec 0c             	sub    $0xc,%esp
-     71b:	6a 00                	push   $0x0
-     71d:	6a 00                	push   $0x0
-     71f:	eb da                	jmp    6fb <parseredirs+0x6b>
-     721:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    }
-  }
-  return cmd;
-}
-     728:	8b 45 08             	mov    0x8(%ebp),%eax
-     72b:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     72e:	5b                   	pop    %ebx
-     72f:	5e                   	pop    %esi
-     730:	5f                   	pop    %edi
-     731:	5d                   	pop    %ebp
-     732:	c3                   	ret    
-      panic("missing file for redirection");
-     733:	83 ec 0c             	sub    $0xc,%esp
-     736:	68 ec 12 00 00       	push   $0x12ec
-     73b:	e8 20 fa ff ff       	call   160 <panic>
-
-00000740 <parseexec>:
-  return cmd;
-}
-
-struct cmd*
-parseexec(char **ps, char *es)
-{
-     740:	f3 0f 1e fb          	endbr32 
-     744:	55                   	push   %ebp
-     745:	89 e5                	mov    %esp,%ebp
-     747:	57                   	push   %edi
-     748:	56                   	push   %esi
-     749:	53                   	push   %ebx
-     74a:	83 ec 30             	sub    $0x30,%esp
-     74d:	8b 75 08             	mov    0x8(%ebp),%esi
-     750:	8b 7d 0c             	mov    0xc(%ebp),%edi
-  char *q, *eq;
-  int tok, argc;
-  struct execcmd *cmd;
-  struct cmd *ret;
-
-  if(peek(ps, es, "("))
-     753:	68 0c 13 00 00       	push   $0x130c
-     758:	57                   	push   %edi
-     759:	56                   	push   %esi
-     75a:	e8 b1 fe ff ff       	call   610 <peek>
-     75f:	83 c4 10             	add    $0x10,%esp
-     762:	85 c0                	test   %eax,%eax
-     764:	0f 85 96 00 00 00    	jne    800 <parseexec+0xc0>
-     76a:	89 c3                	mov    %eax,%ebx
-    return parseblock(ps, es);
-
-  ret = execcmd();
-     76c:	e8 ff fb ff ff       	call   370 <execcmd>
-  cmd = (struct execcmd*)ret;
-
-  argc = 0;
-  ret = parseredirs(ret, ps, es);
-     771:	83 ec 04             	sub    $0x4,%esp
-     774:	57                   	push   %edi
-     775:	56                   	push   %esi
-     776:	50                   	push   %eax
-  ret = execcmd();
-     777:	89 45 d0             	mov    %eax,-0x30(%ebp)
-  ret = parseredirs(ret, ps, es);
-     77a:	e8 11 ff ff ff       	call   690 <parseredirs>
-  while(!peek(ps, es, "|)&;")){
-     77f:	83 c4 10             	add    $0x10,%esp
-  ret = parseredirs(ret, ps, es);
-     782:	89 45 d4             	mov    %eax,-0x2c(%ebp)
-  while(!peek(ps, es, "|)&;")){
-     785:	eb 1c                	jmp    7a3 <parseexec+0x63>
-     787:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     78e:	66 90                	xchg   %ax,%ax
-    cmd->argv[argc] = q;
-    cmd->eargv[argc] = eq;
-    argc++;
-    if(argc >= MAXARGS)
-      panic("too many args");
-    ret = parseredirs(ret, ps, es);
-     790:	83 ec 04             	sub    $0x4,%esp
-     793:	57                   	push   %edi
-     794:	56                   	push   %esi
-     795:	ff 75 d4             	pushl  -0x2c(%ebp)
-     798:	e8 f3 fe ff ff       	call   690 <parseredirs>
-     79d:	83 c4 10             	add    $0x10,%esp
-     7a0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
-  while(!peek(ps, es, "|)&;")){
-     7a3:	83 ec 04             	sub    $0x4,%esp
-     7a6:	68 23 13 00 00       	push   $0x1323
-     7ab:	57                   	push   %edi
-     7ac:	56                   	push   %esi
-     7ad:	e8 5e fe ff ff       	call   610 <peek>
-     7b2:	83 c4 10             	add    $0x10,%esp
-     7b5:	85 c0                	test   %eax,%eax
-     7b7:	75 67                	jne    820 <parseexec+0xe0>
-    if((tok=gettoken(ps, es, &q, &eq)) == 0)
-     7b9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
-     7bc:	50                   	push   %eax
-     7bd:	8d 45 e0             	lea    -0x20(%ebp),%eax
-     7c0:	50                   	push   %eax
-     7c1:	57                   	push   %edi
-     7c2:	56                   	push   %esi
-     7c3:	e8 e8 fc ff ff       	call   4b0 <gettoken>
-     7c8:	83 c4 10             	add    $0x10,%esp
-     7cb:	85 c0                	test   %eax,%eax
-     7cd:	74 51                	je     820 <parseexec+0xe0>
-    if(tok != 'a')
-     7cf:	83 f8 61             	cmp    $0x61,%eax
-     7d2:	75 6b                	jne    83f <parseexec+0xff>
-    cmd->argv[argc] = q;
-     7d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
-     7d7:	8b 55 d0             	mov    -0x30(%ebp),%edx
-     7da:	89 44 9a 04          	mov    %eax,0x4(%edx,%ebx,4)
-    cmd->eargv[argc] = eq;
-     7de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-     7e1:	89 44 9a 2c          	mov    %eax,0x2c(%edx,%ebx,4)
-    argc++;
-     7e5:	83 c3 01             	add    $0x1,%ebx
-    if(argc >= MAXARGS)
-     7e8:	83 fb 0a             	cmp    $0xa,%ebx
-     7eb:	75 a3                	jne    790 <parseexec+0x50>
-      panic("too many args");
-     7ed:	83 ec 0c             	sub    $0xc,%esp
-     7f0:	68 15 13 00 00       	push   $0x1315
-     7f5:	e8 66 f9 ff ff       	call   160 <panic>
-     7fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    return parseblock(ps, es);
-     800:	83 ec 08             	sub    $0x8,%esp
-     803:	57                   	push   %edi
-     804:	56                   	push   %esi
-     805:	e8 66 01 00 00       	call   970 <parseblock>
-     80a:	83 c4 10             	add    $0x10,%esp
-     80d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
-  }
-  cmd->argv[argc] = 0;
-  cmd->eargv[argc] = 0;
-  return ret;
-}
-     810:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-     813:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     816:	5b                   	pop    %ebx
-     817:	5e                   	pop    %esi
-     818:	5f                   	pop    %edi
-     819:	5d                   	pop    %ebp
-     81a:	c3                   	ret    
-     81b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     81f:	90                   	nop
-  cmd->argv[argc] = 0;
-     820:	8b 45 d0             	mov    -0x30(%ebp),%eax
-     823:	8d 04 98             	lea    (%eax,%ebx,4),%eax
-     826:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
-  cmd->eargv[argc] = 0;
-     82d:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
-}
-     834:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-     837:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     83a:	5b                   	pop    %ebx
-     83b:	5e                   	pop    %esi
-     83c:	5f                   	pop    %edi
-     83d:	5d                   	pop    %ebp
-     83e:	c3                   	ret    
-      panic("syntax");
-     83f:	83 ec 0c             	sub    $0xc,%esp
-     842:	68 0e 13 00 00       	push   $0x130e
-     847:	e8 14 f9 ff ff       	call   160 <panic>
-     84c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000850 <parsepipe>:
-{
-     850:	f3 0f 1e fb          	endbr32 
-     854:	55                   	push   %ebp
-     855:	89 e5                	mov    %esp,%ebp
-     857:	57                   	push   %edi
-     858:	56                   	push   %esi
-     859:	53                   	push   %ebx
-     85a:	83 ec 14             	sub    $0x14,%esp
-     85d:	8b 75 08             	mov    0x8(%ebp),%esi
-     860:	8b 7d 0c             	mov    0xc(%ebp),%edi
-  cmd = parseexec(ps, es);
-     863:	57                   	push   %edi
-     864:	56                   	push   %esi
-     865:	e8 d6 fe ff ff       	call   740 <parseexec>
-  if(peek(ps, es, "|")){
-     86a:	83 c4 0c             	add    $0xc,%esp
-     86d:	68 28 13 00 00       	push   $0x1328
-  cmd = parseexec(ps, es);
-     872:	89 c3                	mov    %eax,%ebx
-  if(peek(ps, es, "|")){
-     874:	57                   	push   %edi
-     875:	56                   	push   %esi
-     876:	e8 95 fd ff ff       	call   610 <peek>
-     87b:	83 c4 10             	add    $0x10,%esp
-     87e:	85 c0                	test   %eax,%eax
-     880:	75 0e                	jne    890 <parsepipe+0x40>
-}
-     882:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     885:	89 d8                	mov    %ebx,%eax
-     887:	5b                   	pop    %ebx
-     888:	5e                   	pop    %esi
-     889:	5f                   	pop    %edi
-     88a:	5d                   	pop    %ebp
-     88b:	c3                   	ret    
-     88c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    gettoken(ps, es, 0, 0);
-     890:	6a 00                	push   $0x0
-     892:	6a 00                	push   $0x0
-     894:	57                   	push   %edi
-     895:	56                   	push   %esi
-     896:	e8 15 fc ff ff       	call   4b0 <gettoken>
-    cmd = pipecmd(cmd, parsepipe(ps, es));
-     89b:	58                   	pop    %eax
-     89c:	5a                   	pop    %edx
-     89d:	57                   	push   %edi
-     89e:	56                   	push   %esi
-     89f:	e8 ac ff ff ff       	call   850 <parsepipe>
-     8a4:	89 5d 08             	mov    %ebx,0x8(%ebp)
-     8a7:	83 c4 10             	add    $0x10,%esp
-     8aa:	89 45 0c             	mov    %eax,0xc(%ebp)
-}
-     8ad:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     8b0:	5b                   	pop    %ebx
-     8b1:	5e                   	pop    %esi
-     8b2:	5f                   	pop    %edi
-     8b3:	5d                   	pop    %ebp
-    cmd = pipecmd(cmd, parsepipe(ps, es));
-     8b4:	e9 37 fb ff ff       	jmp    3f0 <pipecmd>
-     8b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-000008c0 <parseline>:
-{
-     8c0:	f3 0f 1e fb          	endbr32 
-     8c4:	55                   	push   %ebp
-     8c5:	89 e5                	mov    %esp,%ebp
-     8c7:	57                   	push   %edi
-     8c8:	56                   	push   %esi
-     8c9:	53                   	push   %ebx
-     8ca:	83 ec 14             	sub    $0x14,%esp
-     8cd:	8b 75 08             	mov    0x8(%ebp),%esi
-     8d0:	8b 7d 0c             	mov    0xc(%ebp),%edi
-  cmd = parsepipe(ps, es);
-     8d3:	57                   	push   %edi
-     8d4:	56                   	push   %esi
-     8d5:	e8 76 ff ff ff       	call   850 <parsepipe>
-  while(peek(ps, es, "&")){
-     8da:	83 c4 10             	add    $0x10,%esp
-  cmd = parsepipe(ps, es);
-     8dd:	89 c3                	mov    %eax,%ebx
-  while(peek(ps, es, "&")){
-     8df:	eb 1f                	jmp    900 <parseline+0x40>
-     8e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    gettoken(ps, es, 0, 0);
-     8e8:	6a 00                	push   $0x0
-     8ea:	6a 00                	push   $0x0
-     8ec:	57                   	push   %edi
-     8ed:	56                   	push   %esi
-     8ee:	e8 bd fb ff ff       	call   4b0 <gettoken>
-    cmd = backcmd(cmd);
-     8f3:	89 1c 24             	mov    %ebx,(%esp)
-     8f6:	e8 75 fb ff ff       	call   470 <backcmd>
-     8fb:	83 c4 10             	add    $0x10,%esp
-     8fe:	89 c3                	mov    %eax,%ebx
-  while(peek(ps, es, "&")){
-     900:	83 ec 04             	sub    $0x4,%esp
-     903:	68 2a 13 00 00       	push   $0x132a
-     908:	57                   	push   %edi
-     909:	56                   	push   %esi
-     90a:	e8 01 fd ff ff       	call   610 <peek>
-     90f:	83 c4 10             	add    $0x10,%esp
-     912:	85 c0                	test   %eax,%eax
-     914:	75 d2                	jne    8e8 <parseline+0x28>
-  if(peek(ps, es, ";")){
-     916:	83 ec 04             	sub    $0x4,%esp
-     919:	68 26 13 00 00       	push   $0x1326
-     91e:	57                   	push   %edi
-     91f:	56                   	push   %esi
-     920:	e8 eb fc ff ff       	call   610 <peek>
-     925:	83 c4 10             	add    $0x10,%esp
-     928:	85 c0                	test   %eax,%eax
-     92a:	75 14                	jne    940 <parseline+0x80>
-}
-     92c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     92f:	89 d8                	mov    %ebx,%eax
-     931:	5b                   	pop    %ebx
-     932:	5e                   	pop    %esi
-     933:	5f                   	pop    %edi
-     934:	5d                   	pop    %ebp
-     935:	c3                   	ret    
-     936:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     93d:	8d 76 00             	lea    0x0(%esi),%esi
-    gettoken(ps, es, 0, 0);
-     940:	6a 00                	push   $0x0
-     942:	6a 00                	push   $0x0
-     944:	57                   	push   %edi
-     945:	56                   	push   %esi
-     946:	e8 65 fb ff ff       	call   4b0 <gettoken>
-    cmd = listcmd(cmd, parseline(ps, es));
-     94b:	58                   	pop    %eax
-     94c:	5a                   	pop    %edx
-     94d:	57                   	push   %edi
-     94e:	56                   	push   %esi
-     94f:	e8 6c ff ff ff       	call   8c0 <parseline>
-     954:	89 5d 08             	mov    %ebx,0x8(%ebp)
-     957:	83 c4 10             	add    $0x10,%esp
-     95a:	89 45 0c             	mov    %eax,0xc(%ebp)
-}
-     95d:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     960:	5b                   	pop    %ebx
-     961:	5e                   	pop    %esi
-     962:	5f                   	pop    %edi
-     963:	5d                   	pop    %ebp
-    cmd = listcmd(cmd, parseline(ps, es));
-     964:	e9 c7 fa ff ff       	jmp    430 <listcmd>
-     969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-00000970 <parseblock>:
-{
-     970:	f3 0f 1e fb          	endbr32 
-     974:	55                   	push   %ebp
-     975:	89 e5                	mov    %esp,%ebp
-     977:	57                   	push   %edi
-     978:	56                   	push   %esi
-     979:	53                   	push   %ebx
-     97a:	83 ec 10             	sub    $0x10,%esp
-     97d:	8b 5d 08             	mov    0x8(%ebp),%ebx
-     980:	8b 75 0c             	mov    0xc(%ebp),%esi
-  if(!peek(ps, es, "("))
-     983:	68 0c 13 00 00       	push   $0x130c
-     988:	56                   	push   %esi
-     989:	53                   	push   %ebx
-     98a:	e8 81 fc ff ff       	call   610 <peek>
-     98f:	83 c4 10             	add    $0x10,%esp
-     992:	85 c0                	test   %eax,%eax
-     994:	74 4a                	je     9e0 <parseblock+0x70>
-  gettoken(ps, es, 0, 0);
-     996:	6a 00                	push   $0x0
-     998:	6a 00                	push   $0x0
-     99a:	56                   	push   %esi
-     99b:	53                   	push   %ebx
-     99c:	e8 0f fb ff ff       	call   4b0 <gettoken>
-  cmd = parseline(ps, es);
-     9a1:	58                   	pop    %eax
-     9a2:	5a                   	pop    %edx
-     9a3:	56                   	push   %esi
-     9a4:	53                   	push   %ebx
-     9a5:	e8 16 ff ff ff       	call   8c0 <parseline>
-  if(!peek(ps, es, ")"))
-     9aa:	83 c4 0c             	add    $0xc,%esp
-     9ad:	68 48 13 00 00       	push   $0x1348
-  cmd = parseline(ps, es);
-     9b2:	89 c7                	mov    %eax,%edi
-  if(!peek(ps, es, ")"))
-     9b4:	56                   	push   %esi
-     9b5:	53                   	push   %ebx
-     9b6:	e8 55 fc ff ff       	call   610 <peek>
-     9bb:	83 c4 10             	add    $0x10,%esp
-     9be:	85 c0                	test   %eax,%eax
-     9c0:	74 2b                	je     9ed <parseblock+0x7d>
-  gettoken(ps, es, 0, 0);
-     9c2:	6a 00                	push   $0x0
-     9c4:	6a 00                	push   $0x0
-     9c6:	56                   	push   %esi
-     9c7:	53                   	push   %ebx
-     9c8:	e8 e3 fa ff ff       	call   4b0 <gettoken>
-  cmd = parseredirs(cmd, ps, es);
-     9cd:	83 c4 0c             	add    $0xc,%esp
-     9d0:	56                   	push   %esi
-     9d1:	53                   	push   %ebx
-     9d2:	57                   	push   %edi
-     9d3:	e8 b8 fc ff ff       	call   690 <parseredirs>
-}
-     9d8:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     9db:	5b                   	pop    %ebx
-     9dc:	5e                   	pop    %esi
-     9dd:	5f                   	pop    %edi
-     9de:	5d                   	pop    %ebp
-     9df:	c3                   	ret    
-    panic("parseblock");
-     9e0:	83 ec 0c             	sub    $0xc,%esp
-     9e3:	68 2c 13 00 00       	push   $0x132c
-     9e8:	e8 73 f7 ff ff       	call   160 <panic>
-    panic("syntax - missing )");
-     9ed:	83 ec 0c             	sub    $0xc,%esp
-     9f0:	68 37 13 00 00       	push   $0x1337
-     9f5:	e8 66 f7 ff ff       	call   160 <panic>
-     9fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000a00 <nulterminate>:
-
-// NUL-terminate all the counted strings.
-struct cmd*
-nulterminate(struct cmd *cmd)
-{
-     a00:	f3 0f 1e fb          	endbr32 
-     a04:	55                   	push   %ebp
-     a05:	89 e5                	mov    %esp,%ebp
-     a07:	53                   	push   %ebx
-     a08:	83 ec 04             	sub    $0x4,%esp
-     a0b:	8b 5d 08             	mov    0x8(%ebp),%ebx
-  struct execcmd *ecmd;
-  struct listcmd *lcmd;
-  struct pipecmd *pcmd;
-  struct redircmd *rcmd;
-
-  if(cmd == 0)
-     a0e:	85 db                	test   %ebx,%ebx
-     a10:	0f 84 9a 00 00 00    	je     ab0 <nulterminate+0xb0>
-    return 0;
-
-  switch(cmd->type){
-     a16:	83 3b 05             	cmpl   $0x5,(%ebx)
-     a19:	77 6d                	ja     a88 <nulterminate+0x88>
-     a1b:	8b 03                	mov    (%ebx),%eax
-     a1d:	3e ff 24 85 88 13 00 	notrack jmp *0x1388(,%eax,4)
-     a24:	00 
-     a25:	8d 76 00             	lea    0x0(%esi),%esi
-    nulterminate(pcmd->right);
-    break;
-
-  case LIST:
-    lcmd = (struct listcmd*)cmd;
-    nulterminate(lcmd->left);
-     a28:	83 ec 0c             	sub    $0xc,%esp
-     a2b:	ff 73 04             	pushl  0x4(%ebx)
-     a2e:	e8 cd ff ff ff       	call   a00 <nulterminate>
-    nulterminate(lcmd->right);
-     a33:	58                   	pop    %eax
-     a34:	ff 73 08             	pushl  0x8(%ebx)
-     a37:	e8 c4 ff ff ff       	call   a00 <nulterminate>
-    break;
-     a3c:	83 c4 10             	add    $0x10,%esp
-     a3f:	89 d8                	mov    %ebx,%eax
-    bcmd = (struct backcmd*)cmd;
-    nulterminate(bcmd->cmd);
-    break;
-  }
-  return cmd;
-}
-     a41:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-     a44:	c9                   	leave  
-     a45:	c3                   	ret    
-     a46:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     a4d:	8d 76 00             	lea    0x0(%esi),%esi
-    nulterminate(bcmd->cmd);
-     a50:	83 ec 0c             	sub    $0xc,%esp
-     a53:	ff 73 04             	pushl  0x4(%ebx)
-     a56:	e8 a5 ff ff ff       	call   a00 <nulterminate>
-    break;
-     a5b:	89 d8                	mov    %ebx,%eax
-     a5d:	83 c4 10             	add    $0x10,%esp
-}
-     a60:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-     a63:	c9                   	leave  
-     a64:	c3                   	ret    
-     a65:	8d 76 00             	lea    0x0(%esi),%esi
-    for(i=0; ecmd->argv[i]; i++)
-     a68:	8b 4b 04             	mov    0x4(%ebx),%ecx
-     a6b:	8d 43 08             	lea    0x8(%ebx),%eax
-     a6e:	85 c9                	test   %ecx,%ecx
-     a70:	74 16                	je     a88 <nulterminate+0x88>
-     a72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-      *ecmd->eargv[i] = 0;
-     a78:	8b 50 24             	mov    0x24(%eax),%edx
-     a7b:	83 c0 04             	add    $0x4,%eax
-     a7e:	c6 02 00             	movb   $0x0,(%edx)
-    for(i=0; ecmd->argv[i]; i++)
-     a81:	8b 50 fc             	mov    -0x4(%eax),%edx
-     a84:	85 d2                	test   %edx,%edx
-     a86:	75 f0                	jne    a78 <nulterminate+0x78>
-  switch(cmd->type){
-     a88:	89 d8                	mov    %ebx,%eax
-}
-     a8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-     a8d:	c9                   	leave  
-     a8e:	c3                   	ret    
-     a8f:	90                   	nop
-    nulterminate(rcmd->cmd);
-     a90:	83 ec 0c             	sub    $0xc,%esp
-     a93:	ff 73 04             	pushl  0x4(%ebx)
-     a96:	e8 65 ff ff ff       	call   a00 <nulterminate>
-    *rcmd->efile = 0;
-     a9b:	8b 43 0c             	mov    0xc(%ebx),%eax
-    break;
-     a9e:	83 c4 10             	add    $0x10,%esp
-    *rcmd->efile = 0;
-     aa1:	c6 00 00             	movb   $0x0,(%eax)
-    break;
-     aa4:	89 d8                	mov    %ebx,%eax
-}
-     aa6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-     aa9:	c9                   	leave  
-     aaa:	c3                   	ret    
-     aab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     aaf:	90                   	nop
-    return 0;
-     ab0:	31 c0                	xor    %eax,%eax
-     ab2:	eb 8d                	jmp    a41 <nulterminate+0x41>
-     ab4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     abb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     abf:	90                   	nop
-
-00000ac0 <parsecmd>:
-{
-     ac0:	f3 0f 1e fb          	endbr32 
-     ac4:	55                   	push   %ebp
-     ac5:	89 e5                	mov    %esp,%ebp
-     ac7:	56                   	push   %esi
-     ac8:	53                   	push   %ebx
-  es = s + strlen(s);
-     ac9:	8b 5d 08             	mov    0x8(%ebp),%ebx
-     acc:	83 ec 0c             	sub    $0xc,%esp
-     acf:	53                   	push   %ebx
-     ad0:	e8 db 00 00 00       	call   bb0 <strlen>
-  cmd = parseline(&s, es);
-     ad5:	59                   	pop    %ecx
-     ad6:	5e                   	pop    %esi
-  es = s + strlen(s);
-     ad7:	01 c3                	add    %eax,%ebx
-  cmd = parseline(&s, es);
-     ad9:	8d 45 08             	lea    0x8(%ebp),%eax
-     adc:	53                   	push   %ebx
-     add:	50                   	push   %eax
-     ade:	e8 dd fd ff ff       	call   8c0 <parseline>
-  peek(&s, es, "");
-     ae3:	83 c4 0c             	add    $0xc,%esp
-  cmd = parseline(&s, es);
-     ae6:	89 c6                	mov    %eax,%esi
-  peek(&s, es, "");
-     ae8:	8d 45 08             	lea    0x8(%ebp),%eax
-     aeb:	68 d1 12 00 00       	push   $0x12d1
-     af0:	53                   	push   %ebx
-     af1:	50                   	push   %eax
-     af2:	e8 19 fb ff ff       	call   610 <peek>
-  if(s != es){
-     af7:	8b 45 08             	mov    0x8(%ebp),%eax
-     afa:	83 c4 10             	add    $0x10,%esp
-     afd:	39 d8                	cmp    %ebx,%eax
-     aff:	75 12                	jne    b13 <parsecmd+0x53>
-  nulterminate(cmd);
-     b01:	83 ec 0c             	sub    $0xc,%esp
-     b04:	56                   	push   %esi
-     b05:	e8 f6 fe ff ff       	call   a00 <nulterminate>
-}
-     b0a:	8d 65 f8             	lea    -0x8(%ebp),%esp
-     b0d:	89 f0                	mov    %esi,%eax
-     b0f:	5b                   	pop    %ebx
-     b10:	5e                   	pop    %esi
-     b11:	5d                   	pop    %ebp
-     b12:	c3                   	ret    
-    printf(2, "leftovers: %s\n", s);
-     b13:	52                   	push   %edx
-     b14:	50                   	push   %eax
-     b15:	68 4a 13 00 00       	push   $0x134a
-     b1a:	6a 02                	push   $0x2
-     b1c:	e8 2f 04 00 00       	call   f50 <printf>
-    panic("syntax");
-     b21:	c7 04 24 0e 13 00 00 	movl   $0x130e,(%esp)
-     b28:	e8 33 f6 ff ff       	call   160 <panic>
-     b2d:	66 90                	xchg   %ax,%ax
-     b2f:	90                   	nop
-
-00000b30 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-     b30:	f3 0f 1e fb          	endbr32 
-     b34:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-     b35:	31 c0                	xor    %eax,%eax
-{
-     b37:	89 e5                	mov    %esp,%ebp
-     b39:	53                   	push   %ebx
-     b3a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-     b3d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-     b40:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-     b44:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-     b47:	83 c0 01             	add    $0x1,%eax
-     b4a:	84 d2                	test   %dl,%dl
-     b4c:	75 f2                	jne    b40 <strcpy+0x10>
-    ;
-  return os;
-}
-     b4e:	89 c8                	mov    %ecx,%eax
-     b50:	5b                   	pop    %ebx
-     b51:	5d                   	pop    %ebp
-     b52:	c3                   	ret    
-     b53:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     b5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000b60 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-     b60:	f3 0f 1e fb          	endbr32 
-     b64:	55                   	push   %ebp
-     b65:	89 e5                	mov    %esp,%ebp
-     b67:	53                   	push   %ebx
-     b68:	8b 4d 08             	mov    0x8(%ebp),%ecx
-     b6b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-     b6e:	0f b6 01             	movzbl (%ecx),%eax
-     b71:	0f b6 1a             	movzbl (%edx),%ebx
-     b74:	84 c0                	test   %al,%al
-     b76:	75 19                	jne    b91 <strcmp+0x31>
-     b78:	eb 26                	jmp    ba0 <strcmp+0x40>
-     b7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-     b80:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-     b84:	83 c1 01             	add    $0x1,%ecx
-     b87:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-     b8a:	0f b6 1a             	movzbl (%edx),%ebx
-     b8d:	84 c0                	test   %al,%al
-     b8f:	74 0f                	je     ba0 <strcmp+0x40>
-     b91:	38 d8                	cmp    %bl,%al
-     b93:	74 eb                	je     b80 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-     b95:	29 d8                	sub    %ebx,%eax
-}
-     b97:	5b                   	pop    %ebx
-     b98:	5d                   	pop    %ebp
-     b99:	c3                   	ret    
-     b9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-     ba0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-     ba2:	29 d8                	sub    %ebx,%eax
-}
-     ba4:	5b                   	pop    %ebx
-     ba5:	5d                   	pop    %ebp
-     ba6:	c3                   	ret    
-     ba7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     bae:	66 90                	xchg   %ax,%ax
-
-00000bb0 <strlen>:
-
-uint
-strlen(const char *s)
-{
-     bb0:	f3 0f 1e fb          	endbr32 
-     bb4:	55                   	push   %ebp
-     bb5:	89 e5                	mov    %esp,%ebp
-     bb7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
-     bba:	80 3a 00             	cmpb   $0x0,(%edx)
-     bbd:	74 21                	je     be0 <strlen+0x30>
-     bbf:	31 c0                	xor    %eax,%eax
-     bc1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     bc8:	83 c0 01             	add    $0x1,%eax
-     bcb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
-     bcf:	89 c1                	mov    %eax,%ecx
-     bd1:	75 f5                	jne    bc8 <strlen+0x18>
-    ;
-  return n;
-}
-     bd3:	89 c8                	mov    %ecx,%eax
-     bd5:	5d                   	pop    %ebp
-     bd6:	c3                   	ret    
-     bd7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     bde:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
-     be0:	31 c9                	xor    %ecx,%ecx
-}
-     be2:	5d                   	pop    %ebp
-     be3:	89 c8                	mov    %ecx,%eax
-     be5:	c3                   	ret    
-     be6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     bed:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000bf0 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
-     bf0:	f3 0f 1e fb          	endbr32 
-     bf4:	55                   	push   %ebp
-     bf5:	89 e5                	mov    %esp,%ebp
-     bf7:	57                   	push   %edi
-     bf8:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
-     bfb:	8b 4d 10             	mov    0x10(%ebp),%ecx
-     bfe:	8b 45 0c             	mov    0xc(%ebp),%eax
-     c01:	89 d7                	mov    %edx,%edi
-     c03:	fc                   	cld    
-     c04:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
-     c06:	89 d0                	mov    %edx,%eax
-     c08:	5f                   	pop    %edi
-     c09:	5d                   	pop    %ebp
-     c0a:	c3                   	ret    
-     c0b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     c0f:	90                   	nop
-
-00000c10 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
-     c10:	f3 0f 1e fb          	endbr32 
-     c14:	55                   	push   %ebp
-     c15:	89 e5                	mov    %esp,%ebp
-     c17:	8b 45 08             	mov    0x8(%ebp),%eax
-     c1a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
-     c1e:	0f b6 10             	movzbl (%eax),%edx
-     c21:	84 d2                	test   %dl,%dl
-     c23:	75 16                	jne    c3b <strchr+0x2b>
-     c25:	eb 21                	jmp    c48 <strchr+0x38>
-     c27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     c2e:	66 90                	xchg   %ax,%ax
-     c30:	0f b6 50 01          	movzbl 0x1(%eax),%edx
-     c34:	83 c0 01             	add    $0x1,%eax
-     c37:	84 d2                	test   %dl,%dl
-     c39:	74 0d                	je     c48 <strchr+0x38>
-    if(*s == c)
-     c3b:	38 d1                	cmp    %dl,%cl
-     c3d:	75 f1                	jne    c30 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
-     c3f:	5d                   	pop    %ebp
-     c40:	c3                   	ret    
-     c41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
-     c48:	31 c0                	xor    %eax,%eax
-}
-     c4a:	5d                   	pop    %ebp
-     c4b:	c3                   	ret    
-     c4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000c50 <gets>:
-
-char*
-gets(char *buf, int max)
-{
-     c50:	f3 0f 1e fb          	endbr32 
-     c54:	55                   	push   %ebp
-     c55:	89 e5                	mov    %esp,%ebp
-     c57:	57                   	push   %edi
-     c58:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
-     c59:	31 f6                	xor    %esi,%esi
-{
-     c5b:	53                   	push   %ebx
-     c5c:	89 f3                	mov    %esi,%ebx
-     c5e:	83 ec 1c             	sub    $0x1c,%esp
-     c61:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
-     c64:	eb 33                	jmp    c99 <gets+0x49>
-     c66:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     c6d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
-     c70:	83 ec 04             	sub    $0x4,%esp
-     c73:	8d 45 e7             	lea    -0x19(%ebp),%eax
-     c76:	6a 01                	push   $0x1
-     c78:	50                   	push   %eax
-     c79:	6a 00                	push   $0x0
-     c7b:	e8 2b 01 00 00       	call   dab <read>
-    if(cc < 1)
-     c80:	83 c4 10             	add    $0x10,%esp
-     c83:	85 c0                	test   %eax,%eax
-     c85:	7e 1c                	jle    ca3 <gets+0x53>
-      break;
-    buf[i++] = c;
-     c87:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
-     c8b:	83 c7 01             	add    $0x1,%edi
-     c8e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
-     c91:	3c 0a                	cmp    $0xa,%al
-     c93:	74 23                	je     cb8 <gets+0x68>
-     c95:	3c 0d                	cmp    $0xd,%al
-     c97:	74 1f                	je     cb8 <gets+0x68>
-  for(i=0; i+1 < max; ){
-     c99:	83 c3 01             	add    $0x1,%ebx
-     c9c:	89 fe                	mov    %edi,%esi
-     c9e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
-     ca1:	7c cd                	jl     c70 <gets+0x20>
-     ca3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
-     ca5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
-     ca8:	c6 03 00             	movb   $0x0,(%ebx)
-}
-     cab:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     cae:	5b                   	pop    %ebx
-     caf:	5e                   	pop    %esi
-     cb0:	5f                   	pop    %edi
-     cb1:	5d                   	pop    %ebp
-     cb2:	c3                   	ret    
-     cb3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     cb7:	90                   	nop
-     cb8:	8b 75 08             	mov    0x8(%ebp),%esi
-     cbb:	8b 45 08             	mov    0x8(%ebp),%eax
-     cbe:	01 de                	add    %ebx,%esi
-     cc0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
-     cc2:	c6 03 00             	movb   $0x0,(%ebx)
-}
-     cc5:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     cc8:	5b                   	pop    %ebx
-     cc9:	5e                   	pop    %esi
-     cca:	5f                   	pop    %edi
-     ccb:	5d                   	pop    %ebp
-     ccc:	c3                   	ret    
-     ccd:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000cd0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
-     cd0:	f3 0f 1e fb          	endbr32 
-     cd4:	55                   	push   %ebp
-     cd5:	89 e5                	mov    %esp,%ebp
-     cd7:	56                   	push   %esi
-     cd8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
-     cd9:	83 ec 08             	sub    $0x8,%esp
-     cdc:	6a 00                	push   $0x0
-     cde:	ff 75 08             	pushl  0x8(%ebp)
-     ce1:	e8 ed 00 00 00       	call   dd3 <open>
-  if(fd < 0)
-     ce6:	83 c4 10             	add    $0x10,%esp
-     ce9:	85 c0                	test   %eax,%eax
-     ceb:	78 2b                	js     d18 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
-     ced:	83 ec 08             	sub    $0x8,%esp
-     cf0:	ff 75 0c             	pushl  0xc(%ebp)
-     cf3:	89 c3                	mov    %eax,%ebx
-     cf5:	50                   	push   %eax
-     cf6:	e8 f0 00 00 00       	call   deb <fstat>
-  close(fd);
-     cfb:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
-     cfe:	89 c6                	mov    %eax,%esi
-  close(fd);
-     d00:	e8 b6 00 00 00       	call   dbb <close>
-  return r;
-     d05:	83 c4 10             	add    $0x10,%esp
-}
-     d08:	8d 65 f8             	lea    -0x8(%ebp),%esp
-     d0b:	89 f0                	mov    %esi,%eax
-     d0d:	5b                   	pop    %ebx
-     d0e:	5e                   	pop    %esi
-     d0f:	5d                   	pop    %ebp
-     d10:	c3                   	ret    
-     d11:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
-     d18:	be ff ff ff ff       	mov    $0xffffffff,%esi
-     d1d:	eb e9                	jmp    d08 <stat+0x38>
-     d1f:	90                   	nop
-
-00000d20 <atoi>:
-
-int
-atoi(const char *s)
-{
-     d20:	f3 0f 1e fb          	endbr32 
-     d24:	55                   	push   %ebp
-     d25:	89 e5                	mov    %esp,%ebp
-     d27:	53                   	push   %ebx
-     d28:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
-     d2b:	0f be 02             	movsbl (%edx),%eax
-     d2e:	8d 48 d0             	lea    -0x30(%eax),%ecx
-     d31:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
-     d34:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
-     d39:	77 1a                	ja     d55 <atoi+0x35>
-     d3b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     d3f:	90                   	nop
-    n = n*10 + *s++ - '0';
-     d40:	83 c2 01             	add    $0x1,%edx
-     d43:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
-     d46:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
-     d4a:	0f be 02             	movsbl (%edx),%eax
-     d4d:	8d 58 d0             	lea    -0x30(%eax),%ebx
-     d50:	80 fb 09             	cmp    $0x9,%bl
-     d53:	76 eb                	jbe    d40 <atoi+0x20>
-  return n;
-}
-     d55:	89 c8                	mov    %ecx,%eax
-     d57:	5b                   	pop    %ebx
-     d58:	5d                   	pop    %ebp
-     d59:	c3                   	ret    
-     d5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000d60 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
-     d60:	f3 0f 1e fb          	endbr32 
-     d64:	55                   	push   %ebp
-     d65:	89 e5                	mov    %esp,%ebp
-     d67:	57                   	push   %edi
-     d68:	8b 45 10             	mov    0x10(%ebp),%eax
-     d6b:	8b 55 08             	mov    0x8(%ebp),%edx
-     d6e:	56                   	push   %esi
-     d6f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
-     d72:	85 c0                	test   %eax,%eax
-     d74:	7e 0f                	jle    d85 <memmove+0x25>
-     d76:	01 d0                	add    %edx,%eax
-  dst = vdst;
-     d78:	89 d7                	mov    %edx,%edi
-     d7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
-     d80:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
-     d81:	39 f8                	cmp    %edi,%eax
-     d83:	75 fb                	jne    d80 <memmove+0x20>
-  return vdst;
-}
-     d85:	5e                   	pop    %esi
-     d86:	89 d0                	mov    %edx,%eax
-     d88:	5f                   	pop    %edi
-     d89:	5d                   	pop    %ebp
-     d8a:	c3                   	ret    
-
-00000d8b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
-     d8b:	b8 01 00 00 00       	mov    $0x1,%eax
-     d90:	cd 40                	int    $0x40
-     d92:	c3                   	ret    
-
-00000d93 <exit>:
-SYSCALL(exit)
-     d93:	b8 02 00 00 00       	mov    $0x2,%eax
-     d98:	cd 40                	int    $0x40
-     d9a:	c3                   	ret    
-
-00000d9b <wait>:
-SYSCALL(wait)
-     d9b:	b8 03 00 00 00       	mov    $0x3,%eax
-     da0:	cd 40                	int    $0x40
-     da2:	c3                   	ret    
-
-00000da3 <pipe>:
-SYSCALL(pipe)
-     da3:	b8 04 00 00 00       	mov    $0x4,%eax
-     da8:	cd 40                	int    $0x40
-     daa:	c3                   	ret    
-
-00000dab <read>:
-SYSCALL(read)
-     dab:	b8 05 00 00 00       	mov    $0x5,%eax
-     db0:	cd 40                	int    $0x40
-     db2:	c3                   	ret    
-
-00000db3 <write>:
-SYSCALL(write)
-     db3:	b8 10 00 00 00       	mov    $0x10,%eax
-     db8:	cd 40                	int    $0x40
-     dba:	c3                   	ret    
-
-00000dbb <close>:
-SYSCALL(close)
-     dbb:	b8 15 00 00 00       	mov    $0x15,%eax
-     dc0:	cd 40                	int    $0x40
-     dc2:	c3                   	ret    
-
-00000dc3 <kill>:
-SYSCALL(kill)
-     dc3:	b8 06 00 00 00       	mov    $0x6,%eax
-     dc8:	cd 40                	int    $0x40
-     dca:	c3                   	ret    
-
-00000dcb <exec>:
-SYSCALL(exec)
-     dcb:	b8 07 00 00 00       	mov    $0x7,%eax
-     dd0:	cd 40                	int    $0x40
-     dd2:	c3                   	ret    
-
-00000dd3 <open>:
-SYSCALL(open)
-     dd3:	b8 0f 00 00 00       	mov    $0xf,%eax
-     dd8:	cd 40                	int    $0x40
-     dda:	c3                   	ret    
-
-00000ddb <mknod>:
-SYSCALL(mknod)
-     ddb:	b8 11 00 00 00       	mov    $0x11,%eax
-     de0:	cd 40                	int    $0x40
-     de2:	c3                   	ret    
-
-00000de3 <unlink>:
-SYSCALL(unlink)
-     de3:	b8 12 00 00 00       	mov    $0x12,%eax
-     de8:	cd 40                	int    $0x40
-     dea:	c3                   	ret    
-
-00000deb <fstat>:
-SYSCALL(fstat)
-     deb:	b8 08 00 00 00       	mov    $0x8,%eax
-     df0:	cd 40                	int    $0x40
-     df2:	c3                   	ret    
-
-00000df3 <link>:
-SYSCALL(link)
-     df3:	b8 13 00 00 00       	mov    $0x13,%eax
-     df8:	cd 40                	int    $0x40
-     dfa:	c3                   	ret    
-
-00000dfb <mkdir>:
-SYSCALL(mkdir)
-     dfb:	b8 14 00 00 00       	mov    $0x14,%eax
-     e00:	cd 40                	int    $0x40
-     e02:	c3                   	ret    
-
-00000e03 <chdir>:
-SYSCALL(chdir)
-     e03:	b8 09 00 00 00       	mov    $0x9,%eax
-     e08:	cd 40                	int    $0x40
-     e0a:	c3                   	ret    
-
-00000e0b <dup>:
-SYSCALL(dup)
-     e0b:	b8 0a 00 00 00       	mov    $0xa,%eax
-     e10:	cd 40                	int    $0x40
-     e12:	c3                   	ret    
-
-00000e13 <getpid>:
-SYSCALL(getpid)
-     e13:	b8 0b 00 00 00       	mov    $0xb,%eax
-     e18:	cd 40                	int    $0x40
-     e1a:	c3                   	ret    
-
-00000e1b <sbrk>:
-SYSCALL(sbrk)
-     e1b:	b8 0c 00 00 00       	mov    $0xc,%eax
-     e20:	cd 40                	int    $0x40
-     e22:	c3                   	ret    
-
-00000e23 <sleep>:
-SYSCALL(sleep)
-     e23:	b8 0d 00 00 00       	mov    $0xd,%eax
-     e28:	cd 40                	int    $0x40
-     e2a:	c3                   	ret    
-
-00000e2b <uptime>:
-SYSCALL(uptime)
-     e2b:	b8 0e 00 00 00       	mov    $0xe,%eax
-     e30:	cd 40                	int    $0x40
-     e32:	c3                   	ret    
-
-00000e33 <getParentID>:
-SYSCALL(getParentID)
-     e33:	b8 16 00 00 00       	mov    $0x16,%eax
-     e38:	cd 40                	int    $0x40
-     e3a:	c3                   	ret    
-
-00000e3b <getChildren>:
-SYSCALL(getChildren)
-     e3b:	b8 17 00 00 00       	mov    $0x17,%eax
-     e40:	cd 40                	int    $0x40
-     e42:	c3                   	ret    
-
-00000e43 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
-     e43:	b8 18 00 00 00       	mov    $0x18,%eax
-     e48:	cd 40                	int    $0x40
-     e4a:	c3                   	ret    
-
-00000e4b <setPriority>:
-SYSCALL(setPriority)
-     e4b:	b8 19 00 00 00       	mov    $0x19,%eax
-     e50:	cd 40                	int    $0x40
-     e52:	c3                   	ret    
-
-00000e53 <changePolicy>:
-SYSCALL(changePolicy)
-     e53:	b8 1a 00 00 00       	mov    $0x1a,%eax
-     e58:	cd 40                	int    $0x40
-     e5a:	c3                   	ret    
-
-00000e5b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
-     e5b:	b8 1b 00 00 00       	mov    $0x1b,%eax
-     e60:	cd 40                	int    $0x40
-     e62:	c3                   	ret    
-
-00000e63 <getWaitingTime>:
-SYSCALL(getWaitingTime)
-     e63:	b8 1c 00 00 00       	mov    $0x1c,%eax
-     e68:	cd 40                	int    $0x40
-     e6a:	c3                   	ret    
-
-00000e6b <getCBT>:
-SYSCALL(getCBT)
-     e6b:	b8 1d 00 00 00       	mov    $0x1d,%eax
-     e70:	cd 40                	int    $0x40
-     e72:	c3                   	ret    
-
-00000e73 <customWait>:
-SYSCALL(customWait)
-     e73:	b8 1e 00 00 00       	mov    $0x1e,%eax
-     e78:	cd 40                	int    $0x40
-     e7a:	c3                   	ret    
-
-00000e7b <setQueue>:
-SYSCALL(setQueue)
-     e7b:	b8 1f 00 00 00       	mov    $0x1f,%eax
-     e80:	cd 40                	int    $0x40
-     e82:	c3                   	ret    
-
-00000e83 <getBurstTime>:
-SYSCALL(getBurstTime)
-     e83:	b8 20 00 00 00       	mov    $0x20,%eax
-     e88:	cd 40                	int    $0x40
-     e8a:	c3                   	ret    
-
-00000e8b <getCreationTime>:
-     e8b:	b8 21 00 00 00       	mov    $0x21,%eax
-     e90:	cd 40                	int    $0x40
-     e92:	c3                   	ret    
-     e93:	66 90                	xchg   %ax,%ax
-     e95:	66 90                	xchg   %ax,%ax
-     e97:	66 90                	xchg   %ax,%ax
-     e99:	66 90                	xchg   %ax,%ax
-     e9b:	66 90                	xchg   %ax,%ax
-     e9d:	66 90                	xchg   %ax,%ax
-     e9f:	90                   	nop
-
-00000ea0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
-     ea0:	55                   	push   %ebp
-     ea1:	89 e5                	mov    %esp,%ebp
-     ea3:	57                   	push   %edi
-     ea4:	56                   	push   %esi
-     ea5:	53                   	push   %ebx
-     ea6:	83 ec 3c             	sub    $0x3c,%esp
-     ea9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
-     eac:	89 d1                	mov    %edx,%ecx
-{
-     eae:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
-     eb1:	85 d2                	test   %edx,%edx
-     eb3:	0f 89 7f 00 00 00    	jns    f38 <printint+0x98>
-     eb9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
-     ebd:	74 79                	je     f38 <printint+0x98>
-    neg = 1;
-     ebf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
-     ec6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
-     ec8:	31 db                	xor    %ebx,%ebx
-     eca:	8d 75 d7             	lea    -0x29(%ebp),%esi
-     ecd:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
-     ed0:	89 c8                	mov    %ecx,%eax
-     ed2:	31 d2                	xor    %edx,%edx
-     ed4:	89 cf                	mov    %ecx,%edi
-     ed6:	f7 75 c4             	divl   -0x3c(%ebp)
-     ed9:	0f b6 92 a8 13 00 00 	movzbl 0x13a8(%edx),%edx
-     ee0:	89 45 c0             	mov    %eax,-0x40(%ebp)
-     ee3:	89 d8                	mov    %ebx,%eax
-     ee5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
-     ee8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
-     eeb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
-     eee:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
-     ef1:	76 dd                	jbe    ed0 <printint+0x30>
-  if(neg)
-     ef3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
-     ef6:	85 c9                	test   %ecx,%ecx
-     ef8:	74 0c                	je     f06 <printint+0x66>
-    buf[i++] = '-';
-     efa:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
-     eff:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
-     f01:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
-     f06:	8b 7d b8             	mov    -0x48(%ebp),%edi
-     f09:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
-     f0d:	eb 07                	jmp    f16 <printint+0x76>
-     f0f:	90                   	nop
-     f10:	0f b6 13             	movzbl (%ebx),%edx
-     f13:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
-     f16:	83 ec 04             	sub    $0x4,%esp
-     f19:	88 55 d7             	mov    %dl,-0x29(%ebp)
-     f1c:	6a 01                	push   $0x1
-     f1e:	56                   	push   %esi
-     f1f:	57                   	push   %edi
-     f20:	e8 8e fe ff ff       	call   db3 <write>
-  while(--i >= 0)
-     f25:	83 c4 10             	add    $0x10,%esp
-     f28:	39 de                	cmp    %ebx,%esi
-     f2a:	75 e4                	jne    f10 <printint+0x70>
-    putc(fd, buf[i]);
-}
-     f2c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     f2f:	5b                   	pop    %ebx
-     f30:	5e                   	pop    %esi
-     f31:	5f                   	pop    %edi
-     f32:	5d                   	pop    %ebp
-     f33:	c3                   	ret    
-     f34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
-     f38:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
-     f3f:	eb 87                	jmp    ec8 <printint+0x28>
-     f41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     f48:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     f4f:	90                   	nop
-
-00000f50 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
-     f50:	f3 0f 1e fb          	endbr32 
-     f54:	55                   	push   %ebp
-     f55:	89 e5                	mov    %esp,%ebp
-     f57:	57                   	push   %edi
-     f58:	56                   	push   %esi
-     f59:	53                   	push   %ebx
-     f5a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
-     f5d:	8b 75 0c             	mov    0xc(%ebp),%esi
-     f60:	0f b6 1e             	movzbl (%esi),%ebx
-     f63:	84 db                	test   %bl,%bl
-     f65:	0f 84 b4 00 00 00    	je     101f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
-     f6b:	8d 45 10             	lea    0x10(%ebp),%eax
-     f6e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
-     f71:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
-     f74:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
-     f76:	89 45 d0             	mov    %eax,-0x30(%ebp)
-     f79:	eb 33                	jmp    fae <printf+0x5e>
-     f7b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     f7f:	90                   	nop
-     f80:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
-     f83:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
-     f88:	83 f8 25             	cmp    $0x25,%eax
-     f8b:	74 17                	je     fa4 <printf+0x54>
-  write(fd, &c, 1);
-     f8d:	83 ec 04             	sub    $0x4,%esp
-     f90:	88 5d e7             	mov    %bl,-0x19(%ebp)
-     f93:	6a 01                	push   $0x1
-     f95:	57                   	push   %edi
-     f96:	ff 75 08             	pushl  0x8(%ebp)
-     f99:	e8 15 fe ff ff       	call   db3 <write>
-     f9e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
-     fa1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
-     fa4:	0f b6 1e             	movzbl (%esi),%ebx
-     fa7:	83 c6 01             	add    $0x1,%esi
-     faa:	84 db                	test   %bl,%bl
-     fac:	74 71                	je     101f <printf+0xcf>
-    c = fmt[i] & 0xff;
-     fae:	0f be cb             	movsbl %bl,%ecx
-     fb1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
-     fb4:	85 d2                	test   %edx,%edx
-     fb6:	74 c8                	je     f80 <printf+0x30>
-      }
-    } else if(state == '%'){
-     fb8:	83 fa 25             	cmp    $0x25,%edx
-     fbb:	75 e7                	jne    fa4 <printf+0x54>
-      if(c == 'd'){
-     fbd:	83 f8 64             	cmp    $0x64,%eax
-     fc0:	0f 84 9a 00 00 00    	je     1060 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
-     fc6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
-     fcc:	83 f9 70             	cmp    $0x70,%ecx
-     fcf:	74 5f                	je     1030 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
-     fd1:	83 f8 73             	cmp    $0x73,%eax
-     fd4:	0f 84 d6 00 00 00    	je     10b0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
-     fda:	83 f8 63             	cmp    $0x63,%eax
-     fdd:	0f 84 8d 00 00 00    	je     1070 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
-     fe3:	83 f8 25             	cmp    $0x25,%eax
-     fe6:	0f 84 b4 00 00 00    	je     10a0 <printf+0x150>
-  write(fd, &c, 1);
-     fec:	83 ec 04             	sub    $0x4,%esp
-     fef:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
-     ff3:	6a 01                	push   $0x1
-     ff5:	57                   	push   %edi
-     ff6:	ff 75 08             	pushl  0x8(%ebp)
-     ff9:	e8 b5 fd ff ff       	call   db3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
-     ffe:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
-    1001:	83 c4 0c             	add    $0xc,%esp
-    1004:	6a 01                	push   $0x1
-    1006:	83 c6 01             	add    $0x1,%esi
-    1009:	57                   	push   %edi
-    100a:	ff 75 08             	pushl  0x8(%ebp)
-    100d:	e8 a1 fd ff ff       	call   db3 <write>
-  for(i = 0; fmt[i]; i++){
-    1012:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
-    1016:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
-    1019:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
-    101b:	84 db                	test   %bl,%bl
-    101d:	75 8f                	jne    fae <printf+0x5e>
-    }
-  }
-}
-    101f:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    1022:	5b                   	pop    %ebx
-    1023:	5e                   	pop    %esi
-    1024:	5f                   	pop    %edi
-    1025:	5d                   	pop    %ebp
-    1026:	c3                   	ret    
-    1027:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    102e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
-    1030:	83 ec 0c             	sub    $0xc,%esp
-    1033:	b9 10 00 00 00       	mov    $0x10,%ecx
-    1038:	6a 00                	push   $0x0
-    103a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-    103d:	8b 45 08             	mov    0x8(%ebp),%eax
-    1040:	8b 13                	mov    (%ebx),%edx
-    1042:	e8 59 fe ff ff       	call   ea0 <printint>
-        ap++;
-    1047:	89 d8                	mov    %ebx,%eax
-    1049:	83 c4 10             	add    $0x10,%esp
-      state = 0;
-    104c:	31 d2                	xor    %edx,%edx
-        ap++;
-    104e:	83 c0 04             	add    $0x4,%eax
-    1051:	89 45 d0             	mov    %eax,-0x30(%ebp)
-    1054:	e9 4b ff ff ff       	jmp    fa4 <printf+0x54>
-    1059:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
-    1060:	83 ec 0c             	sub    $0xc,%esp
-    1063:	b9 0a 00 00 00       	mov    $0xa,%ecx
-    1068:	6a 01                	push   $0x1
-    106a:	eb ce                	jmp    103a <printf+0xea>
-    106c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
-    1070:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
-    1073:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
-    1076:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
-    1078:	6a 01                	push   $0x1
-        ap++;
-    107a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
-    107d:	57                   	push   %edi
-    107e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
-    1081:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
-    1084:	e8 2a fd ff ff       	call   db3 <write>
-        ap++;
-    1089:	89 5d d0             	mov    %ebx,-0x30(%ebp)
-    108c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
-    108f:	31 d2                	xor    %edx,%edx
-    1091:	e9 0e ff ff ff       	jmp    fa4 <printf+0x54>
-    1096:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    109d:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
-    10a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
-    10a3:	83 ec 04             	sub    $0x4,%esp
-    10a6:	e9 59 ff ff ff       	jmp    1004 <printf+0xb4>
-    10ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    10af:	90                   	nop
-        s = (char*)*ap;
-    10b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
-    10b3:	8b 18                	mov    (%eax),%ebx
-        ap++;
-    10b5:	83 c0 04             	add    $0x4,%eax
-    10b8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
-    10bb:	85 db                	test   %ebx,%ebx
-    10bd:	74 17                	je     10d6 <printf+0x186>
-        while(*s != 0){
-    10bf:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
-    10c2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
-    10c4:	84 c0                	test   %al,%al
-    10c6:	0f 84 d8 fe ff ff    	je     fa4 <printf+0x54>
-    10cc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
-    10cf:	89 de                	mov    %ebx,%esi
-    10d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
-    10d4:	eb 1a                	jmp    10f0 <printf+0x1a0>
-          s = "(null)";
-    10d6:	bb a0 13 00 00       	mov    $0x13a0,%ebx
-        while(*s != 0){
-    10db:	89 75 d4             	mov    %esi,-0x2c(%ebp)
-    10de:	b8 28 00 00 00       	mov    $0x28,%eax
-    10e3:	89 de                	mov    %ebx,%esi
-    10e5:	8b 5d 08             	mov    0x8(%ebp),%ebx
-    10e8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    10ef:	90                   	nop
-  write(fd, &c, 1);
-    10f0:	83 ec 04             	sub    $0x4,%esp
-          s++;
-    10f3:	83 c6 01             	add    $0x1,%esi
-    10f6:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
-    10f9:	6a 01                	push   $0x1
-    10fb:	57                   	push   %edi
-    10fc:	53                   	push   %ebx
-    10fd:	e8 b1 fc ff ff       	call   db3 <write>
-        while(*s != 0){
-    1102:	0f b6 06             	movzbl (%esi),%eax
-    1105:	83 c4 10             	add    $0x10,%esp
-    1108:	84 c0                	test   %al,%al
-    110a:	75 e4                	jne    10f0 <printf+0x1a0>
-    110c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
-    110f:	31 d2                	xor    %edx,%edx
-    1111:	e9 8e fe ff ff       	jmp    fa4 <printf+0x54>
-    1116:	66 90                	xchg   %ax,%ax
-    1118:	66 90                	xchg   %ax,%ax
-    111a:	66 90                	xchg   %ax,%ax
-    111c:	66 90                	xchg   %ax,%ax
-    111e:	66 90                	xchg   %ax,%ax
-
-00001120 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
-    1120:	f3 0f 1e fb          	endbr32 
-    1124:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
-    1125:	a1 04 1a 00 00       	mov    0x1a04,%eax
-{
-    112a:	89 e5                	mov    %esp,%ebp
-    112c:	57                   	push   %edi
-    112d:	56                   	push   %esi
-    112e:	53                   	push   %ebx
-    112f:	8b 5d 08             	mov    0x8(%ebp),%ebx
-    1132:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
-    1134:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
-    1137:	39 c8                	cmp    %ecx,%eax
-    1139:	73 15                	jae    1150 <free+0x30>
-    113b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    113f:	90                   	nop
-    1140:	39 d1                	cmp    %edx,%ecx
-    1142:	72 14                	jb     1158 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
-    1144:	39 d0                	cmp    %edx,%eax
-    1146:	73 10                	jae    1158 <free+0x38>
-{
-    1148:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
-    114a:	8b 10                	mov    (%eax),%edx
-    114c:	39 c8                	cmp    %ecx,%eax
-    114e:	72 f0                	jb     1140 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
-    1150:	39 d0                	cmp    %edx,%eax
-    1152:	72 f4                	jb     1148 <free+0x28>
-    1154:	39 d1                	cmp    %edx,%ecx
-    1156:	73 f0                	jae    1148 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
-    1158:	8b 73 fc             	mov    -0x4(%ebx),%esi
-    115b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
-    115e:	39 fa                	cmp    %edi,%edx
-    1160:	74 1e                	je     1180 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
-    1162:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
-    1165:	8b 50 04             	mov    0x4(%eax),%edx
-    1168:	8d 34 d0             	lea    (%eax,%edx,8),%esi
-    116b:	39 f1                	cmp    %esi,%ecx
-    116d:	74 28                	je     1197 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
-    116f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
-    1171:	5b                   	pop    %ebx
-  freep = p;
-    1172:	a3 04 1a 00 00       	mov    %eax,0x1a04
-}
-    1177:	5e                   	pop    %esi
-    1178:	5f                   	pop    %edi
-    1179:	5d                   	pop    %ebp
-    117a:	c3                   	ret    
-    117b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    117f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
-    1180:	03 72 04             	add    0x4(%edx),%esi
-    1183:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
-    1186:	8b 10                	mov    (%eax),%edx
-    1188:	8b 12                	mov    (%edx),%edx
-    118a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
-    118d:	8b 50 04             	mov    0x4(%eax),%edx
-    1190:	8d 34 d0             	lea    (%eax,%edx,8),%esi
-    1193:	39 f1                	cmp    %esi,%ecx
-    1195:	75 d8                	jne    116f <free+0x4f>
-    p->s.size += bp->s.size;
-    1197:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
-    119a:	a3 04 1a 00 00       	mov    %eax,0x1a04
-    p->s.size += bp->s.size;
-    119f:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
-    11a2:	8b 53 f8             	mov    -0x8(%ebx),%edx
-    11a5:	89 10                	mov    %edx,(%eax)
-}
-    11a7:	5b                   	pop    %ebx
-    11a8:	5e                   	pop    %esi
-    11a9:	5f                   	pop    %edi
-    11aa:	5d                   	pop    %ebp
-    11ab:	c3                   	ret    
-    11ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000011b0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
-    11b0:	f3 0f 1e fb          	endbr32 
-    11b4:	55                   	push   %ebp
-    11b5:	89 e5                	mov    %esp,%ebp
-    11b7:	57                   	push   %edi
-    11b8:	56                   	push   %esi
-    11b9:	53                   	push   %ebx
-    11ba:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
-    11bd:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
-    11c0:	8b 3d 04 1a 00 00    	mov    0x1a04,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
-    11c6:	8d 70 07             	lea    0x7(%eax),%esi
-    11c9:	c1 ee 03             	shr    $0x3,%esi
-    11cc:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
-    11cf:	85 ff                	test   %edi,%edi
-    11d1:	0f 84 a9 00 00 00    	je     1280 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
-    11d7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
-    11d9:	8b 48 04             	mov    0x4(%eax),%ecx
-    11dc:	39 f1                	cmp    %esi,%ecx
-    11de:	73 6d                	jae    124d <malloc+0x9d>
-    11e0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
-    11e6:	bb 00 10 00 00       	mov    $0x1000,%ebx
-    11eb:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
-    11ee:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
-    11f5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
-    11f8:	eb 17                	jmp    1211 <malloc+0x61>
-    11fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
-    1200:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
-    1202:	8b 4a 04             	mov    0x4(%edx),%ecx
-    1205:	39 f1                	cmp    %esi,%ecx
-    1207:	73 4f                	jae    1258 <malloc+0xa8>
-    1209:	8b 3d 04 1a 00 00    	mov    0x1a04,%edi
-    120f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
-    1211:	39 c7                	cmp    %eax,%edi
-    1213:	75 eb                	jne    1200 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
-    1215:	83 ec 0c             	sub    $0xc,%esp
-    1218:	ff 75 e4             	pushl  -0x1c(%ebp)
-    121b:	e8 fb fb ff ff       	call   e1b <sbrk>
-  if(p == (char*)-1)
-    1220:	83 c4 10             	add    $0x10,%esp
-    1223:	83 f8 ff             	cmp    $0xffffffff,%eax
-    1226:	74 1b                	je     1243 <malloc+0x93>
-  hp->s.size = nu;
-    1228:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
-    122b:	83 ec 0c             	sub    $0xc,%esp
-    122e:	83 c0 08             	add    $0x8,%eax
-    1231:	50                   	push   %eax
-    1232:	e8 e9 fe ff ff       	call   1120 <free>
-  return freep;
-    1237:	a1 04 1a 00 00       	mov    0x1a04,%eax
-      if((p = morecore(nunits)) == 0)
-    123c:	83 c4 10             	add    $0x10,%esp
-    123f:	85 c0                	test   %eax,%eax
-    1241:	75 bd                	jne    1200 <malloc+0x50>
-        return 0;
-  }
-}
-    1243:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
-    1246:	31 c0                	xor    %eax,%eax
-}
-    1248:	5b                   	pop    %ebx
-    1249:	5e                   	pop    %esi
-    124a:	5f                   	pop    %edi
-    124b:	5d                   	pop    %ebp
-    124c:	c3                   	ret    
-    if(p->s.size >= nunits){
-    124d:	89 c2                	mov    %eax,%edx
-    124f:	89 f8                	mov    %edi,%eax
-    1251:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
-    1258:	39 ce                	cmp    %ecx,%esi
-    125a:	74 54                	je     12b0 <malloc+0x100>
-        p->s.size -= nunits;
-    125c:	29 f1                	sub    %esi,%ecx
-    125e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
-    1261:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
-    1264:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
-    1267:	a3 04 1a 00 00       	mov    %eax,0x1a04
-}
-    126c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
-    126f:	8d 42 08             	lea    0x8(%edx),%eax
-}
-    1272:	5b                   	pop    %ebx
-    1273:	5e                   	pop    %esi
-    1274:	5f                   	pop    %edi
-    1275:	5d                   	pop    %ebp
-    1276:	c3                   	ret    
-    1277:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    127e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
-    1280:	c7 05 04 1a 00 00 08 	movl   $0x1a08,0x1a04
-    1287:	1a 00 00 
-    base.s.size = 0;
-    128a:	bf 08 1a 00 00       	mov    $0x1a08,%edi
-    base.s.ptr = freep = prevp = &base;
-    128f:	c7 05 08 1a 00 00 08 	movl   $0x1a08,0x1a08
-    1296:	1a 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
-    1299:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
-    129b:	c7 05 0c 1a 00 00 00 	movl   $0x0,0x1a0c
-    12a2:	00 00 00 
-    if(p->s.size >= nunits){
-    12a5:	e9 36 ff ff ff       	jmp    11e0 <malloc+0x30>
-    12aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
-    12b0:	8b 0a                	mov    (%edx),%ecx
-    12b2:	89 08                	mov    %ecx,(%eax)
-    12b4:	eb b1                	jmp    1267 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/sh.c b/xv6-public/Operating-System-Project/sh.c
deleted file mode 100644
index 054bab9..0000000
--- a/xv6-public/Operating-System-Project/sh.c
+++ /dev/null
@@ -1,493 +0,0 @@
-// Shell.
-
-#include "types.h"
-#include "user.h"
-#include "fcntl.h"
-
-// Parsed command representation
-#define EXEC  1
-#define REDIR 2
-#define PIPE  3
-#define LIST  4
-#define BACK  5
-
-#define MAXARGS 10
-
-struct cmd {
-  int type;
-};
-
-struct execcmd {
-  int type;
-  char *argv[MAXARGS];
-  char *eargv[MAXARGS];
-};
-
-struct redircmd {
-  int type;
-  struct cmd *cmd;
-  char *file;
-  char *efile;
-  int mode;
-  int fd;
-};
-
-struct pipecmd {
-  int type;
-  struct cmd *left;
-  struct cmd *right;
-};
-
-struct listcmd {
-  int type;
-  struct cmd *left;
-  struct cmd *right;
-};
-
-struct backcmd {
-  int type;
-  struct cmd *cmd;
-};
-
-int fork1(void);  // Fork but panics on failure.
-void panic(char*);
-struct cmd *parsecmd(char*);
-
-// Execute cmd.  Never returns.
-void
-runcmd(struct cmd *cmd)
-{
-  int p[2];
-  struct backcmd *bcmd;
-  struct execcmd *ecmd;
-  struct listcmd *lcmd;
-  struct pipecmd *pcmd;
-  struct redircmd *rcmd;
-
-  if(cmd == 0)
-    exit();
-
-  switch(cmd->type){
-  default:
-    panic("runcmd");
-
-  case EXEC:
-    ecmd = (struct execcmd*)cmd;
-    if(ecmd->argv[0] == 0)
-      exit();
-    exec(ecmd->argv[0], ecmd->argv);
-    printf(2, "exec %s failed\n", ecmd->argv[0]);
-    break;
-
-  case REDIR:
-    rcmd = (struct redircmd*)cmd;
-    close(rcmd->fd);
-    if(open(rcmd->file, rcmd->mode) < 0){
-      printf(2, "open %s failed\n", rcmd->file);
-      exit();
-    }
-    runcmd(rcmd->cmd);
-    break;
-
-  case LIST:
-    lcmd = (struct listcmd*)cmd;
-    if(fork1() == 0)
-      runcmd(lcmd->left);
-    wait();
-    runcmd(lcmd->right);
-    break;
-
-  case PIPE:
-    pcmd = (struct pipecmd*)cmd;
-    if(pipe(p) < 0)
-      panic("pipe");
-    if(fork1() == 0){
-      close(1);
-      dup(p[1]);
-      close(p[0]);
-      close(p[1]);
-      runcmd(pcmd->left);
-    }
-    if(fork1() == 0){
-      close(0);
-      dup(p[0]);
-      close(p[0]);
-      close(p[1]);
-      runcmd(pcmd->right);
-    }
-    close(p[0]);
-    close(p[1]);
-    wait();
-    wait();
-    break;
-
-  case BACK:
-    bcmd = (struct backcmd*)cmd;
-    if(fork1() == 0)
-      runcmd(bcmd->cmd);
-    break;
-  }
-  exit();
-}
-
-int
-getcmd(char *buf, int nbuf)
-{
-  printf(2, "$ ");
-  memset(buf, 0, nbuf);
-  gets(buf, nbuf);
-  if(buf[0] == 0) // EOF
-    return -1;
-  return 0;
-}
-
-int
-main(void)
-{
-  static char buf[100];
-  int fd;
-
-  // Ensure that three file descriptors are open.
-  while((fd = open("console", O_RDWR)) >= 0){
-    if(fd >= 3){
-      close(fd);
-      break;
-    }
-  }
-
-  // Read and run input commands.
-  while(getcmd(buf, sizeof(buf)) >= 0){
-    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
-      // Chdir must be called by the parent, not the child.
-      buf[strlen(buf)-1] = 0;  // chop \n
-      if(chdir(buf+3) < 0)
-        printf(2, "cannot cd %s\n", buf+3);
-      continue;
-    }
-    if(fork1() == 0)
-      runcmd(parsecmd(buf));
-    wait();
-  }
-  exit();
-}
-
-void
-panic(char *s)
-{
-  printf(2, "%s\n", s);
-  exit();
-}
-
-int
-fork1(void)
-{
-  int pid;
-
-  pid = fork();
-  if(pid == -1)
-    panic("fork");
-  return pid;
-}
-
-//PAGEBREAK!
-// Constructors
-
-struct cmd*
-execcmd(void)
-{
-  struct execcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = EXEC;
-  return (struct cmd*)cmd;
-}
-
-struct cmd*
-redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
-{
-  struct redircmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = REDIR;
-  cmd->cmd = subcmd;
-  cmd->file = file;
-  cmd->efile = efile;
-  cmd->mode = mode;
-  cmd->fd = fd;
-  return (struct cmd*)cmd;
-}
-
-struct cmd*
-pipecmd(struct cmd *left, struct cmd *right)
-{
-  struct pipecmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = PIPE;
-  cmd->left = left;
-  cmd->right = right;
-  return (struct cmd*)cmd;
-}
-
-struct cmd*
-listcmd(struct cmd *left, struct cmd *right)
-{
-  struct listcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = LIST;
-  cmd->left = left;
-  cmd->right = right;
-  return (struct cmd*)cmd;
-}
-
-struct cmd*
-backcmd(struct cmd *subcmd)
-{
-  struct backcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = BACK;
-  cmd->cmd = subcmd;
-  return (struct cmd*)cmd;
-}
-//PAGEBREAK!
-// Parsing
-
-char whitespace[] = " \t\r\n\v";
-char symbols[] = "<|>&;()";
-
-int
-gettoken(char **ps, char *es, char **q, char **eq)
-{
-  char *s;
-  int ret;
-
-  s = *ps;
-  while(s < es && strchr(whitespace, *s))
-    s++;
-  if(q)
-    *q = s;
-  ret = *s;
-  switch(*s){
-  case 0:
-    break;
-  case '|':
-  case '(':
-  case ')':
-  case ';':
-  case '&':
-  case '<':
-    s++;
-    break;
-  case '>':
-    s++;
-    if(*s == '>'){
-      ret = '+';
-      s++;
-    }
-    break;
-  default:
-    ret = 'a';
-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
-      s++;
-    break;
-  }
-  if(eq)
-    *eq = s;
-
-  while(s < es && strchr(whitespace, *s))
-    s++;
-  *ps = s;
-  return ret;
-}
-
-int
-peek(char **ps, char *es, char *toks)
-{
-  char *s;
-
-  s = *ps;
-  while(s < es && strchr(whitespace, *s))
-    s++;
-  *ps = s;
-  return *s && strchr(toks, *s);
-}
-
-struct cmd *parseline(char**, char*);
-struct cmd *parsepipe(char**, char*);
-struct cmd *parseexec(char**, char*);
-struct cmd *nulterminate(struct cmd*);
-
-struct cmd*
-parsecmd(char *s)
-{
-  char *es;
-  struct cmd *cmd;
-
-  es = s + strlen(s);
-  cmd = parseline(&s, es);
-  peek(&s, es, "");
-  if(s != es){
-    printf(2, "leftovers: %s\n", s);
-    panic("syntax");
-  }
-  nulterminate(cmd);
-  return cmd;
-}
-
-struct cmd*
-parseline(char **ps, char *es)
-{
-  struct cmd *cmd;
-
-  cmd = parsepipe(ps, es);
-  while(peek(ps, es, "&")){
-    gettoken(ps, es, 0, 0);
-    cmd = backcmd(cmd);
-  }
-  if(peek(ps, es, ";")){
-    gettoken(ps, es, 0, 0);
-    cmd = listcmd(cmd, parseline(ps, es));
-  }
-  return cmd;
-}
-
-struct cmd*
-parsepipe(char **ps, char *es)
-{
-  struct cmd *cmd;
-
-  cmd = parseexec(ps, es);
-  if(peek(ps, es, "|")){
-    gettoken(ps, es, 0, 0);
-    cmd = pipecmd(cmd, parsepipe(ps, es));
-  }
-  return cmd;
-}
-
-struct cmd*
-parseredirs(struct cmd *cmd, char **ps, char *es)
-{
-  int tok;
-  char *q, *eq;
-
-  while(peek(ps, es, "<>")){
-    tok = gettoken(ps, es, 0, 0);
-    if(gettoken(ps, es, &q, &eq) != 'a')
-      panic("missing file for redirection");
-    switch(tok){
-    case '<':
-      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
-      break;
-    case '>':
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
-      break;
-    case '+':  // >>
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
-      break;
-    }
-  }
-  return cmd;
-}
-
-struct cmd*
-parseblock(char **ps, char *es)
-{
-  struct cmd *cmd;
-
-  if(!peek(ps, es, "("))
-    panic("parseblock");
-  gettoken(ps, es, 0, 0);
-  cmd = parseline(ps, es);
-  if(!peek(ps, es, ")"))
-    panic("syntax - missing )");
-  gettoken(ps, es, 0, 0);
-  cmd = parseredirs(cmd, ps, es);
-  return cmd;
-}
-
-struct cmd*
-parseexec(char **ps, char *es)
-{
-  char *q, *eq;
-  int tok, argc;
-  struct execcmd *cmd;
-  struct cmd *ret;
-
-  if(peek(ps, es, "("))
-    return parseblock(ps, es);
-
-  ret = execcmd();
-  cmd = (struct execcmd*)ret;
-
-  argc = 0;
-  ret = parseredirs(ret, ps, es);
-  while(!peek(ps, es, "|)&;")){
-    if((tok=gettoken(ps, es, &q, &eq)) == 0)
-      break;
-    if(tok != 'a')
-      panic("syntax");
-    cmd->argv[argc] = q;
-    cmd->eargv[argc] = eq;
-    argc++;
-    if(argc >= MAXARGS)
-      panic("too many args");
-    ret = parseredirs(ret, ps, es);
-  }
-  cmd->argv[argc] = 0;
-  cmd->eargv[argc] = 0;
-  return ret;
-}
-
-// NUL-terminate all the counted strings.
-struct cmd*
-nulterminate(struct cmd *cmd)
-{
-  int i;
-  struct backcmd *bcmd;
-  struct execcmd *ecmd;
-  struct listcmd *lcmd;
-  struct pipecmd *pcmd;
-  struct redircmd *rcmd;
-
-  if(cmd == 0)
-    return 0;
-
-  switch(cmd->type){
-  case EXEC:
-    ecmd = (struct execcmd*)cmd;
-    for(i=0; ecmd->argv[i]; i++)
-      *ecmd->eargv[i] = 0;
-    break;
-
-  case REDIR:
-    rcmd = (struct redircmd*)cmd;
-    nulterminate(rcmd->cmd);
-    *rcmd->efile = 0;
-    break;
-
-  case PIPE:
-    pcmd = (struct pipecmd*)cmd;
-    nulterminate(pcmd->left);
-    nulterminate(pcmd->right);
-    break;
-
-  case LIST:
-    lcmd = (struct listcmd*)cmd;
-    nulterminate(lcmd->left);
-    nulterminate(lcmd->right);
-    break;
-
-  case BACK:
-    bcmd = (struct backcmd*)cmd;
-    nulterminate(bcmd->cmd);
-    break;
-  }
-  return cmd;
-}
diff --git a/xv6-public/Operating-System-Project/sh.d b/xv6-public/Operating-System-Project/sh.d
deleted file mode 100644
index 51ddf2d..0000000
--- a/xv6-public/Operating-System-Project/sh.d
+++ /dev/null
@@ -1 +0,0 @@
-sh.o: sh.c /usr/include/stdc-predef.h types.h user.h fcntl.h
diff --git a/xv6-public/Operating-System-Project/sh.o b/xv6-public/Operating-System-Project/sh.o
deleted file mode 100644
index 924a6d1..0000000
Binary files a/xv6-public/Operating-System-Project/sh.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/sh.sym b/xv6-public/Operating-System-Project/sh.sym
deleted file mode 100644
index 74d45ea..0000000
--- a/xv6-public/Operating-System-Project/sh.sym
+++ /dev/null
@@ -1,91 +0,0 @@
-00000000 .text
-000012b8 .rodata
-000013bc .eh_frame
-00001978 .data
-000019a0 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 sh.c
-000019a0 buf.1147
-00000000 ulib.c
-00000000 printf.c
-00000ea0 printint
-000013a8 digits.1109
-00000000 umalloc.c
-00001a04 freep
-00001a08 base
-00000b30 strcpy
-00000e3b getChildren
-00000f50 printf
-00000d60 memmove
-00000ddb mknod
-00000370 execcmd
-00000c50 gets
-00000e13 getpid
-00000850 parsepipe
-00000e73 customWait
-00000ac0 parsecmd
-00000470 backcmd
-00000e6b getCBT
-00000610 peek
-00000690 parseredirs
-000004b0 gettoken
-000011b0 malloc
-00000e23 sleep
-00001980 whitespace
-00000340 fork1
-00000a00 nulterminate
-00000da3 pipe
-00000e53 changePolicy
-00000110 getcmd
-00000db3 write
-00000deb fstat
-00000dc3 kill
-00000e03 chdir
-000008c0 parseline
-00000180 runcmd
-00000e7b setQueue
-00000970 parseblock
-00000dcb exec
-00000d9b wait
-00001978 symbols
-00000dab read
-00000740 parseexec
-00000e83 getBurstTime
-00000de3 unlink
-00000160 panic
-00000d8b fork
-00000e5b getTurnAroundTime
-00000e1b sbrk
-00000e2b uptime
-00001986 __bss_start
-00000bf0 memset
-00000000 main
-00000b60 strcmp
-00000e0b dup
-00000e43 getSyscallCounter
-000003f0 pipecmd
-000003a0 redircmd
-00000e33 getParentID
-00000cd0 stat
-00001986 _edata
-00001a10 _end
-00000df3 link
-00000d93 exit
-00000e4b setPriority
-00000d20 atoi
-00000e8b getCreationTime
-00000bb0 strlen
-00000dd3 open
-00000c10 strchr
-00000dfb mkdir
-00000dbb close
-00000e63 getWaitingTime
-00000430 listcmd
-00001120 free
diff --git a/xv6-public/Operating-System-Project/show1 b/xv6-public/Operating-System-Project/show1
deleted file mode 100644
index e0d3d83..0000000
--- a/xv6-public/Operating-System-Project/show1
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/bin/sh
-
-runoff1 "$@" | pr.pl -h "xv6/$@" | mpage -m50t50b -o -bLetter -T -t -2 -FLucidaSans-Typewriter83 -L60 >x.ps; gv --swap x.ps
diff --git a/xv6-public/Operating-System-Project/sign.pl b/xv6-public/Operating-System-Project/sign.pl
deleted file mode 100644
index d793035..0000000
--- a/xv6-public/Operating-System-Project/sign.pl
+++ /dev/null
@@ -1,19 +0,0 @@
-#!/usr/bin/perl
-
-open(SIG, $ARGV[0]) || die "open $ARGV[0]: $!";
-
-$n = sysread(SIG, $buf, 1000);
-
-if($n > 510){
-  print STDERR "boot block too large: $n bytes (max 510)\n";
-  exit 1;
-}
-
-print STDERR "boot block is $n bytes (max 510)\n";
-
-$buf .= "\0" x (510-$n);
-$buf .= "\x55\xAA";
-
-open(SIG, ">$ARGV[0]") || die "open >$ARGV[0]: $!";
-print SIG $buf;
-close SIG;
diff --git a/xv6-public/Operating-System-Project/sleep1.p b/xv6-public/Operating-System-Project/sleep1.p
deleted file mode 100644
index af69772..0000000
--- a/xv6-public/Operating-System-Project/sleep1.p
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
-This file defines a Promela model for xv6's
-acquire, release, sleep, and wakeup, along with
-a model of a simple producer/consumer queue.
-
-To run:
-	spinp sleep1.p
-
-(You may need to install Spin, available at http://spinroot.com/.)
-
-After a successful run spin prints something like:
-
-	unreached in proctype consumer
-		(0 of 37 states)
-	unreached in proctype producer
-		(0 of 23 states)
-
-After an unsuccessful run, the spinp script prints
-an execution trace that causes a deadlock.
-
-The safe body of producer reads:
-
-		acquire(lk);
-		x = value; value = x + 1; x = 0;
-		wakeup(0);
-		release(lk);
-		i = i + 1;
-
-If this is changed to:
-
-		x = value; value = x + 1; x = 0;
-		acquire(lk);
-		wakeup(0);
-		release(lk);
-		i = i + 1;
-
-then a deadlock can happen, because the non-atomic
-increment of value conflicts with the non-atomic 
-decrement in consumer, causing value to have a bad value.
-Try this.
-
-If it is changed to:
-
-		acquire(lk);
-		x = value; value = x + 1; x = 0;
-		release(lk);
-		wakeup(0);
-		i = i + 1;
-
-then nothing bad happens: it is okay to wakeup after release
-instead of before, although it seems morally wrong.
-*/
-
-#define ITER 4
-#define N 2
-
-bit lk;
-byte value;
-bit sleeping[N];
-
-inline acquire(x)
-{
-	atomic { x == 0; x = 1 }
-}
-
-inline release(x)
-{
-	assert x==1;
-	x = 0
-}
-
-inline sleep(cond, lk)
-{
-	assert !sleeping[_pid];
-	if
-	:: cond ->
-		skip
-	:: else ->
-		atomic { release(lk); sleeping[_pid] = 1 };
-		sleeping[_pid] == 0;
-		acquire(lk)
-	fi
-}
-
-inline wakeup()
-{
-	w = 0;
-	do
-	:: w < N ->
-		sleeping[w] = 0;
-		w = w + 1
-	:: else ->
-		break
-	od
-}
-
-active[N] proctype consumer()
-{
-	byte i, x;
-	
-	i = 0;
-	do
-	:: i < ITER ->
-		acquire(lk);
-		sleep(value > 0, lk);
-		x = value; value = x - 1; x = 0;
-		release(lk);
-		i = i + 1;
-	:: else ->
-		break
-	od;
-	i = 0;
-	skip
-}
-
-active[N] proctype producer()
-{
-	byte i, x, w;
-	
-	i = 0;
-	do
-	:: i < ITER ->
-		acquire(lk);
-		x = value; value = x + 1; x = 0;
-		release(lk);
-		wakeup();
-		i = i + 1;
-	:: else ->
-		break
-	od;
-	i = 0;
-	skip	
-}
-
diff --git a/xv6-public/Operating-System-Project/sleeplock.c b/xv6-public/Operating-System-Project/sleeplock.c
deleted file mode 100644
index e0750ea..0000000
--- a/xv6-public/Operating-System-Project/sleeplock.c
+++ /dev/null
@@ -1,56 +0,0 @@
-// Sleeping locks
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "x86.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-
-void
-initsleeplock(struct sleeplock *lk, char *name)
-{
-  initlock(&lk->lk, "sleep lock");
-  lk->name = name;
-  lk->locked = 0;
-  lk->pid = 0;
-}
-
-void
-acquiresleep(struct sleeplock *lk)
-{
-  acquire(&lk->lk);
-  while (lk->locked) {
-    sleep(lk, &lk->lk);
-  }
-  lk->locked = 1;
-  lk->pid = myproc()->pid;
-  release(&lk->lk);
-}
-
-void
-releasesleep(struct sleeplock *lk)
-{
-  acquire(&lk->lk);
-  lk->locked = 0;
-  lk->pid = 0;
-  wakeup(lk);
-  release(&lk->lk);
-}
-
-int
-holdingsleep(struct sleeplock *lk)
-{
-  int r;
-  
-  acquire(&lk->lk);
-  r = lk->locked && (lk->pid == myproc()->pid);
-  release(&lk->lk);
-  return r;
-}
-
-
-
diff --git a/xv6-public/Operating-System-Project/sleeplock.d b/xv6-public/Operating-System-Project/sleeplock.d
deleted file mode 100644
index e50551a..0000000
--- a/xv6-public/Operating-System-Project/sleeplock.d
+++ /dev/null
@@ -1,2 +0,0 @@
-sleeplock.o: sleeplock.c /usr/include/stdc-predef.h types.h defs.h \
- param.h x86.h memlayout.h mmu.h proc.h spinlock.h sleeplock.h
diff --git a/xv6-public/Operating-System-Project/sleeplock.h b/xv6-public/Operating-System-Project/sleeplock.h
deleted file mode 100644
index 110e6f3..0000000
--- a/xv6-public/Operating-System-Project/sleeplock.h
+++ /dev/null
@@ -1,10 +0,0 @@
-// Long-term locks for processes
-struct sleeplock {
-  uint locked;       // Is the lock held?
-  struct spinlock lk; // spinlock protecting this sleep lock
-  
-  // For debugging:
-  char *name;        // Name of lock.
-  int pid;           // Process holding lock
-};
-
diff --git a/xv6-public/Operating-System-Project/sleeplock.o b/xv6-public/Operating-System-Project/sleeplock.o
deleted file mode 100644
index 86b1bae..0000000
Binary files a/xv6-public/Operating-System-Project/sleeplock.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/spinlock.c b/xv6-public/Operating-System-Project/spinlock.c
deleted file mode 100644
index 4020186..0000000
--- a/xv6-public/Operating-System-Project/spinlock.c
+++ /dev/null
@@ -1,126 +0,0 @@
-// Mutual exclusion spin locks.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "x86.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "spinlock.h"
-
-void
-initlock(struct spinlock *lk, char *name)
-{
-  lk->name = name;
-  lk->locked = 0;
-  lk->cpu = 0;
-}
-
-// Acquire the lock.
-// Loops (spins) until the lock is acquired.
-// Holding a lock for a long time may cause
-// other CPUs to waste time spinning to acquire it.
-void
-acquire(struct spinlock *lk)
-{
-  pushcli(); // disable interrupts to avoid deadlock.
-  if(holding(lk))
-    panic("acquire");
-
-  // The xchg is atomic.
-  while(xchg(&lk->locked, 1) != 0)
-    ;
-
-  // Tell the C compiler and the processor to not move loads or stores
-  // past this point, to ensure that the critical section's memory
-  // references happen after the lock is acquired.
-  __sync_synchronize();
-
-  // Record info about lock acquisition for debugging.
-  lk->cpu = mycpu();
-  getcallerpcs(&lk, lk->pcs);
-}
-
-// Release the lock.
-void
-release(struct spinlock *lk)
-{
-  if(!holding(lk))
-    panic("release");
-
-  lk->pcs[0] = 0;
-  lk->cpu = 0;
-
-  // Tell the C compiler and the processor to not move loads or stores
-  // past this point, to ensure that all the stores in the critical
-  // section are visible to other cores before the lock is released.
-  // Both the C compiler and the hardware may re-order loads and
-  // stores; __sync_synchronize() tells them both not to.
-  __sync_synchronize();
-
-  // Release the lock, equivalent to lk->locked = 0.
-  // This code can't use a C assignment, since it might
-  // not be atomic. A real OS would use C atomics here.
-  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
-
-  popcli();
-}
-
-// Record the current call stack in pcs[] by following the %ebp chain.
-void
-getcallerpcs(void *v, uint pcs[])
-{
-  uint *ebp;
-  int i;
-
-  ebp = (uint*)v - 2;
-  for(i = 0; i < 10; i++){
-    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
-      break;
-    pcs[i] = ebp[1];     // saved %eip
-    ebp = (uint*)ebp[0]; // saved %ebp
-  }
-  for(; i < 10; i++)
-    pcs[i] = 0;
-}
-
-// Check whether this cpu is holding the lock.
-int
-holding(struct spinlock *lock)
-{
-  int r;
-  pushcli();
-  r = lock->locked && lock->cpu == mycpu();
-  popcli();
-  return r;
-}
-
-
-// Pushcli/popcli are like cli/sti except that they are matched:
-// it takes two popcli to undo two pushcli.  Also, if interrupts
-// are off, then pushcli, popcli leaves them off.
-
-void
-pushcli(void)
-{
-  int eflags;
-
-  eflags = readeflags();
-  cli();
-  if(mycpu()->ncli == 0)
-    mycpu()->intena = eflags & FL_IF;
-  mycpu()->ncli += 1;
-}
-
-void
-popcli(void)
-{
-  if(readeflags()&FL_IF)
-    panic("popcli - interruptible");
-  if(--mycpu()->ncli < 0)
-    panic("popcli");
-  if(mycpu()->ncli == 0 && mycpu()->intena)
-    sti();
-}
-
diff --git a/xv6-public/Operating-System-Project/spinlock.d b/xv6-public/Operating-System-Project/spinlock.d
deleted file mode 100644
index 9f70952..0000000
--- a/xv6-public/Operating-System-Project/spinlock.d
+++ /dev/null
@@ -1,2 +0,0 @@
-spinlock.o: spinlock.c /usr/include/stdc-predef.h types.h defs.h param.h \
- x86.h memlayout.h mmu.h proc.h spinlock.h
diff --git a/xv6-public/Operating-System-Project/spinlock.h b/xv6-public/Operating-System-Project/spinlock.h
deleted file mode 100644
index 0a9d8e2..0000000
--- a/xv6-public/Operating-System-Project/spinlock.h
+++ /dev/null
@@ -1,11 +0,0 @@
-// Mutual exclusion lock.
-struct spinlock {
-  uint locked;       // Is the lock held?
-
-  // For debugging:
-  char *name;        // Name of lock.
-  struct cpu *cpu;   // The cpu holding the lock.
-  uint pcs[10];      // The call stack (an array of program counters)
-                     // that locked the lock.
-};
-
diff --git a/xv6-public/Operating-System-Project/spinlock.o b/xv6-public/Operating-System-Project/spinlock.o
deleted file mode 100644
index 5d5ca91..0000000
Binary files a/xv6-public/Operating-System-Project/spinlock.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/spinp b/xv6-public/Operating-System-Project/spinp
deleted file mode 100644
index db9614b..0000000
--- a/xv6-public/Operating-System-Project/spinp
+++ /dev/null
@@ -1,16 +0,0 @@
-#!/bin/sh
-
-if [ $# != 1 ] || [ ! -f "$1" ]; then
-	echo 'usage: spinp file.p' 1>&2
-	exit 1
-fi
-
-rm -f $1.trail
-spin -a $1 || exit 1
-cc -DSAFETY -DREACH -DMEMLIM=500 -o pan pan.c
-pan -i
-rm pan.* pan
-if [ -f $1.trail ]; then
-	spin -t -p $1
-fi
-
diff --git a/xv6-public/Operating-System-Project/stat.h b/xv6-public/Operating-System-Project/stat.h
deleted file mode 100644
index 8a80933..0000000
--- a/xv6-public/Operating-System-Project/stat.h
+++ /dev/null
@@ -1,11 +0,0 @@
-#define T_DIR  1   // Directory
-#define T_FILE 2   // File
-#define T_DEV  3   // Device
-
-struct stat {
-  short type;  // Type of file
-  int dev;     // File system's disk device
-  uint ino;    // Inode number
-  short nlink; // Number of links to file
-  uint size;   // Size of file in bytes
-};
diff --git a/xv6-public/Operating-System-Project/stressfs.asm b/xv6-public/Operating-System-Project/stressfs.asm
deleted file mode 100644
index 7ae9186..0000000
--- a/xv6-public/Operating-System-Project/stressfs.asm
+++ /dev/null
@@ -1,1363 +0,0 @@
-
-_stressfs:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "fs.h"
-#include "fcntl.h"
-
-int
-main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-  int fd, i;
-  char path[] = "stressfs0";
-   b:	b8 30 00 00 00       	mov    $0x30,%eax
-{
-  10:	ff 71 fc             	pushl  -0x4(%ecx)
-  13:	55                   	push   %ebp
-  14:	89 e5                	mov    %esp,%ebp
-  16:	57                   	push   %edi
-  17:	56                   	push   %esi
-  char data[512];
-
-  printf(1, "stressfs starting\n");
-  memset(data, 'a', sizeof(data));
-  18:	8d b5 e8 fd ff ff    	lea    -0x218(%ebp),%esi
-{
-  1e:	53                   	push   %ebx
-
-  for(i = 0; i < 4; i++)
-  1f:	31 db                	xor    %ebx,%ebx
-{
-  21:	51                   	push   %ecx
-  22:	81 ec 20 02 00 00    	sub    $0x220,%esp
-  char path[] = "stressfs0";
-  28:	66 89 85 e6 fd ff ff 	mov    %ax,-0x21a(%ebp)
-  printf(1, "stressfs starting\n");
-  2f:	68 c8 08 00 00       	push   $0x8c8
-  34:	6a 01                	push   $0x1
-  char path[] = "stressfs0";
-  36:	c7 85 de fd ff ff 73 	movl   $0x65727473,-0x222(%ebp)
-  3d:	74 72 65 
-  40:	c7 85 e2 fd ff ff 73 	movl   $0x73667373,-0x21e(%ebp)
-  47:	73 66 73 
-  printf(1, "stressfs starting\n");
-  4a:	e8 11 05 00 00       	call   560 <printf>
-  memset(data, 'a', sizeof(data));
-  4f:	83 c4 0c             	add    $0xc,%esp
-  52:	68 00 02 00 00       	push   $0x200
-  57:	6a 61                	push   $0x61
-  59:	56                   	push   %esi
-  5a:	e8 a1 01 00 00       	call   200 <memset>
-  5f:	83 c4 10             	add    $0x10,%esp
-    if(fork() > 0)
-  62:	e8 34 03 00 00       	call   39b <fork>
-  67:	85 c0                	test   %eax,%eax
-  69:	0f 8f bb 00 00 00    	jg     12a <main+0x12a>
-  for(i = 0; i < 4; i++)
-  6f:	83 c3 01             	add    $0x1,%ebx
-  72:	83 fb 04             	cmp    $0x4,%ebx
-  75:	75 eb                	jne    62 <main+0x62>
-  77:	bf 04 00 00 00       	mov    $0x4,%edi
-      break;
-
-  printf(1, "write %d\n", i);
-  7c:	83 ec 04             	sub    $0x4,%esp
-  7f:	53                   	push   %ebx
-
-  path[8] += i;
-  fd = open(path, O_CREATE | O_RDWR);
-  80:	bb 14 00 00 00       	mov    $0x14,%ebx
-  printf(1, "write %d\n", i);
-  85:	68 db 08 00 00       	push   $0x8db
-  8a:	6a 01                	push   $0x1
-  8c:	e8 cf 04 00 00       	call   560 <printf>
-  path[8] += i;
-  91:	89 f8                	mov    %edi,%eax
-  fd = open(path, O_CREATE | O_RDWR);
-  93:	5f                   	pop    %edi
-  path[8] += i;
-  94:	00 85 e6 fd ff ff    	add    %al,-0x21a(%ebp)
-  fd = open(path, O_CREATE | O_RDWR);
-  9a:	58                   	pop    %eax
-  9b:	8d 85 de fd ff ff    	lea    -0x222(%ebp),%eax
-  a1:	68 02 02 00 00       	push   $0x202
-  a6:	50                   	push   %eax
-  a7:	e8 37 03 00 00       	call   3e3 <open>
-  ac:	83 c4 10             	add    $0x10,%esp
-  af:	89 c7                	mov    %eax,%edi
-  for(i = 0; i < 20; i++)
-  b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-//    printf(fd, "%d\n", i);
-    write(fd, data, sizeof(data));
-  b8:	83 ec 04             	sub    $0x4,%esp
-  bb:	68 00 02 00 00       	push   $0x200
-  c0:	56                   	push   %esi
-  c1:	57                   	push   %edi
-  c2:	e8 fc 02 00 00       	call   3c3 <write>
-  for(i = 0; i < 20; i++)
-  c7:	83 c4 10             	add    $0x10,%esp
-  ca:	83 eb 01             	sub    $0x1,%ebx
-  cd:	75 e9                	jne    b8 <main+0xb8>
-  close(fd);
-  cf:	83 ec 0c             	sub    $0xc,%esp
-  d2:	57                   	push   %edi
-  d3:	e8 f3 02 00 00       	call   3cb <close>
-
-  printf(1, "read\n");
-  d8:	58                   	pop    %eax
-  d9:	5a                   	pop    %edx
-  da:	68 e5 08 00 00       	push   $0x8e5
-  df:	6a 01                	push   $0x1
-  e1:	e8 7a 04 00 00       	call   560 <printf>
-
-  fd = open(path, O_RDONLY);
-  e6:	8d 85 de fd ff ff    	lea    -0x222(%ebp),%eax
-  ec:	59                   	pop    %ecx
-  ed:	5b                   	pop    %ebx
-  ee:	6a 00                	push   $0x0
-  f0:	bb 14 00 00 00       	mov    $0x14,%ebx
-  f5:	50                   	push   %eax
-  f6:	e8 e8 02 00 00       	call   3e3 <open>
-  fb:	83 c4 10             	add    $0x10,%esp
-  fe:	89 c7                	mov    %eax,%edi
-  for (i = 0; i < 20; i++)
-    read(fd, data, sizeof(data));
- 100:	83 ec 04             	sub    $0x4,%esp
- 103:	68 00 02 00 00       	push   $0x200
- 108:	56                   	push   %esi
- 109:	57                   	push   %edi
- 10a:	e8 ac 02 00 00       	call   3bb <read>
-  for (i = 0; i < 20; i++)
- 10f:	83 c4 10             	add    $0x10,%esp
- 112:	83 eb 01             	sub    $0x1,%ebx
- 115:	75 e9                	jne    100 <main+0x100>
-  close(fd);
- 117:	83 ec 0c             	sub    $0xc,%esp
- 11a:	57                   	push   %edi
- 11b:	e8 ab 02 00 00       	call   3cb <close>
-
-  wait();
- 120:	e8 86 02 00 00       	call   3ab <wait>
-
-  exit();
- 125:	e8 79 02 00 00       	call   3a3 <exit>
- 12a:	89 df                	mov    %ebx,%edi
- 12c:	e9 4b ff ff ff       	jmp    7c <main+0x7c>
- 131:	66 90                	xchg   %ax,%ax
- 133:	66 90                	xchg   %ax,%ax
- 135:	66 90                	xchg   %ax,%ax
- 137:	66 90                	xchg   %ax,%ax
- 139:	66 90                	xchg   %ax,%ax
- 13b:	66 90                	xchg   %ax,%ax
- 13d:	66 90                	xchg   %ax,%ax
- 13f:	90                   	nop
-
-00000140 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
- 140:	f3 0f 1e fb          	endbr32 
- 144:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
- 145:	31 c0                	xor    %eax,%eax
-{
- 147:	89 e5                	mov    %esp,%ebp
- 149:	53                   	push   %ebx
- 14a:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 14d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
- 150:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
- 154:	88 14 01             	mov    %dl,(%ecx,%eax,1)
- 157:	83 c0 01             	add    $0x1,%eax
- 15a:	84 d2                	test   %dl,%dl
- 15c:	75 f2                	jne    150 <strcpy+0x10>
-    ;
-  return os;
-}
- 15e:	89 c8                	mov    %ecx,%eax
- 160:	5b                   	pop    %ebx
- 161:	5d                   	pop    %ebp
- 162:	c3                   	ret    
- 163:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 16a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000170 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
- 170:	f3 0f 1e fb          	endbr32 
- 174:	55                   	push   %ebp
- 175:	89 e5                	mov    %esp,%ebp
- 177:	53                   	push   %ebx
- 178:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 17b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
- 17e:	0f b6 01             	movzbl (%ecx),%eax
- 181:	0f b6 1a             	movzbl (%edx),%ebx
- 184:	84 c0                	test   %al,%al
- 186:	75 19                	jne    1a1 <strcmp+0x31>
- 188:	eb 26                	jmp    1b0 <strcmp+0x40>
- 18a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 190:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
- 194:	83 c1 01             	add    $0x1,%ecx
- 197:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
- 19a:	0f b6 1a             	movzbl (%edx),%ebx
- 19d:	84 c0                	test   %al,%al
- 19f:	74 0f                	je     1b0 <strcmp+0x40>
- 1a1:	38 d8                	cmp    %bl,%al
- 1a3:	74 eb                	je     190 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
- 1a5:	29 d8                	sub    %ebx,%eax
-}
- 1a7:	5b                   	pop    %ebx
- 1a8:	5d                   	pop    %ebp
- 1a9:	c3                   	ret    
- 1aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 1b0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
- 1b2:	29 d8                	sub    %ebx,%eax
-}
- 1b4:	5b                   	pop    %ebx
- 1b5:	5d                   	pop    %ebp
- 1b6:	c3                   	ret    
- 1b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1be:	66 90                	xchg   %ax,%ax
-
-000001c0 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 1c0:	f3 0f 1e fb          	endbr32 
- 1c4:	55                   	push   %ebp
- 1c5:	89 e5                	mov    %esp,%ebp
- 1c7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 1ca:	80 3a 00             	cmpb   $0x0,(%edx)
- 1cd:	74 21                	je     1f0 <strlen+0x30>
- 1cf:	31 c0                	xor    %eax,%eax
- 1d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1d8:	83 c0 01             	add    $0x1,%eax
- 1db:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 1df:	89 c1                	mov    %eax,%ecx
- 1e1:	75 f5                	jne    1d8 <strlen+0x18>
-    ;
-  return n;
-}
- 1e3:	89 c8                	mov    %ecx,%eax
- 1e5:	5d                   	pop    %ebp
- 1e6:	c3                   	ret    
- 1e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1ee:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 1f0:	31 c9                	xor    %ecx,%ecx
-}
- 1f2:	5d                   	pop    %ebp
- 1f3:	89 c8                	mov    %ecx,%eax
- 1f5:	c3                   	ret    
- 1f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1fd:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000200 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 200:	f3 0f 1e fb          	endbr32 
- 204:	55                   	push   %ebp
- 205:	89 e5                	mov    %esp,%ebp
- 207:	57                   	push   %edi
- 208:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 20b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 20e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 211:	89 d7                	mov    %edx,%edi
- 213:	fc                   	cld    
- 214:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 216:	89 d0                	mov    %edx,%eax
- 218:	5f                   	pop    %edi
- 219:	5d                   	pop    %ebp
- 21a:	c3                   	ret    
- 21b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 21f:	90                   	nop
-
-00000220 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 220:	f3 0f 1e fb          	endbr32 
- 224:	55                   	push   %ebp
- 225:	89 e5                	mov    %esp,%ebp
- 227:	8b 45 08             	mov    0x8(%ebp),%eax
- 22a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 22e:	0f b6 10             	movzbl (%eax),%edx
- 231:	84 d2                	test   %dl,%dl
- 233:	75 16                	jne    24b <strchr+0x2b>
- 235:	eb 21                	jmp    258 <strchr+0x38>
- 237:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 23e:	66 90                	xchg   %ax,%ax
- 240:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 244:	83 c0 01             	add    $0x1,%eax
- 247:	84 d2                	test   %dl,%dl
- 249:	74 0d                	je     258 <strchr+0x38>
-    if(*s == c)
- 24b:	38 d1                	cmp    %dl,%cl
- 24d:	75 f1                	jne    240 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 24f:	5d                   	pop    %ebp
- 250:	c3                   	ret    
- 251:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 258:	31 c0                	xor    %eax,%eax
-}
- 25a:	5d                   	pop    %ebp
- 25b:	c3                   	ret    
- 25c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000260 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 260:	f3 0f 1e fb          	endbr32 
- 264:	55                   	push   %ebp
- 265:	89 e5                	mov    %esp,%ebp
- 267:	57                   	push   %edi
- 268:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 269:	31 f6                	xor    %esi,%esi
-{
- 26b:	53                   	push   %ebx
- 26c:	89 f3                	mov    %esi,%ebx
- 26e:	83 ec 1c             	sub    $0x1c,%esp
- 271:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 274:	eb 33                	jmp    2a9 <gets+0x49>
- 276:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 27d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 280:	83 ec 04             	sub    $0x4,%esp
- 283:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 286:	6a 01                	push   $0x1
- 288:	50                   	push   %eax
- 289:	6a 00                	push   $0x0
- 28b:	e8 2b 01 00 00       	call   3bb <read>
-    if(cc < 1)
- 290:	83 c4 10             	add    $0x10,%esp
- 293:	85 c0                	test   %eax,%eax
- 295:	7e 1c                	jle    2b3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 297:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 29b:	83 c7 01             	add    $0x1,%edi
- 29e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 2a1:	3c 0a                	cmp    $0xa,%al
- 2a3:	74 23                	je     2c8 <gets+0x68>
- 2a5:	3c 0d                	cmp    $0xd,%al
- 2a7:	74 1f                	je     2c8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 2a9:	83 c3 01             	add    $0x1,%ebx
- 2ac:	89 fe                	mov    %edi,%esi
- 2ae:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 2b1:	7c cd                	jl     280 <gets+0x20>
- 2b3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 2b5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 2b8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 2bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 2be:	5b                   	pop    %ebx
- 2bf:	5e                   	pop    %esi
- 2c0:	5f                   	pop    %edi
- 2c1:	5d                   	pop    %ebp
- 2c2:	c3                   	ret    
- 2c3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 2c7:	90                   	nop
- 2c8:	8b 75 08             	mov    0x8(%ebp),%esi
- 2cb:	8b 45 08             	mov    0x8(%ebp),%eax
- 2ce:	01 de                	add    %ebx,%esi
- 2d0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 2d2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 2d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 2d8:	5b                   	pop    %ebx
- 2d9:	5e                   	pop    %esi
- 2da:	5f                   	pop    %edi
- 2db:	5d                   	pop    %ebp
- 2dc:	c3                   	ret    
- 2dd:	8d 76 00             	lea    0x0(%esi),%esi
-
-000002e0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 2e0:	f3 0f 1e fb          	endbr32 
- 2e4:	55                   	push   %ebp
- 2e5:	89 e5                	mov    %esp,%ebp
- 2e7:	56                   	push   %esi
- 2e8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 2e9:	83 ec 08             	sub    $0x8,%esp
- 2ec:	6a 00                	push   $0x0
- 2ee:	ff 75 08             	pushl  0x8(%ebp)
- 2f1:	e8 ed 00 00 00       	call   3e3 <open>
-  if(fd < 0)
- 2f6:	83 c4 10             	add    $0x10,%esp
- 2f9:	85 c0                	test   %eax,%eax
- 2fb:	78 2b                	js     328 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 2fd:	83 ec 08             	sub    $0x8,%esp
- 300:	ff 75 0c             	pushl  0xc(%ebp)
- 303:	89 c3                	mov    %eax,%ebx
- 305:	50                   	push   %eax
- 306:	e8 f0 00 00 00       	call   3fb <fstat>
-  close(fd);
- 30b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 30e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 310:	e8 b6 00 00 00       	call   3cb <close>
-  return r;
- 315:	83 c4 10             	add    $0x10,%esp
-}
- 318:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 31b:	89 f0                	mov    %esi,%eax
- 31d:	5b                   	pop    %ebx
- 31e:	5e                   	pop    %esi
- 31f:	5d                   	pop    %ebp
- 320:	c3                   	ret    
- 321:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 328:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 32d:	eb e9                	jmp    318 <stat+0x38>
- 32f:	90                   	nop
-
-00000330 <atoi>:
-
-int
-atoi(const char *s)
-{
- 330:	f3 0f 1e fb          	endbr32 
- 334:	55                   	push   %ebp
- 335:	89 e5                	mov    %esp,%ebp
- 337:	53                   	push   %ebx
- 338:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 33b:	0f be 02             	movsbl (%edx),%eax
- 33e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 341:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 344:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 349:	77 1a                	ja     365 <atoi+0x35>
- 34b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 34f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 350:	83 c2 01             	add    $0x1,%edx
- 353:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 356:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 35a:	0f be 02             	movsbl (%edx),%eax
- 35d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 360:	80 fb 09             	cmp    $0x9,%bl
- 363:	76 eb                	jbe    350 <atoi+0x20>
-  return n;
-}
- 365:	89 c8                	mov    %ecx,%eax
- 367:	5b                   	pop    %ebx
- 368:	5d                   	pop    %ebp
- 369:	c3                   	ret    
- 36a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000370 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 370:	f3 0f 1e fb          	endbr32 
- 374:	55                   	push   %ebp
- 375:	89 e5                	mov    %esp,%ebp
- 377:	57                   	push   %edi
- 378:	8b 45 10             	mov    0x10(%ebp),%eax
- 37b:	8b 55 08             	mov    0x8(%ebp),%edx
- 37e:	56                   	push   %esi
- 37f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 382:	85 c0                	test   %eax,%eax
- 384:	7e 0f                	jle    395 <memmove+0x25>
- 386:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 388:	89 d7                	mov    %edx,%edi
- 38a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 390:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 391:	39 f8                	cmp    %edi,%eax
- 393:	75 fb                	jne    390 <memmove+0x20>
-  return vdst;
-}
- 395:	5e                   	pop    %esi
- 396:	89 d0                	mov    %edx,%eax
- 398:	5f                   	pop    %edi
- 399:	5d                   	pop    %ebp
- 39a:	c3                   	ret    
-
-0000039b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 39b:	b8 01 00 00 00       	mov    $0x1,%eax
- 3a0:	cd 40                	int    $0x40
- 3a2:	c3                   	ret    
-
-000003a3 <exit>:
-SYSCALL(exit)
- 3a3:	b8 02 00 00 00       	mov    $0x2,%eax
- 3a8:	cd 40                	int    $0x40
- 3aa:	c3                   	ret    
-
-000003ab <wait>:
-SYSCALL(wait)
- 3ab:	b8 03 00 00 00       	mov    $0x3,%eax
- 3b0:	cd 40                	int    $0x40
- 3b2:	c3                   	ret    
-
-000003b3 <pipe>:
-SYSCALL(pipe)
- 3b3:	b8 04 00 00 00       	mov    $0x4,%eax
- 3b8:	cd 40                	int    $0x40
- 3ba:	c3                   	ret    
-
-000003bb <read>:
-SYSCALL(read)
- 3bb:	b8 05 00 00 00       	mov    $0x5,%eax
- 3c0:	cd 40                	int    $0x40
- 3c2:	c3                   	ret    
-
-000003c3 <write>:
-SYSCALL(write)
- 3c3:	b8 10 00 00 00       	mov    $0x10,%eax
- 3c8:	cd 40                	int    $0x40
- 3ca:	c3                   	ret    
-
-000003cb <close>:
-SYSCALL(close)
- 3cb:	b8 15 00 00 00       	mov    $0x15,%eax
- 3d0:	cd 40                	int    $0x40
- 3d2:	c3                   	ret    
-
-000003d3 <kill>:
-SYSCALL(kill)
- 3d3:	b8 06 00 00 00       	mov    $0x6,%eax
- 3d8:	cd 40                	int    $0x40
- 3da:	c3                   	ret    
-
-000003db <exec>:
-SYSCALL(exec)
- 3db:	b8 07 00 00 00       	mov    $0x7,%eax
- 3e0:	cd 40                	int    $0x40
- 3e2:	c3                   	ret    
-
-000003e3 <open>:
-SYSCALL(open)
- 3e3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 3e8:	cd 40                	int    $0x40
- 3ea:	c3                   	ret    
-
-000003eb <mknod>:
-SYSCALL(mknod)
- 3eb:	b8 11 00 00 00       	mov    $0x11,%eax
- 3f0:	cd 40                	int    $0x40
- 3f2:	c3                   	ret    
-
-000003f3 <unlink>:
-SYSCALL(unlink)
- 3f3:	b8 12 00 00 00       	mov    $0x12,%eax
- 3f8:	cd 40                	int    $0x40
- 3fa:	c3                   	ret    
-
-000003fb <fstat>:
-SYSCALL(fstat)
- 3fb:	b8 08 00 00 00       	mov    $0x8,%eax
- 400:	cd 40                	int    $0x40
- 402:	c3                   	ret    
-
-00000403 <link>:
-SYSCALL(link)
- 403:	b8 13 00 00 00       	mov    $0x13,%eax
- 408:	cd 40                	int    $0x40
- 40a:	c3                   	ret    
-
-0000040b <mkdir>:
-SYSCALL(mkdir)
- 40b:	b8 14 00 00 00       	mov    $0x14,%eax
- 410:	cd 40                	int    $0x40
- 412:	c3                   	ret    
-
-00000413 <chdir>:
-SYSCALL(chdir)
- 413:	b8 09 00 00 00       	mov    $0x9,%eax
- 418:	cd 40                	int    $0x40
- 41a:	c3                   	ret    
-
-0000041b <dup>:
-SYSCALL(dup)
- 41b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 420:	cd 40                	int    $0x40
- 422:	c3                   	ret    
-
-00000423 <getpid>:
-SYSCALL(getpid)
- 423:	b8 0b 00 00 00       	mov    $0xb,%eax
- 428:	cd 40                	int    $0x40
- 42a:	c3                   	ret    
-
-0000042b <sbrk>:
-SYSCALL(sbrk)
- 42b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 430:	cd 40                	int    $0x40
- 432:	c3                   	ret    
-
-00000433 <sleep>:
-SYSCALL(sleep)
- 433:	b8 0d 00 00 00       	mov    $0xd,%eax
- 438:	cd 40                	int    $0x40
- 43a:	c3                   	ret    
-
-0000043b <uptime>:
-SYSCALL(uptime)
- 43b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 440:	cd 40                	int    $0x40
- 442:	c3                   	ret    
-
-00000443 <getParentID>:
-SYSCALL(getParentID)
- 443:	b8 16 00 00 00       	mov    $0x16,%eax
- 448:	cd 40                	int    $0x40
- 44a:	c3                   	ret    
-
-0000044b <getChildren>:
-SYSCALL(getChildren)
- 44b:	b8 17 00 00 00       	mov    $0x17,%eax
- 450:	cd 40                	int    $0x40
- 452:	c3                   	ret    
-
-00000453 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 453:	b8 18 00 00 00       	mov    $0x18,%eax
- 458:	cd 40                	int    $0x40
- 45a:	c3                   	ret    
-
-0000045b <setPriority>:
-SYSCALL(setPriority)
- 45b:	b8 19 00 00 00       	mov    $0x19,%eax
- 460:	cd 40                	int    $0x40
- 462:	c3                   	ret    
-
-00000463 <changePolicy>:
-SYSCALL(changePolicy)
- 463:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 468:	cd 40                	int    $0x40
- 46a:	c3                   	ret    
-
-0000046b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 46b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 470:	cd 40                	int    $0x40
- 472:	c3                   	ret    
-
-00000473 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 473:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 478:	cd 40                	int    $0x40
- 47a:	c3                   	ret    
-
-0000047b <getCBT>:
-SYSCALL(getCBT)
- 47b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 480:	cd 40                	int    $0x40
- 482:	c3                   	ret    
-
-00000483 <customWait>:
-SYSCALL(customWait)
- 483:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 488:	cd 40                	int    $0x40
- 48a:	c3                   	ret    
-
-0000048b <setQueue>:
-SYSCALL(setQueue)
- 48b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 490:	cd 40                	int    $0x40
- 492:	c3                   	ret    
-
-00000493 <getBurstTime>:
-SYSCALL(getBurstTime)
- 493:	b8 20 00 00 00       	mov    $0x20,%eax
- 498:	cd 40                	int    $0x40
- 49a:	c3                   	ret    
-
-0000049b <getCreationTime>:
- 49b:	b8 21 00 00 00       	mov    $0x21,%eax
- 4a0:	cd 40                	int    $0x40
- 4a2:	c3                   	ret    
- 4a3:	66 90                	xchg   %ax,%ax
- 4a5:	66 90                	xchg   %ax,%ax
- 4a7:	66 90                	xchg   %ax,%ax
- 4a9:	66 90                	xchg   %ax,%ax
- 4ab:	66 90                	xchg   %ax,%ax
- 4ad:	66 90                	xchg   %ax,%ax
- 4af:	90                   	nop
-
-000004b0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 4b0:	55                   	push   %ebp
- 4b1:	89 e5                	mov    %esp,%ebp
- 4b3:	57                   	push   %edi
- 4b4:	56                   	push   %esi
- 4b5:	53                   	push   %ebx
- 4b6:	83 ec 3c             	sub    $0x3c,%esp
- 4b9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 4bc:	89 d1                	mov    %edx,%ecx
-{
- 4be:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 4c1:	85 d2                	test   %edx,%edx
- 4c3:	0f 89 7f 00 00 00    	jns    548 <printint+0x98>
- 4c9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 4cd:	74 79                	je     548 <printint+0x98>
-    neg = 1;
- 4cf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 4d6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 4d8:	31 db                	xor    %ebx,%ebx
- 4da:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 4dd:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 4e0:	89 c8                	mov    %ecx,%eax
- 4e2:	31 d2                	xor    %edx,%edx
- 4e4:	89 cf                	mov    %ecx,%edi
- 4e6:	f7 75 c4             	divl   -0x3c(%ebp)
- 4e9:	0f b6 92 f4 08 00 00 	movzbl 0x8f4(%edx),%edx
- 4f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 4f3:	89 d8                	mov    %ebx,%eax
- 4f5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 4f8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 4fb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 4fe:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 501:	76 dd                	jbe    4e0 <printint+0x30>
-  if(neg)
- 503:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 506:	85 c9                	test   %ecx,%ecx
- 508:	74 0c                	je     516 <printint+0x66>
-    buf[i++] = '-';
- 50a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 50f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 511:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 516:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 519:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 51d:	eb 07                	jmp    526 <printint+0x76>
- 51f:	90                   	nop
- 520:	0f b6 13             	movzbl (%ebx),%edx
- 523:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 526:	83 ec 04             	sub    $0x4,%esp
- 529:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 52c:	6a 01                	push   $0x1
- 52e:	56                   	push   %esi
- 52f:	57                   	push   %edi
- 530:	e8 8e fe ff ff       	call   3c3 <write>
-  while(--i >= 0)
- 535:	83 c4 10             	add    $0x10,%esp
- 538:	39 de                	cmp    %ebx,%esi
- 53a:	75 e4                	jne    520 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 53c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 53f:	5b                   	pop    %ebx
- 540:	5e                   	pop    %esi
- 541:	5f                   	pop    %edi
- 542:	5d                   	pop    %ebp
- 543:	c3                   	ret    
- 544:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 548:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 54f:	eb 87                	jmp    4d8 <printint+0x28>
- 551:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 558:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 55f:	90                   	nop
-
-00000560 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 560:	f3 0f 1e fb          	endbr32 
- 564:	55                   	push   %ebp
- 565:	89 e5                	mov    %esp,%ebp
- 567:	57                   	push   %edi
- 568:	56                   	push   %esi
- 569:	53                   	push   %ebx
- 56a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 56d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 570:	0f b6 1e             	movzbl (%esi),%ebx
- 573:	84 db                	test   %bl,%bl
- 575:	0f 84 b4 00 00 00    	je     62f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 57b:	8d 45 10             	lea    0x10(%ebp),%eax
- 57e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 581:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 584:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 586:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 589:	eb 33                	jmp    5be <printf+0x5e>
- 58b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 58f:	90                   	nop
- 590:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 593:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 598:	83 f8 25             	cmp    $0x25,%eax
- 59b:	74 17                	je     5b4 <printf+0x54>
-  write(fd, &c, 1);
- 59d:	83 ec 04             	sub    $0x4,%esp
- 5a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 5a3:	6a 01                	push   $0x1
- 5a5:	57                   	push   %edi
- 5a6:	ff 75 08             	pushl  0x8(%ebp)
- 5a9:	e8 15 fe ff ff       	call   3c3 <write>
- 5ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 5b1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 5b4:	0f b6 1e             	movzbl (%esi),%ebx
- 5b7:	83 c6 01             	add    $0x1,%esi
- 5ba:	84 db                	test   %bl,%bl
- 5bc:	74 71                	je     62f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 5be:	0f be cb             	movsbl %bl,%ecx
- 5c1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 5c4:	85 d2                	test   %edx,%edx
- 5c6:	74 c8                	je     590 <printf+0x30>
-      }
-    } else if(state == '%'){
- 5c8:	83 fa 25             	cmp    $0x25,%edx
- 5cb:	75 e7                	jne    5b4 <printf+0x54>
-      if(c == 'd'){
- 5cd:	83 f8 64             	cmp    $0x64,%eax
- 5d0:	0f 84 9a 00 00 00    	je     670 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 5d6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 5dc:	83 f9 70             	cmp    $0x70,%ecx
- 5df:	74 5f                	je     640 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 5e1:	83 f8 73             	cmp    $0x73,%eax
- 5e4:	0f 84 d6 00 00 00    	je     6c0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 5ea:	83 f8 63             	cmp    $0x63,%eax
- 5ed:	0f 84 8d 00 00 00    	je     680 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 5f3:	83 f8 25             	cmp    $0x25,%eax
- 5f6:	0f 84 b4 00 00 00    	je     6b0 <printf+0x150>
-  write(fd, &c, 1);
- 5fc:	83 ec 04             	sub    $0x4,%esp
- 5ff:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 603:	6a 01                	push   $0x1
- 605:	57                   	push   %edi
- 606:	ff 75 08             	pushl  0x8(%ebp)
- 609:	e8 b5 fd ff ff       	call   3c3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 60e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 611:	83 c4 0c             	add    $0xc,%esp
- 614:	6a 01                	push   $0x1
- 616:	83 c6 01             	add    $0x1,%esi
- 619:	57                   	push   %edi
- 61a:	ff 75 08             	pushl  0x8(%ebp)
- 61d:	e8 a1 fd ff ff       	call   3c3 <write>
-  for(i = 0; fmt[i]; i++){
- 622:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 626:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 629:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 62b:	84 db                	test   %bl,%bl
- 62d:	75 8f                	jne    5be <printf+0x5e>
-    }
-  }
-}
- 62f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 632:	5b                   	pop    %ebx
- 633:	5e                   	pop    %esi
- 634:	5f                   	pop    %edi
- 635:	5d                   	pop    %ebp
- 636:	c3                   	ret    
- 637:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 63e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 640:	83 ec 0c             	sub    $0xc,%esp
- 643:	b9 10 00 00 00       	mov    $0x10,%ecx
- 648:	6a 00                	push   $0x0
- 64a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 64d:	8b 45 08             	mov    0x8(%ebp),%eax
- 650:	8b 13                	mov    (%ebx),%edx
- 652:	e8 59 fe ff ff       	call   4b0 <printint>
-        ap++;
- 657:	89 d8                	mov    %ebx,%eax
- 659:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 65c:	31 d2                	xor    %edx,%edx
-        ap++;
- 65e:	83 c0 04             	add    $0x4,%eax
- 661:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 664:	e9 4b ff ff ff       	jmp    5b4 <printf+0x54>
- 669:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 670:	83 ec 0c             	sub    $0xc,%esp
- 673:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 678:	6a 01                	push   $0x1
- 67a:	eb ce                	jmp    64a <printf+0xea>
- 67c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 680:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 683:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 686:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 688:	6a 01                	push   $0x1
-        ap++;
- 68a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 68d:	57                   	push   %edi
- 68e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 691:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 694:	e8 2a fd ff ff       	call   3c3 <write>
-        ap++;
- 699:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 69c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 69f:	31 d2                	xor    %edx,%edx
- 6a1:	e9 0e ff ff ff       	jmp    5b4 <printf+0x54>
- 6a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 6ad:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 6b0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 6b3:	83 ec 04             	sub    $0x4,%esp
- 6b6:	e9 59 ff ff ff       	jmp    614 <printf+0xb4>
- 6bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 6bf:	90                   	nop
-        s = (char*)*ap;
- 6c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 6c3:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 6c5:	83 c0 04             	add    $0x4,%eax
- 6c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 6cb:	85 db                	test   %ebx,%ebx
- 6cd:	74 17                	je     6e6 <printf+0x186>
-        while(*s != 0){
- 6cf:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 6d2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 6d4:	84 c0                	test   %al,%al
- 6d6:	0f 84 d8 fe ff ff    	je     5b4 <printf+0x54>
- 6dc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 6df:	89 de                	mov    %ebx,%esi
- 6e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 6e4:	eb 1a                	jmp    700 <printf+0x1a0>
-          s = "(null)";
- 6e6:	bb eb 08 00 00       	mov    $0x8eb,%ebx
-        while(*s != 0){
- 6eb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 6ee:	b8 28 00 00 00       	mov    $0x28,%eax
- 6f3:	89 de                	mov    %ebx,%esi
- 6f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 6f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 6ff:	90                   	nop
-  write(fd, &c, 1);
- 700:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 703:	83 c6 01             	add    $0x1,%esi
- 706:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 709:	6a 01                	push   $0x1
- 70b:	57                   	push   %edi
- 70c:	53                   	push   %ebx
- 70d:	e8 b1 fc ff ff       	call   3c3 <write>
-        while(*s != 0){
- 712:	0f b6 06             	movzbl (%esi),%eax
- 715:	83 c4 10             	add    $0x10,%esp
- 718:	84 c0                	test   %al,%al
- 71a:	75 e4                	jne    700 <printf+0x1a0>
- 71c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 71f:	31 d2                	xor    %edx,%edx
- 721:	e9 8e fe ff ff       	jmp    5b4 <printf+0x54>
- 726:	66 90                	xchg   %ax,%ax
- 728:	66 90                	xchg   %ax,%ax
- 72a:	66 90                	xchg   %ax,%ax
- 72c:	66 90                	xchg   %ax,%ax
- 72e:	66 90                	xchg   %ax,%ax
-
-00000730 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 730:	f3 0f 1e fb          	endbr32 
- 734:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 735:	a1 ac 0b 00 00       	mov    0xbac,%eax
-{
- 73a:	89 e5                	mov    %esp,%ebp
- 73c:	57                   	push   %edi
- 73d:	56                   	push   %esi
- 73e:	53                   	push   %ebx
- 73f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 742:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 744:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 747:	39 c8                	cmp    %ecx,%eax
- 749:	73 15                	jae    760 <free+0x30>
- 74b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 74f:	90                   	nop
- 750:	39 d1                	cmp    %edx,%ecx
- 752:	72 14                	jb     768 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 754:	39 d0                	cmp    %edx,%eax
- 756:	73 10                	jae    768 <free+0x38>
-{
- 758:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 75a:	8b 10                	mov    (%eax),%edx
- 75c:	39 c8                	cmp    %ecx,%eax
- 75e:	72 f0                	jb     750 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 760:	39 d0                	cmp    %edx,%eax
- 762:	72 f4                	jb     758 <free+0x28>
- 764:	39 d1                	cmp    %edx,%ecx
- 766:	73 f0                	jae    758 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 768:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 76b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 76e:	39 fa                	cmp    %edi,%edx
- 770:	74 1e                	je     790 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 772:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 775:	8b 50 04             	mov    0x4(%eax),%edx
- 778:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 77b:	39 f1                	cmp    %esi,%ecx
- 77d:	74 28                	je     7a7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 77f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 781:	5b                   	pop    %ebx
-  freep = p;
- 782:	a3 ac 0b 00 00       	mov    %eax,0xbac
-}
- 787:	5e                   	pop    %esi
- 788:	5f                   	pop    %edi
- 789:	5d                   	pop    %ebp
- 78a:	c3                   	ret    
- 78b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 78f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 790:	03 72 04             	add    0x4(%edx),%esi
- 793:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 796:	8b 10                	mov    (%eax),%edx
- 798:	8b 12                	mov    (%edx),%edx
- 79a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 79d:	8b 50 04             	mov    0x4(%eax),%edx
- 7a0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 7a3:	39 f1                	cmp    %esi,%ecx
- 7a5:	75 d8                	jne    77f <free+0x4f>
-    p->s.size += bp->s.size;
- 7a7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 7aa:	a3 ac 0b 00 00       	mov    %eax,0xbac
-    p->s.size += bp->s.size;
- 7af:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 7b2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 7b5:	89 10                	mov    %edx,(%eax)
-}
- 7b7:	5b                   	pop    %ebx
- 7b8:	5e                   	pop    %esi
- 7b9:	5f                   	pop    %edi
- 7ba:	5d                   	pop    %ebp
- 7bb:	c3                   	ret    
- 7bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000007c0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 7c0:	f3 0f 1e fb          	endbr32 
- 7c4:	55                   	push   %ebp
- 7c5:	89 e5                	mov    %esp,%ebp
- 7c7:	57                   	push   %edi
- 7c8:	56                   	push   %esi
- 7c9:	53                   	push   %ebx
- 7ca:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 7cd:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 7d0:	8b 3d ac 0b 00 00    	mov    0xbac,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 7d6:	8d 70 07             	lea    0x7(%eax),%esi
- 7d9:	c1 ee 03             	shr    $0x3,%esi
- 7dc:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 7df:	85 ff                	test   %edi,%edi
- 7e1:	0f 84 a9 00 00 00    	je     890 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 7e7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 7e9:	8b 48 04             	mov    0x4(%eax),%ecx
- 7ec:	39 f1                	cmp    %esi,%ecx
- 7ee:	73 6d                	jae    85d <malloc+0x9d>
- 7f0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 7f6:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 7fb:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 7fe:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 805:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 808:	eb 17                	jmp    821 <malloc+0x61>
- 80a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 810:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 812:	8b 4a 04             	mov    0x4(%edx),%ecx
- 815:	39 f1                	cmp    %esi,%ecx
- 817:	73 4f                	jae    868 <malloc+0xa8>
- 819:	8b 3d ac 0b 00 00    	mov    0xbac,%edi
- 81f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 821:	39 c7                	cmp    %eax,%edi
- 823:	75 eb                	jne    810 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 825:	83 ec 0c             	sub    $0xc,%esp
- 828:	ff 75 e4             	pushl  -0x1c(%ebp)
- 82b:	e8 fb fb ff ff       	call   42b <sbrk>
-  if(p == (char*)-1)
- 830:	83 c4 10             	add    $0x10,%esp
- 833:	83 f8 ff             	cmp    $0xffffffff,%eax
- 836:	74 1b                	je     853 <malloc+0x93>
-  hp->s.size = nu;
- 838:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 83b:	83 ec 0c             	sub    $0xc,%esp
- 83e:	83 c0 08             	add    $0x8,%eax
- 841:	50                   	push   %eax
- 842:	e8 e9 fe ff ff       	call   730 <free>
-  return freep;
- 847:	a1 ac 0b 00 00       	mov    0xbac,%eax
-      if((p = morecore(nunits)) == 0)
- 84c:	83 c4 10             	add    $0x10,%esp
- 84f:	85 c0                	test   %eax,%eax
- 851:	75 bd                	jne    810 <malloc+0x50>
-        return 0;
-  }
-}
- 853:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 856:	31 c0                	xor    %eax,%eax
-}
- 858:	5b                   	pop    %ebx
- 859:	5e                   	pop    %esi
- 85a:	5f                   	pop    %edi
- 85b:	5d                   	pop    %ebp
- 85c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 85d:	89 c2                	mov    %eax,%edx
- 85f:	89 f8                	mov    %edi,%eax
- 861:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 868:	39 ce                	cmp    %ecx,%esi
- 86a:	74 54                	je     8c0 <malloc+0x100>
-        p->s.size -= nunits;
- 86c:	29 f1                	sub    %esi,%ecx
- 86e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 871:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 874:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 877:	a3 ac 0b 00 00       	mov    %eax,0xbac
-}
- 87c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 87f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 882:	5b                   	pop    %ebx
- 883:	5e                   	pop    %esi
- 884:	5f                   	pop    %edi
- 885:	5d                   	pop    %ebp
- 886:	c3                   	ret    
- 887:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 88e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 890:	c7 05 ac 0b 00 00 b0 	movl   $0xbb0,0xbac
- 897:	0b 00 00 
-    base.s.size = 0;
- 89a:	bf b0 0b 00 00       	mov    $0xbb0,%edi
-    base.s.ptr = freep = prevp = &base;
- 89f:	c7 05 b0 0b 00 00 b0 	movl   $0xbb0,0xbb0
- 8a6:	0b 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 8a9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 8ab:	c7 05 b4 0b 00 00 00 	movl   $0x0,0xbb4
- 8b2:	00 00 00 
-    if(p->s.size >= nunits){
- 8b5:	e9 36 ff ff ff       	jmp    7f0 <malloc+0x30>
- 8ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 8c0:	8b 0a                	mov    (%edx),%ecx
- 8c2:	89 08                	mov    %ecx,(%eax)
- 8c4:	eb b1                	jmp    877 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/stressfs.c b/xv6-public/Operating-System-Project/stressfs.c
deleted file mode 100644
index c0a4743..0000000
--- a/xv6-public/Operating-System-Project/stressfs.c
+++ /dev/null
@@ -1,49 +0,0 @@
-// Demonstrate that moving the "acquire" in iderw after the loop that
-// appends to the idequeue results in a race.
-
-// For this to work, you should also add a spin within iderw's
-// idequeue traversal loop.  Adding the following demonstrated a panic
-// after about 5 runs of stressfs in QEMU on a 2.1GHz CPU:
-//    for (i = 0; i < 40000; i++)
-//      asm volatile("");
-
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-#include "fcntl.h"
-
-int
-main(int argc, char *argv[])
-{
-  int fd, i;
-  char path[] = "stressfs0";
-  char data[512];
-
-  printf(1, "stressfs starting\n");
-  memset(data, 'a', sizeof(data));
-
-  for(i = 0; i < 4; i++)
-    if(fork() > 0)
-      break;
-
-  printf(1, "write %d\n", i);
-
-  path[8] += i;
-  fd = open(path, O_CREATE | O_RDWR);
-  for(i = 0; i < 20; i++)
-//    printf(fd, "%d\n", i);
-    write(fd, data, sizeof(data));
-  close(fd);
-
-  printf(1, "read\n");
-
-  fd = open(path, O_RDONLY);
-  for (i = 0; i < 20; i++)
-    read(fd, data, sizeof(data));
-  close(fd);
-
-  wait();
-
-  exit();
-}
diff --git a/xv6-public/Operating-System-Project/stressfs.d b/xv6-public/Operating-System-Project/stressfs.d
deleted file mode 100644
index 7d5de54..0000000
--- a/xv6-public/Operating-System-Project/stressfs.d
+++ /dev/null
@@ -1,2 +0,0 @@
-stressfs.o: stressfs.c /usr/include/stdc-predef.h types.h stat.h user.h \
- fs.h fcntl.h
diff --git a/xv6-public/Operating-System-Project/stressfs.o b/xv6-public/Operating-System-Project/stressfs.o
deleted file mode 100644
index 14d1521..0000000
Binary files a/xv6-public/Operating-System-Project/stressfs.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/stressfs.sym b/xv6-public/Operating-System-Project/stressfs.sym
deleted file mode 100644
index 0f1c71c..0000000
--- a/xv6-public/Operating-System-Project/stressfs.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-000008c8 .rodata
-00000908 .eh_frame
-00000bac .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 stressfs.c
-00000000 ulib.c
-00000000 printf.c
-000004b0 printint
-000008f4 digits.1109
-00000000 umalloc.c
-00000bac freep
-00000bb0 base
-00000140 strcpy
-0000044b getChildren
-00000560 printf
-00000370 memmove
-000003eb mknod
-00000260 gets
-00000423 getpid
-00000483 customWait
-0000047b getCBT
-000007c0 malloc
-00000433 sleep
-000003b3 pipe
-00000463 changePolicy
-000003c3 write
-000003fb fstat
-000003d3 kill
-00000413 chdir
-0000048b setQueue
-000003db exec
-000003ab wait
-000003bb read
-00000493 getBurstTime
-000003f3 unlink
-0000039b fork
-0000046b getTurnAroundTime
-0000042b sbrk
-0000043b uptime
-00000bac __bss_start
-00000200 memset
-00000000 main
-00000170 strcmp
-0000041b dup
-00000453 getSyscallCounter
-00000443 getParentID
-000002e0 stat
-00000bac _edata
-00000bb8 _end
-00000403 link
-000003a3 exit
-0000045b setPriority
-00000330 atoi
-0000049b getCreationTime
-000001c0 strlen
-000003e3 open
-00000220 strchr
-0000040b mkdir
-000003cb close
-00000473 getWaitingTime
-00000730 free
diff --git a/xv6-public/Operating-System-Project/string.c b/xv6-public/Operating-System-Project/string.c
deleted file mode 100644
index a7cc61f..0000000
--- a/xv6-public/Operating-System-Project/string.c
+++ /dev/null
@@ -1,105 +0,0 @@
-#include "types.h"
-#include "x86.h"
-
-void*
-memset(void *dst, int c, uint n)
-{
-  if ((int)dst%4 == 0 && n%4 == 0){
-    c &= 0xFF;
-    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
-  } else
-    stosb(dst, c, n);
-  return dst;
-}
-
-int
-memcmp(const void *v1, const void *v2, uint n)
-{
-  const uchar *s1, *s2;
-
-  s1 = v1;
-  s2 = v2;
-  while(n-- > 0){
-    if(*s1 != *s2)
-      return *s1 - *s2;
-    s1++, s2++;
-  }
-
-  return 0;
-}
-
-void*
-memmove(void *dst, const void *src, uint n)
-{
-  const char *s;
-  char *d;
-
-  s = src;
-  d = dst;
-  if(s < d && s + n > d){
-    s += n;
-    d += n;
-    while(n-- > 0)
-      *--d = *--s;
-  } else
-    while(n-- > 0)
-      *d++ = *s++;
-
-  return dst;
-}
-
-// memcpy exists to placate GCC.  Use memmove.
-void*
-memcpy(void *dst, const void *src, uint n)
-{
-  return memmove(dst, src, n);
-}
-
-int
-strncmp(const char *p, const char *q, uint n)
-{
-  while(n > 0 && *p && *p == *q)
-    n--, p++, q++;
-  if(n == 0)
-    return 0;
-  return (uchar)*p - (uchar)*q;
-}
-
-char*
-strncpy(char *s, const char *t, int n)
-{
-  char *os;
-
-  os = s;
-  while(n-- > 0 && (*s++ = *t++) != 0)
-    ;
-  while(n-- > 0)
-    *s++ = 0;
-  return os;
-}
-
-// Like strncpy but guaranteed to NUL-terminate.
-char*
-safestrcpy(char *s, const char *t, int n)
-{
-  char *os;
-
-  os = s;
-  if(n <= 0)
-    return os;
-  while(--n > 0 && (*s++ = *t++) != 0)
-    ;
-  *s = 0;
-  return os;
-}
-
-int
-strlen(const char *s)
-{
-  int n;
-
-  for(n = 0; s[n]; n++)
-    ;
-  return n;
-}
-
diff --git a/xv6-public/Operating-System-Project/string.d b/xv6-public/Operating-System-Project/string.d
deleted file mode 100644
index 68931ed..0000000
--- a/xv6-public/Operating-System-Project/string.d
+++ /dev/null
@@ -1 +0,0 @@
-string.o: string.c /usr/include/stdc-predef.h types.h x86.h
diff --git a/xv6-public/Operating-System-Project/string.o b/xv6-public/Operating-System-Project/string.o
deleted file mode 100644
index be918a1..0000000
Binary files a/xv6-public/Operating-System-Project/string.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/swtch.S b/xv6-public/Operating-System-Project/swtch.S
deleted file mode 100644
index 63a7dcc..0000000
--- a/xv6-public/Operating-System-Project/swtch.S
+++ /dev/null
@@ -1,29 +0,0 @@
-# Context switch
-#
-#   void swtch(struct context **old, struct context *new);
-# 
-# Save the current registers on the stack, creating
-# a struct context, and save its address in *old.
-# Switch stacks to new and pop previously-saved registers.
-
-.globl swtch
-swtch:
-  movl 4(%esp), %eax
-  movl 8(%esp), %edx
-
-  # Save old callee-saved registers
-  pushl %ebp
-  pushl %ebx
-  pushl %esi
-  pushl %edi
-
-  # Switch stacks
-  movl %esp, (%eax)
-  movl %edx, %esp
-
-  # Load new callee-saved registers
-  popl %edi
-  popl %esi
-  popl %ebx
-  popl %ebp
-  ret
diff --git a/xv6-public/Operating-System-Project/swtch.o b/xv6-public/Operating-System-Project/swtch.o
deleted file mode 100644
index 0fe409d..0000000
Binary files a/xv6-public/Operating-System-Project/swtch.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/syscall.c b/xv6-public/Operating-System-Project/syscall.c
deleted file mode 100644
index 40ab069..0000000
--- a/xv6-public/Operating-System-Project/syscall.c
+++ /dev/null
@@ -1,168 +0,0 @@
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-#include "syscall.h"
-
-// User code makes a system call with INT T_SYSCALL.
-// System call number in %eax.
-// Arguments on the stack, from the user call to the C
-// library system call function. The saved user %esp points
-// to a saved program counter, and then the first argument.
-
-// Fetch the int at addr from the current process.
-int fetchint(uint addr, int *ip)
-{
-  struct proc *curproc = myproc();
-
-  if (addr >= curproc->sz || addr + 4 > curproc->sz)
-    return -1;
-  *ip = *(int *)(addr);
-  return 0;
-}
-
-// Fetch the nul-terminated string at addr from the current process.
-// Doesn't actually copy the string - just sets *pp to point at it.
-// Returns length of string, not including nul.
-int fetchstr(uint addr, char **pp)
-{
-  char *s, *ep;
-  struct proc *curproc = myproc();
-
-  if (addr >= curproc->sz)
-    return -1;
-  *pp = (char *)addr;
-  ep = (char *)curproc->sz;
-  for (s = *pp; s < ep; s++)
-  {
-    if (*s == 0)
-      return s - *pp;
-  }
-  return -1;
-}
-
-// Fetch the nth 32-bit system call argument.
-int argint(int n, int *ip)
-{
-  return fetchint((myproc()->tf->esp) + 4 + 4 * n, ip);
-}
-
-// Fetch the nth word-sized system call argument as a pointer
-// to a block of memory of size bytes.  Check that the pointer
-// lies within the process address space.
-int argptr(int n, char **pp, int size)
-{
-  int i;
-  struct proc *curproc = myproc();
-
-  if (argint(n, &i) < 0)
-    return -1;
-  if (size < 0 || (uint)i >= curproc->sz || (uint)i + size > curproc->sz)
-    return -1;
-  *pp = (char *)i;
-  return 0;
-}
-
-// Fetch the nth word-sized system call argument as a string pointer.
-// Check that the pointer is valid and the string is nul-terminated.
-// (There is no shared writable memory, so the string can't change
-// between this check and being used by the kernel.)
-int argstr(int n, char **pp)
-{
-  int addr;
-  if (argint(n, &addr) < 0)
-    return -1;
-  return fetchstr(addr, pp);
-}
-
-extern int sys_chdir(void);
-extern int sys_close(void);
-extern int sys_dup(void);
-extern int sys_exec(void);
-extern int sys_exit(void);
-extern int sys_fork(void);
-extern int sys_fstat(void);
-extern int sys_getpid(void);
-extern int sys_kill(void);
-extern int sys_link(void);
-extern int sys_mkdir(void);
-extern int sys_mknod(void);
-extern int sys_open(void);
-extern int sys_pipe(void);
-extern int sys_read(void);
-extern int sys_sbrk(void);
-extern int sys_sleep(void);
-extern int sys_unlink(void);
-extern int sys_wait(void);
-extern int sys_write(void);
-extern int sys_uptime(void);
-extern int sys_getParentID(void);
-extern int sys_getChildren(void);
-extern int sys_getSyscallCounter(void);
-extern int sys_setPriority(void);
-extern int sys_changePolicy(void);
-extern int sys_getTurnAroundTime(void);
-extern int sys_getBurstTime(void);
-extern int sys_getCreationTime(void);
-extern int sys_getWaitingTime(void);
-extern int sys_getCBT(void);
-extern int sys_customWait(void);
-extern int sys_setQueue(void);
-
-static int (*syscalls[])(void) = {
-    [SYS_fork] sys_fork,
-    [SYS_exit] sys_exit,
-    [SYS_wait] sys_wait,
-    [SYS_pipe] sys_pipe,
-    [SYS_read] sys_read,
-    [SYS_kill] sys_kill,
-    [SYS_exec] sys_exec,
-    [SYS_fstat] sys_fstat,
-    [SYS_chdir] sys_chdir,
-    [SYS_dup] sys_dup,
-    [SYS_getpid] sys_getpid,
-    [SYS_sbrk] sys_sbrk,
-    [SYS_sleep] sys_sleep,
-    [SYS_uptime] sys_uptime,
-    [SYS_open] sys_open,
-    [SYS_write] sys_write,
-    [SYS_mknod] sys_mknod,
-    [SYS_unlink] sys_unlink,
-    [SYS_link] sys_link,
-    [SYS_mkdir] sys_mkdir,
-    [SYS_close] sys_close,
-    [SYS_getParentID] sys_getParentID,
-    [SYS_getChildren] sys_getChildren,
-    [SYS_getSyscallCounter] sys_getSyscallCounter,
-    [SYS_setPriority] sys_setPriority,
-    [SYS_changePolicy] sys_changePolicy,
-    [SYS_getTurnAroundTime] sys_getTurnAroundTime,
-    [SYS_getWaitingTime] sys_getWaitingTime,
-    [SYS_getCBT] sys_getCBT,
-    [SYS_customWait] sys_customWait,
-    [SYS_setQueue] sys_setQueue,
-    [SYS_getBurstTime] sys_getBurstTime,
-
-};
-
-void syscall(void)
-{
-  int num;
-  struct proc *curproc = myproc();
-
-  num = curproc->tf->eax;
-  if (num > 0 && num < NELEM(syscalls) && syscalls[num])
-  {
-    curproc->syscallsCount[num - 1]++;
-    curproc->tf->eax = syscalls[num]();
-  }
-  else
-  {
-    cprintf("%d %s: unknown sys call %d\n",
-            curproc->pid, curproc->name, num);
-    curproc->tf->eax = -1;
-  }
-}
diff --git a/xv6-public/Operating-System-Project/syscall.d b/xv6-public/Operating-System-Project/syscall.d
deleted file mode 100644
index 4649283..0000000
--- a/xv6-public/Operating-System-Project/syscall.d
+++ /dev/null
@@ -1,2 +0,0 @@
-syscall.o: syscall.c /usr/include/stdc-predef.h types.h defs.h param.h \
- memlayout.h mmu.h proc.h x86.h syscall.h
diff --git a/xv6-public/Operating-System-Project/syscall.h b/xv6-public/Operating-System-Project/syscall.h
deleted file mode 100644
index bd04af0..0000000
--- a/xv6-public/Operating-System-Project/syscall.h
+++ /dev/null
@@ -1,34 +0,0 @@
-// System call numbers
-#define SYS_fork 1
-#define SYS_exit 2
-#define SYS_wait 3
-#define SYS_pipe 4
-#define SYS_read 5
-#define SYS_kill 6
-#define SYS_exec 7
-#define SYS_fstat 8
-#define SYS_chdir 9
-#define SYS_dup 10
-#define SYS_getpid 11
-#define SYS_sbrk 12
-#define SYS_sleep 13
-#define SYS_uptime 14
-#define SYS_open 15
-#define SYS_write 16
-#define SYS_mknod 17
-#define SYS_unlink 18
-#define SYS_link 19
-#define SYS_mkdir 20
-#define SYS_close 21
-#define SYS_getParentID 22
-#define SYS_getChildren 23
-#define SYS_getSyscallCounter 24
-#define SYS_setPriority 25
-#define SYS_changePolicy 26
-#define SYS_getTurnAroundTime 27
-#define SYS_getWaitingTime 28
-#define SYS_getCBT 29
-#define SYS_customWait 30
-#define SYS_setQueue 31
-#define SYS_getBurstTime 32
-#define SYS_getCreationTime 33
diff --git a/xv6-public/Operating-System-Project/syscall.o b/xv6-public/Operating-System-Project/syscall.o
deleted file mode 100644
index 647a02b..0000000
Binary files a/xv6-public/Operating-System-Project/syscall.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/sysfile.c b/xv6-public/Operating-System-Project/sysfile.c
deleted file mode 100644
index bfe61b7..0000000
--- a/xv6-public/Operating-System-Project/sysfile.c
+++ /dev/null
@@ -1,444 +0,0 @@
-//
-// File-system system calls.
-// Mostly argument checking, since we don't trust
-// user code, and calls into file.c and fs.c.
-//
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "stat.h"
-#include "mmu.h"
-#include "proc.h"
-#include "fs.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "file.h"
-#include "fcntl.h"
-
-// Fetch the nth word-sized system call argument as a file descriptor
-// and return both the descriptor and the corresponding struct file.
-static int
-argfd(int n, int *pfd, struct file **pf)
-{
-  int fd;
-  struct file *f;
-
-  if(argint(n, &fd) < 0)
-    return -1;
-  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
-    return -1;
-  if(pfd)
-    *pfd = fd;
-  if(pf)
-    *pf = f;
-  return 0;
-}
-
-// Allocate a file descriptor for the given file.
-// Takes over file reference from caller on success.
-static int
-fdalloc(struct file *f)
-{
-  int fd;
-  struct proc *curproc = myproc();
-
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd] == 0){
-      curproc->ofile[fd] = f;
-      return fd;
-    }
-  }
-  return -1;
-}
-
-int
-sys_dup(void)
-{
-  struct file *f;
-  int fd;
-
-  if(argfd(0, 0, &f) < 0)
-    return -1;
-  if((fd=fdalloc(f)) < 0)
-    return -1;
-  filedup(f);
-  return fd;
-}
-
-int
-sys_read(void)
-{
-  struct file *f;
-  int n;
-  char *p;
-
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
-    return -1;
-  return fileread(f, p, n);
-}
-
-int
-sys_write(void)
-{
-  struct file *f;
-  int n;
-  char *p;
-
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
-    return -1;
-  return filewrite(f, p, n);
-}
-
-int
-sys_close(void)
-{
-  int fd;
-  struct file *f;
-
-  if(argfd(0, &fd, &f) < 0)
-    return -1;
-  myproc()->ofile[fd] = 0;
-  fileclose(f);
-  return 0;
-}
-
-int
-sys_fstat(void)
-{
-  struct file *f;
-  struct stat *st;
-
-  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
-    return -1;
-  return filestat(f, st);
-}
-
-// Create the path new as a link to the same inode as old.
-int
-sys_link(void)
-{
-  char name[DIRSIZ], *new, *old;
-  struct inode *dp, *ip;
-
-  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
-    return -1;
-
-  begin_op();
-  if((ip = namei(old)) == 0){
-    end_op();
-    return -1;
-  }
-
-  ilock(ip);
-  if(ip->type == T_DIR){
-    iunlockput(ip);
-    end_op();
-    return -1;
-  }
-
-  ip->nlink++;
-  iupdate(ip);
-  iunlock(ip);
-
-  if((dp = nameiparent(new, name)) == 0)
-    goto bad;
-  ilock(dp);
-  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
-    iunlockput(dp);
-    goto bad;
-  }
-  iunlockput(dp);
-  iput(ip);
-
-  end_op();
-
-  return 0;
-
-bad:
-  ilock(ip);
-  ip->nlink--;
-  iupdate(ip);
-  iunlockput(ip);
-  end_op();
-  return -1;
-}
-
-// Is the directory dp empty except for "." and ".." ?
-static int
-isdirempty(struct inode *dp)
-{
-  int off;
-  struct dirent de;
-
-  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-      panic("isdirempty: readi");
-    if(de.inum != 0)
-      return 0;
-  }
-  return 1;
-}
-
-//PAGEBREAK!
-int
-sys_unlink(void)
-{
-  struct inode *ip, *dp;
-  struct dirent de;
-  char name[DIRSIZ], *path;
-  uint off;
-
-  if(argstr(0, &path) < 0)
-    return -1;
-
-  begin_op();
-  if((dp = nameiparent(path, name)) == 0){
-    end_op();
-    return -1;
-  }
-
-  ilock(dp);
-
-  // Cannot unlink "." or "..".
-  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
-    goto bad;
-
-  if((ip = dirlookup(dp, name, &off)) == 0)
-    goto bad;
-  ilock(ip);
-
-  if(ip->nlink < 1)
-    panic("unlink: nlink < 1");
-  if(ip->type == T_DIR && !isdirempty(ip)){
-    iunlockput(ip);
-    goto bad;
-  }
-
-  memset(&de, 0, sizeof(de));
-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-    panic("unlink: writei");
-  if(ip->type == T_DIR){
-    dp->nlink--;
-    iupdate(dp);
-  }
-  iunlockput(dp);
-
-  ip->nlink--;
-  iupdate(ip);
-  iunlockput(ip);
-
-  end_op();
-
-  return 0;
-
-bad:
-  iunlockput(dp);
-  end_op();
-  return -1;
-}
-
-static struct inode*
-create(char *path, short type, short major, short minor)
-{
-  struct inode *ip, *dp;
-  char name[DIRSIZ];
-
-  if((dp = nameiparent(path, name)) == 0)
-    return 0;
-  ilock(dp);
-
-  if((ip = dirlookup(dp, name, 0)) != 0){
-    iunlockput(dp);
-    ilock(ip);
-    if(type == T_FILE && ip->type == T_FILE)
-      return ip;
-    iunlockput(ip);
-    return 0;
-  }
-
-  if((ip = ialloc(dp->dev, type)) == 0)
-    panic("create: ialloc");
-
-  ilock(ip);
-  ip->major = major;
-  ip->minor = minor;
-  ip->nlink = 1;
-  iupdate(ip);
-
-  if(type == T_DIR){  // Create . and .. entries.
-    dp->nlink++;  // for ".."
-    iupdate(dp);
-    // No ip->nlink++ for ".": avoid cyclic ref count.
-    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
-      panic("create dots");
-  }
-
-  if(dirlink(dp, name, ip->inum) < 0)
-    panic("create: dirlink");
-
-  iunlockput(dp);
-
-  return ip;
-}
-
-int
-sys_open(void)
-{
-  char *path;
-  int fd, omode;
-  struct file *f;
-  struct inode *ip;
-
-  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
-    return -1;
-
-  begin_op();
-
-  if(omode & O_CREATE){
-    ip = create(path, T_FILE, 0, 0);
-    if(ip == 0){
-      end_op();
-      return -1;
-    }
-  } else {
-    if((ip = namei(path)) == 0){
-      end_op();
-      return -1;
-    }
-    ilock(ip);
-    if(ip->type == T_DIR && omode != O_RDONLY){
-      iunlockput(ip);
-      end_op();
-      return -1;
-    }
-  }
-
-  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
-    if(f)
-      fileclose(f);
-    iunlockput(ip);
-    end_op();
-    return -1;
-  }
-  iunlock(ip);
-  end_op();
-
-  f->type = FD_INODE;
-  f->ip = ip;
-  f->off = 0;
-  f->readable = !(omode & O_WRONLY);
-  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
-  return fd;
-}
-
-int
-sys_mkdir(void)
-{
-  char *path;
-  struct inode *ip;
-
-  begin_op();
-  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
-    end_op();
-    return -1;
-  }
-  iunlockput(ip);
-  end_op();
-  return 0;
-}
-
-int
-sys_mknod(void)
-{
-  struct inode *ip;
-  char *path;
-  int major, minor;
-
-  begin_op();
-  if((argstr(0, &path)) < 0 ||
-     argint(1, &major) < 0 ||
-     argint(2, &minor) < 0 ||
-     (ip = create(path, T_DEV, major, minor)) == 0){
-    end_op();
-    return -1;
-  }
-  iunlockput(ip);
-  end_op();
-  return 0;
-}
-
-int
-sys_chdir(void)
-{
-  char *path;
-  struct inode *ip;
-  struct proc *curproc = myproc();
-  
-  begin_op();
-  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
-    end_op();
-    return -1;
-  }
-  ilock(ip);
-  if(ip->type != T_DIR){
-    iunlockput(ip);
-    end_op();
-    return -1;
-  }
-  iunlock(ip);
-  iput(curproc->cwd);
-  end_op();
-  curproc->cwd = ip;
-  return 0;
-}
-
-int
-sys_exec(void)
-{
-  char *path, *argv[MAXARG];
-  int i;
-  uint uargv, uarg;
-
-  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
-    return -1;
-  }
-  memset(argv, 0, sizeof(argv));
-  for(i=0;; i++){
-    if(i >= NELEM(argv))
-      return -1;
-    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
-      return -1;
-    if(uarg == 0){
-      argv[i] = 0;
-      break;
-    }
-    if(fetchstr(uarg, &argv[i]) < 0)
-      return -1;
-  }
-  return exec(path, argv);
-}
-
-int
-sys_pipe(void)
-{
-  int *fd;
-  struct file *rf, *wf;
-  int fd0, fd1;
-
-  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
-    return -1;
-  if(pipealloc(&rf, &wf) < 0)
-    return -1;
-  fd0 = -1;
-  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
-    if(fd0 >= 0)
-      myproc()->ofile[fd0] = 0;
-    fileclose(rf);
-    fileclose(wf);
-    return -1;
-  }
-  fd[0] = fd0;
-  fd[1] = fd1;
-  return 0;
-}
diff --git a/xv6-public/Operating-System-Project/sysfile.d b/xv6-public/Operating-System-Project/sysfile.d
deleted file mode 100644
index 74f1a20..0000000
--- a/xv6-public/Operating-System-Project/sysfile.d
+++ /dev/null
@@ -1,2 +0,0 @@
-sysfile.o: sysfile.c /usr/include/stdc-predef.h types.h defs.h param.h \
- stat.h mmu.h proc.h fs.h spinlock.h sleeplock.h file.h fcntl.h
diff --git a/xv6-public/Operating-System-Project/sysfile.o b/xv6-public/Operating-System-Project/sysfile.o
deleted file mode 100644
index 2ec4e59..0000000
Binary files a/xv6-public/Operating-System-Project/sysfile.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/sysproc.c b/xv6-public/Operating-System-Project/sysproc.c
deleted file mode 100644
index dfcb8db..0000000
--- a/xv6-public/Operating-System-Project/sysproc.c
+++ /dev/null
@@ -1,201 +0,0 @@
-#include "types.h"
-#include "x86.h"
-#include "defs.h"
-#include "date.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-
-int sys_fork(void)
-{
-  return fork();
-}
-
-int sys_exit(void)
-{
-  exit();
-  return 0; // not reached
-}
-
-int sys_wait(void)
-{
-  return wait();
-}
-
-int sys_kill(void)
-{
-  int pid;
-
-  if (argint(0, &pid) < 0)
-    return -1;
-  return kill(pid);
-}
-
-int sys_getpid(void)
-{
-  return myproc()->pid;
-}
-
-int sys_sbrk(void)
-{
-  int addr;
-  int n;
-
-  if (argint(0, &n) < 0)
-    return -1;
-  addr = myproc()->sz;
-  if (growproc(n) < 0)
-    return -1;
-  return addr;
-}
-
-int sys_sleep(void)
-{
-  int n;
-  uint ticks0;
-
-  if (argint(0, &n) < 0)
-    return -1;
-  acquire(&tickslock);
-  ticks0 = ticks;
-  while (ticks - ticks0 < n)
-  {
-    if (myproc()->killed)
-    {
-      release(&tickslock);
-      return -1;
-    }
-    sleep(&ticks, &tickslock);
-  }
-  release(&tickslock);
-  return 0;
-}
-
-// return how many clock tick interrupts have occurred
-// since start.
-int sys_uptime(void)
-{
-  uint xticks;
-
-  acquire(&tickslock);
-  xticks = ticks;
-  release(&tickslock);
-  return xticks;
-}
-
-int sys_getParentID(void)
-{
-  return getParentID();
-}
-
-int sys_getChildren(void)
-{
-  int *children_pid;
-  if (argptr(0, (void *)&children_pid, sizeof(*children_pid)) < 0)
-  {
-    return -1;
-  }
-  else
-  {
-    return getChildren(children_pid);
-  }
-}
-
-int sys_getSyscallCounter(void)
-{
-  int syscall_num;
-  if (argint(0, &syscall_num) < 0)
-  {
-    return -1;
-  }
-  else
-  {
-    return getSyscallCounter(syscall_num);
-  }
-}
-
-int sys_setPriority(void)
-{
-  int newPriority;
-  if (argint(0, &newPriority) < 0)
-    return -1;
-  else
-    return setPriority(newPriority);
-}
-
-int sys_changePolicy(void)
-{
-  int newPolicy;
-  if (argint(0, &newPolicy) < 0)
-    return -1;
-  else
-    return changePolicy(newPolicy);
-}
-int sys_getCreationTime(void)
-{
-  int pid;
-  if (argint(0, &pid) < 0)
-    return -1;
-  else
-    return getCreationTime(pid);
-}
-
-int sys_getTurnAroundTime(void)
-{
-  int pid;
-  if (argint(0, &pid) < 0)
-    return -1;
-  else
-    return getTurnAroundTime(pid);
-}
-int sys_getBurstTime(void)
-{
-  int pid;
-  if (argint(0, &pid) < 0)
-    return -1;
-  else
-  return getBurstTime(pid);
-}
-int sys_getWaitingTime(void)
-{
-  int pid;
-  if (argint(0, &pid) < 0)
-    return -1;
-  else
-    return getWaitingTime(pid);
-}
-
-int sys_getCBT(void)
-{
-  int pid;
-  if (argint(0, &pid) < 0)
-    return -1;
-  else
-    return getCBT(pid);
-}
-
-int sys_customWait(void)
-{
-  int *procTimes;
-  if (argptr(0, (void *)&procTimes, sizeof(*procTimes)) < 0)
-  {
-    return -1;
-  }
-  else
-  {
-    return customWait(procTimes);
-  }
-}
-
-int sys_setQueue(void)
-{
-  int queueNumber;
-  if (argint(0, &queueNumber) < 0)
-  {    
-    return -1;
-  }
-  else
-    return setQueue(queueNumber);
-
-}
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/sysproc.d b/xv6-public/Operating-System-Project/sysproc.d
deleted file mode 100644
index 34b0083..0000000
--- a/xv6-public/Operating-System-Project/sysproc.d
+++ /dev/null
@@ -1,2 +0,0 @@
-sysproc.o: sysproc.c /usr/include/stdc-predef.h types.h x86.h defs.h \
- param.h date.h memlayout.h mmu.h proc.h
diff --git a/xv6-public/Operating-System-Project/sysproc.o b/xv6-public/Operating-System-Project/sysproc.o
deleted file mode 100644
index b9f1cc6..0000000
Binary files a/xv6-public/Operating-System-Project/sysproc.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/toc.ftr b/xv6-public/Operating-System-Project/toc.ftr
deleted file mode 100644
index 0061c1d..0000000
--- a/xv6-public/Operating-System-Project/toc.ftr
+++ /dev/null
@@ -1,13 +0,0 @@
-
-
-The source listing is preceded by a cross-reference that lists every defined 
-constant, struct, global variable, and function in xv6.  Each entry gives,
-on the same line as the name, the line number (or, in a few cases, numbers)
-where the name is defined.  Successive lines in an entry list the line
-numbers where the name is used.  For example, this entry:
-
-    swtch 2658
-        0374 2428 2466 2657 2658
-
-indicates that swtch is defined on line 2658 and is mentioned on five lines
-on sheets 03, 24, and 26.
diff --git a/xv6-public/Operating-System-Project/toc.hdr b/xv6-public/Operating-System-Project/toc.hdr
deleted file mode 100644
index 3698d81..0000000
--- a/xv6-public/Operating-System-Project/toc.hdr
+++ /dev/null
@@ -1,6 +0,0 @@
-The numbers to the left of the file names in the table are sheet numbers.
-The source code has been printed in a double column format with fifty
-lines per column, giving one hundred lines per sheet (or page).
-Thus there is a convenient relationship between line numbers and sheet numbers.
-
-
diff --git a/xv6-public/Operating-System-Project/trap.c b/xv6-public/Operating-System-Project/trap.c
deleted file mode 100644
index e7c59d2..0000000
--- a/xv6-public/Operating-System-Project/trap.c
+++ /dev/null
@@ -1,173 +0,0 @@
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-#include "traps.h"
-#include "spinlock.h"
-
-// Interrupt descriptor table (shared by all CPUs).
-struct gatedesc idt[256];
-extern uint vectors[]; // in vectors.S: array of 256 entry pointers
-struct spinlock tickslock;
-uint ticks;
-
-void tvinit(void)
-{
-  int i;
-
-  for (i = 0; i < 256; i++)
-    SETGATE(idt[i], 0, SEG_KCODE << 3, vectors[i], 0);
-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE << 3, vectors[T_SYSCALL], DPL_USER);
-
-  initlock(&tickslock, "time");
-}
-
-void idtinit(void)
-{
-  lidt(idt, sizeof(idt));
-}
-
-//PAGEBREAK: 41
-void trap(struct trapframe *tf)
-{
-  if (tf->trapno == T_SYSCALL)
-  {
-    if (myproc()->killed)
-      exit();
-    myproc()->tf = tf;
-    syscall();
-    if (myproc()->killed)
-      exit();
-    return;
-  }
-
-  switch (tf->trapno)
-  {
-  case T_IRQ0 + IRQ_TIMER:
-    if (cpuid() == 0)
-    {
-      acquire(&tickslock);
-      ticks++;
-      wakeup(&ticks);
-      release(&tickslock);
-    }
-    lapiceoi();
-    break;
-  case T_IRQ0 + IRQ_IDE:
-    ideintr();
-    lapiceoi();
-    break;
-  case T_IRQ0 + IRQ_IDE + 1:
-    // Bochs generates spurious IDE1 interrupts.
-    break;
-  case T_IRQ0 + IRQ_KBD:
-    kbdintr();
-    lapiceoi();
-    break;
-  case T_IRQ0 + IRQ_COM1:
-    uartintr();
-    lapiceoi();
-    break;
-  case T_IRQ0 + 7:
-  case T_IRQ0 + IRQ_SPURIOUS:
-    cprintf("cpu%d: spurious interrupt at %x:%x\n",
-            cpuid(), tf->cs, tf->eip);
-    lapiceoi();
-    break;
-
-  //PAGEBREAK: 13
-  default:
-    if (myproc() == 0 || (tf->cs & 3) == 0)
-    {
-      // In kernel, it must be our mistake.
-      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
-              tf->trapno, cpuid(), tf->eip, rcr2());
-      panic("trap");
-    }
-    // In user space, assume process misbehaved.
-    cprintf("pid %d %s: trap %d err %d on cpu %d "
-            "eip 0x%x addr 0x%x--kill proc\n",
-            myproc()->pid, myproc()->name, tf->trapno,
-            tf->err, cpuid(), tf->eip, rcr2());
-    myproc()->killed = 1;
-  }
-
-  // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running
-  // until it gets to the regular system call return.)
-  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
-    exit();
-
-  // Force process to give up CPU on clock tick.
-  // If interrupts were on while locks held, would need to check nlock.
-  // On each tick, check the remaining time left for current process,
-  // if zero, yield.
-  if (myproc() && myproc()->state == RUNNING &&
-      tf->trapno == T_IRQ0 + IRQ_TIMER)
-  {
-    switch (policy)
-    {
-    case DEFAULT:
-      yield();
-      break;
-
-    case ROUND_ROBIN:
-      if (myproc()->rr_remaining_t == 0)
-      {
-        // Reset remainin time back to quantum
-        myproc()->rr_remaining_t = QUANTUM;
-        yield();
-      }
-      else
-      {
-        myproc()->rr_remaining_t--;
-      }
-      break;
-
-    case PRIORITY:
-    case INVERSE_PRIORITY:
-      yield();
-      break;
-
-    case MULTILAYRED_PRIORITY:
-      switch (myproc()->queue)
-      {
-      case 1: // default
-      case 2: // priority scheduling
-      case 3: // reverse priority scheduling
-        yield();
-        break;
-
-      case 4: // round robin scheduling
-        if (myproc()->rr_remaining_t == 0)
-        {
-          // Reset remainin time back to quantum
-          myproc()->rr_remaining_t = QUANTUM;
-          yield();
-        }
-        else
-        {
-          myproc()->rr_remaining_t--;
-        }
-        break;
-      default:
-        yield();
-        break;
-      }
-      break;
-    }
-  }
-
-  // Update each process sleeping, runnable, running time
-  if (tf->trapno == T_IRQ0 + IRQ_TIMER)
-  {
-    updateStateDurations();
-  }
-
-  // Check if the process has been killed since we yielded
-  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
-    exit();
-}
diff --git a/xv6-public/Operating-System-Project/trap.d b/xv6-public/Operating-System-Project/trap.d
deleted file mode 100644
index c48ab89..0000000
--- a/xv6-public/Operating-System-Project/trap.d
+++ /dev/null
@@ -1,2 +0,0 @@
-trap.o: trap.c /usr/include/stdc-predef.h types.h defs.h param.h \
- memlayout.h mmu.h proc.h x86.h traps.h spinlock.h
diff --git a/xv6-public/Operating-System-Project/trap.o b/xv6-public/Operating-System-Project/trap.o
deleted file mode 100644
index 71d74cd..0000000
Binary files a/xv6-public/Operating-System-Project/trap.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/trapasm.S b/xv6-public/Operating-System-Project/trapasm.S
deleted file mode 100644
index da8aefc..0000000
--- a/xv6-public/Operating-System-Project/trapasm.S
+++ /dev/null
@@ -1,32 +0,0 @@
-#include "mmu.h"
-
-  # vectors.S sends all traps here.
-.globl alltraps
-alltraps:
-  # Build trap frame.
-  pushl %ds
-  pushl %es
-  pushl %fs
-  pushl %gs
-  pushal
-  
-  # Set up data segments.
-  movw $(SEG_KDATA<<3), %ax
-  movw %ax, %ds
-  movw %ax, %es
-
-  # Call trap(tf), where tf=%esp
-  pushl %esp
-  call trap
-  addl $4, %esp
-
-  # Return falls through to trapret...
-.globl trapret
-trapret:
-  popal
-  popl %gs
-  popl %fs
-  popl %es
-  popl %ds
-  addl $0x8, %esp  # trapno and errcode
-  iret
diff --git a/xv6-public/Operating-System-Project/trapasm.o b/xv6-public/Operating-System-Project/trapasm.o
deleted file mode 100644
index 4ad1e5a..0000000
Binary files a/xv6-public/Operating-System-Project/trapasm.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/traps.h b/xv6-public/Operating-System-Project/traps.h
deleted file mode 100644
index 0bd1fd8..0000000
--- a/xv6-public/Operating-System-Project/traps.h
+++ /dev/null
@@ -1,38 +0,0 @@
-// x86 trap and interrupt constants.
-
-// Processor-defined:
-#define T_DIVIDE         0      // divide error
-#define T_DEBUG          1      // debug exception
-#define T_NMI            2      // non-maskable interrupt
-#define T_BRKPT          3      // breakpoint
-#define T_OFLOW          4      // overflow
-#define T_BOUND          5      // bounds check
-#define T_ILLOP          6      // illegal opcode
-#define T_DEVICE         7      // device not available
-#define T_DBLFLT         8      // double fault
-// #define T_COPROC      9      // reserved (not used since 486)
-#define T_TSS           10      // invalid task switch segment
-#define T_SEGNP         11      // segment not present
-#define T_STACK         12      // stack exception
-#define T_GPFLT         13      // general protection fault
-#define T_PGFLT         14      // page fault
-// #define T_RES        15      // reserved
-#define T_FPERR         16      // floating point error
-#define T_ALIGN         17      // aligment check
-#define T_MCHK          18      // machine check
-#define T_SIMDERR       19      // SIMD floating point error
-
-// These are arbitrarily chosen, but with care not to overlap
-// processor defined exceptions or interrupt vectors.
-#define T_SYSCALL       64      // system call
-#define T_DEFAULT      500      // catchall
-
-#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ
-
-#define IRQ_TIMER        0
-#define IRQ_KBD          1
-#define IRQ_COM1         4
-#define IRQ_IDE         14
-#define IRQ_ERROR       19
-#define IRQ_SPURIOUS    31
-
diff --git a/xv6-public/Operating-System-Project/types.h b/xv6-public/Operating-System-Project/types.h
deleted file mode 100644
index 73ca1f9..0000000
--- a/xv6-public/Operating-System-Project/types.h
+++ /dev/null
@@ -1,4 +0,0 @@
-typedef unsigned int uint;
-typedef unsigned short ushort;
-typedef unsigned char uchar;
-typedef uint pde_t;
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/uart.c b/xv6-public/Operating-System-Project/uart.c
deleted file mode 100644
index b8946da..0000000
--- a/xv6-public/Operating-System-Project/uart.c
+++ /dev/null
@@ -1,77 +0,0 @@
-// Intel 8250 serial port (UART).
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "traps.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "file.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-
-#define COM1    0x3f8
-
-static int uart;    // is there a uart?
-
-void
-uartinit(void)
-{
-  char *p;
-
-  // Turn off the FIFO
-  outb(COM1+2, 0);
-
-  // 9600 baud, 8 data bits, 1 stop bit, parity off.
-  outb(COM1+3, 0x80);    // Unlock divisor
-  outb(COM1+0, 115200/9600);
-  outb(COM1+1, 0);
-  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
-  outb(COM1+4, 0);
-  outb(COM1+1, 0x01);    // Enable receive interrupts.
-
-  // If status is 0xFF, no serial port.
-  if(inb(COM1+5) == 0xFF)
-    return;
-  uart = 1;
-
-  // Acknowledge pre-existing interrupt conditions;
-  // enable interrupts.
-  inb(COM1+2);
-  inb(COM1+0);
-  ioapicenable(IRQ_COM1, 0);
-
-  // Announce that we're here.
-  for(p="xv6...\n"; *p; p++)
-    uartputc(*p);
-}
-
-void
-uartputc(int c)
-{
-  int i;
-
-  if(!uart)
-    return;
-  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
-    microdelay(10);
-  outb(COM1+0, c);
-}
-
-static int
-uartgetc(void)
-{
-  if(!uart)
-    return -1;
-  if(!(inb(COM1+5) & 0x01))
-    return -1;
-  return inb(COM1+0);
-}
-
-void
-uartintr(void)
-{
-  consoleintr(uartgetc);
-}
diff --git a/xv6-public/Operating-System-Project/uart.d b/xv6-public/Operating-System-Project/uart.d
deleted file mode 100644
index d156629..0000000
--- a/xv6-public/Operating-System-Project/uart.d
+++ /dev/null
@@ -1,2 +0,0 @@
-uart.o: uart.c /usr/include/stdc-predef.h types.h defs.h param.h traps.h \
- spinlock.h sleeplock.h fs.h file.h mmu.h proc.h x86.h
diff --git a/xv6-public/Operating-System-Project/uart.o b/xv6-public/Operating-System-Project/uart.o
deleted file mode 100644
index 9ddc387..0000000
Binary files a/xv6-public/Operating-System-Project/uart.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/ulib.c b/xv6-public/Operating-System-Project/ulib.c
deleted file mode 100644
index 8e1e1a2..0000000
--- a/xv6-public/Operating-System-Project/ulib.c
+++ /dev/null
@@ -1,106 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "fcntl.h"
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-    ;
-  return os;
-}
-
-int
-strcmp(const char *p, const char *q)
-{
-  while(*p && *p == *q)
-    p++, q++;
-  return (uchar)*p - (uchar)*q;
-}
-
-uint
-strlen(const char *s)
-{
-  int n;
-
-  for(n = 0; s[n]; n++)
-    ;
-  return n;
-}
-
-void*
-memset(void *dst, int c, uint n)
-{
-  stosb(dst, c, n);
-  return dst;
-}
-
-char*
-strchr(const char *s, char c)
-{
-  for(; *s; s++)
-    if(*s == c)
-      return (char*)s;
-  return 0;
-}
-
-char*
-gets(char *buf, int max)
-{
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
-    cc = read(0, &c, 1);
-    if(cc < 1)
-      break;
-    buf[i++] = c;
-    if(c == '\n' || c == '\r')
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
-
-int
-stat(const char *n, struct stat *st)
-{
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
-  if(fd < 0)
-    return -1;
-  r = fstat(fd, st);
-  close(fd);
-  return r;
-}
-
-int
-atoi(const char *s)
-{
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
-    n = n*10 + *s++ - '0';
-  return n;
-}
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
-    *dst++ = *src++;
-  return vdst;
-}
diff --git a/xv6-public/Operating-System-Project/ulib.d b/xv6-public/Operating-System-Project/ulib.d
deleted file mode 100644
index 61f575e..0000000
--- a/xv6-public/Operating-System-Project/ulib.d
+++ /dev/null
@@ -1,2 +0,0 @@
-ulib.o: ulib.c /usr/include/stdc-predef.h types.h stat.h fcntl.h user.h \
- x86.h
diff --git a/xv6-public/Operating-System-Project/ulib.o b/xv6-public/Operating-System-Project/ulib.o
deleted file mode 100644
index 0a7c943..0000000
Binary files a/xv6-public/Operating-System-Project/ulib.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/umalloc.c b/xv6-public/Operating-System-Project/umalloc.c
deleted file mode 100644
index a7e7d2c..0000000
--- a/xv6-public/Operating-System-Project/umalloc.c
+++ /dev/null
@@ -1,90 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "param.h"
-
-// Memory allocator by Kernighan and Ritchie,
-// The C programming Language, 2nd ed.  Section 8.7.
-
-typedef long Align;
-
-union header {
-  struct {
-    union header *ptr;
-    uint size;
-  } s;
-  Align x;
-};
-
-typedef union header Header;
-
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
-      break;
-  if(bp + bp->s.size == p->s.ptr){
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
-  if(p + p->s.size == bp){
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
-  freep = p;
-}
-
-static Header*
-morecore(uint nu)
-{
-  char *p;
-  Header *hp;
-
-  if(nu < 4096)
-    nu = 4096;
-  p = sbrk(nu * sizeof(Header));
-  if(p == (char*)-1)
-    return 0;
-  hp = (Header*)p;
-  hp->s.size = nu;
-  free((void*)(hp + 1));
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
-  if((prevp = freep) == 0){
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
-    if(p->s.size >= nunits){
-      if(p->s.size == nunits)
-        prevp->s.ptr = p->s.ptr;
-      else {
-        p->s.size -= nunits;
-        p += p->s.size;
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
-      if((p = morecore(nunits)) == 0)
-        return 0;
-  }
-}
diff --git a/xv6-public/Operating-System-Project/umalloc.d b/xv6-public/Operating-System-Project/umalloc.d
deleted file mode 100644
index cc1d152..0000000
--- a/xv6-public/Operating-System-Project/umalloc.d
+++ /dev/null
@@ -1,2 +0,0 @@
-umalloc.o: umalloc.c /usr/include/stdc-predef.h types.h stat.h user.h \
- param.h
diff --git a/xv6-public/Operating-System-Project/umalloc.o b/xv6-public/Operating-System-Project/umalloc.o
deleted file mode 100644
index 4a76b50..0000000
Binary files a/xv6-public/Operating-System-Project/umalloc.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/user.h b/xv6-public/Operating-System-Project/user.h
deleted file mode 100644
index 602693a..0000000
--- a/xv6-public/Operating-System-Project/user.h
+++ /dev/null
@@ -1,53 +0,0 @@
-struct stat;
-struct rtcdate;
-
-// system calls
-int fork(void);
-int exit(void) __attribute__((noreturn));
-int wait(void);
-int pipe(int *);
-int write(int, const void *, int);
-int read(int, void *, int);
-int close(int);
-int kill(int);
-int exec(char *, char **);
-int open(const char *, int);
-int mknod(const char *, short, short);
-int unlink(const char *);
-int fstat(int fd, struct stat *);
-int link(const char *, const char *);
-int mkdir(const char *);
-int chdir(const char *);
-int dup(int);
-int getpid(void);
-char *sbrk(int);
-int sleep(int);
-int uptime(void);
-int getParentID(void);
-int getChildren(int *children_pid);
-int getSyscallCounter(int syscall_num);
-int setPriority(int newPriority);
-int changePolicy(int newPolicy);
-int getTurnAroundTime(int pid);
-int getBurstTime(int pid);
-int getCreationTime(int pid);
-
-int getWaitingTime(int pid);
-int getCBT(int pid);
-int customWait(int *procTimes);
-int setQueue(int queueNumber);
-
-
-// ulib.c
-int stat(const char *, struct stat *);
-char *strcpy(char *, const char *);
-void *memmove(void *, const void *, int);
-char *strchr(const char *, char c);
-int strcmp(const char *, const char *);
-void printf(int, const char *, ...);
-char *gets(char *, int max);
-uint strlen(const char *);
-void *memset(void *, int, uint);
-void *malloc(uint);
-void free(void *);
-int atoi(const char *);
diff --git a/xv6-public/Operating-System-Project/usertests.asm b/xv6-public/Operating-System-Project/usertests.asm
deleted file mode 100644
index 06680c1..0000000
--- a/xv6-public/Operating-System-Project/usertests.asm
+++ /dev/null
@@ -1,6759 +0,0 @@
-
-_usertests:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-  return randstate;
-}
-
-int
-main(int argc, char *argv[])
-{
-       0:	f3 0f 1e fb          	endbr32 
-       4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-       8:	83 e4 f0             	and    $0xfffffff0,%esp
-       b:	ff 71 fc             	pushl  -0x4(%ecx)
-       e:	55                   	push   %ebp
-       f:	89 e5                	mov    %esp,%ebp
-      11:	51                   	push   %ecx
-      12:	83 ec 0c             	sub    $0xc,%esp
-  printf(1, "usertests starting\n");
-      15:	68 96 4e 00 00       	push   $0x4e96
-      1a:	6a 01                	push   $0x1
-      1c:	e8 1f 3b 00 00       	call   3b40 <printf>
-
-  if(open("usertests.ran", 0) >= 0){
-      21:	59                   	pop    %ecx
-      22:	58                   	pop    %eax
-      23:	6a 00                	push   $0x0
-      25:	68 aa 4e 00 00       	push   $0x4eaa
-      2a:	e8 94 39 00 00       	call   39c3 <open>
-      2f:	83 c4 10             	add    $0x10,%esp
-      32:	85 c0                	test   %eax,%eax
-      34:	78 13                	js     49 <main+0x49>
-    printf(1, "already ran user tests -- rebuild fs.img\n");
-      36:	52                   	push   %edx
-      37:	52                   	push   %edx
-      38:	68 14 56 00 00       	push   $0x5614
-      3d:	6a 01                	push   $0x1
-      3f:	e8 fc 3a 00 00       	call   3b40 <printf>
-    exit();
-      44:	e8 3a 39 00 00       	call   3983 <exit>
-  }
-  close(open("usertests.ran", O_CREATE));
-      49:	50                   	push   %eax
-      4a:	50                   	push   %eax
-      4b:	68 00 02 00 00       	push   $0x200
-      50:	68 aa 4e 00 00       	push   $0x4eaa
-      55:	e8 69 39 00 00       	call   39c3 <open>
-      5a:	89 04 24             	mov    %eax,(%esp)
-      5d:	e8 49 39 00 00       	call   39ab <close>
-
-  argptest();
-      62:	e8 29 36 00 00       	call   3690 <argptest>
-  createdelete();
-      67:	e8 04 12 00 00       	call   1270 <createdelete>
-  linkunlink();
-      6c:	e8 df 1a 00 00       	call   1b50 <linkunlink>
-  concreate();
-      71:	e8 da 17 00 00       	call   1850 <concreate>
-  fourfiles();
-      76:	e8 f5 0f 00 00       	call   1070 <fourfiles>
-  sharedfd();
-      7b:	e8 30 0e 00 00       	call   eb0 <sharedfd>
-
-  bigargtest();
-      80:	e8 ab 32 00 00       	call   3330 <bigargtest>
-  bigwrite();
-      85:	e8 06 24 00 00       	call   2490 <bigwrite>
-  bigargtest();
-      8a:	e8 a1 32 00 00       	call   3330 <bigargtest>
-  bsstest();
-      8f:	e8 2c 32 00 00       	call   32c0 <bsstest>
-  sbrktest();
-      94:	e8 37 2d 00 00       	call   2dd0 <sbrktest>
-  validatetest();
-      99:	e8 62 31 00 00       	call   3200 <validatetest>
-
-  opentest();
-      9e:	e8 6d 03 00 00       	call   410 <opentest>
-  writetest();
-      a3:	e8 08 04 00 00       	call   4b0 <writetest>
-  writetest1();
-      a8:	e8 e3 05 00 00       	call   690 <writetest1>
-  createtest();
-      ad:	e8 ae 07 00 00       	call   860 <createtest>
-
-  openiputtest();
-      b2:	e8 59 02 00 00       	call   310 <openiputtest>
-  exitiputtest();
-      b7:	e8 54 01 00 00       	call   210 <exitiputtest>
-  iputtest();
-      bc:	e8 5f 00 00 00       	call   120 <iputtest>
-
-  mem();
-      c1:	e8 1a 0d 00 00       	call   de0 <mem>
-  pipe1();
-      c6:	e8 95 09 00 00       	call   a60 <pipe1>
-  preempt();
-      cb:	e8 30 0b 00 00       	call   c00 <preempt>
-  exitwait();
-      d0:	e8 8b 0c 00 00       	call   d60 <exitwait>
-
-  rmdot();
-      d5:	e8 a6 27 00 00       	call   2880 <rmdot>
-  fourteen();
-      da:	e8 61 26 00 00       	call   2740 <fourteen>
-  bigfile();
-      df:	e8 8c 24 00 00       	call   2570 <bigfile>
-  subdir();
-      e4:	e8 b7 1c 00 00       	call   1da0 <subdir>
-  linktest();
-      e9:	e8 42 15 00 00       	call   1630 <linktest>
-  unlinkread();
-      ee:	e8 ad 13 00 00       	call   14a0 <unlinkread>
-  dirfile();
-      f3:	e8 08 29 00 00       	call   2a00 <dirfile>
-  iref();
-      f8:	e8 03 2b 00 00       	call   2c00 <iref>
-  forktest();
-      fd:	e8 1e 2c 00 00       	call   2d20 <forktest>
-  bigdir(); // slow
-     102:	e8 59 1b 00 00       	call   1c60 <bigdir>
-
-  uio();
-     107:	e8 04 35 00 00       	call   3610 <uio>
-
-  exectest();
-     10c:	e8 ff 08 00 00       	call   a10 <exectest>
-
-  exit();
-     111:	e8 6d 38 00 00       	call   3983 <exit>
-     116:	66 90                	xchg   %ax,%ax
-     118:	66 90                	xchg   %ax,%ax
-     11a:	66 90                	xchg   %ax,%ax
-     11c:	66 90                	xchg   %ax,%ax
-     11e:	66 90                	xchg   %ax,%ax
-
-00000120 <iputtest>:
-{
-     120:	f3 0f 1e fb          	endbr32 
-     124:	55                   	push   %ebp
-     125:	89 e5                	mov    %esp,%ebp
-     127:	83 ec 10             	sub    $0x10,%esp
-  printf(stdout, "iput test\n");
-     12a:	68 3c 3f 00 00       	push   $0x3f3c
-     12f:	ff 35 40 5f 00 00    	pushl  0x5f40
-     135:	e8 06 3a 00 00       	call   3b40 <printf>
-  if(mkdir("iputdir") < 0){
-     13a:	c7 04 24 cf 3e 00 00 	movl   $0x3ecf,(%esp)
-     141:	e8 a5 38 00 00       	call   39eb <mkdir>
-     146:	83 c4 10             	add    $0x10,%esp
-     149:	85 c0                	test   %eax,%eax
-     14b:	78 58                	js     1a5 <iputtest+0x85>
-  if(chdir("iputdir") < 0){
-     14d:	83 ec 0c             	sub    $0xc,%esp
-     150:	68 cf 3e 00 00       	push   $0x3ecf
-     155:	e8 99 38 00 00       	call   39f3 <chdir>
-     15a:	83 c4 10             	add    $0x10,%esp
-     15d:	85 c0                	test   %eax,%eax
-     15f:	0f 88 85 00 00 00    	js     1ea <iputtest+0xca>
-  if(unlink("../iputdir") < 0){
-     165:	83 ec 0c             	sub    $0xc,%esp
-     168:	68 cc 3e 00 00       	push   $0x3ecc
-     16d:	e8 61 38 00 00       	call   39d3 <unlink>
-     172:	83 c4 10             	add    $0x10,%esp
-     175:	85 c0                	test   %eax,%eax
-     177:	78 5a                	js     1d3 <iputtest+0xb3>
-  if(chdir("/") < 0){
-     179:	83 ec 0c             	sub    $0xc,%esp
-     17c:	68 f1 3e 00 00       	push   $0x3ef1
-     181:	e8 6d 38 00 00       	call   39f3 <chdir>
-     186:	83 c4 10             	add    $0x10,%esp
-     189:	85 c0                	test   %eax,%eax
-     18b:	78 2f                	js     1bc <iputtest+0x9c>
-  printf(stdout, "iput test ok\n");
-     18d:	83 ec 08             	sub    $0x8,%esp
-     190:	68 74 3f 00 00       	push   $0x3f74
-     195:	ff 35 40 5f 00 00    	pushl  0x5f40
-     19b:	e8 a0 39 00 00       	call   3b40 <printf>
-}
-     1a0:	83 c4 10             	add    $0x10,%esp
-     1a3:	c9                   	leave  
-     1a4:	c3                   	ret    
-    printf(stdout, "mkdir failed\n");
-     1a5:	50                   	push   %eax
-     1a6:	50                   	push   %eax
-     1a7:	68 a8 3e 00 00       	push   $0x3ea8
-     1ac:	ff 35 40 5f 00 00    	pushl  0x5f40
-     1b2:	e8 89 39 00 00       	call   3b40 <printf>
-    exit();
-     1b7:	e8 c7 37 00 00       	call   3983 <exit>
-    printf(stdout, "chdir / failed\n");
-     1bc:	50                   	push   %eax
-     1bd:	50                   	push   %eax
-     1be:	68 f3 3e 00 00       	push   $0x3ef3
-     1c3:	ff 35 40 5f 00 00    	pushl  0x5f40
-     1c9:	e8 72 39 00 00       	call   3b40 <printf>
-    exit();
-     1ce:	e8 b0 37 00 00       	call   3983 <exit>
-    printf(stdout, "unlink ../iputdir failed\n");
-     1d3:	52                   	push   %edx
-     1d4:	52                   	push   %edx
-     1d5:	68 d7 3e 00 00       	push   $0x3ed7
-     1da:	ff 35 40 5f 00 00    	pushl  0x5f40
-     1e0:	e8 5b 39 00 00       	call   3b40 <printf>
-    exit();
-     1e5:	e8 99 37 00 00       	call   3983 <exit>
-    printf(stdout, "chdir iputdir failed\n");
-     1ea:	51                   	push   %ecx
-     1eb:	51                   	push   %ecx
-     1ec:	68 b6 3e 00 00       	push   $0x3eb6
-     1f1:	ff 35 40 5f 00 00    	pushl  0x5f40
-     1f7:	e8 44 39 00 00       	call   3b40 <printf>
-    exit();
-     1fc:	e8 82 37 00 00       	call   3983 <exit>
-     201:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     208:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     20f:	90                   	nop
-
-00000210 <exitiputtest>:
-{
-     210:	f3 0f 1e fb          	endbr32 
-     214:	55                   	push   %ebp
-     215:	89 e5                	mov    %esp,%ebp
-     217:	83 ec 10             	sub    $0x10,%esp
-  printf(stdout, "exitiput test\n");
-     21a:	68 03 3f 00 00       	push   $0x3f03
-     21f:	ff 35 40 5f 00 00    	pushl  0x5f40
-     225:	e8 16 39 00 00       	call   3b40 <printf>
-  pid = fork();
-     22a:	e8 4c 37 00 00       	call   397b <fork>
-  if(pid < 0){
-     22f:	83 c4 10             	add    $0x10,%esp
-     232:	85 c0                	test   %eax,%eax
-     234:	0f 88 86 00 00 00    	js     2c0 <exitiputtest+0xb0>
-  if(pid == 0){
-     23a:	75 4c                	jne    288 <exitiputtest+0x78>
-    if(mkdir("iputdir") < 0){
-     23c:	83 ec 0c             	sub    $0xc,%esp
-     23f:	68 cf 3e 00 00       	push   $0x3ecf
-     244:	e8 a2 37 00 00       	call   39eb <mkdir>
-     249:	83 c4 10             	add    $0x10,%esp
-     24c:	85 c0                	test   %eax,%eax
-     24e:	0f 88 83 00 00 00    	js     2d7 <exitiputtest+0xc7>
-    if(chdir("iputdir") < 0){
-     254:	83 ec 0c             	sub    $0xc,%esp
-     257:	68 cf 3e 00 00       	push   $0x3ecf
-     25c:	e8 92 37 00 00       	call   39f3 <chdir>
-     261:	83 c4 10             	add    $0x10,%esp
-     264:	85 c0                	test   %eax,%eax
-     266:	0f 88 82 00 00 00    	js     2ee <exitiputtest+0xde>
-    if(unlink("../iputdir") < 0){
-     26c:	83 ec 0c             	sub    $0xc,%esp
-     26f:	68 cc 3e 00 00       	push   $0x3ecc
-     274:	e8 5a 37 00 00       	call   39d3 <unlink>
-     279:	83 c4 10             	add    $0x10,%esp
-     27c:	85 c0                	test   %eax,%eax
-     27e:	78 28                	js     2a8 <exitiputtest+0x98>
-    exit();
-     280:	e8 fe 36 00 00       	call   3983 <exit>
-     285:	8d 76 00             	lea    0x0(%esi),%esi
-  wait();
-     288:	e8 fe 36 00 00       	call   398b <wait>
-  printf(stdout, "exitiput test ok\n");
-     28d:	83 ec 08             	sub    $0x8,%esp
-     290:	68 26 3f 00 00       	push   $0x3f26
-     295:	ff 35 40 5f 00 00    	pushl  0x5f40
-     29b:	e8 a0 38 00 00       	call   3b40 <printf>
-}
-     2a0:	83 c4 10             	add    $0x10,%esp
-     2a3:	c9                   	leave  
-     2a4:	c3                   	ret    
-     2a5:	8d 76 00             	lea    0x0(%esi),%esi
-      printf(stdout, "unlink ../iputdir failed\n");
-     2a8:	83 ec 08             	sub    $0x8,%esp
-     2ab:	68 d7 3e 00 00       	push   $0x3ed7
-     2b0:	ff 35 40 5f 00 00    	pushl  0x5f40
-     2b6:	e8 85 38 00 00       	call   3b40 <printf>
-      exit();
-     2bb:	e8 c3 36 00 00       	call   3983 <exit>
-    printf(stdout, "fork failed\n");
-     2c0:	51                   	push   %ecx
-     2c1:	51                   	push   %ecx
-     2c2:	68 e9 4d 00 00       	push   $0x4de9
-     2c7:	ff 35 40 5f 00 00    	pushl  0x5f40
-     2cd:	e8 6e 38 00 00       	call   3b40 <printf>
-    exit();
-     2d2:	e8 ac 36 00 00       	call   3983 <exit>
-      printf(stdout, "mkdir failed\n");
-     2d7:	52                   	push   %edx
-     2d8:	52                   	push   %edx
-     2d9:	68 a8 3e 00 00       	push   $0x3ea8
-     2de:	ff 35 40 5f 00 00    	pushl  0x5f40
-     2e4:	e8 57 38 00 00       	call   3b40 <printf>
-      exit();
-     2e9:	e8 95 36 00 00       	call   3983 <exit>
-      printf(stdout, "child chdir failed\n");
-     2ee:	50                   	push   %eax
-     2ef:	50                   	push   %eax
-     2f0:	68 12 3f 00 00       	push   $0x3f12
-     2f5:	ff 35 40 5f 00 00    	pushl  0x5f40
-     2fb:	e8 40 38 00 00       	call   3b40 <printf>
-      exit();
-     300:	e8 7e 36 00 00       	call   3983 <exit>
-     305:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     30c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000310 <openiputtest>:
-{
-     310:	f3 0f 1e fb          	endbr32 
-     314:	55                   	push   %ebp
-     315:	89 e5                	mov    %esp,%ebp
-     317:	83 ec 10             	sub    $0x10,%esp
-  printf(stdout, "openiput test\n");
-     31a:	68 38 3f 00 00       	push   $0x3f38
-     31f:	ff 35 40 5f 00 00    	pushl  0x5f40
-     325:	e8 16 38 00 00       	call   3b40 <printf>
-  if(mkdir("oidir") < 0){
-     32a:	c7 04 24 47 3f 00 00 	movl   $0x3f47,(%esp)
-     331:	e8 b5 36 00 00       	call   39eb <mkdir>
-     336:	83 c4 10             	add    $0x10,%esp
-     339:	85 c0                	test   %eax,%eax
-     33b:	0f 88 9b 00 00 00    	js     3dc <openiputtest+0xcc>
-  pid = fork();
-     341:	e8 35 36 00 00       	call   397b <fork>
-  if(pid < 0){
-     346:	85 c0                	test   %eax,%eax
-     348:	78 7b                	js     3c5 <openiputtest+0xb5>
-  if(pid == 0){
-     34a:	75 34                	jne    380 <openiputtest+0x70>
-    int fd = open("oidir", O_RDWR);
-     34c:	83 ec 08             	sub    $0x8,%esp
-     34f:	6a 02                	push   $0x2
-     351:	68 47 3f 00 00       	push   $0x3f47
-     356:	e8 68 36 00 00       	call   39c3 <open>
-    if(fd >= 0){
-     35b:	83 c4 10             	add    $0x10,%esp
-     35e:	85 c0                	test   %eax,%eax
-     360:	78 5e                	js     3c0 <openiputtest+0xb0>
-      printf(stdout, "open directory for write succeeded\n");
-     362:	83 ec 08             	sub    $0x8,%esp
-     365:	68 cc 4e 00 00       	push   $0x4ecc
-     36a:	ff 35 40 5f 00 00    	pushl  0x5f40
-     370:	e8 cb 37 00 00       	call   3b40 <printf>
-      exit();
-     375:	e8 09 36 00 00       	call   3983 <exit>
-     37a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  sleep(1);
-     380:	83 ec 0c             	sub    $0xc,%esp
-     383:	6a 01                	push   $0x1
-     385:	e8 89 36 00 00       	call   3a13 <sleep>
-  if(unlink("oidir") != 0){
-     38a:	c7 04 24 47 3f 00 00 	movl   $0x3f47,(%esp)
-     391:	e8 3d 36 00 00       	call   39d3 <unlink>
-     396:	83 c4 10             	add    $0x10,%esp
-     399:	85 c0                	test   %eax,%eax
-     39b:	75 56                	jne    3f3 <openiputtest+0xe3>
-  wait();
-     39d:	e8 e9 35 00 00       	call   398b <wait>
-  printf(stdout, "openiput test ok\n");
-     3a2:	83 ec 08             	sub    $0x8,%esp
-     3a5:	68 70 3f 00 00       	push   $0x3f70
-     3aa:	ff 35 40 5f 00 00    	pushl  0x5f40
-     3b0:	e8 8b 37 00 00       	call   3b40 <printf>
-     3b5:	83 c4 10             	add    $0x10,%esp
-}
-     3b8:	c9                   	leave  
-     3b9:	c3                   	ret    
-     3ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    exit();
-     3c0:	e8 be 35 00 00       	call   3983 <exit>
-    printf(stdout, "fork failed\n");
-     3c5:	52                   	push   %edx
-     3c6:	52                   	push   %edx
-     3c7:	68 e9 4d 00 00       	push   $0x4de9
-     3cc:	ff 35 40 5f 00 00    	pushl  0x5f40
-     3d2:	e8 69 37 00 00       	call   3b40 <printf>
-    exit();
-     3d7:	e8 a7 35 00 00       	call   3983 <exit>
-    printf(stdout, "mkdir oidir failed\n");
-     3dc:	51                   	push   %ecx
-     3dd:	51                   	push   %ecx
-     3de:	68 4d 3f 00 00       	push   $0x3f4d
-     3e3:	ff 35 40 5f 00 00    	pushl  0x5f40
-     3e9:	e8 52 37 00 00       	call   3b40 <printf>
-    exit();
-     3ee:	e8 90 35 00 00       	call   3983 <exit>
-    printf(stdout, "unlink failed\n");
-     3f3:	50                   	push   %eax
-     3f4:	50                   	push   %eax
-     3f5:	68 61 3f 00 00       	push   $0x3f61
-     3fa:	ff 35 40 5f 00 00    	pushl  0x5f40
-     400:	e8 3b 37 00 00       	call   3b40 <printf>
-    exit();
-     405:	e8 79 35 00 00       	call   3983 <exit>
-     40a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000410 <opentest>:
-{
-     410:	f3 0f 1e fb          	endbr32 
-     414:	55                   	push   %ebp
-     415:	89 e5                	mov    %esp,%ebp
-     417:	83 ec 10             	sub    $0x10,%esp
-  printf(stdout, "open test\n");
-     41a:	68 82 3f 00 00       	push   $0x3f82
-     41f:	ff 35 40 5f 00 00    	pushl  0x5f40
-     425:	e8 16 37 00 00       	call   3b40 <printf>
-  fd = open("echo", 0);
-     42a:	58                   	pop    %eax
-     42b:	5a                   	pop    %edx
-     42c:	6a 00                	push   $0x0
-     42e:	68 8d 3f 00 00       	push   $0x3f8d
-     433:	e8 8b 35 00 00       	call   39c3 <open>
-  if(fd < 0){
-     438:	83 c4 10             	add    $0x10,%esp
-     43b:	85 c0                	test   %eax,%eax
-     43d:	78 36                	js     475 <opentest+0x65>
-  close(fd);
-     43f:	83 ec 0c             	sub    $0xc,%esp
-     442:	50                   	push   %eax
-     443:	e8 63 35 00 00       	call   39ab <close>
-  fd = open("doesnotexist", 0);
-     448:	5a                   	pop    %edx
-     449:	59                   	pop    %ecx
-     44a:	6a 00                	push   $0x0
-     44c:	68 a5 3f 00 00       	push   $0x3fa5
-     451:	e8 6d 35 00 00       	call   39c3 <open>
-  if(fd >= 0){
-     456:	83 c4 10             	add    $0x10,%esp
-     459:	85 c0                	test   %eax,%eax
-     45b:	79 2f                	jns    48c <opentest+0x7c>
-  printf(stdout, "open test ok\n");
-     45d:	83 ec 08             	sub    $0x8,%esp
-     460:	68 d0 3f 00 00       	push   $0x3fd0
-     465:	ff 35 40 5f 00 00    	pushl  0x5f40
-     46b:	e8 d0 36 00 00       	call   3b40 <printf>
-}
-     470:	83 c4 10             	add    $0x10,%esp
-     473:	c9                   	leave  
-     474:	c3                   	ret    
-    printf(stdout, "open echo failed!\n");
-     475:	50                   	push   %eax
-     476:	50                   	push   %eax
-     477:	68 92 3f 00 00       	push   $0x3f92
-     47c:	ff 35 40 5f 00 00    	pushl  0x5f40
-     482:	e8 b9 36 00 00       	call   3b40 <printf>
-    exit();
-     487:	e8 f7 34 00 00       	call   3983 <exit>
-    printf(stdout, "open doesnotexist succeeded!\n");
-     48c:	50                   	push   %eax
-     48d:	50                   	push   %eax
-     48e:	68 b2 3f 00 00       	push   $0x3fb2
-     493:	ff 35 40 5f 00 00    	pushl  0x5f40
-     499:	e8 a2 36 00 00       	call   3b40 <printf>
-    exit();
-     49e:	e8 e0 34 00 00       	call   3983 <exit>
-     4a3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     4aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-000004b0 <writetest>:
-{
-     4b0:	f3 0f 1e fb          	endbr32 
-     4b4:	55                   	push   %ebp
-     4b5:	89 e5                	mov    %esp,%ebp
-     4b7:	56                   	push   %esi
-     4b8:	53                   	push   %ebx
-  printf(stdout, "small file test\n");
-     4b9:	83 ec 08             	sub    $0x8,%esp
-     4bc:	68 de 3f 00 00       	push   $0x3fde
-     4c1:	ff 35 40 5f 00 00    	pushl  0x5f40
-     4c7:	e8 74 36 00 00       	call   3b40 <printf>
-  fd = open("small", O_CREATE|O_RDWR);
-     4cc:	58                   	pop    %eax
-     4cd:	5a                   	pop    %edx
-     4ce:	68 02 02 00 00       	push   $0x202
-     4d3:	68 ef 3f 00 00       	push   $0x3fef
-     4d8:	e8 e6 34 00 00       	call   39c3 <open>
-  if(fd >= 0){
-     4dd:	83 c4 10             	add    $0x10,%esp
-     4e0:	85 c0                	test   %eax,%eax
-     4e2:	0f 88 8c 01 00 00    	js     674 <writetest+0x1c4>
-    printf(stdout, "creat small succeeded; ok\n");
-     4e8:	83 ec 08             	sub    $0x8,%esp
-     4eb:	89 c6                	mov    %eax,%esi
-  for(i = 0; i < 100; i++){
-     4ed:	31 db                	xor    %ebx,%ebx
-    printf(stdout, "creat small succeeded; ok\n");
-     4ef:	68 f5 3f 00 00       	push   $0x3ff5
-     4f4:	ff 35 40 5f 00 00    	pushl  0x5f40
-     4fa:	e8 41 36 00 00       	call   3b40 <printf>
-     4ff:	83 c4 10             	add    $0x10,%esp
-     502:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    if(write(fd, "aaaaaaaaaa", 10) != 10){
-     508:	83 ec 04             	sub    $0x4,%esp
-     50b:	6a 0a                	push   $0xa
-     50d:	68 2c 40 00 00       	push   $0x402c
-     512:	56                   	push   %esi
-     513:	e8 8b 34 00 00       	call   39a3 <write>
-     518:	83 c4 10             	add    $0x10,%esp
-     51b:	83 f8 0a             	cmp    $0xa,%eax
-     51e:	0f 85 d9 00 00 00    	jne    5fd <writetest+0x14d>
-    if(write(fd, "bbbbbbbbbb", 10) != 10){
-     524:	83 ec 04             	sub    $0x4,%esp
-     527:	6a 0a                	push   $0xa
-     529:	68 37 40 00 00       	push   $0x4037
-     52e:	56                   	push   %esi
-     52f:	e8 6f 34 00 00       	call   39a3 <write>
-     534:	83 c4 10             	add    $0x10,%esp
-     537:	83 f8 0a             	cmp    $0xa,%eax
-     53a:	0f 85 d6 00 00 00    	jne    616 <writetest+0x166>
-  for(i = 0; i < 100; i++){
-     540:	83 c3 01             	add    $0x1,%ebx
-     543:	83 fb 64             	cmp    $0x64,%ebx
-     546:	75 c0                	jne    508 <writetest+0x58>
-  printf(stdout, "writes ok\n");
-     548:	83 ec 08             	sub    $0x8,%esp
-     54b:	68 42 40 00 00       	push   $0x4042
-     550:	ff 35 40 5f 00 00    	pushl  0x5f40
-     556:	e8 e5 35 00 00       	call   3b40 <printf>
-  close(fd);
-     55b:	89 34 24             	mov    %esi,(%esp)
-     55e:	e8 48 34 00 00       	call   39ab <close>
-  fd = open("small", O_RDONLY);
-     563:	5b                   	pop    %ebx
-     564:	5e                   	pop    %esi
-     565:	6a 00                	push   $0x0
-     567:	68 ef 3f 00 00       	push   $0x3fef
-     56c:	e8 52 34 00 00       	call   39c3 <open>
-  if(fd >= 0){
-     571:	83 c4 10             	add    $0x10,%esp
-  fd = open("small", O_RDONLY);
-     574:	89 c3                	mov    %eax,%ebx
-  if(fd >= 0){
-     576:	85 c0                	test   %eax,%eax
-     578:	0f 88 b1 00 00 00    	js     62f <writetest+0x17f>
-    printf(stdout, "open small succeeded ok\n");
-     57e:	83 ec 08             	sub    $0x8,%esp
-     581:	68 4d 40 00 00       	push   $0x404d
-     586:	ff 35 40 5f 00 00    	pushl  0x5f40
-     58c:	e8 af 35 00 00       	call   3b40 <printf>
-  i = read(fd, buf, 2000);
-     591:	83 c4 0c             	add    $0xc,%esp
-     594:	68 d0 07 00 00       	push   $0x7d0
-     599:	68 20 87 00 00       	push   $0x8720
-     59e:	53                   	push   %ebx
-     59f:	e8 f7 33 00 00       	call   399b <read>
-  if(i == 2000){
-     5a4:	83 c4 10             	add    $0x10,%esp
-     5a7:	3d d0 07 00 00       	cmp    $0x7d0,%eax
-     5ac:	0f 85 94 00 00 00    	jne    646 <writetest+0x196>
-    printf(stdout, "read succeeded ok\n");
-     5b2:	83 ec 08             	sub    $0x8,%esp
-     5b5:	68 81 40 00 00       	push   $0x4081
-     5ba:	ff 35 40 5f 00 00    	pushl  0x5f40
-     5c0:	e8 7b 35 00 00       	call   3b40 <printf>
-  close(fd);
-     5c5:	89 1c 24             	mov    %ebx,(%esp)
-     5c8:	e8 de 33 00 00       	call   39ab <close>
-  if(unlink("small") < 0){
-     5cd:	c7 04 24 ef 3f 00 00 	movl   $0x3fef,(%esp)
-     5d4:	e8 fa 33 00 00       	call   39d3 <unlink>
-     5d9:	83 c4 10             	add    $0x10,%esp
-     5dc:	85 c0                	test   %eax,%eax
-     5de:	78 7d                	js     65d <writetest+0x1ad>
-  printf(stdout, "small file test ok\n");
-     5e0:	83 ec 08             	sub    $0x8,%esp
-     5e3:	68 a9 40 00 00       	push   $0x40a9
-     5e8:	ff 35 40 5f 00 00    	pushl  0x5f40
-     5ee:	e8 4d 35 00 00       	call   3b40 <printf>
-}
-     5f3:	83 c4 10             	add    $0x10,%esp
-     5f6:	8d 65 f8             	lea    -0x8(%ebp),%esp
-     5f9:	5b                   	pop    %ebx
-     5fa:	5e                   	pop    %esi
-     5fb:	5d                   	pop    %ebp
-     5fc:	c3                   	ret    
-      printf(stdout, "error: write aa %d new file failed\n", i);
-     5fd:	83 ec 04             	sub    $0x4,%esp
-     600:	53                   	push   %ebx
-     601:	68 f0 4e 00 00       	push   $0x4ef0
-     606:	ff 35 40 5f 00 00    	pushl  0x5f40
-     60c:	e8 2f 35 00 00       	call   3b40 <printf>
-      exit();
-     611:	e8 6d 33 00 00       	call   3983 <exit>
-      printf(stdout, "error: write bb %d new file failed\n", i);
-     616:	83 ec 04             	sub    $0x4,%esp
-     619:	53                   	push   %ebx
-     61a:	68 14 4f 00 00       	push   $0x4f14
-     61f:	ff 35 40 5f 00 00    	pushl  0x5f40
-     625:	e8 16 35 00 00       	call   3b40 <printf>
-      exit();
-     62a:	e8 54 33 00 00       	call   3983 <exit>
-    printf(stdout, "error: open small failed!\n");
-     62f:	51                   	push   %ecx
-     630:	51                   	push   %ecx
-     631:	68 66 40 00 00       	push   $0x4066
-     636:	ff 35 40 5f 00 00    	pushl  0x5f40
-     63c:	e8 ff 34 00 00       	call   3b40 <printf>
-    exit();
-     641:	e8 3d 33 00 00       	call   3983 <exit>
-    printf(stdout, "read failed\n");
-     646:	52                   	push   %edx
-     647:	52                   	push   %edx
-     648:	68 ad 43 00 00       	push   $0x43ad
-     64d:	ff 35 40 5f 00 00    	pushl  0x5f40
-     653:	e8 e8 34 00 00       	call   3b40 <printf>
-    exit();
-     658:	e8 26 33 00 00       	call   3983 <exit>
-    printf(stdout, "unlink small failed\n");
-     65d:	50                   	push   %eax
-     65e:	50                   	push   %eax
-     65f:	68 94 40 00 00       	push   $0x4094
-     664:	ff 35 40 5f 00 00    	pushl  0x5f40
-     66a:	e8 d1 34 00 00       	call   3b40 <printf>
-    exit();
-     66f:	e8 0f 33 00 00       	call   3983 <exit>
-    printf(stdout, "error: creat small failed!\n");
-     674:	50                   	push   %eax
-     675:	50                   	push   %eax
-     676:	68 10 40 00 00       	push   $0x4010
-     67b:	ff 35 40 5f 00 00    	pushl  0x5f40
-     681:	e8 ba 34 00 00       	call   3b40 <printf>
-    exit();
-     686:	e8 f8 32 00 00       	call   3983 <exit>
-     68b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     68f:	90                   	nop
-
-00000690 <writetest1>:
-{
-     690:	f3 0f 1e fb          	endbr32 
-     694:	55                   	push   %ebp
-     695:	89 e5                	mov    %esp,%ebp
-     697:	56                   	push   %esi
-     698:	53                   	push   %ebx
-  printf(stdout, "big files test\n");
-     699:	83 ec 08             	sub    $0x8,%esp
-     69c:	68 bd 40 00 00       	push   $0x40bd
-     6a1:	ff 35 40 5f 00 00    	pushl  0x5f40
-     6a7:	e8 94 34 00 00       	call   3b40 <printf>
-  fd = open("big", O_CREATE|O_RDWR);
-     6ac:	58                   	pop    %eax
-     6ad:	5a                   	pop    %edx
-     6ae:	68 02 02 00 00       	push   $0x202
-     6b3:	68 37 41 00 00       	push   $0x4137
-     6b8:	e8 06 33 00 00       	call   39c3 <open>
-  if(fd < 0){
-     6bd:	83 c4 10             	add    $0x10,%esp
-     6c0:	85 c0                	test   %eax,%eax
-     6c2:	0f 88 5d 01 00 00    	js     825 <writetest1+0x195>
-     6c8:	89 c6                	mov    %eax,%esi
-  for(i = 0; i < MAXFILE; i++){
-     6ca:	31 db                	xor    %ebx,%ebx
-     6cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    if(write(fd, buf, 512) != 512){
-     6d0:	83 ec 04             	sub    $0x4,%esp
-    ((int*)buf)[0] = i;
-     6d3:	89 1d 20 87 00 00    	mov    %ebx,0x8720
-    if(write(fd, buf, 512) != 512){
-     6d9:	68 00 02 00 00       	push   $0x200
-     6de:	68 20 87 00 00       	push   $0x8720
-     6e3:	56                   	push   %esi
-     6e4:	e8 ba 32 00 00       	call   39a3 <write>
-     6e9:	83 c4 10             	add    $0x10,%esp
-     6ec:	3d 00 02 00 00       	cmp    $0x200,%eax
-     6f1:	0f 85 b3 00 00 00    	jne    7aa <writetest1+0x11a>
-  for(i = 0; i < MAXFILE; i++){
-     6f7:	83 c3 01             	add    $0x1,%ebx
-     6fa:	81 fb 8c 00 00 00    	cmp    $0x8c,%ebx
-     700:	75 ce                	jne    6d0 <writetest1+0x40>
-  close(fd);
-     702:	83 ec 0c             	sub    $0xc,%esp
-     705:	56                   	push   %esi
-     706:	e8 a0 32 00 00       	call   39ab <close>
-  fd = open("big", O_RDONLY);
-     70b:	5b                   	pop    %ebx
-     70c:	5e                   	pop    %esi
-     70d:	6a 00                	push   $0x0
-     70f:	68 37 41 00 00       	push   $0x4137
-     714:	e8 aa 32 00 00       	call   39c3 <open>
-  if(fd < 0){
-     719:	83 c4 10             	add    $0x10,%esp
-  fd = open("big", O_RDONLY);
-     71c:	89 c3                	mov    %eax,%ebx
-  if(fd < 0){
-     71e:	85 c0                	test   %eax,%eax
-     720:	0f 88 e8 00 00 00    	js     80e <writetest1+0x17e>
-  n = 0;
-     726:	31 f6                	xor    %esi,%esi
-     728:	eb 1d                	jmp    747 <writetest1+0xb7>
-     72a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    } else if(i != 512){
-     730:	3d 00 02 00 00       	cmp    $0x200,%eax
-     735:	0f 85 9f 00 00 00    	jne    7da <writetest1+0x14a>
-    if(((int*)buf)[0] != n){
-     73b:	a1 20 87 00 00       	mov    0x8720,%eax
-     740:	39 f0                	cmp    %esi,%eax
-     742:	75 7f                	jne    7c3 <writetest1+0x133>
-    n++;
-     744:	83 c6 01             	add    $0x1,%esi
-    i = read(fd, buf, 512);
-     747:	83 ec 04             	sub    $0x4,%esp
-     74a:	68 00 02 00 00       	push   $0x200
-     74f:	68 20 87 00 00       	push   $0x8720
-     754:	53                   	push   %ebx
-     755:	e8 41 32 00 00       	call   399b <read>
-    if(i == 0){
-     75a:	83 c4 10             	add    $0x10,%esp
-     75d:	85 c0                	test   %eax,%eax
-     75f:	75 cf                	jne    730 <writetest1+0xa0>
-      if(n == MAXFILE - 1){
-     761:	81 fe 8b 00 00 00    	cmp    $0x8b,%esi
-     767:	0f 84 86 00 00 00    	je     7f3 <writetest1+0x163>
-  close(fd);
-     76d:	83 ec 0c             	sub    $0xc,%esp
-     770:	53                   	push   %ebx
-     771:	e8 35 32 00 00       	call   39ab <close>
-  if(unlink("big") < 0){
-     776:	c7 04 24 37 41 00 00 	movl   $0x4137,(%esp)
-     77d:	e8 51 32 00 00       	call   39d3 <unlink>
-     782:	83 c4 10             	add    $0x10,%esp
-     785:	85 c0                	test   %eax,%eax
-     787:	0f 88 af 00 00 00    	js     83c <writetest1+0x1ac>
-  printf(stdout, "big files ok\n");
-     78d:	83 ec 08             	sub    $0x8,%esp
-     790:	68 5e 41 00 00       	push   $0x415e
-     795:	ff 35 40 5f 00 00    	pushl  0x5f40
-     79b:	e8 a0 33 00 00       	call   3b40 <printf>
-}
-     7a0:	83 c4 10             	add    $0x10,%esp
-     7a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
-     7a6:	5b                   	pop    %ebx
-     7a7:	5e                   	pop    %esi
-     7a8:	5d                   	pop    %ebp
-     7a9:	c3                   	ret    
-      printf(stdout, "error: write big file failed\n", i);
-     7aa:	83 ec 04             	sub    $0x4,%esp
-     7ad:	53                   	push   %ebx
-     7ae:	68 e7 40 00 00       	push   $0x40e7
-     7b3:	ff 35 40 5f 00 00    	pushl  0x5f40
-     7b9:	e8 82 33 00 00       	call   3b40 <printf>
-      exit();
-     7be:	e8 c0 31 00 00       	call   3983 <exit>
-      printf(stdout, "read content of block %d is %d\n",
-     7c3:	50                   	push   %eax
-     7c4:	56                   	push   %esi
-     7c5:	68 38 4f 00 00       	push   $0x4f38
-     7ca:	ff 35 40 5f 00 00    	pushl  0x5f40
-     7d0:	e8 6b 33 00 00       	call   3b40 <printf>
-      exit();
-     7d5:	e8 a9 31 00 00       	call   3983 <exit>
-      printf(stdout, "read failed %d\n", i);
-     7da:	83 ec 04             	sub    $0x4,%esp
-     7dd:	50                   	push   %eax
-     7de:	68 3b 41 00 00       	push   $0x413b
-     7e3:	ff 35 40 5f 00 00    	pushl  0x5f40
-     7e9:	e8 52 33 00 00       	call   3b40 <printf>
-      exit();
-     7ee:	e8 90 31 00 00       	call   3983 <exit>
-        printf(stdout, "read only %d blocks from big", n);
-     7f3:	52                   	push   %edx
-     7f4:	68 8b 00 00 00       	push   $0x8b
-     7f9:	68 1e 41 00 00       	push   $0x411e
-     7fe:	ff 35 40 5f 00 00    	pushl  0x5f40
-     804:	e8 37 33 00 00       	call   3b40 <printf>
-        exit();
-     809:	e8 75 31 00 00       	call   3983 <exit>
-    printf(stdout, "error: open big failed!\n");
-     80e:	51                   	push   %ecx
-     80f:	51                   	push   %ecx
-     810:	68 05 41 00 00       	push   $0x4105
-     815:	ff 35 40 5f 00 00    	pushl  0x5f40
-     81b:	e8 20 33 00 00       	call   3b40 <printf>
-    exit();
-     820:	e8 5e 31 00 00       	call   3983 <exit>
-    printf(stdout, "error: creat big failed!\n");
-     825:	50                   	push   %eax
-     826:	50                   	push   %eax
-     827:	68 cd 40 00 00       	push   $0x40cd
-     82c:	ff 35 40 5f 00 00    	pushl  0x5f40
-     832:	e8 09 33 00 00       	call   3b40 <printf>
-    exit();
-     837:	e8 47 31 00 00       	call   3983 <exit>
-    printf(stdout, "unlink big failed\n");
-     83c:	50                   	push   %eax
-     83d:	50                   	push   %eax
-     83e:	68 4b 41 00 00       	push   $0x414b
-     843:	ff 35 40 5f 00 00    	pushl  0x5f40
-     849:	e8 f2 32 00 00       	call   3b40 <printf>
-    exit();
-     84e:	e8 30 31 00 00       	call   3983 <exit>
-     853:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     85a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000860 <createtest>:
-{
-     860:	f3 0f 1e fb          	endbr32 
-     864:	55                   	push   %ebp
-     865:	89 e5                	mov    %esp,%ebp
-     867:	53                   	push   %ebx
-  name[2] = '\0';
-     868:	bb 30 00 00 00       	mov    $0x30,%ebx
-{
-     86d:	83 ec 0c             	sub    $0xc,%esp
-  printf(stdout, "many creates, followed by unlink test\n");
-     870:	68 58 4f 00 00       	push   $0x4f58
-     875:	ff 35 40 5f 00 00    	pushl  0x5f40
-     87b:	e8 c0 32 00 00       	call   3b40 <printf>
-  name[0] = 'a';
-     880:	c6 05 20 a7 00 00 61 	movb   $0x61,0xa720
-  name[2] = '\0';
-     887:	83 c4 10             	add    $0x10,%esp
-     88a:	c6 05 22 a7 00 00 00 	movb   $0x0,0xa722
-  for(i = 0; i < 52; i++){
-     891:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    fd = open(name, O_CREATE|O_RDWR);
-     898:	83 ec 08             	sub    $0x8,%esp
-    name[1] = '0' + i;
-     89b:	88 1d 21 a7 00 00    	mov    %bl,0xa721
-    fd = open(name, O_CREATE|O_RDWR);
-     8a1:	83 c3 01             	add    $0x1,%ebx
-     8a4:	68 02 02 00 00       	push   $0x202
-     8a9:	68 20 a7 00 00       	push   $0xa720
-     8ae:	e8 10 31 00 00       	call   39c3 <open>
-    close(fd);
-     8b3:	89 04 24             	mov    %eax,(%esp)
-     8b6:	e8 f0 30 00 00       	call   39ab <close>
-  for(i = 0; i < 52; i++){
-     8bb:	83 c4 10             	add    $0x10,%esp
-     8be:	80 fb 64             	cmp    $0x64,%bl
-     8c1:	75 d5                	jne    898 <createtest+0x38>
-  name[0] = 'a';
-     8c3:	c6 05 20 a7 00 00 61 	movb   $0x61,0xa720
-  name[2] = '\0';
-     8ca:	bb 30 00 00 00       	mov    $0x30,%ebx
-     8cf:	c6 05 22 a7 00 00 00 	movb   $0x0,0xa722
-  for(i = 0; i < 52; i++){
-     8d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     8dd:	8d 76 00             	lea    0x0(%esi),%esi
-    unlink(name);
-     8e0:	83 ec 0c             	sub    $0xc,%esp
-    name[1] = '0' + i;
-     8e3:	88 1d 21 a7 00 00    	mov    %bl,0xa721
-    unlink(name);
-     8e9:	83 c3 01             	add    $0x1,%ebx
-     8ec:	68 20 a7 00 00       	push   $0xa720
-     8f1:	e8 dd 30 00 00       	call   39d3 <unlink>
-  for(i = 0; i < 52; i++){
-     8f6:	83 c4 10             	add    $0x10,%esp
-     8f9:	80 fb 64             	cmp    $0x64,%bl
-     8fc:	75 e2                	jne    8e0 <createtest+0x80>
-  printf(stdout, "many creates, followed by unlink; ok\n");
-     8fe:	83 ec 08             	sub    $0x8,%esp
-     901:	68 80 4f 00 00       	push   $0x4f80
-     906:	ff 35 40 5f 00 00    	pushl  0x5f40
-     90c:	e8 2f 32 00 00       	call   3b40 <printf>
-}
-     911:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-     914:	83 c4 10             	add    $0x10,%esp
-     917:	c9                   	leave  
-     918:	c3                   	ret    
-     919:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-00000920 <dirtest>:
-{
-     920:	f3 0f 1e fb          	endbr32 
-     924:	55                   	push   %ebp
-     925:	89 e5                	mov    %esp,%ebp
-     927:	83 ec 10             	sub    $0x10,%esp
-  printf(stdout, "mkdir test\n");
-     92a:	68 6c 41 00 00       	push   $0x416c
-     92f:	ff 35 40 5f 00 00    	pushl  0x5f40
-     935:	e8 06 32 00 00       	call   3b40 <printf>
-  if(mkdir("dir0") < 0){
-     93a:	c7 04 24 78 41 00 00 	movl   $0x4178,(%esp)
-     941:	e8 a5 30 00 00       	call   39eb <mkdir>
-     946:	83 c4 10             	add    $0x10,%esp
-     949:	85 c0                	test   %eax,%eax
-     94b:	78 58                	js     9a5 <dirtest+0x85>
-  if(chdir("dir0") < 0){
-     94d:	83 ec 0c             	sub    $0xc,%esp
-     950:	68 78 41 00 00       	push   $0x4178
-     955:	e8 99 30 00 00       	call   39f3 <chdir>
-     95a:	83 c4 10             	add    $0x10,%esp
-     95d:	85 c0                	test   %eax,%eax
-     95f:	0f 88 85 00 00 00    	js     9ea <dirtest+0xca>
-  if(chdir("..") < 0){
-     965:	83 ec 0c             	sub    $0xc,%esp
-     968:	68 1d 47 00 00       	push   $0x471d
-     96d:	e8 81 30 00 00       	call   39f3 <chdir>
-     972:	83 c4 10             	add    $0x10,%esp
-     975:	85 c0                	test   %eax,%eax
-     977:	78 5a                	js     9d3 <dirtest+0xb3>
-  if(unlink("dir0") < 0){
-     979:	83 ec 0c             	sub    $0xc,%esp
-     97c:	68 78 41 00 00       	push   $0x4178
-     981:	e8 4d 30 00 00       	call   39d3 <unlink>
-     986:	83 c4 10             	add    $0x10,%esp
-     989:	85 c0                	test   %eax,%eax
-     98b:	78 2f                	js     9bc <dirtest+0x9c>
-  printf(stdout, "mkdir test ok\n");
-     98d:	83 ec 08             	sub    $0x8,%esp
-     990:	68 b5 41 00 00       	push   $0x41b5
-     995:	ff 35 40 5f 00 00    	pushl  0x5f40
-     99b:	e8 a0 31 00 00       	call   3b40 <printf>
-}
-     9a0:	83 c4 10             	add    $0x10,%esp
-     9a3:	c9                   	leave  
-     9a4:	c3                   	ret    
-    printf(stdout, "mkdir failed\n");
-     9a5:	50                   	push   %eax
-     9a6:	50                   	push   %eax
-     9a7:	68 a8 3e 00 00       	push   $0x3ea8
-     9ac:	ff 35 40 5f 00 00    	pushl  0x5f40
-     9b2:	e8 89 31 00 00       	call   3b40 <printf>
-    exit();
-     9b7:	e8 c7 2f 00 00       	call   3983 <exit>
-    printf(stdout, "unlink dir0 failed\n");
-     9bc:	50                   	push   %eax
-     9bd:	50                   	push   %eax
-     9be:	68 a1 41 00 00       	push   $0x41a1
-     9c3:	ff 35 40 5f 00 00    	pushl  0x5f40
-     9c9:	e8 72 31 00 00       	call   3b40 <printf>
-    exit();
-     9ce:	e8 b0 2f 00 00       	call   3983 <exit>
-    printf(stdout, "chdir .. failed\n");
-     9d3:	52                   	push   %edx
-     9d4:	52                   	push   %edx
-     9d5:	68 90 41 00 00       	push   $0x4190
-     9da:	ff 35 40 5f 00 00    	pushl  0x5f40
-     9e0:	e8 5b 31 00 00       	call   3b40 <printf>
-    exit();
-     9e5:	e8 99 2f 00 00       	call   3983 <exit>
-    printf(stdout, "chdir dir0 failed\n");
-     9ea:	51                   	push   %ecx
-     9eb:	51                   	push   %ecx
-     9ec:	68 7d 41 00 00       	push   $0x417d
-     9f1:	ff 35 40 5f 00 00    	pushl  0x5f40
-     9f7:	e8 44 31 00 00       	call   3b40 <printf>
-    exit();
-     9fc:	e8 82 2f 00 00       	call   3983 <exit>
-     a01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     a08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     a0f:	90                   	nop
-
-00000a10 <exectest>:
-{
-     a10:	f3 0f 1e fb          	endbr32 
-     a14:	55                   	push   %ebp
-     a15:	89 e5                	mov    %esp,%ebp
-     a17:	83 ec 10             	sub    $0x10,%esp
-  printf(stdout, "exec test\n");
-     a1a:	68 c4 41 00 00       	push   $0x41c4
-     a1f:	ff 35 40 5f 00 00    	pushl  0x5f40
-     a25:	e8 16 31 00 00       	call   3b40 <printf>
-  if(exec("echo", echoargv) < 0){
-     a2a:	5a                   	pop    %edx
-     a2b:	59                   	pop    %ecx
-     a2c:	68 44 5f 00 00       	push   $0x5f44
-     a31:	68 8d 3f 00 00       	push   $0x3f8d
-     a36:	e8 80 2f 00 00       	call   39bb <exec>
-     a3b:	83 c4 10             	add    $0x10,%esp
-     a3e:	85 c0                	test   %eax,%eax
-     a40:	78 02                	js     a44 <exectest+0x34>
-}
-     a42:	c9                   	leave  
-     a43:	c3                   	ret    
-    printf(stdout, "exec echo failed\n");
-     a44:	50                   	push   %eax
-     a45:	50                   	push   %eax
-     a46:	68 cf 41 00 00       	push   $0x41cf
-     a4b:	ff 35 40 5f 00 00    	pushl  0x5f40
-     a51:	e8 ea 30 00 00       	call   3b40 <printf>
-    exit();
-     a56:	e8 28 2f 00 00       	call   3983 <exit>
-     a5b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     a5f:	90                   	nop
-
-00000a60 <pipe1>:
-{
-     a60:	f3 0f 1e fb          	endbr32 
-     a64:	55                   	push   %ebp
-     a65:	89 e5                	mov    %esp,%ebp
-     a67:	57                   	push   %edi
-     a68:	56                   	push   %esi
-  if(pipe(fds) != 0){
-     a69:	8d 45 e0             	lea    -0x20(%ebp),%eax
-{
-     a6c:	53                   	push   %ebx
-     a6d:	83 ec 38             	sub    $0x38,%esp
-  if(pipe(fds) != 0){
-     a70:	50                   	push   %eax
-     a71:	e8 1d 2f 00 00       	call   3993 <pipe>
-     a76:	83 c4 10             	add    $0x10,%esp
-     a79:	85 c0                	test   %eax,%eax
-     a7b:	0f 85 38 01 00 00    	jne    bb9 <pipe1+0x159>
-  pid = fork();
-     a81:	e8 f5 2e 00 00       	call   397b <fork>
-  if(pid == 0){
-     a86:	85 c0                	test   %eax,%eax
-     a88:	0f 84 8d 00 00 00    	je     b1b <pipe1+0xbb>
-  } else if(pid > 0){
-     a8e:	0f 8e 38 01 00 00    	jle    bcc <pipe1+0x16c>
-    close(fds[1]);
-     a94:	83 ec 0c             	sub    $0xc,%esp
-     a97:	ff 75 e4             	pushl  -0x1c(%ebp)
-  seq = 0;
-     a9a:	31 db                	xor    %ebx,%ebx
-    cc = 1;
-     a9c:	be 01 00 00 00       	mov    $0x1,%esi
-    close(fds[1]);
-     aa1:	e8 05 2f 00 00       	call   39ab <close>
-    total = 0;
-     aa6:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
-    while((n = read(fds[0], buf, cc)) > 0){
-     aad:	83 c4 10             	add    $0x10,%esp
-     ab0:	83 ec 04             	sub    $0x4,%esp
-     ab3:	56                   	push   %esi
-     ab4:	68 20 87 00 00       	push   $0x8720
-     ab9:	ff 75 e0             	pushl  -0x20(%ebp)
-     abc:	e8 da 2e 00 00       	call   399b <read>
-     ac1:	83 c4 10             	add    $0x10,%esp
-     ac4:	89 c7                	mov    %eax,%edi
-     ac6:	85 c0                	test   %eax,%eax
-     ac8:	0f 8e a7 00 00 00    	jle    b75 <pipe1+0x115>
-     ace:	8d 0c 3b             	lea    (%ebx,%edi,1),%ecx
-      for(i = 0; i < n; i++){
-     ad1:	31 c0                	xor    %eax,%eax
-     ad3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     ad7:	90                   	nop
-        if((buf[i] & 0xff) != (seq++ & 0xff)){
-     ad8:	89 da                	mov    %ebx,%edx
-     ada:	83 c3 01             	add    $0x1,%ebx
-     add:	38 90 20 87 00 00    	cmp    %dl,0x8720(%eax)
-     ae3:	75 1c                	jne    b01 <pipe1+0xa1>
-      for(i = 0; i < n; i++){
-     ae5:	83 c0 01             	add    $0x1,%eax
-     ae8:	39 d9                	cmp    %ebx,%ecx
-     aea:	75 ec                	jne    ad8 <pipe1+0x78>
-      cc = cc * 2;
-     aec:	01 f6                	add    %esi,%esi
-      total += n;
-     aee:	01 7d d4             	add    %edi,-0x2c(%ebp)
-     af1:	b8 00 20 00 00       	mov    $0x2000,%eax
-     af6:	81 fe 00 20 00 00    	cmp    $0x2000,%esi
-     afc:	0f 4f f0             	cmovg  %eax,%esi
-     aff:	eb af                	jmp    ab0 <pipe1+0x50>
-          printf(1, "pipe1 oops 2\n");
-     b01:	83 ec 08             	sub    $0x8,%esp
-     b04:	68 fe 41 00 00       	push   $0x41fe
-     b09:	6a 01                	push   $0x1
-     b0b:	e8 30 30 00 00       	call   3b40 <printf>
-          return;
-     b10:	83 c4 10             	add    $0x10,%esp
-}
-     b13:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     b16:	5b                   	pop    %ebx
-     b17:	5e                   	pop    %esi
-     b18:	5f                   	pop    %edi
-     b19:	5d                   	pop    %ebp
-     b1a:	c3                   	ret    
-    close(fds[0]);
-     b1b:	83 ec 0c             	sub    $0xc,%esp
-     b1e:	ff 75 e0             	pushl  -0x20(%ebp)
-  seq = 0;
-     b21:	31 db                	xor    %ebx,%ebx
-    close(fds[0]);
-     b23:	e8 83 2e 00 00       	call   39ab <close>
-     b28:	83 c4 10             	add    $0x10,%esp
-      for(i = 0; i < 1033; i++)
-     b2b:	31 c0                	xor    %eax,%eax
-     b2d:	8d 76 00             	lea    0x0(%esi),%esi
-        buf[i] = seq++;
-     b30:	8d 14 18             	lea    (%eax,%ebx,1),%edx
-      for(i = 0; i < 1033; i++)
-     b33:	83 c0 01             	add    $0x1,%eax
-        buf[i] = seq++;
-     b36:	88 90 1f 87 00 00    	mov    %dl,0x871f(%eax)
-      for(i = 0; i < 1033; i++)
-     b3c:	3d 09 04 00 00       	cmp    $0x409,%eax
-     b41:	75 ed                	jne    b30 <pipe1+0xd0>
-      if(write(fds[1], buf, 1033) != 1033){
-     b43:	83 ec 04             	sub    $0x4,%esp
-     b46:	81 c3 09 04 00 00    	add    $0x409,%ebx
-     b4c:	68 09 04 00 00       	push   $0x409
-     b51:	68 20 87 00 00       	push   $0x8720
-     b56:	ff 75 e4             	pushl  -0x1c(%ebp)
-     b59:	e8 45 2e 00 00       	call   39a3 <write>
-     b5e:	83 c4 10             	add    $0x10,%esp
-     b61:	3d 09 04 00 00       	cmp    $0x409,%eax
-     b66:	75 77                	jne    bdf <pipe1+0x17f>
-    for(n = 0; n < 5; n++){
-     b68:	81 fb 2d 14 00 00    	cmp    $0x142d,%ebx
-     b6e:	75 bb                	jne    b2b <pipe1+0xcb>
-    exit();
-     b70:	e8 0e 2e 00 00       	call   3983 <exit>
-    if(total != 5 * 1033){
-     b75:	81 7d d4 2d 14 00 00 	cmpl   $0x142d,-0x2c(%ebp)
-     b7c:	75 26                	jne    ba4 <pipe1+0x144>
-    close(fds[0]);
-     b7e:	83 ec 0c             	sub    $0xc,%esp
-     b81:	ff 75 e0             	pushl  -0x20(%ebp)
-     b84:	e8 22 2e 00 00       	call   39ab <close>
-    wait();
-     b89:	e8 fd 2d 00 00       	call   398b <wait>
-  printf(1, "pipe1 ok\n");
-     b8e:	5a                   	pop    %edx
-     b8f:	59                   	pop    %ecx
-     b90:	68 23 42 00 00       	push   $0x4223
-     b95:	6a 01                	push   $0x1
-     b97:	e8 a4 2f 00 00       	call   3b40 <printf>
-     b9c:	83 c4 10             	add    $0x10,%esp
-     b9f:	e9 6f ff ff ff       	jmp    b13 <pipe1+0xb3>
-      printf(1, "pipe1 oops 3 total %d\n", total);
-     ba4:	53                   	push   %ebx
-     ba5:	ff 75 d4             	pushl  -0x2c(%ebp)
-     ba8:	68 0c 42 00 00       	push   $0x420c
-     bad:	6a 01                	push   $0x1
-     baf:	e8 8c 2f 00 00       	call   3b40 <printf>
-      exit();
-     bb4:	e8 ca 2d 00 00       	call   3983 <exit>
-    printf(1, "pipe() failed\n");
-     bb9:	57                   	push   %edi
-     bba:	57                   	push   %edi
-     bbb:	68 e1 41 00 00       	push   $0x41e1
-     bc0:	6a 01                	push   $0x1
-     bc2:	e8 79 2f 00 00       	call   3b40 <printf>
-    exit();
-     bc7:	e8 b7 2d 00 00       	call   3983 <exit>
-    printf(1, "fork() failed\n");
-     bcc:	50                   	push   %eax
-     bcd:	50                   	push   %eax
-     bce:	68 2d 42 00 00       	push   $0x422d
-     bd3:	6a 01                	push   $0x1
-     bd5:	e8 66 2f 00 00       	call   3b40 <printf>
-    exit();
-     bda:	e8 a4 2d 00 00       	call   3983 <exit>
-        printf(1, "pipe1 oops 1\n");
-     bdf:	56                   	push   %esi
-     be0:	56                   	push   %esi
-     be1:	68 f0 41 00 00       	push   $0x41f0
-     be6:	6a 01                	push   $0x1
-     be8:	e8 53 2f 00 00       	call   3b40 <printf>
-        exit();
-     bed:	e8 91 2d 00 00       	call   3983 <exit>
-     bf2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     bf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-00000c00 <preempt>:
-{
-     c00:	f3 0f 1e fb          	endbr32 
-     c04:	55                   	push   %ebp
-     c05:	89 e5                	mov    %esp,%ebp
-     c07:	57                   	push   %edi
-     c08:	56                   	push   %esi
-     c09:	53                   	push   %ebx
-     c0a:	83 ec 24             	sub    $0x24,%esp
-  printf(1, "preempt: ");
-     c0d:	68 3c 42 00 00       	push   $0x423c
-     c12:	6a 01                	push   $0x1
-     c14:	e8 27 2f 00 00       	call   3b40 <printf>
-  pid1 = fork();
-     c19:	e8 5d 2d 00 00       	call   397b <fork>
-  if(pid1 == 0)
-     c1e:	83 c4 10             	add    $0x10,%esp
-     c21:	85 c0                	test   %eax,%eax
-     c23:	75 0b                	jne    c30 <preempt+0x30>
-    for(;;)
-     c25:	eb fe                	jmp    c25 <preempt+0x25>
-     c27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     c2e:	66 90                	xchg   %ax,%ax
-     c30:	89 c7                	mov    %eax,%edi
-  pid2 = fork();
-     c32:	e8 44 2d 00 00       	call   397b <fork>
-     c37:	89 c6                	mov    %eax,%esi
-  if(pid2 == 0)
-     c39:	85 c0                	test   %eax,%eax
-     c3b:	75 03                	jne    c40 <preempt+0x40>
-    for(;;)
-     c3d:	eb fe                	jmp    c3d <preempt+0x3d>
-     c3f:	90                   	nop
-  pipe(pfds);
-     c40:	83 ec 0c             	sub    $0xc,%esp
-     c43:	8d 45 e0             	lea    -0x20(%ebp),%eax
-     c46:	50                   	push   %eax
-     c47:	e8 47 2d 00 00       	call   3993 <pipe>
-  pid3 = fork();
-     c4c:	e8 2a 2d 00 00       	call   397b <fork>
-  if(pid3 == 0){
-     c51:	83 c4 10             	add    $0x10,%esp
-  pid3 = fork();
-     c54:	89 c3                	mov    %eax,%ebx
-  if(pid3 == 0){
-     c56:	85 c0                	test   %eax,%eax
-     c58:	75 3e                	jne    c98 <preempt+0x98>
-    close(pfds[0]);
-     c5a:	83 ec 0c             	sub    $0xc,%esp
-     c5d:	ff 75 e0             	pushl  -0x20(%ebp)
-     c60:	e8 46 2d 00 00       	call   39ab <close>
-    if(write(pfds[1], "x", 1) != 1)
-     c65:	83 c4 0c             	add    $0xc,%esp
-     c68:	6a 01                	push   $0x1
-     c6a:	68 01 48 00 00       	push   $0x4801
-     c6f:	ff 75 e4             	pushl  -0x1c(%ebp)
-     c72:	e8 2c 2d 00 00       	call   39a3 <write>
-     c77:	83 c4 10             	add    $0x10,%esp
-     c7a:	83 f8 01             	cmp    $0x1,%eax
-     c7d:	0f 85 a4 00 00 00    	jne    d27 <preempt+0x127>
-    close(pfds[1]);
-     c83:	83 ec 0c             	sub    $0xc,%esp
-     c86:	ff 75 e4             	pushl  -0x1c(%ebp)
-     c89:	e8 1d 2d 00 00       	call   39ab <close>
-     c8e:	83 c4 10             	add    $0x10,%esp
-    for(;;)
-     c91:	eb fe                	jmp    c91 <preempt+0x91>
-     c93:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     c97:	90                   	nop
-  close(pfds[1]);
-     c98:	83 ec 0c             	sub    $0xc,%esp
-     c9b:	ff 75 e4             	pushl  -0x1c(%ebp)
-     c9e:	e8 08 2d 00 00       	call   39ab <close>
-  if(read(pfds[0], buf, sizeof(buf)) != 1){
-     ca3:	83 c4 0c             	add    $0xc,%esp
-     ca6:	68 00 20 00 00       	push   $0x2000
-     cab:	68 20 87 00 00       	push   $0x8720
-     cb0:	ff 75 e0             	pushl  -0x20(%ebp)
-     cb3:	e8 e3 2c 00 00       	call   399b <read>
-     cb8:	83 c4 10             	add    $0x10,%esp
-     cbb:	83 f8 01             	cmp    $0x1,%eax
-     cbe:	75 7e                	jne    d3e <preempt+0x13e>
-  close(pfds[0]);
-     cc0:	83 ec 0c             	sub    $0xc,%esp
-     cc3:	ff 75 e0             	pushl  -0x20(%ebp)
-     cc6:	e8 e0 2c 00 00       	call   39ab <close>
-  printf(1, "kill... ");
-     ccb:	58                   	pop    %eax
-     ccc:	5a                   	pop    %edx
-     ccd:	68 6d 42 00 00       	push   $0x426d
-     cd2:	6a 01                	push   $0x1
-     cd4:	e8 67 2e 00 00       	call   3b40 <printf>
-  kill(pid1);
-     cd9:	89 3c 24             	mov    %edi,(%esp)
-     cdc:	e8 d2 2c 00 00       	call   39b3 <kill>
-  kill(pid2);
-     ce1:	89 34 24             	mov    %esi,(%esp)
-     ce4:	e8 ca 2c 00 00       	call   39b3 <kill>
-  kill(pid3);
-     ce9:	89 1c 24             	mov    %ebx,(%esp)
-     cec:	e8 c2 2c 00 00       	call   39b3 <kill>
-  printf(1, "wait... ");
-     cf1:	59                   	pop    %ecx
-     cf2:	5b                   	pop    %ebx
-     cf3:	68 76 42 00 00       	push   $0x4276
-     cf8:	6a 01                	push   $0x1
-     cfa:	e8 41 2e 00 00       	call   3b40 <printf>
-  wait();
-     cff:	e8 87 2c 00 00       	call   398b <wait>
-  wait();
-     d04:	e8 82 2c 00 00       	call   398b <wait>
-  wait();
-     d09:	e8 7d 2c 00 00       	call   398b <wait>
-  printf(1, "preempt ok\n");
-     d0e:	5e                   	pop    %esi
-     d0f:	5f                   	pop    %edi
-     d10:	68 7f 42 00 00       	push   $0x427f
-     d15:	6a 01                	push   $0x1
-     d17:	e8 24 2e 00 00       	call   3b40 <printf>
-     d1c:	83 c4 10             	add    $0x10,%esp
-}
-     d1f:	8d 65 f4             	lea    -0xc(%ebp),%esp
-     d22:	5b                   	pop    %ebx
-     d23:	5e                   	pop    %esi
-     d24:	5f                   	pop    %edi
-     d25:	5d                   	pop    %ebp
-     d26:	c3                   	ret    
-      printf(1, "preempt write error");
-     d27:	83 ec 08             	sub    $0x8,%esp
-     d2a:	68 46 42 00 00       	push   $0x4246
-     d2f:	6a 01                	push   $0x1
-     d31:	e8 0a 2e 00 00       	call   3b40 <printf>
-     d36:	83 c4 10             	add    $0x10,%esp
-     d39:	e9 45 ff ff ff       	jmp    c83 <preempt+0x83>
-    printf(1, "preempt read error");
-     d3e:	83 ec 08             	sub    $0x8,%esp
-     d41:	68 5a 42 00 00       	push   $0x425a
-     d46:	6a 01                	push   $0x1
-     d48:	e8 f3 2d 00 00       	call   3b40 <printf>
-    return;
-     d4d:	83 c4 10             	add    $0x10,%esp
-     d50:	eb cd                	jmp    d1f <preempt+0x11f>
-     d52:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     d59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-00000d60 <exitwait>:
-{
-     d60:	f3 0f 1e fb          	endbr32 
-     d64:	55                   	push   %ebp
-     d65:	89 e5                	mov    %esp,%ebp
-     d67:	56                   	push   %esi
-     d68:	be 64 00 00 00       	mov    $0x64,%esi
-     d6d:	53                   	push   %ebx
-     d6e:	eb 10                	jmp    d80 <exitwait+0x20>
-    if(pid){
-     d70:	74 68                	je     dda <exitwait+0x7a>
-      if(wait() != pid){
-     d72:	e8 14 2c 00 00       	call   398b <wait>
-     d77:	39 d8                	cmp    %ebx,%eax
-     d79:	75 2d                	jne    da8 <exitwait+0x48>
-  for(i = 0; i < 100; i++){
-     d7b:	83 ee 01             	sub    $0x1,%esi
-     d7e:	74 41                	je     dc1 <exitwait+0x61>
-    pid = fork();
-     d80:	e8 f6 2b 00 00       	call   397b <fork>
-     d85:	89 c3                	mov    %eax,%ebx
-    if(pid < 0){
-     d87:	85 c0                	test   %eax,%eax
-     d89:	79 e5                	jns    d70 <exitwait+0x10>
-      printf(1, "fork failed\n");
-     d8b:	83 ec 08             	sub    $0x8,%esp
-     d8e:	68 e9 4d 00 00       	push   $0x4de9
-     d93:	6a 01                	push   $0x1
-     d95:	e8 a6 2d 00 00       	call   3b40 <printf>
-      return;
-     d9a:	83 c4 10             	add    $0x10,%esp
-}
-     d9d:	8d 65 f8             	lea    -0x8(%ebp),%esp
-     da0:	5b                   	pop    %ebx
-     da1:	5e                   	pop    %esi
-     da2:	5d                   	pop    %ebp
-     da3:	c3                   	ret    
-     da4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        printf(1, "wait wrong pid\n");
-     da8:	83 ec 08             	sub    $0x8,%esp
-     dab:	68 8b 42 00 00       	push   $0x428b
-     db0:	6a 01                	push   $0x1
-     db2:	e8 89 2d 00 00       	call   3b40 <printf>
-        return;
-     db7:	83 c4 10             	add    $0x10,%esp
-}
-     dba:	8d 65 f8             	lea    -0x8(%ebp),%esp
-     dbd:	5b                   	pop    %ebx
-     dbe:	5e                   	pop    %esi
-     dbf:	5d                   	pop    %ebp
-     dc0:	c3                   	ret    
-  printf(1, "exitwait ok\n");
-     dc1:	83 ec 08             	sub    $0x8,%esp
-     dc4:	68 9b 42 00 00       	push   $0x429b
-     dc9:	6a 01                	push   $0x1
-     dcb:	e8 70 2d 00 00       	call   3b40 <printf>
-     dd0:	83 c4 10             	add    $0x10,%esp
-}
-     dd3:	8d 65 f8             	lea    -0x8(%ebp),%esp
-     dd6:	5b                   	pop    %ebx
-     dd7:	5e                   	pop    %esi
-     dd8:	5d                   	pop    %ebp
-     dd9:	c3                   	ret    
-      exit();
-     dda:	e8 a4 2b 00 00       	call   3983 <exit>
-     ddf:	90                   	nop
-
-00000de0 <mem>:
-{
-     de0:	f3 0f 1e fb          	endbr32 
-     de4:	55                   	push   %ebp
-     de5:	89 e5                	mov    %esp,%ebp
-     de7:	56                   	push   %esi
-     de8:	31 f6                	xor    %esi,%esi
-     dea:	53                   	push   %ebx
-  printf(1, "mem test\n");
-     deb:	83 ec 08             	sub    $0x8,%esp
-     dee:	68 a8 42 00 00       	push   $0x42a8
-     df3:	6a 01                	push   $0x1
-     df5:	e8 46 2d 00 00       	call   3b40 <printf>
-  ppid = getpid();
-     dfa:	e8 04 2c 00 00       	call   3a03 <getpid>
-     dff:	89 c3                	mov    %eax,%ebx
-  if((pid = fork()) == 0){
-     e01:	e8 75 2b 00 00       	call   397b <fork>
-     e06:	83 c4 10             	add    $0x10,%esp
-     e09:	85 c0                	test   %eax,%eax
-     e0b:	74 0f                	je     e1c <mem+0x3c>
-     e0d:	e9 8e 00 00 00       	jmp    ea0 <mem+0xc0>
-     e12:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-      *(char**)m2 = m1;
-     e18:	89 30                	mov    %esi,(%eax)
-     e1a:	89 c6                	mov    %eax,%esi
-    while((m2 = malloc(10001)) != 0){
-     e1c:	83 ec 0c             	sub    $0xc,%esp
-     e1f:	68 11 27 00 00       	push   $0x2711
-     e24:	e8 77 2f 00 00       	call   3da0 <malloc>
-     e29:	83 c4 10             	add    $0x10,%esp
-     e2c:	85 c0                	test   %eax,%eax
-     e2e:	75 e8                	jne    e18 <mem+0x38>
-    while(m1){
-     e30:	85 f6                	test   %esi,%esi
-     e32:	74 18                	je     e4c <mem+0x6c>
-     e34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-      m2 = *(char**)m1;
-     e38:	89 f0                	mov    %esi,%eax
-      free(m1);
-     e3a:	83 ec 0c             	sub    $0xc,%esp
-      m2 = *(char**)m1;
-     e3d:	8b 36                	mov    (%esi),%esi
-      free(m1);
-     e3f:	50                   	push   %eax
-     e40:	e8 cb 2e 00 00       	call   3d10 <free>
-    while(m1){
-     e45:	83 c4 10             	add    $0x10,%esp
-     e48:	85 f6                	test   %esi,%esi
-     e4a:	75 ec                	jne    e38 <mem+0x58>
-    m1 = malloc(1024*20);
-     e4c:	83 ec 0c             	sub    $0xc,%esp
-     e4f:	68 00 50 00 00       	push   $0x5000
-     e54:	e8 47 2f 00 00       	call   3da0 <malloc>
-    if(m1 == 0){
-     e59:	83 c4 10             	add    $0x10,%esp
-     e5c:	85 c0                	test   %eax,%eax
-     e5e:	74 20                	je     e80 <mem+0xa0>
-    free(m1);
-     e60:	83 ec 0c             	sub    $0xc,%esp
-     e63:	50                   	push   %eax
-     e64:	e8 a7 2e 00 00       	call   3d10 <free>
-    printf(1, "mem ok\n");
-     e69:	58                   	pop    %eax
-     e6a:	5a                   	pop    %edx
-     e6b:	68 cc 42 00 00       	push   $0x42cc
-     e70:	6a 01                	push   $0x1
-     e72:	e8 c9 2c 00 00       	call   3b40 <printf>
-    exit();
-     e77:	e8 07 2b 00 00       	call   3983 <exit>
-     e7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-      printf(1, "couldn't allocate mem?!!\n");
-     e80:	83 ec 08             	sub    $0x8,%esp
-     e83:	68 b2 42 00 00       	push   $0x42b2
-     e88:	6a 01                	push   $0x1
-     e8a:	e8 b1 2c 00 00       	call   3b40 <printf>
-      kill(ppid);
-     e8f:	89 1c 24             	mov    %ebx,(%esp)
-     e92:	e8 1c 2b 00 00       	call   39b3 <kill>
-      exit();
-     e97:	e8 e7 2a 00 00       	call   3983 <exit>
-     e9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-}
-     ea0:	8d 65 f8             	lea    -0x8(%ebp),%esp
-     ea3:	5b                   	pop    %ebx
-     ea4:	5e                   	pop    %esi
-     ea5:	5d                   	pop    %ebp
-    wait();
-     ea6:	e9 e0 2a 00 00       	jmp    398b <wait>
-     eab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-     eaf:	90                   	nop
-
-00000eb0 <sharedfd>:
-{
-     eb0:	f3 0f 1e fb          	endbr32 
-     eb4:	55                   	push   %ebp
-     eb5:	89 e5                	mov    %esp,%ebp
-     eb7:	57                   	push   %edi
-     eb8:	56                   	push   %esi
-     eb9:	53                   	push   %ebx
-     eba:	83 ec 34             	sub    $0x34,%esp
-  printf(1, "sharedfd test\n");
-     ebd:	68 d4 42 00 00       	push   $0x42d4
-     ec2:	6a 01                	push   $0x1
-     ec4:	e8 77 2c 00 00       	call   3b40 <printf>
-  unlink("sharedfd");
-     ec9:	c7 04 24 e3 42 00 00 	movl   $0x42e3,(%esp)
-     ed0:	e8 fe 2a 00 00       	call   39d3 <unlink>
-  fd = open("sharedfd", O_CREATE|O_RDWR);
-     ed5:	5b                   	pop    %ebx
-     ed6:	5e                   	pop    %esi
-     ed7:	68 02 02 00 00       	push   $0x202
-     edc:	68 e3 42 00 00       	push   $0x42e3
-     ee1:	e8 dd 2a 00 00       	call   39c3 <open>
-  if(fd < 0){
-     ee6:	83 c4 10             	add    $0x10,%esp
-     ee9:	85 c0                	test   %eax,%eax
-     eeb:	0f 88 26 01 00 00    	js     1017 <sharedfd+0x167>
-     ef1:	89 c7                	mov    %eax,%edi
-  memset(buf, pid==0?'c':'p', sizeof(buf));
-     ef3:	8d 75 de             	lea    -0x22(%ebp),%esi
-     ef6:	bb e8 03 00 00       	mov    $0x3e8,%ebx
-  pid = fork();
-     efb:	e8 7b 2a 00 00       	call   397b <fork>
-  memset(buf, pid==0?'c':'p', sizeof(buf));
-     f00:	83 f8 01             	cmp    $0x1,%eax
-  pid = fork();
-     f03:	89 45 d4             	mov    %eax,-0x2c(%ebp)
-  memset(buf, pid==0?'c':'p', sizeof(buf));
-     f06:	19 c0                	sbb    %eax,%eax
-     f08:	83 ec 04             	sub    $0x4,%esp
-     f0b:	83 e0 f3             	and    $0xfffffff3,%eax
-     f0e:	6a 0a                	push   $0xa
-     f10:	83 c0 70             	add    $0x70,%eax
-     f13:	50                   	push   %eax
-     f14:	56                   	push   %esi
-     f15:	e8 c6 28 00 00       	call   37e0 <memset>
-     f1a:	83 c4 10             	add    $0x10,%esp
-     f1d:	eb 06                	jmp    f25 <sharedfd+0x75>
-     f1f:	90                   	nop
-  for(i = 0; i < 1000; i++){
-     f20:	83 eb 01             	sub    $0x1,%ebx
-     f23:	74 26                	je     f4b <sharedfd+0x9b>
-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
-     f25:	83 ec 04             	sub    $0x4,%esp
-     f28:	6a 0a                	push   $0xa
-     f2a:	56                   	push   %esi
-     f2b:	57                   	push   %edi
-     f2c:	e8 72 2a 00 00       	call   39a3 <write>
-     f31:	83 c4 10             	add    $0x10,%esp
-     f34:	83 f8 0a             	cmp    $0xa,%eax
-     f37:	74 e7                	je     f20 <sharedfd+0x70>
-      printf(1, "fstests: write sharedfd failed\n");
-     f39:	83 ec 08             	sub    $0x8,%esp
-     f3c:	68 d4 4f 00 00       	push   $0x4fd4
-     f41:	6a 01                	push   $0x1
-     f43:	e8 f8 2b 00 00       	call   3b40 <printf>
-      break;
-     f48:	83 c4 10             	add    $0x10,%esp
-  if(pid == 0)
-     f4b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
-     f4e:	85 c9                	test   %ecx,%ecx
-     f50:	0f 84 f5 00 00 00    	je     104b <sharedfd+0x19b>
-    wait();
-     f56:	e8 30 2a 00 00       	call   398b <wait>
-  close(fd);
-     f5b:	83 ec 0c             	sub    $0xc,%esp
-  nc = np = 0;
-     f5e:	31 db                	xor    %ebx,%ebx
-  close(fd);
-     f60:	57                   	push   %edi
-     f61:	8d 7d e8             	lea    -0x18(%ebp),%edi
-     f64:	e8 42 2a 00 00       	call   39ab <close>
-  fd = open("sharedfd", 0);
-     f69:	58                   	pop    %eax
-     f6a:	5a                   	pop    %edx
-     f6b:	6a 00                	push   $0x0
-     f6d:	68 e3 42 00 00       	push   $0x42e3
-     f72:	e8 4c 2a 00 00       	call   39c3 <open>
-  if(fd < 0){
-     f77:	83 c4 10             	add    $0x10,%esp
-  nc = np = 0;
-     f7a:	31 d2                	xor    %edx,%edx
-  fd = open("sharedfd", 0);
-     f7c:	89 45 d0             	mov    %eax,-0x30(%ebp)
-  if(fd < 0){
-     f7f:	85 c0                	test   %eax,%eax
-     f81:	0f 88 aa 00 00 00    	js     1031 <sharedfd+0x181>
-     f87:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-     f8e:	66 90                	xchg   %ax,%ax
-  while((n = read(fd, buf, sizeof(buf))) > 0){
-     f90:	83 ec 04             	sub    $0x4,%esp
-     f93:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-     f96:	6a 0a                	push   $0xa
-     f98:	56                   	push   %esi
-     f99:	ff 75 d0             	pushl  -0x30(%ebp)
-     f9c:	e8 fa 29 00 00       	call   399b <read>
-     fa1:	83 c4 10             	add    $0x10,%esp
-     fa4:	85 c0                	test   %eax,%eax
-     fa6:	7e 28                	jle    fd0 <sharedfd+0x120>
-    for(i = 0; i < sizeof(buf); i++){
-     fa8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-     fab:	89 f0                	mov    %esi,%eax
-     fad:	eb 13                	jmp    fc2 <sharedfd+0x112>
-     faf:	90                   	nop
-        np++;
-     fb0:	80 f9 70             	cmp    $0x70,%cl
-     fb3:	0f 94 c1             	sete   %cl
-     fb6:	0f b6 c9             	movzbl %cl,%ecx
-     fb9:	01 cb                	add    %ecx,%ebx
-    for(i = 0; i < sizeof(buf); i++){
-     fbb:	83 c0 01             	add    $0x1,%eax
-     fbe:	39 c7                	cmp    %eax,%edi
-     fc0:	74 ce                	je     f90 <sharedfd+0xe0>
-      if(buf[i] == 'c')
-     fc2:	0f b6 08             	movzbl (%eax),%ecx
-     fc5:	80 f9 63             	cmp    $0x63,%cl
-     fc8:	75 e6                	jne    fb0 <sharedfd+0x100>
-        nc++;
-     fca:	83 c2 01             	add    $0x1,%edx
-      if(buf[i] == 'p')
-     fcd:	eb ec                	jmp    fbb <sharedfd+0x10b>
-     fcf:	90                   	nop
-  close(fd);
-     fd0:	83 ec 0c             	sub    $0xc,%esp
-     fd3:	ff 75 d0             	pushl  -0x30(%ebp)
-     fd6:	e8 d0 29 00 00       	call   39ab <close>
-  unlink("sharedfd");
-     fdb:	c7 04 24 e3 42 00 00 	movl   $0x42e3,(%esp)
-     fe2:	e8 ec 29 00 00       	call   39d3 <unlink>
-  if(nc == 10000 && np == 10000){
-     fe7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-     fea:	83 c4 10             	add    $0x10,%esp
-     fed:	81 fa 10 27 00 00    	cmp    $0x2710,%edx
-     ff3:	75 5b                	jne    1050 <sharedfd+0x1a0>
-     ff5:	81 fb 10 27 00 00    	cmp    $0x2710,%ebx
-     ffb:	75 53                	jne    1050 <sharedfd+0x1a0>
-    printf(1, "sharedfd ok\n");
-     ffd:	83 ec 08             	sub    $0x8,%esp
-    1000:	68 ec 42 00 00       	push   $0x42ec
-    1005:	6a 01                	push   $0x1
-    1007:	e8 34 2b 00 00       	call   3b40 <printf>
-    100c:	83 c4 10             	add    $0x10,%esp
-}
-    100f:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    1012:	5b                   	pop    %ebx
-    1013:	5e                   	pop    %esi
-    1014:	5f                   	pop    %edi
-    1015:	5d                   	pop    %ebp
-    1016:	c3                   	ret    
-    printf(1, "fstests: cannot open sharedfd for writing");
-    1017:	83 ec 08             	sub    $0x8,%esp
-    101a:	68 a8 4f 00 00       	push   $0x4fa8
-    101f:	6a 01                	push   $0x1
-    1021:	e8 1a 2b 00 00       	call   3b40 <printf>
-    return;
-    1026:	83 c4 10             	add    $0x10,%esp
-}
-    1029:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    102c:	5b                   	pop    %ebx
-    102d:	5e                   	pop    %esi
-    102e:	5f                   	pop    %edi
-    102f:	5d                   	pop    %ebp
-    1030:	c3                   	ret    
-    printf(1, "fstests: cannot open sharedfd for reading\n");
-    1031:	83 ec 08             	sub    $0x8,%esp
-    1034:	68 f4 4f 00 00       	push   $0x4ff4
-    1039:	6a 01                	push   $0x1
-    103b:	e8 00 2b 00 00       	call   3b40 <printf>
-    return;
-    1040:	83 c4 10             	add    $0x10,%esp
-}
-    1043:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    1046:	5b                   	pop    %ebx
-    1047:	5e                   	pop    %esi
-    1048:	5f                   	pop    %edi
-    1049:	5d                   	pop    %ebp
-    104a:	c3                   	ret    
-    exit();
-    104b:	e8 33 29 00 00       	call   3983 <exit>
-    printf(1, "sharedfd oops %d %d\n", nc, np);
-    1050:	53                   	push   %ebx
-    1051:	52                   	push   %edx
-    1052:	68 f9 42 00 00       	push   $0x42f9
-    1057:	6a 01                	push   $0x1
-    1059:	e8 e2 2a 00 00       	call   3b40 <printf>
-    exit();
-    105e:	e8 20 29 00 00       	call   3983 <exit>
-    1063:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    106a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00001070 <fourfiles>:
-{
-    1070:	f3 0f 1e fb          	endbr32 
-    1074:	55                   	push   %ebp
-    1075:	89 e5                	mov    %esp,%ebp
-    1077:	57                   	push   %edi
-    1078:	56                   	push   %esi
-  printf(1, "fourfiles test\n");
-    1079:	be 0e 43 00 00       	mov    $0x430e,%esi
-{
-    107e:	53                   	push   %ebx
-  for(pi = 0; pi < 4; pi++){
-    107f:	31 db                	xor    %ebx,%ebx
-{
-    1081:	83 ec 34             	sub    $0x34,%esp
-  char *names[] = { "f0", "f1", "f2", "f3" };
-    1084:	c7 45 d8 0e 43 00 00 	movl   $0x430e,-0x28(%ebp)
-  printf(1, "fourfiles test\n");
-    108b:	68 14 43 00 00       	push   $0x4314
-    1090:	6a 01                	push   $0x1
-  char *names[] = { "f0", "f1", "f2", "f3" };
-    1092:	c7 45 dc 57 44 00 00 	movl   $0x4457,-0x24(%ebp)
-    1099:	c7 45 e0 5b 44 00 00 	movl   $0x445b,-0x20(%ebp)
-    10a0:	c7 45 e4 11 43 00 00 	movl   $0x4311,-0x1c(%ebp)
-  printf(1, "fourfiles test\n");
-    10a7:	e8 94 2a 00 00       	call   3b40 <printf>
-    10ac:	83 c4 10             	add    $0x10,%esp
-    unlink(fname);
-    10af:	83 ec 0c             	sub    $0xc,%esp
-    10b2:	56                   	push   %esi
-    10b3:	e8 1b 29 00 00       	call   39d3 <unlink>
-    pid = fork();
-    10b8:	e8 be 28 00 00       	call   397b <fork>
-    if(pid < 0){
-    10bd:	83 c4 10             	add    $0x10,%esp
-    10c0:	85 c0                	test   %eax,%eax
-    10c2:	0f 88 60 01 00 00    	js     1228 <fourfiles+0x1b8>
-    if(pid == 0){
-    10c8:	0f 84 e5 00 00 00    	je     11b3 <fourfiles+0x143>
-  for(pi = 0; pi < 4; pi++){
-    10ce:	83 c3 01             	add    $0x1,%ebx
-    10d1:	83 fb 04             	cmp    $0x4,%ebx
-    10d4:	74 06                	je     10dc <fourfiles+0x6c>
-    10d6:	8b 74 9d d8          	mov    -0x28(%ebp,%ebx,4),%esi
-    10da:	eb d3                	jmp    10af <fourfiles+0x3f>
-    wait();
-    10dc:	e8 aa 28 00 00       	call   398b <wait>
-  for(i = 0; i < 2; i++){
-    10e1:	31 f6                	xor    %esi,%esi
-    wait();
-    10e3:	e8 a3 28 00 00       	call   398b <wait>
-    10e8:	e8 9e 28 00 00       	call   398b <wait>
-    10ed:	e8 99 28 00 00       	call   398b <wait>
-    fname = names[i];
-    10f2:	8b 44 b5 d8          	mov    -0x28(%ebp,%esi,4),%eax
-    fd = open(fname, 0);
-    10f6:	83 ec 08             	sub    $0x8,%esp
-    total = 0;
-    10f9:	31 db                	xor    %ebx,%ebx
-    fd = open(fname, 0);
-    10fb:	6a 00                	push   $0x0
-    10fd:	50                   	push   %eax
-    fname = names[i];
-    10fe:	89 45 d0             	mov    %eax,-0x30(%ebp)
-    fd = open(fname, 0);
-    1101:	e8 bd 28 00 00       	call   39c3 <open>
-    while((n = read(fd, buf, sizeof(buf))) > 0){
-    1106:	83 c4 10             	add    $0x10,%esp
-    fd = open(fname, 0);
-    1109:	89 45 d4             	mov    %eax,-0x2c(%ebp)
-    while((n = read(fd, buf, sizeof(buf))) > 0){
-    110c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    1110:	83 ec 04             	sub    $0x4,%esp
-    1113:	68 00 20 00 00       	push   $0x2000
-    1118:	68 20 87 00 00       	push   $0x8720
-    111d:	ff 75 d4             	pushl  -0x2c(%ebp)
-    1120:	e8 76 28 00 00       	call   399b <read>
-    1125:	83 c4 10             	add    $0x10,%esp
-    1128:	85 c0                	test   %eax,%eax
-    112a:	7e 22                	jle    114e <fourfiles+0xde>
-      for(j = 0; j < n; j++){
-    112c:	31 d2                	xor    %edx,%edx
-    112e:	66 90                	xchg   %ax,%ax
-        if(buf[j] != '0'+i){
-    1130:	83 fe 01             	cmp    $0x1,%esi
-    1133:	0f be ba 20 87 00 00 	movsbl 0x8720(%edx),%edi
-    113a:	19 c9                	sbb    %ecx,%ecx
-    113c:	83 c1 31             	add    $0x31,%ecx
-    113f:	39 cf                	cmp    %ecx,%edi
-    1141:	75 5c                	jne    119f <fourfiles+0x12f>
-      for(j = 0; j < n; j++){
-    1143:	83 c2 01             	add    $0x1,%edx
-    1146:	39 d0                	cmp    %edx,%eax
-    1148:	75 e6                	jne    1130 <fourfiles+0xc0>
-      total += n;
-    114a:	01 c3                	add    %eax,%ebx
-    114c:	eb c2                	jmp    1110 <fourfiles+0xa0>
-    close(fd);
-    114e:	83 ec 0c             	sub    $0xc,%esp
-    1151:	ff 75 d4             	pushl  -0x2c(%ebp)
-    1154:	e8 52 28 00 00       	call   39ab <close>
-    if(total != 12*500){
-    1159:	83 c4 10             	add    $0x10,%esp
-    115c:	81 fb 70 17 00 00    	cmp    $0x1770,%ebx
-    1162:	0f 85 d4 00 00 00    	jne    123c <fourfiles+0x1cc>
-    unlink(fname);
-    1168:	83 ec 0c             	sub    $0xc,%esp
-    116b:	ff 75 d0             	pushl  -0x30(%ebp)
-    116e:	e8 60 28 00 00       	call   39d3 <unlink>
-  for(i = 0; i < 2; i++){
-    1173:	83 c4 10             	add    $0x10,%esp
-    1176:	83 fe 01             	cmp    $0x1,%esi
-    1179:	75 1a                	jne    1195 <fourfiles+0x125>
-  printf(1, "fourfiles ok\n");
-    117b:	83 ec 08             	sub    $0x8,%esp
-    117e:	68 52 43 00 00       	push   $0x4352
-    1183:	6a 01                	push   $0x1
-    1185:	e8 b6 29 00 00       	call   3b40 <printf>
-}
-    118a:	83 c4 10             	add    $0x10,%esp
-    118d:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    1190:	5b                   	pop    %ebx
-    1191:	5e                   	pop    %esi
-    1192:	5f                   	pop    %edi
-    1193:	5d                   	pop    %ebp
-    1194:	c3                   	ret    
-    1195:	be 01 00 00 00       	mov    $0x1,%esi
-    119a:	e9 53 ff ff ff       	jmp    10f2 <fourfiles+0x82>
-          printf(1, "wrong char\n");
-    119f:	83 ec 08             	sub    $0x8,%esp
-    11a2:	68 35 43 00 00       	push   $0x4335
-    11a7:	6a 01                	push   $0x1
-    11a9:	e8 92 29 00 00       	call   3b40 <printf>
-          exit();
-    11ae:	e8 d0 27 00 00       	call   3983 <exit>
-      fd = open(fname, O_CREATE | O_RDWR);
-    11b3:	83 ec 08             	sub    $0x8,%esp
-    11b6:	68 02 02 00 00       	push   $0x202
-    11bb:	56                   	push   %esi
-    11bc:	e8 02 28 00 00       	call   39c3 <open>
-      if(fd < 0){
-    11c1:	83 c4 10             	add    $0x10,%esp
-      fd = open(fname, O_CREATE | O_RDWR);
-    11c4:	89 c6                	mov    %eax,%esi
-      if(fd < 0){
-    11c6:	85 c0                	test   %eax,%eax
-    11c8:	78 45                	js     120f <fourfiles+0x19f>
-      memset(buf, '0'+pi, 512);
-    11ca:	83 ec 04             	sub    $0x4,%esp
-    11cd:	83 c3 30             	add    $0x30,%ebx
-    11d0:	68 00 02 00 00       	push   $0x200
-    11d5:	53                   	push   %ebx
-    11d6:	bb 0c 00 00 00       	mov    $0xc,%ebx
-    11db:	68 20 87 00 00       	push   $0x8720
-    11e0:	e8 fb 25 00 00       	call   37e0 <memset>
-    11e5:	83 c4 10             	add    $0x10,%esp
-        if((n = write(fd, buf, 500)) != 500){
-    11e8:	83 ec 04             	sub    $0x4,%esp
-    11eb:	68 f4 01 00 00       	push   $0x1f4
-    11f0:	68 20 87 00 00       	push   $0x8720
-    11f5:	56                   	push   %esi
-    11f6:	e8 a8 27 00 00       	call   39a3 <write>
-    11fb:	83 c4 10             	add    $0x10,%esp
-    11fe:	3d f4 01 00 00       	cmp    $0x1f4,%eax
-    1203:	75 4a                	jne    124f <fourfiles+0x1df>
-      for(i = 0; i < 12; i++){
-    1205:	83 eb 01             	sub    $0x1,%ebx
-    1208:	75 de                	jne    11e8 <fourfiles+0x178>
-      exit();
-    120a:	e8 74 27 00 00       	call   3983 <exit>
-        printf(1, "create failed\n");
-    120f:	51                   	push   %ecx
-    1210:	51                   	push   %ecx
-    1211:	68 af 45 00 00       	push   $0x45af
-    1216:	6a 01                	push   $0x1
-    1218:	e8 23 29 00 00       	call   3b40 <printf>
-        exit();
-    121d:	e8 61 27 00 00       	call   3983 <exit>
-    1222:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-      printf(1, "fork failed\n");
-    1228:	83 ec 08             	sub    $0x8,%esp
-    122b:	68 e9 4d 00 00       	push   $0x4de9
-    1230:	6a 01                	push   $0x1
-    1232:	e8 09 29 00 00       	call   3b40 <printf>
-      exit();
-    1237:	e8 47 27 00 00       	call   3983 <exit>
-      printf(1, "wrong length %d\n", total);
-    123c:	50                   	push   %eax
-    123d:	53                   	push   %ebx
-    123e:	68 41 43 00 00       	push   $0x4341
-    1243:	6a 01                	push   $0x1
-    1245:	e8 f6 28 00 00       	call   3b40 <printf>
-      exit();
-    124a:	e8 34 27 00 00       	call   3983 <exit>
-          printf(1, "write failed %d\n", n);
-    124f:	52                   	push   %edx
-    1250:	50                   	push   %eax
-    1251:	68 24 43 00 00       	push   $0x4324
-    1256:	6a 01                	push   $0x1
-    1258:	e8 e3 28 00 00       	call   3b40 <printf>
-          exit();
-    125d:	e8 21 27 00 00       	call   3983 <exit>
-    1262:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    1269:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-00001270 <createdelete>:
-{
-    1270:	f3 0f 1e fb          	endbr32 
-    1274:	55                   	push   %ebp
-    1275:	89 e5                	mov    %esp,%ebp
-    1277:	57                   	push   %edi
-    1278:	56                   	push   %esi
-    1279:	53                   	push   %ebx
-  for(pi = 0; pi < 4; pi++){
-    127a:	31 db                	xor    %ebx,%ebx
-{
-    127c:	83 ec 44             	sub    $0x44,%esp
-  printf(1, "createdelete test\n");
-    127f:	68 60 43 00 00       	push   $0x4360
-    1284:	6a 01                	push   $0x1
-    1286:	e8 b5 28 00 00       	call   3b40 <printf>
-    128b:	83 c4 10             	add    $0x10,%esp
-    pid = fork();
-    128e:	e8 e8 26 00 00       	call   397b <fork>
-    if(pid < 0){
-    1293:	85 c0                	test   %eax,%eax
-    1295:	0f 88 ce 01 00 00    	js     1469 <createdelete+0x1f9>
-    if(pid == 0){
-    129b:	0f 84 17 01 00 00    	je     13b8 <createdelete+0x148>
-  for(pi = 0; pi < 4; pi++){
-    12a1:	83 c3 01             	add    $0x1,%ebx
-    12a4:	83 fb 04             	cmp    $0x4,%ebx
-    12a7:	75 e5                	jne    128e <createdelete+0x1e>
-    wait();
-    12a9:	e8 dd 26 00 00       	call   398b <wait>
-    12ae:	8d 7d c8             	lea    -0x38(%ebp),%edi
-  name[0] = name[1] = name[2] = 0;
-    12b1:	be ff ff ff ff       	mov    $0xffffffff,%esi
-    wait();
-    12b6:	e8 d0 26 00 00       	call   398b <wait>
-    12bb:	e8 cb 26 00 00       	call   398b <wait>
-    12c0:	e8 c6 26 00 00       	call   398b <wait>
-  name[0] = name[1] = name[2] = 0;
-    12c5:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
-  for(i = 0; i < N; i++){
-    12c9:	89 7d c0             	mov    %edi,-0x40(%ebp)
-    12cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    for(pi = 0; pi < 4; pi++){
-    12d0:	8d 46 31             	lea    0x31(%esi),%eax
-    12d3:	89 f7                	mov    %esi,%edi
-    12d5:	83 c6 01             	add    $0x1,%esi
-    12d8:	83 fe 09             	cmp    $0x9,%esi
-    12db:	88 45 c7             	mov    %al,-0x39(%ebp)
-    12de:	0f 9f c3             	setg   %bl
-    12e1:	85 f6                	test   %esi,%esi
-    12e3:	0f 94 c0             	sete   %al
-    12e6:	09 c3                	or     %eax,%ebx
-    12e8:	88 5d c6             	mov    %bl,-0x3a(%ebp)
-      name[2] = '\0';
-    12eb:	bb 70 00 00 00       	mov    $0x70,%ebx
-      fd = open(name, 0);
-    12f0:	83 ec 08             	sub    $0x8,%esp
-      name[1] = '0' + i;
-    12f3:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
-      name[0] = 'p' + pi;
-    12f7:	88 5d c8             	mov    %bl,-0x38(%ebp)
-      fd = open(name, 0);
-    12fa:	6a 00                	push   $0x0
-    12fc:	ff 75 c0             	pushl  -0x40(%ebp)
-      name[1] = '0' + i;
-    12ff:	88 45 c9             	mov    %al,-0x37(%ebp)
-      fd = open(name, 0);
-    1302:	e8 bc 26 00 00       	call   39c3 <open>
-      if((i == 0 || i >= N/2) && fd < 0){
-    1307:	83 c4 10             	add    $0x10,%esp
-    130a:	80 7d c6 00          	cmpb   $0x0,-0x3a(%ebp)
-    130e:	0f 84 8c 00 00 00    	je     13a0 <createdelete+0x130>
-    1314:	85 c0                	test   %eax,%eax
-    1316:	0f 88 21 01 00 00    	js     143d <createdelete+0x1cd>
-      } else if((i >= 1 && i < N/2) && fd >= 0){
-    131c:	83 ff 08             	cmp    $0x8,%edi
-    131f:	0f 86 60 01 00 00    	jbe    1485 <createdelete+0x215>
-        close(fd);
-    1325:	83 ec 0c             	sub    $0xc,%esp
-    1328:	50                   	push   %eax
-    1329:	e8 7d 26 00 00       	call   39ab <close>
-    132e:	83 c4 10             	add    $0x10,%esp
-    for(pi = 0; pi < 4; pi++){
-    1331:	83 c3 01             	add    $0x1,%ebx
-    1334:	80 fb 74             	cmp    $0x74,%bl
-    1337:	75 b7                	jne    12f0 <createdelete+0x80>
-  for(i = 0; i < N; i++){
-    1339:	83 fe 13             	cmp    $0x13,%esi
-    133c:	75 92                	jne    12d0 <createdelete+0x60>
-    133e:	8b 7d c0             	mov    -0x40(%ebp),%edi
-    1341:	be 70 00 00 00       	mov    $0x70,%esi
-    1346:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    134d:	8d 76 00             	lea    0x0(%esi),%esi
-    for(pi = 0; pi < 4; pi++){
-    1350:	8d 46 c0             	lea    -0x40(%esi),%eax
-  name[0] = name[1] = name[2] = 0;
-    1353:	bb 04 00 00 00       	mov    $0x4,%ebx
-    1358:	88 45 c7             	mov    %al,-0x39(%ebp)
-      unlink(name);
-    135b:	83 ec 0c             	sub    $0xc,%esp
-      name[0] = 'p' + i;
-    135e:	89 f0                	mov    %esi,%eax
-      unlink(name);
-    1360:	57                   	push   %edi
-      name[0] = 'p' + i;
-    1361:	88 45 c8             	mov    %al,-0x38(%ebp)
-      name[1] = '0' + i;
-    1364:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
-    1368:	88 45 c9             	mov    %al,-0x37(%ebp)
-      unlink(name);
-    136b:	e8 63 26 00 00       	call   39d3 <unlink>
-    for(pi = 0; pi < 4; pi++){
-    1370:	83 c4 10             	add    $0x10,%esp
-    1373:	83 eb 01             	sub    $0x1,%ebx
-    1376:	75 e3                	jne    135b <createdelete+0xeb>
-  for(i = 0; i < N; i++){
-    1378:	83 c6 01             	add    $0x1,%esi
-    137b:	89 f0                	mov    %esi,%eax
-    137d:	3c 84                	cmp    $0x84,%al
-    137f:	75 cf                	jne    1350 <createdelete+0xe0>
-  printf(1, "createdelete ok\n");
-    1381:	83 ec 08             	sub    $0x8,%esp
-    1384:	68 73 43 00 00       	push   $0x4373
-    1389:	6a 01                	push   $0x1
-    138b:	e8 b0 27 00 00       	call   3b40 <printf>
-}
-    1390:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    1393:	5b                   	pop    %ebx
-    1394:	5e                   	pop    %esi
-    1395:	5f                   	pop    %edi
-    1396:	5d                   	pop    %ebp
-    1397:	c3                   	ret    
-    1398:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    139f:	90                   	nop
-      } else if((i >= 1 && i < N/2) && fd >= 0){
-    13a0:	83 ff 08             	cmp    $0x8,%edi
-    13a3:	0f 86 d4 00 00 00    	jbe    147d <createdelete+0x20d>
-      if(fd >= 0)
-    13a9:	85 c0                	test   %eax,%eax
-    13ab:	78 84                	js     1331 <createdelete+0xc1>
-    13ad:	e9 73 ff ff ff       	jmp    1325 <createdelete+0xb5>
-    13b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-      name[0] = 'p' + pi;
-    13b8:	83 c3 70             	add    $0x70,%ebx
-      name[2] = '\0';
-    13bb:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
-    13bf:	8d 7d c8             	lea    -0x38(%ebp),%edi
-      name[0] = 'p' + pi;
-    13c2:	88 5d c8             	mov    %bl,-0x38(%ebp)
-      name[2] = '\0';
-    13c5:	31 db                	xor    %ebx,%ebx
-    13c7:	eb 0f                	jmp    13d8 <createdelete+0x168>
-    13c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      for(i = 0; i < N; i++){
-    13d0:	83 fb 13             	cmp    $0x13,%ebx
-    13d3:	74 63                	je     1438 <createdelete+0x1c8>
-    13d5:	83 c3 01             	add    $0x1,%ebx
-        fd = open(name, O_CREATE | O_RDWR);
-    13d8:	83 ec 08             	sub    $0x8,%esp
-        name[1] = '0' + i;
-    13db:	8d 43 30             	lea    0x30(%ebx),%eax
-        fd = open(name, O_CREATE | O_RDWR);
-    13de:	68 02 02 00 00       	push   $0x202
-    13e3:	57                   	push   %edi
-        name[1] = '0' + i;
-    13e4:	88 45 c9             	mov    %al,-0x37(%ebp)
-        fd = open(name, O_CREATE | O_RDWR);
-    13e7:	e8 d7 25 00 00       	call   39c3 <open>
-        if(fd < 0){
-    13ec:	83 c4 10             	add    $0x10,%esp
-    13ef:	85 c0                	test   %eax,%eax
-    13f1:	78 62                	js     1455 <createdelete+0x1e5>
-        close(fd);
-    13f3:	83 ec 0c             	sub    $0xc,%esp
-    13f6:	50                   	push   %eax
-    13f7:	e8 af 25 00 00       	call   39ab <close>
-        if(i > 0 && (i % 2 ) == 0){
-    13fc:	83 c4 10             	add    $0x10,%esp
-    13ff:	85 db                	test   %ebx,%ebx
-    1401:	74 d2                	je     13d5 <createdelete+0x165>
-    1403:	f6 c3 01             	test   $0x1,%bl
-    1406:	75 c8                	jne    13d0 <createdelete+0x160>
-          if(unlink(name) < 0){
-    1408:	83 ec 0c             	sub    $0xc,%esp
-          name[1] = '0' + (i / 2);
-    140b:	89 d8                	mov    %ebx,%eax
-          if(unlink(name) < 0){
-    140d:	57                   	push   %edi
-          name[1] = '0' + (i / 2);
-    140e:	d1 f8                	sar    %eax
-    1410:	83 c0 30             	add    $0x30,%eax
-    1413:	88 45 c9             	mov    %al,-0x37(%ebp)
-          if(unlink(name) < 0){
-    1416:	e8 b8 25 00 00       	call   39d3 <unlink>
-    141b:	83 c4 10             	add    $0x10,%esp
-    141e:	85 c0                	test   %eax,%eax
-    1420:	79 ae                	jns    13d0 <createdelete+0x160>
-            printf(1, "unlink failed\n");
-    1422:	52                   	push   %edx
-    1423:	52                   	push   %edx
-    1424:	68 61 3f 00 00       	push   $0x3f61
-    1429:	6a 01                	push   $0x1
-    142b:	e8 10 27 00 00       	call   3b40 <printf>
-            exit();
-    1430:	e8 4e 25 00 00       	call   3983 <exit>
-    1435:	8d 76 00             	lea    0x0(%esi),%esi
-      exit();
-    1438:	e8 46 25 00 00       	call   3983 <exit>
-    143d:	8b 7d c0             	mov    -0x40(%ebp),%edi
-        printf(1, "oops createdelete %s didn't exist\n", name);
-    1440:	83 ec 04             	sub    $0x4,%esp
-    1443:	57                   	push   %edi
-    1444:	68 20 50 00 00       	push   $0x5020
-    1449:	6a 01                	push   $0x1
-    144b:	e8 f0 26 00 00       	call   3b40 <printf>
-        exit();
-    1450:	e8 2e 25 00 00       	call   3983 <exit>
-          printf(1, "create failed\n");
-    1455:	83 ec 08             	sub    $0x8,%esp
-    1458:	68 af 45 00 00       	push   $0x45af
-    145d:	6a 01                	push   $0x1
-    145f:	e8 dc 26 00 00       	call   3b40 <printf>
-          exit();
-    1464:	e8 1a 25 00 00       	call   3983 <exit>
-      printf(1, "fork failed\n");
-    1469:	83 ec 08             	sub    $0x8,%esp
-    146c:	68 e9 4d 00 00       	push   $0x4de9
-    1471:	6a 01                	push   $0x1
-    1473:	e8 c8 26 00 00       	call   3b40 <printf>
-      exit();
-    1478:	e8 06 25 00 00       	call   3983 <exit>
-      } else if((i >= 1 && i < N/2) && fd >= 0){
-    147d:	85 c0                	test   %eax,%eax
-    147f:	0f 88 ac fe ff ff    	js     1331 <createdelete+0xc1>
-    1485:	8b 7d c0             	mov    -0x40(%ebp),%edi
-        printf(1, "oops createdelete %s did exist\n", name);
-    1488:	50                   	push   %eax
-    1489:	57                   	push   %edi
-    148a:	68 44 50 00 00       	push   $0x5044
-    148f:	6a 01                	push   $0x1
-    1491:	e8 aa 26 00 00       	call   3b40 <printf>
-        exit();
-    1496:	e8 e8 24 00 00       	call   3983 <exit>
-    149b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    149f:	90                   	nop
-
-000014a0 <unlinkread>:
-{
-    14a0:	f3 0f 1e fb          	endbr32 
-    14a4:	55                   	push   %ebp
-    14a5:	89 e5                	mov    %esp,%ebp
-    14a7:	56                   	push   %esi
-    14a8:	53                   	push   %ebx
-  printf(1, "unlinkread test\n");
-    14a9:	83 ec 08             	sub    $0x8,%esp
-    14ac:	68 84 43 00 00       	push   $0x4384
-    14b1:	6a 01                	push   $0x1
-    14b3:	e8 88 26 00 00       	call   3b40 <printf>
-  fd = open("unlinkread", O_CREATE | O_RDWR);
-    14b8:	5b                   	pop    %ebx
-    14b9:	5e                   	pop    %esi
-    14ba:	68 02 02 00 00       	push   $0x202
-    14bf:	68 95 43 00 00       	push   $0x4395
-    14c4:	e8 fa 24 00 00       	call   39c3 <open>
-  if(fd < 0){
-    14c9:	83 c4 10             	add    $0x10,%esp
-    14cc:	85 c0                	test   %eax,%eax
-    14ce:	0f 88 e6 00 00 00    	js     15ba <unlinkread+0x11a>
-  write(fd, "hello", 5);
-    14d4:	83 ec 04             	sub    $0x4,%esp
-    14d7:	89 c3                	mov    %eax,%ebx
-    14d9:	6a 05                	push   $0x5
-    14db:	68 ba 43 00 00       	push   $0x43ba
-    14e0:	50                   	push   %eax
-    14e1:	e8 bd 24 00 00       	call   39a3 <write>
-  close(fd);
-    14e6:	89 1c 24             	mov    %ebx,(%esp)
-    14e9:	e8 bd 24 00 00       	call   39ab <close>
-  fd = open("unlinkread", O_RDWR);
-    14ee:	58                   	pop    %eax
-    14ef:	5a                   	pop    %edx
-    14f0:	6a 02                	push   $0x2
-    14f2:	68 95 43 00 00       	push   $0x4395
-    14f7:	e8 c7 24 00 00       	call   39c3 <open>
-  if(fd < 0){
-    14fc:	83 c4 10             	add    $0x10,%esp
-  fd = open("unlinkread", O_RDWR);
-    14ff:	89 c3                	mov    %eax,%ebx
-  if(fd < 0){
-    1501:	85 c0                	test   %eax,%eax
-    1503:	0f 88 10 01 00 00    	js     1619 <unlinkread+0x179>
-  if(unlink("unlinkread") != 0){
-    1509:	83 ec 0c             	sub    $0xc,%esp
-    150c:	68 95 43 00 00       	push   $0x4395
-    1511:	e8 bd 24 00 00       	call   39d3 <unlink>
-    1516:	83 c4 10             	add    $0x10,%esp
-    1519:	85 c0                	test   %eax,%eax
-    151b:	0f 85 e5 00 00 00    	jne    1606 <unlinkread+0x166>
-  fd1 = open("unlinkread", O_CREATE | O_RDWR);
-    1521:	83 ec 08             	sub    $0x8,%esp
-    1524:	68 02 02 00 00       	push   $0x202
-    1529:	68 95 43 00 00       	push   $0x4395
-    152e:	e8 90 24 00 00       	call   39c3 <open>
-  write(fd1, "yyy", 3);
-    1533:	83 c4 0c             	add    $0xc,%esp
-    1536:	6a 03                	push   $0x3
-  fd1 = open("unlinkread", O_CREATE | O_RDWR);
-    1538:	89 c6                	mov    %eax,%esi
-  write(fd1, "yyy", 3);
-    153a:	68 f2 43 00 00       	push   $0x43f2
-    153f:	50                   	push   %eax
-    1540:	e8 5e 24 00 00       	call   39a3 <write>
-  close(fd1);
-    1545:	89 34 24             	mov    %esi,(%esp)
-    1548:	e8 5e 24 00 00       	call   39ab <close>
-  if(read(fd, buf, sizeof(buf)) != 5){
-    154d:	83 c4 0c             	add    $0xc,%esp
-    1550:	68 00 20 00 00       	push   $0x2000
-    1555:	68 20 87 00 00       	push   $0x8720
-    155a:	53                   	push   %ebx
-    155b:	e8 3b 24 00 00       	call   399b <read>
-    1560:	83 c4 10             	add    $0x10,%esp
-    1563:	83 f8 05             	cmp    $0x5,%eax
-    1566:	0f 85 87 00 00 00    	jne    15f3 <unlinkread+0x153>
-  if(buf[0] != 'h'){
-    156c:	80 3d 20 87 00 00 68 	cmpb   $0x68,0x8720
-    1573:	75 6b                	jne    15e0 <unlinkread+0x140>
-  if(write(fd, buf, 10) != 10){
-    1575:	83 ec 04             	sub    $0x4,%esp
-    1578:	6a 0a                	push   $0xa
-    157a:	68 20 87 00 00       	push   $0x8720
-    157f:	53                   	push   %ebx
-    1580:	e8 1e 24 00 00       	call   39a3 <write>
-    1585:	83 c4 10             	add    $0x10,%esp
-    1588:	83 f8 0a             	cmp    $0xa,%eax
-    158b:	75 40                	jne    15cd <unlinkread+0x12d>
-  close(fd);
-    158d:	83 ec 0c             	sub    $0xc,%esp
-    1590:	53                   	push   %ebx
-    1591:	e8 15 24 00 00       	call   39ab <close>
-  unlink("unlinkread");
-    1596:	c7 04 24 95 43 00 00 	movl   $0x4395,(%esp)
-    159d:	e8 31 24 00 00       	call   39d3 <unlink>
-  printf(1, "unlinkread ok\n");
-    15a2:	58                   	pop    %eax
-    15a3:	5a                   	pop    %edx
-    15a4:	68 3d 44 00 00       	push   $0x443d
-    15a9:	6a 01                	push   $0x1
-    15ab:	e8 90 25 00 00       	call   3b40 <printf>
-}
-    15b0:	83 c4 10             	add    $0x10,%esp
-    15b3:	8d 65 f8             	lea    -0x8(%ebp),%esp
-    15b6:	5b                   	pop    %ebx
-    15b7:	5e                   	pop    %esi
-    15b8:	5d                   	pop    %ebp
-    15b9:	c3                   	ret    
-    printf(1, "create unlinkread failed\n");
-    15ba:	51                   	push   %ecx
-    15bb:	51                   	push   %ecx
-    15bc:	68 a0 43 00 00       	push   $0x43a0
-    15c1:	6a 01                	push   $0x1
-    15c3:	e8 78 25 00 00       	call   3b40 <printf>
-    exit();
-    15c8:	e8 b6 23 00 00       	call   3983 <exit>
-    printf(1, "unlinkread write failed\n");
-    15cd:	51                   	push   %ecx
-    15ce:	51                   	push   %ecx
-    15cf:	68 24 44 00 00       	push   $0x4424
-    15d4:	6a 01                	push   $0x1
-    15d6:	e8 65 25 00 00       	call   3b40 <printf>
-    exit();
-    15db:	e8 a3 23 00 00       	call   3983 <exit>
-    printf(1, "unlinkread wrong data\n");
-    15e0:	53                   	push   %ebx
-    15e1:	53                   	push   %ebx
-    15e2:	68 0d 44 00 00       	push   $0x440d
-    15e7:	6a 01                	push   $0x1
-    15e9:	e8 52 25 00 00       	call   3b40 <printf>
-    exit();
-    15ee:	e8 90 23 00 00       	call   3983 <exit>
-    printf(1, "unlinkread read failed");
-    15f3:	56                   	push   %esi
-    15f4:	56                   	push   %esi
-    15f5:	68 f6 43 00 00       	push   $0x43f6
-    15fa:	6a 01                	push   $0x1
-    15fc:	e8 3f 25 00 00       	call   3b40 <printf>
-    exit();
-    1601:	e8 7d 23 00 00       	call   3983 <exit>
-    printf(1, "unlink unlinkread failed\n");
-    1606:	50                   	push   %eax
-    1607:	50                   	push   %eax
-    1608:	68 d8 43 00 00       	push   $0x43d8
-    160d:	6a 01                	push   $0x1
-    160f:	e8 2c 25 00 00       	call   3b40 <printf>
-    exit();
-    1614:	e8 6a 23 00 00       	call   3983 <exit>
-    printf(1, "open unlinkread failed\n");
-    1619:	50                   	push   %eax
-    161a:	50                   	push   %eax
-    161b:	68 c0 43 00 00       	push   $0x43c0
-    1620:	6a 01                	push   $0x1
-    1622:	e8 19 25 00 00       	call   3b40 <printf>
-    exit();
-    1627:	e8 57 23 00 00       	call   3983 <exit>
-    162c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00001630 <linktest>:
-{
-    1630:	f3 0f 1e fb          	endbr32 
-    1634:	55                   	push   %ebp
-    1635:	89 e5                	mov    %esp,%ebp
-    1637:	53                   	push   %ebx
-    1638:	83 ec 0c             	sub    $0xc,%esp
-  printf(1, "linktest\n");
-    163b:	68 4c 44 00 00       	push   $0x444c
-    1640:	6a 01                	push   $0x1
-    1642:	e8 f9 24 00 00       	call   3b40 <printf>
-  unlink("lf1");
-    1647:	c7 04 24 56 44 00 00 	movl   $0x4456,(%esp)
-    164e:	e8 80 23 00 00       	call   39d3 <unlink>
-  unlink("lf2");
-    1653:	c7 04 24 5a 44 00 00 	movl   $0x445a,(%esp)
-    165a:	e8 74 23 00 00       	call   39d3 <unlink>
-  fd = open("lf1", O_CREATE|O_RDWR);
-    165f:	58                   	pop    %eax
-    1660:	5a                   	pop    %edx
-    1661:	68 02 02 00 00       	push   $0x202
-    1666:	68 56 44 00 00       	push   $0x4456
-    166b:	e8 53 23 00 00       	call   39c3 <open>
-  if(fd < 0){
-    1670:	83 c4 10             	add    $0x10,%esp
-    1673:	85 c0                	test   %eax,%eax
-    1675:	0f 88 1e 01 00 00    	js     1799 <linktest+0x169>
-  if(write(fd, "hello", 5) != 5){
-    167b:	83 ec 04             	sub    $0x4,%esp
-    167e:	89 c3                	mov    %eax,%ebx
-    1680:	6a 05                	push   $0x5
-    1682:	68 ba 43 00 00       	push   $0x43ba
-    1687:	50                   	push   %eax
-    1688:	e8 16 23 00 00       	call   39a3 <write>
-    168d:	83 c4 10             	add    $0x10,%esp
-    1690:	83 f8 05             	cmp    $0x5,%eax
-    1693:	0f 85 98 01 00 00    	jne    1831 <linktest+0x201>
-  close(fd);
-    1699:	83 ec 0c             	sub    $0xc,%esp
-    169c:	53                   	push   %ebx
-    169d:	e8 09 23 00 00       	call   39ab <close>
-  if(link("lf1", "lf2") < 0){
-    16a2:	5b                   	pop    %ebx
-    16a3:	58                   	pop    %eax
-    16a4:	68 5a 44 00 00       	push   $0x445a
-    16a9:	68 56 44 00 00       	push   $0x4456
-    16ae:	e8 30 23 00 00       	call   39e3 <link>
-    16b3:	83 c4 10             	add    $0x10,%esp
-    16b6:	85 c0                	test   %eax,%eax
-    16b8:	0f 88 60 01 00 00    	js     181e <linktest+0x1ee>
-  unlink("lf1");
-    16be:	83 ec 0c             	sub    $0xc,%esp
-    16c1:	68 56 44 00 00       	push   $0x4456
-    16c6:	e8 08 23 00 00       	call   39d3 <unlink>
-  if(open("lf1", 0) >= 0){
-    16cb:	58                   	pop    %eax
-    16cc:	5a                   	pop    %edx
-    16cd:	6a 00                	push   $0x0
-    16cf:	68 56 44 00 00       	push   $0x4456
-    16d4:	e8 ea 22 00 00       	call   39c3 <open>
-    16d9:	83 c4 10             	add    $0x10,%esp
-    16dc:	85 c0                	test   %eax,%eax
-    16de:	0f 89 27 01 00 00    	jns    180b <linktest+0x1db>
-  fd = open("lf2", 0);
-    16e4:	83 ec 08             	sub    $0x8,%esp
-    16e7:	6a 00                	push   $0x0
-    16e9:	68 5a 44 00 00       	push   $0x445a
-    16ee:	e8 d0 22 00 00       	call   39c3 <open>
-  if(fd < 0){
-    16f3:	83 c4 10             	add    $0x10,%esp
-  fd = open("lf2", 0);
-    16f6:	89 c3                	mov    %eax,%ebx
-  if(fd < 0){
-    16f8:	85 c0                	test   %eax,%eax
-    16fa:	0f 88 f8 00 00 00    	js     17f8 <linktest+0x1c8>
-  if(read(fd, buf, sizeof(buf)) != 5){
-    1700:	83 ec 04             	sub    $0x4,%esp
-    1703:	68 00 20 00 00       	push   $0x2000
-    1708:	68 20 87 00 00       	push   $0x8720
-    170d:	50                   	push   %eax
-    170e:	e8 88 22 00 00       	call   399b <read>
-    1713:	83 c4 10             	add    $0x10,%esp
-    1716:	83 f8 05             	cmp    $0x5,%eax
-    1719:	0f 85 c6 00 00 00    	jne    17e5 <linktest+0x1b5>
-  close(fd);
-    171f:	83 ec 0c             	sub    $0xc,%esp
-    1722:	53                   	push   %ebx
-    1723:	e8 83 22 00 00       	call   39ab <close>
-  if(link("lf2", "lf2") >= 0){
-    1728:	58                   	pop    %eax
-    1729:	5a                   	pop    %edx
-    172a:	68 5a 44 00 00       	push   $0x445a
-    172f:	68 5a 44 00 00       	push   $0x445a
-    1734:	e8 aa 22 00 00       	call   39e3 <link>
-    1739:	83 c4 10             	add    $0x10,%esp
-    173c:	85 c0                	test   %eax,%eax
-    173e:	0f 89 8e 00 00 00    	jns    17d2 <linktest+0x1a2>
-  unlink("lf2");
-    1744:	83 ec 0c             	sub    $0xc,%esp
-    1747:	68 5a 44 00 00       	push   $0x445a
-    174c:	e8 82 22 00 00       	call   39d3 <unlink>
-  if(link("lf2", "lf1") >= 0){
-    1751:	59                   	pop    %ecx
-    1752:	5b                   	pop    %ebx
-    1753:	68 56 44 00 00       	push   $0x4456
-    1758:	68 5a 44 00 00       	push   $0x445a
-    175d:	e8 81 22 00 00       	call   39e3 <link>
-    1762:	83 c4 10             	add    $0x10,%esp
-    1765:	85 c0                	test   %eax,%eax
-    1767:	79 56                	jns    17bf <linktest+0x18f>
-  if(link(".", "lf1") >= 0){
-    1769:	83 ec 08             	sub    $0x8,%esp
-    176c:	68 56 44 00 00       	push   $0x4456
-    1771:	68 1e 47 00 00       	push   $0x471e
-    1776:	e8 68 22 00 00       	call   39e3 <link>
-    177b:	83 c4 10             	add    $0x10,%esp
-    177e:	85 c0                	test   %eax,%eax
-    1780:	79 2a                	jns    17ac <linktest+0x17c>
-  printf(1, "linktest ok\n");
-    1782:	83 ec 08             	sub    $0x8,%esp
-    1785:	68 f4 44 00 00       	push   $0x44f4
-    178a:	6a 01                	push   $0x1
-    178c:	e8 af 23 00 00       	call   3b40 <printf>
-}
-    1791:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-    1794:	83 c4 10             	add    $0x10,%esp
-    1797:	c9                   	leave  
-    1798:	c3                   	ret    
-    printf(1, "create lf1 failed\n");
-    1799:	50                   	push   %eax
-    179a:	50                   	push   %eax
-    179b:	68 5e 44 00 00       	push   $0x445e
-    17a0:	6a 01                	push   $0x1
-    17a2:	e8 99 23 00 00       	call   3b40 <printf>
-    exit();
-    17a7:	e8 d7 21 00 00       	call   3983 <exit>
-    printf(1, "link . lf1 succeeded! oops\n");
-    17ac:	50                   	push   %eax
-    17ad:	50                   	push   %eax
-    17ae:	68 d8 44 00 00       	push   $0x44d8
-    17b3:	6a 01                	push   $0x1
-    17b5:	e8 86 23 00 00       	call   3b40 <printf>
-    exit();
-    17ba:	e8 c4 21 00 00       	call   3983 <exit>
-    printf(1, "link non-existant succeeded! oops\n");
-    17bf:	52                   	push   %edx
-    17c0:	52                   	push   %edx
-    17c1:	68 8c 50 00 00       	push   $0x508c
-    17c6:	6a 01                	push   $0x1
-    17c8:	e8 73 23 00 00       	call   3b40 <printf>
-    exit();
-    17cd:	e8 b1 21 00 00       	call   3983 <exit>
-    printf(1, "link lf2 lf2 succeeded! oops\n");
-    17d2:	50                   	push   %eax
-    17d3:	50                   	push   %eax
-    17d4:	68 ba 44 00 00       	push   $0x44ba
-    17d9:	6a 01                	push   $0x1
-    17db:	e8 60 23 00 00       	call   3b40 <printf>
-    exit();
-    17e0:	e8 9e 21 00 00       	call   3983 <exit>
-    printf(1, "read lf2 failed\n");
-    17e5:	51                   	push   %ecx
-    17e6:	51                   	push   %ecx
-    17e7:	68 a9 44 00 00       	push   $0x44a9
-    17ec:	6a 01                	push   $0x1
-    17ee:	e8 4d 23 00 00       	call   3b40 <printf>
-    exit();
-    17f3:	e8 8b 21 00 00       	call   3983 <exit>
-    printf(1, "open lf2 failed\n");
-    17f8:	53                   	push   %ebx
-    17f9:	53                   	push   %ebx
-    17fa:	68 98 44 00 00       	push   $0x4498
-    17ff:	6a 01                	push   $0x1
-    1801:	e8 3a 23 00 00       	call   3b40 <printf>
-    exit();
-    1806:	e8 78 21 00 00       	call   3983 <exit>
-    printf(1, "unlinked lf1 but it is still there!\n");
-    180b:	50                   	push   %eax
-    180c:	50                   	push   %eax
-    180d:	68 64 50 00 00       	push   $0x5064
-    1812:	6a 01                	push   $0x1
-    1814:	e8 27 23 00 00       	call   3b40 <printf>
-    exit();
-    1819:	e8 65 21 00 00       	call   3983 <exit>
-    printf(1, "link lf1 lf2 failed\n");
-    181e:	51                   	push   %ecx
-    181f:	51                   	push   %ecx
-    1820:	68 83 44 00 00       	push   $0x4483
-    1825:	6a 01                	push   $0x1
-    1827:	e8 14 23 00 00       	call   3b40 <printf>
-    exit();
-    182c:	e8 52 21 00 00       	call   3983 <exit>
-    printf(1, "write lf1 failed\n");
-    1831:	50                   	push   %eax
-    1832:	50                   	push   %eax
-    1833:	68 71 44 00 00       	push   $0x4471
-    1838:	6a 01                	push   $0x1
-    183a:	e8 01 23 00 00       	call   3b40 <printf>
-    exit();
-    183f:	e8 3f 21 00 00       	call   3983 <exit>
-    1844:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    184b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    184f:	90                   	nop
-
-00001850 <concreate>:
-{
-    1850:	f3 0f 1e fb          	endbr32 
-    1854:	55                   	push   %ebp
-    1855:	89 e5                	mov    %esp,%ebp
-    1857:	57                   	push   %edi
-    1858:	56                   	push   %esi
-  for(i = 0; i < 40; i++){
-    1859:	31 f6                	xor    %esi,%esi
-{
-    185b:	53                   	push   %ebx
-    185c:	8d 5d ad             	lea    -0x53(%ebp),%ebx
-    185f:	83 ec 64             	sub    $0x64,%esp
-  printf(1, "concreate test\n");
-    1862:	68 01 45 00 00       	push   $0x4501
-    1867:	6a 01                	push   $0x1
-    1869:	e8 d2 22 00 00       	call   3b40 <printf>
-  file[0] = 'C';
-    186e:	c6 45 ad 43          	movb   $0x43,-0x53(%ebp)
-  file[2] = '\0';
-    1872:	83 c4 10             	add    $0x10,%esp
-    1875:	c6 45 af 00          	movb   $0x0,-0x51(%ebp)
-  for(i = 0; i < 40; i++){
-    1879:	eb 48                	jmp    18c3 <concreate+0x73>
-    187b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    187f:	90                   	nop
-    1880:	69 c6 ab aa aa aa    	imul   $0xaaaaaaab,%esi,%eax
-    if(pid && (i % 3) == 1){
-    1886:	3d ab aa aa aa       	cmp    $0xaaaaaaab,%eax
-    188b:	0f 83 af 00 00 00    	jae    1940 <concreate+0xf0>
-      fd = open(file, O_CREATE | O_RDWR);
-    1891:	83 ec 08             	sub    $0x8,%esp
-    1894:	68 02 02 00 00       	push   $0x202
-    1899:	53                   	push   %ebx
-    189a:	e8 24 21 00 00       	call   39c3 <open>
-      if(fd < 0){
-    189f:	83 c4 10             	add    $0x10,%esp
-    18a2:	85 c0                	test   %eax,%eax
-    18a4:	78 5f                	js     1905 <concreate+0xb5>
-      close(fd);
-    18a6:	83 ec 0c             	sub    $0xc,%esp
-  for(i = 0; i < 40; i++){
-    18a9:	83 c6 01             	add    $0x1,%esi
-      close(fd);
-    18ac:	50                   	push   %eax
-    18ad:	e8 f9 20 00 00       	call   39ab <close>
-    18b2:	83 c4 10             	add    $0x10,%esp
-      wait();
-    18b5:	e8 d1 20 00 00       	call   398b <wait>
-  for(i = 0; i < 40; i++){
-    18ba:	83 fe 28             	cmp    $0x28,%esi
-    18bd:	0f 84 9f 00 00 00    	je     1962 <concreate+0x112>
-    unlink(file);
-    18c3:	83 ec 0c             	sub    $0xc,%esp
-    file[1] = '0' + i;
-    18c6:	8d 46 30             	lea    0x30(%esi),%eax
-    unlink(file);
-    18c9:	53                   	push   %ebx
-    file[1] = '0' + i;
-    18ca:	88 45 ae             	mov    %al,-0x52(%ebp)
-    unlink(file);
-    18cd:	e8 01 21 00 00       	call   39d3 <unlink>
-    pid = fork();
-    18d2:	e8 a4 20 00 00       	call   397b <fork>
-    if(pid && (i % 3) == 1){
-    18d7:	83 c4 10             	add    $0x10,%esp
-    18da:	85 c0                	test   %eax,%eax
-    18dc:	75 a2                	jne    1880 <concreate+0x30>
-      link("C0", file);
-    18de:	69 f6 cd cc cc cc    	imul   $0xcccccccd,%esi,%esi
-    } else if(pid == 0 && (i % 5) == 1){
-    18e4:	81 fe cd cc cc cc    	cmp    $0xcccccccd,%esi
-    18ea:	73 34                	jae    1920 <concreate+0xd0>
-      fd = open(file, O_CREATE | O_RDWR);
-    18ec:	83 ec 08             	sub    $0x8,%esp
-    18ef:	68 02 02 00 00       	push   $0x202
-    18f4:	53                   	push   %ebx
-    18f5:	e8 c9 20 00 00       	call   39c3 <open>
-      if(fd < 0){
-    18fa:	83 c4 10             	add    $0x10,%esp
-    18fd:	85 c0                	test   %eax,%eax
-    18ff:	0f 89 39 02 00 00    	jns    1b3e <concreate+0x2ee>
-        printf(1, "concreate create %s failed\n", file);
-    1905:	83 ec 04             	sub    $0x4,%esp
-    1908:	53                   	push   %ebx
-    1909:	68 14 45 00 00       	push   $0x4514
-    190e:	6a 01                	push   $0x1
-    1910:	e8 2b 22 00 00       	call   3b40 <printf>
-        exit();
-    1915:	e8 69 20 00 00       	call   3983 <exit>
-    191a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-      link("C0", file);
-    1920:	83 ec 08             	sub    $0x8,%esp
-    1923:	53                   	push   %ebx
-    1924:	68 11 45 00 00       	push   $0x4511
-    1929:	e8 b5 20 00 00       	call   39e3 <link>
-    192e:	83 c4 10             	add    $0x10,%esp
-      exit();
-    1931:	e8 4d 20 00 00       	call   3983 <exit>
-    1936:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    193d:	8d 76 00             	lea    0x0(%esi),%esi
-      link("C0", file);
-    1940:	83 ec 08             	sub    $0x8,%esp
-  for(i = 0; i < 40; i++){
-    1943:	83 c6 01             	add    $0x1,%esi
-      link("C0", file);
-    1946:	53                   	push   %ebx
-    1947:	68 11 45 00 00       	push   $0x4511
-    194c:	e8 92 20 00 00       	call   39e3 <link>
-    1951:	83 c4 10             	add    $0x10,%esp
-      wait();
-    1954:	e8 32 20 00 00       	call   398b <wait>
-  for(i = 0; i < 40; i++){
-    1959:	83 fe 28             	cmp    $0x28,%esi
-    195c:	0f 85 61 ff ff ff    	jne    18c3 <concreate+0x73>
-  memset(fa, 0, sizeof(fa));
-    1962:	83 ec 04             	sub    $0x4,%esp
-    1965:	8d 45 c0             	lea    -0x40(%ebp),%eax
-    1968:	6a 28                	push   $0x28
-    196a:	6a 00                	push   $0x0
-    196c:	50                   	push   %eax
-    196d:	e8 6e 1e 00 00       	call   37e0 <memset>
-  fd = open(".", 0);
-    1972:	5e                   	pop    %esi
-    1973:	5f                   	pop    %edi
-    1974:	6a 00                	push   $0x0
-    1976:	68 1e 47 00 00       	push   $0x471e
-    197b:	8d 7d b0             	lea    -0x50(%ebp),%edi
-    197e:	e8 40 20 00 00       	call   39c3 <open>
-  n = 0;
-    1983:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
-  while(read(fd, &de, sizeof(de)) > 0){
-    198a:	83 c4 10             	add    $0x10,%esp
-  fd = open(".", 0);
-    198d:	89 c6                	mov    %eax,%esi
-  while(read(fd, &de, sizeof(de)) > 0){
-    198f:	90                   	nop
-    1990:	83 ec 04             	sub    $0x4,%esp
-    1993:	6a 10                	push   $0x10
-    1995:	57                   	push   %edi
-    1996:	56                   	push   %esi
-    1997:	e8 ff 1f 00 00       	call   399b <read>
-    199c:	83 c4 10             	add    $0x10,%esp
-    199f:	85 c0                	test   %eax,%eax
-    19a1:	7e 3d                	jle    19e0 <concreate+0x190>
-    if(de.inum == 0)
-    19a3:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
-    19a8:	74 e6                	je     1990 <concreate+0x140>
-    if(de.name[0] == 'C' && de.name[2] == '\0'){
-    19aa:	80 7d b2 43          	cmpb   $0x43,-0x4e(%ebp)
-    19ae:	75 e0                	jne    1990 <concreate+0x140>
-    19b0:	80 7d b4 00          	cmpb   $0x0,-0x4c(%ebp)
-    19b4:	75 da                	jne    1990 <concreate+0x140>
-      i = de.name[1] - '0';
-    19b6:	0f be 45 b3          	movsbl -0x4d(%ebp),%eax
-    19ba:	83 e8 30             	sub    $0x30,%eax
-      if(i < 0 || i >= sizeof(fa)){
-    19bd:	83 f8 27             	cmp    $0x27,%eax
-    19c0:	0f 87 60 01 00 00    	ja     1b26 <concreate+0x2d6>
-      if(fa[i]){
-    19c6:	80 7c 05 c0 00       	cmpb   $0x0,-0x40(%ebp,%eax,1)
-    19cb:	0f 85 3d 01 00 00    	jne    1b0e <concreate+0x2be>
-      n++;
-    19d1:	83 45 a4 01          	addl   $0x1,-0x5c(%ebp)
-      fa[i] = 1;
-    19d5:	c6 44 05 c0 01       	movb   $0x1,-0x40(%ebp,%eax,1)
-      n++;
-    19da:	eb b4                	jmp    1990 <concreate+0x140>
-    19dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  close(fd);
-    19e0:	83 ec 0c             	sub    $0xc,%esp
-    19e3:	56                   	push   %esi
-    19e4:	e8 c2 1f 00 00       	call   39ab <close>
-  if(n != 40){
-    19e9:	83 c4 10             	add    $0x10,%esp
-    19ec:	83 7d a4 28          	cmpl   $0x28,-0x5c(%ebp)
-    19f0:	0f 85 05 01 00 00    	jne    1afb <concreate+0x2ab>
-  for(i = 0; i < 40; i++){
-    19f6:	31 f6                	xor    %esi,%esi
-    19f8:	eb 4c                	jmp    1a46 <concreate+0x1f6>
-    19fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-       ((i % 3) == 1 && pid != 0)){
-    1a00:	85 ff                	test   %edi,%edi
-    1a02:	74 05                	je     1a09 <concreate+0x1b9>
-    1a04:	83 f8 01             	cmp    $0x1,%eax
-    1a07:	74 6c                	je     1a75 <concreate+0x225>
-      unlink(file);
-    1a09:	83 ec 0c             	sub    $0xc,%esp
-    1a0c:	53                   	push   %ebx
-    1a0d:	e8 c1 1f 00 00       	call   39d3 <unlink>
-      unlink(file);
-    1a12:	89 1c 24             	mov    %ebx,(%esp)
-    1a15:	e8 b9 1f 00 00       	call   39d3 <unlink>
-      unlink(file);
-    1a1a:	89 1c 24             	mov    %ebx,(%esp)
-    1a1d:	e8 b1 1f 00 00       	call   39d3 <unlink>
-      unlink(file);
-    1a22:	89 1c 24             	mov    %ebx,(%esp)
-    1a25:	e8 a9 1f 00 00       	call   39d3 <unlink>
-    1a2a:	83 c4 10             	add    $0x10,%esp
-    if(pid == 0)
-    1a2d:	85 ff                	test   %edi,%edi
-    1a2f:	0f 84 fc fe ff ff    	je     1931 <concreate+0xe1>
-      wait();
-    1a35:	e8 51 1f 00 00       	call   398b <wait>
-  for(i = 0; i < 40; i++){
-    1a3a:	83 c6 01             	add    $0x1,%esi
-    1a3d:	83 fe 28             	cmp    $0x28,%esi
-    1a40:	0f 84 8a 00 00 00    	je     1ad0 <concreate+0x280>
-    file[1] = '0' + i;
-    1a46:	8d 46 30             	lea    0x30(%esi),%eax
-    1a49:	88 45 ae             	mov    %al,-0x52(%ebp)
-    pid = fork();
-    1a4c:	e8 2a 1f 00 00       	call   397b <fork>
-    1a51:	89 c7                	mov    %eax,%edi
-    if(pid < 0){
-    1a53:	85 c0                	test   %eax,%eax
-    1a55:	0f 88 8c 00 00 00    	js     1ae7 <concreate+0x297>
-    if(((i % 3) == 0 && pid == 0) ||
-    1a5b:	b8 ab aa aa aa       	mov    $0xaaaaaaab,%eax
-    1a60:	f7 e6                	mul    %esi
-    1a62:	89 d0                	mov    %edx,%eax
-    1a64:	83 e2 fe             	and    $0xfffffffe,%edx
-    1a67:	d1 e8                	shr    %eax
-    1a69:	01 c2                	add    %eax,%edx
-    1a6b:	89 f0                	mov    %esi,%eax
-    1a6d:	29 d0                	sub    %edx,%eax
-    1a6f:	89 c1                	mov    %eax,%ecx
-    1a71:	09 f9                	or     %edi,%ecx
-    1a73:	75 8b                	jne    1a00 <concreate+0x1b0>
-      close(open(file, 0));
-    1a75:	83 ec 08             	sub    $0x8,%esp
-    1a78:	6a 00                	push   $0x0
-    1a7a:	53                   	push   %ebx
-    1a7b:	e8 43 1f 00 00       	call   39c3 <open>
-    1a80:	89 04 24             	mov    %eax,(%esp)
-    1a83:	e8 23 1f 00 00       	call   39ab <close>
-      close(open(file, 0));
-    1a88:	58                   	pop    %eax
-    1a89:	5a                   	pop    %edx
-    1a8a:	6a 00                	push   $0x0
-    1a8c:	53                   	push   %ebx
-    1a8d:	e8 31 1f 00 00       	call   39c3 <open>
-    1a92:	89 04 24             	mov    %eax,(%esp)
-    1a95:	e8 11 1f 00 00       	call   39ab <close>
-      close(open(file, 0));
-    1a9a:	59                   	pop    %ecx
-    1a9b:	58                   	pop    %eax
-    1a9c:	6a 00                	push   $0x0
-    1a9e:	53                   	push   %ebx
-    1a9f:	e8 1f 1f 00 00       	call   39c3 <open>
-    1aa4:	89 04 24             	mov    %eax,(%esp)
-    1aa7:	e8 ff 1e 00 00       	call   39ab <close>
-      close(open(file, 0));
-    1aac:	58                   	pop    %eax
-    1aad:	5a                   	pop    %edx
-    1aae:	6a 00                	push   $0x0
-    1ab0:	53                   	push   %ebx
-    1ab1:	e8 0d 1f 00 00       	call   39c3 <open>
-    1ab6:	89 04 24             	mov    %eax,(%esp)
-    1ab9:	e8 ed 1e 00 00       	call   39ab <close>
-    1abe:	83 c4 10             	add    $0x10,%esp
-    1ac1:	e9 67 ff ff ff       	jmp    1a2d <concreate+0x1dd>
-    1ac6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    1acd:	8d 76 00             	lea    0x0(%esi),%esi
-  printf(1, "concreate ok\n");
-    1ad0:	83 ec 08             	sub    $0x8,%esp
-    1ad3:	68 66 45 00 00       	push   $0x4566
-    1ad8:	6a 01                	push   $0x1
-    1ada:	e8 61 20 00 00       	call   3b40 <printf>
-}
-    1adf:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    1ae2:	5b                   	pop    %ebx
-    1ae3:	5e                   	pop    %esi
-    1ae4:	5f                   	pop    %edi
-    1ae5:	5d                   	pop    %ebp
-    1ae6:	c3                   	ret    
-      printf(1, "fork failed\n");
-    1ae7:	83 ec 08             	sub    $0x8,%esp
-    1aea:	68 e9 4d 00 00       	push   $0x4de9
-    1aef:	6a 01                	push   $0x1
-    1af1:	e8 4a 20 00 00       	call   3b40 <printf>
-      exit();
-    1af6:	e8 88 1e 00 00       	call   3983 <exit>
-    printf(1, "concreate not enough files in directory listing\n");
-    1afb:	51                   	push   %ecx
-    1afc:	51                   	push   %ecx
-    1afd:	68 b0 50 00 00       	push   $0x50b0
-    1b02:	6a 01                	push   $0x1
-    1b04:	e8 37 20 00 00       	call   3b40 <printf>
-    exit();
-    1b09:	e8 75 1e 00 00       	call   3983 <exit>
-        printf(1, "concreate duplicate file %s\n", de.name);
-    1b0e:	83 ec 04             	sub    $0x4,%esp
-    1b11:	8d 45 b2             	lea    -0x4e(%ebp),%eax
-    1b14:	50                   	push   %eax
-    1b15:	68 49 45 00 00       	push   $0x4549
-    1b1a:	6a 01                	push   $0x1
-    1b1c:	e8 1f 20 00 00       	call   3b40 <printf>
-        exit();
-    1b21:	e8 5d 1e 00 00       	call   3983 <exit>
-        printf(1, "concreate weird file %s\n", de.name);
-    1b26:	83 ec 04             	sub    $0x4,%esp
-    1b29:	8d 45 b2             	lea    -0x4e(%ebp),%eax
-    1b2c:	50                   	push   %eax
-    1b2d:	68 30 45 00 00       	push   $0x4530
-    1b32:	6a 01                	push   $0x1
-    1b34:	e8 07 20 00 00       	call   3b40 <printf>
-        exit();
-    1b39:	e8 45 1e 00 00       	call   3983 <exit>
-      close(fd);
-    1b3e:	83 ec 0c             	sub    $0xc,%esp
-    1b41:	50                   	push   %eax
-    1b42:	e8 64 1e 00 00       	call   39ab <close>
-    1b47:	83 c4 10             	add    $0x10,%esp
-    1b4a:	e9 e2 fd ff ff       	jmp    1931 <concreate+0xe1>
-    1b4f:	90                   	nop
-
-00001b50 <linkunlink>:
-{
-    1b50:	f3 0f 1e fb          	endbr32 
-    1b54:	55                   	push   %ebp
-    1b55:	89 e5                	mov    %esp,%ebp
-    1b57:	57                   	push   %edi
-    1b58:	56                   	push   %esi
-    1b59:	53                   	push   %ebx
-    1b5a:	83 ec 24             	sub    $0x24,%esp
-  printf(1, "linkunlink test\n");
-    1b5d:	68 74 45 00 00       	push   $0x4574
-    1b62:	6a 01                	push   $0x1
-    1b64:	e8 d7 1f 00 00       	call   3b40 <printf>
-  unlink("x");
-    1b69:	c7 04 24 01 48 00 00 	movl   $0x4801,(%esp)
-    1b70:	e8 5e 1e 00 00       	call   39d3 <unlink>
-  pid = fork();
-    1b75:	e8 01 1e 00 00       	call   397b <fork>
-  if(pid < 0){
-    1b7a:	83 c4 10             	add    $0x10,%esp
-  pid = fork();
-    1b7d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-  if(pid < 0){
-    1b80:	85 c0                	test   %eax,%eax
-    1b82:	0f 88 b2 00 00 00    	js     1c3a <linkunlink+0xea>
-  unsigned int x = (pid ? 1 : 97);
-    1b88:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
-    1b8c:	bb 64 00 00 00       	mov    $0x64,%ebx
-    if((x % 3) == 0){
-    1b91:	be ab aa aa aa       	mov    $0xaaaaaaab,%esi
-  unsigned int x = (pid ? 1 : 97);
-    1b96:	19 ff                	sbb    %edi,%edi
-    1b98:	83 e7 60             	and    $0x60,%edi
-    1b9b:	83 c7 01             	add    $0x1,%edi
-    1b9e:	eb 1a                	jmp    1bba <linkunlink+0x6a>
-    } else if((x % 3) == 1){
-    1ba0:	83 f8 01             	cmp    $0x1,%eax
-    1ba3:	74 7b                	je     1c20 <linkunlink+0xd0>
-      unlink("x");
-    1ba5:	83 ec 0c             	sub    $0xc,%esp
-    1ba8:	68 01 48 00 00       	push   $0x4801
-    1bad:	e8 21 1e 00 00       	call   39d3 <unlink>
-    1bb2:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; i < 100; i++){
-    1bb5:	83 eb 01             	sub    $0x1,%ebx
-    1bb8:	74 41                	je     1bfb <linkunlink+0xab>
-    x = x * 1103515245 + 12345;
-    1bba:	69 cf 6d 4e c6 41    	imul   $0x41c64e6d,%edi,%ecx
-    1bc0:	8d b9 39 30 00 00    	lea    0x3039(%ecx),%edi
-    if((x % 3) == 0){
-    1bc6:	89 f8                	mov    %edi,%eax
-    1bc8:	f7 e6                	mul    %esi
-    1bca:	89 d0                	mov    %edx,%eax
-    1bcc:	83 e2 fe             	and    $0xfffffffe,%edx
-    1bcf:	d1 e8                	shr    %eax
-    1bd1:	01 c2                	add    %eax,%edx
-    1bd3:	89 f8                	mov    %edi,%eax
-    1bd5:	29 d0                	sub    %edx,%eax
-    1bd7:	75 c7                	jne    1ba0 <linkunlink+0x50>
-      close(open("x", O_RDWR | O_CREATE));
-    1bd9:	83 ec 08             	sub    $0x8,%esp
-    1bdc:	68 02 02 00 00       	push   $0x202
-    1be1:	68 01 48 00 00       	push   $0x4801
-    1be6:	e8 d8 1d 00 00       	call   39c3 <open>
-    1beb:	89 04 24             	mov    %eax,(%esp)
-    1bee:	e8 b8 1d 00 00       	call   39ab <close>
-    1bf3:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; i < 100; i++){
-    1bf6:	83 eb 01             	sub    $0x1,%ebx
-    1bf9:	75 bf                	jne    1bba <linkunlink+0x6a>
-  if(pid)
-    1bfb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-    1bfe:	85 c0                	test   %eax,%eax
-    1c00:	74 4b                	je     1c4d <linkunlink+0xfd>
-    wait();
-    1c02:	e8 84 1d 00 00       	call   398b <wait>
-  printf(1, "linkunlink ok\n");
-    1c07:	83 ec 08             	sub    $0x8,%esp
-    1c0a:	68 89 45 00 00       	push   $0x4589
-    1c0f:	6a 01                	push   $0x1
-    1c11:	e8 2a 1f 00 00       	call   3b40 <printf>
-}
-    1c16:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    1c19:	5b                   	pop    %ebx
-    1c1a:	5e                   	pop    %esi
-    1c1b:	5f                   	pop    %edi
-    1c1c:	5d                   	pop    %ebp
-    1c1d:	c3                   	ret    
-    1c1e:	66 90                	xchg   %ax,%ax
-      link("cat", "x");
-    1c20:	83 ec 08             	sub    $0x8,%esp
-    1c23:	68 01 48 00 00       	push   $0x4801
-    1c28:	68 85 45 00 00       	push   $0x4585
-    1c2d:	e8 b1 1d 00 00       	call   39e3 <link>
-    1c32:	83 c4 10             	add    $0x10,%esp
-    1c35:	e9 7b ff ff ff       	jmp    1bb5 <linkunlink+0x65>
-    printf(1, "fork failed\n");
-    1c3a:	52                   	push   %edx
-    1c3b:	52                   	push   %edx
-    1c3c:	68 e9 4d 00 00       	push   $0x4de9
-    1c41:	6a 01                	push   $0x1
-    1c43:	e8 f8 1e 00 00       	call   3b40 <printf>
-    exit();
-    1c48:	e8 36 1d 00 00       	call   3983 <exit>
-    exit();
-    1c4d:	e8 31 1d 00 00       	call   3983 <exit>
-    1c52:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    1c59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-
-00001c60 <bigdir>:
-{
-    1c60:	f3 0f 1e fb          	endbr32 
-    1c64:	55                   	push   %ebp
-    1c65:	89 e5                	mov    %esp,%ebp
-    1c67:	57                   	push   %edi
-    1c68:	56                   	push   %esi
-    1c69:	53                   	push   %ebx
-    1c6a:	83 ec 24             	sub    $0x24,%esp
-  printf(1, "bigdir test\n");
-    1c6d:	68 98 45 00 00       	push   $0x4598
-    1c72:	6a 01                	push   $0x1
-    1c74:	e8 c7 1e 00 00       	call   3b40 <printf>
-  unlink("bd");
-    1c79:	c7 04 24 a5 45 00 00 	movl   $0x45a5,(%esp)
-    1c80:	e8 4e 1d 00 00       	call   39d3 <unlink>
-  fd = open("bd", O_CREATE);
-    1c85:	5a                   	pop    %edx
-    1c86:	59                   	pop    %ecx
-    1c87:	68 00 02 00 00       	push   $0x200
-    1c8c:	68 a5 45 00 00       	push   $0x45a5
-    1c91:	e8 2d 1d 00 00       	call   39c3 <open>
-  if(fd < 0){
-    1c96:	83 c4 10             	add    $0x10,%esp
-    1c99:	85 c0                	test   %eax,%eax
-    1c9b:	0f 88 ea 00 00 00    	js     1d8b <bigdir+0x12b>
-  close(fd);
-    1ca1:	83 ec 0c             	sub    $0xc,%esp
-  for(i = 0; i < 500; i++){
-    1ca4:	31 f6                	xor    %esi,%esi
-    1ca6:	8d 7d de             	lea    -0x22(%ebp),%edi
-  close(fd);
-    1ca9:	50                   	push   %eax
-    1caa:	e8 fc 1c 00 00       	call   39ab <close>
-    1caf:	83 c4 10             	add    $0x10,%esp
-    1cb2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    name[1] = '0' + (i / 64);
-    1cb8:	89 f0                	mov    %esi,%eax
-    if(link("bd", name) != 0){
-    1cba:	83 ec 08             	sub    $0x8,%esp
-    name[0] = 'x';
-    1cbd:	c6 45 de 78          	movb   $0x78,-0x22(%ebp)
-    name[1] = '0' + (i / 64);
-    1cc1:	c1 f8 06             	sar    $0x6,%eax
-    if(link("bd", name) != 0){
-    1cc4:	57                   	push   %edi
-    name[1] = '0' + (i / 64);
-    1cc5:	83 c0 30             	add    $0x30,%eax
-    if(link("bd", name) != 0){
-    1cc8:	68 a5 45 00 00       	push   $0x45a5
-    name[1] = '0' + (i / 64);
-    1ccd:	88 45 df             	mov    %al,-0x21(%ebp)
-    name[2] = '0' + (i % 64);
-    1cd0:	89 f0                	mov    %esi,%eax
-    1cd2:	83 e0 3f             	and    $0x3f,%eax
-    name[3] = '\0';
-    1cd5:	c6 45 e1 00          	movb   $0x0,-0x1f(%ebp)
-    name[2] = '0' + (i % 64);
-    1cd9:	83 c0 30             	add    $0x30,%eax
-    1cdc:	88 45 e0             	mov    %al,-0x20(%ebp)
-    if(link("bd", name) != 0){
-    1cdf:	e8 ff 1c 00 00       	call   39e3 <link>
-    1ce4:	83 c4 10             	add    $0x10,%esp
-    1ce7:	89 c3                	mov    %eax,%ebx
-    1ce9:	85 c0                	test   %eax,%eax
-    1ceb:	75 76                	jne    1d63 <bigdir+0x103>
-  for(i = 0; i < 500; i++){
-    1ced:	83 c6 01             	add    $0x1,%esi
-    1cf0:	81 fe f4 01 00 00    	cmp    $0x1f4,%esi
-    1cf6:	75 c0                	jne    1cb8 <bigdir+0x58>
-  unlink("bd");
-    1cf8:	83 ec 0c             	sub    $0xc,%esp
-    1cfb:	68 a5 45 00 00       	push   $0x45a5
-    1d00:	e8 ce 1c 00 00       	call   39d3 <unlink>
-    1d05:	83 c4 10             	add    $0x10,%esp
-    1d08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    1d0f:	90                   	nop
-    name[1] = '0' + (i / 64);
-    1d10:	89 d8                	mov    %ebx,%eax
-    if(unlink(name) != 0){
-    1d12:	83 ec 0c             	sub    $0xc,%esp
-    name[0] = 'x';
-    1d15:	c6 45 de 78          	movb   $0x78,-0x22(%ebp)
-    name[1] = '0' + (i / 64);
-    1d19:	c1 f8 06             	sar    $0x6,%eax
-    if(unlink(name) != 0){
-    1d1c:	57                   	push   %edi
-    name[1] = '0' + (i / 64);
-    1d1d:	83 c0 30             	add    $0x30,%eax
-    name[3] = '\0';
-    1d20:	c6 45 e1 00          	movb   $0x0,-0x1f(%ebp)
-    name[1] = '0' + (i / 64);
-    1d24:	88 45 df             	mov    %al,-0x21(%ebp)
-    name[2] = '0' + (i % 64);
-    1d27:	89 d8                	mov    %ebx,%eax
-    1d29:	83 e0 3f             	and    $0x3f,%eax
-    1d2c:	83 c0 30             	add    $0x30,%eax
-    1d2f:	88 45 e0             	mov    %al,-0x20(%ebp)
-    if(unlink(name) != 0){
-    1d32:	e8 9c 1c 00 00       	call   39d3 <unlink>
-    1d37:	83 c4 10             	add    $0x10,%esp
-    1d3a:	85 c0                	test   %eax,%eax
-    1d3c:	75 39                	jne    1d77 <bigdir+0x117>
-  for(i = 0; i < 500; i++){
-    1d3e:	83 c3 01             	add    $0x1,%ebx
-    1d41:	81 fb f4 01 00 00    	cmp    $0x1f4,%ebx
-    1d47:	75 c7                	jne    1d10 <bigdir+0xb0>
-  printf(1, "bigdir ok\n");
-    1d49:	83 ec 08             	sub    $0x8,%esp
-    1d4c:	68 e7 45 00 00       	push   $0x45e7
-    1d51:	6a 01                	push   $0x1
-    1d53:	e8 e8 1d 00 00       	call   3b40 <printf>
-    1d58:	83 c4 10             	add    $0x10,%esp
-}
-    1d5b:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    1d5e:	5b                   	pop    %ebx
-    1d5f:	5e                   	pop    %esi
-    1d60:	5f                   	pop    %edi
-    1d61:	5d                   	pop    %ebp
-    1d62:	c3                   	ret    
-      printf(1, "bigdir link failed\n");
-    1d63:	83 ec 08             	sub    $0x8,%esp
-    1d66:	68 be 45 00 00       	push   $0x45be
-    1d6b:	6a 01                	push   $0x1
-    1d6d:	e8 ce 1d 00 00       	call   3b40 <printf>
-      exit();
-    1d72:	e8 0c 1c 00 00       	call   3983 <exit>
-      printf(1, "bigdir unlink failed");
-    1d77:	83 ec 08             	sub    $0x8,%esp
-    1d7a:	68 d2 45 00 00       	push   $0x45d2
-    1d7f:	6a 01                	push   $0x1
-    1d81:	e8 ba 1d 00 00       	call   3b40 <printf>
-      exit();
-    1d86:	e8 f8 1b 00 00       	call   3983 <exit>
-    printf(1, "bigdir create failed\n");
-    1d8b:	50                   	push   %eax
-    1d8c:	50                   	push   %eax
-    1d8d:	68 a8 45 00 00       	push   $0x45a8
-    1d92:	6a 01                	push   $0x1
-    1d94:	e8 a7 1d 00 00       	call   3b40 <printf>
-    exit();
-    1d99:	e8 e5 1b 00 00       	call   3983 <exit>
-    1d9e:	66 90                	xchg   %ax,%ax
-
-00001da0 <subdir>:
-{
-    1da0:	f3 0f 1e fb          	endbr32 
-    1da4:	55                   	push   %ebp
-    1da5:	89 e5                	mov    %esp,%ebp
-    1da7:	53                   	push   %ebx
-    1da8:	83 ec 0c             	sub    $0xc,%esp
-  printf(1, "subdir test\n");
-    1dab:	68 f2 45 00 00       	push   $0x45f2
-    1db0:	6a 01                	push   $0x1
-    1db2:	e8 89 1d 00 00       	call   3b40 <printf>
-  unlink("ff");
-    1db7:	c7 04 24 7b 46 00 00 	movl   $0x467b,(%esp)
-    1dbe:	e8 10 1c 00 00       	call   39d3 <unlink>
-  if(mkdir("dd") != 0){
-    1dc3:	c7 04 24 18 47 00 00 	movl   $0x4718,(%esp)
-    1dca:	e8 1c 1c 00 00       	call   39eb <mkdir>
-    1dcf:	83 c4 10             	add    $0x10,%esp
-    1dd2:	85 c0                	test   %eax,%eax
-    1dd4:	0f 85 b3 05 00 00    	jne    238d <subdir+0x5ed>
-  fd = open("dd/ff", O_CREATE | O_RDWR);
-    1dda:	83 ec 08             	sub    $0x8,%esp
-    1ddd:	68 02 02 00 00       	push   $0x202
-    1de2:	68 51 46 00 00       	push   $0x4651
-    1de7:	e8 d7 1b 00 00       	call   39c3 <open>
-  if(fd < 0){
-    1dec:	83 c4 10             	add    $0x10,%esp
-  fd = open("dd/ff", O_CREATE | O_RDWR);
-    1def:	89 c3                	mov    %eax,%ebx
-  if(fd < 0){
-    1df1:	85 c0                	test   %eax,%eax
-    1df3:	0f 88 81 05 00 00    	js     237a <subdir+0x5da>
-  write(fd, "ff", 2);
-    1df9:	83 ec 04             	sub    $0x4,%esp
-    1dfc:	6a 02                	push   $0x2
-    1dfe:	68 7b 46 00 00       	push   $0x467b
-    1e03:	50                   	push   %eax
-    1e04:	e8 9a 1b 00 00       	call   39a3 <write>
-  close(fd);
-    1e09:	89 1c 24             	mov    %ebx,(%esp)
-    1e0c:	e8 9a 1b 00 00       	call   39ab <close>
-  if(unlink("dd") >= 0){
-    1e11:	c7 04 24 18 47 00 00 	movl   $0x4718,(%esp)
-    1e18:	e8 b6 1b 00 00       	call   39d3 <unlink>
-    1e1d:	83 c4 10             	add    $0x10,%esp
-    1e20:	85 c0                	test   %eax,%eax
-    1e22:	0f 89 3f 05 00 00    	jns    2367 <subdir+0x5c7>
-  if(mkdir("/dd/dd") != 0){
-    1e28:	83 ec 0c             	sub    $0xc,%esp
-    1e2b:	68 2c 46 00 00       	push   $0x462c
-    1e30:	e8 b6 1b 00 00       	call   39eb <mkdir>
-    1e35:	83 c4 10             	add    $0x10,%esp
-    1e38:	85 c0                	test   %eax,%eax
-    1e3a:	0f 85 14 05 00 00    	jne    2354 <subdir+0x5b4>
-  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
-    1e40:	83 ec 08             	sub    $0x8,%esp
-    1e43:	68 02 02 00 00       	push   $0x202
-    1e48:	68 4e 46 00 00       	push   $0x464e
-    1e4d:	e8 71 1b 00 00       	call   39c3 <open>
-  if(fd < 0){
-    1e52:	83 c4 10             	add    $0x10,%esp
-  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
-    1e55:	89 c3                	mov    %eax,%ebx
-  if(fd < 0){
-    1e57:	85 c0                	test   %eax,%eax
-    1e59:	0f 88 24 04 00 00    	js     2283 <subdir+0x4e3>
-  write(fd, "FF", 2);
-    1e5f:	83 ec 04             	sub    $0x4,%esp
-    1e62:	6a 02                	push   $0x2
-    1e64:	68 6f 46 00 00       	push   $0x466f
-    1e69:	50                   	push   %eax
-    1e6a:	e8 34 1b 00 00       	call   39a3 <write>
-  close(fd);
-    1e6f:	89 1c 24             	mov    %ebx,(%esp)
-    1e72:	e8 34 1b 00 00       	call   39ab <close>
-  fd = open("dd/dd/../ff", 0);
-    1e77:	58                   	pop    %eax
-    1e78:	5a                   	pop    %edx
-    1e79:	6a 00                	push   $0x0
-    1e7b:	68 72 46 00 00       	push   $0x4672
-    1e80:	e8 3e 1b 00 00       	call   39c3 <open>
-  if(fd < 0){
-    1e85:	83 c4 10             	add    $0x10,%esp
-  fd = open("dd/dd/../ff", 0);
-    1e88:	89 c3                	mov    %eax,%ebx
-  if(fd < 0){
-    1e8a:	85 c0                	test   %eax,%eax
-    1e8c:	0f 88 de 03 00 00    	js     2270 <subdir+0x4d0>
-  cc = read(fd, buf, sizeof(buf));
-    1e92:	83 ec 04             	sub    $0x4,%esp
-    1e95:	68 00 20 00 00       	push   $0x2000
-    1e9a:	68 20 87 00 00       	push   $0x8720
-    1e9f:	50                   	push   %eax
-    1ea0:	e8 f6 1a 00 00       	call   399b <read>
-  if(cc != 2 || buf[0] != 'f'){
-    1ea5:	83 c4 10             	add    $0x10,%esp
-    1ea8:	83 f8 02             	cmp    $0x2,%eax
-    1eab:	0f 85 3a 03 00 00    	jne    21eb <subdir+0x44b>
-    1eb1:	80 3d 20 87 00 00 66 	cmpb   $0x66,0x8720
-    1eb8:	0f 85 2d 03 00 00    	jne    21eb <subdir+0x44b>
-  close(fd);
-    1ebe:	83 ec 0c             	sub    $0xc,%esp
-    1ec1:	53                   	push   %ebx
-    1ec2:	e8 e4 1a 00 00       	call   39ab <close>
-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
-    1ec7:	59                   	pop    %ecx
-    1ec8:	5b                   	pop    %ebx
-    1ec9:	68 b2 46 00 00       	push   $0x46b2
-    1ece:	68 4e 46 00 00       	push   $0x464e
-    1ed3:	e8 0b 1b 00 00       	call   39e3 <link>
-    1ed8:	83 c4 10             	add    $0x10,%esp
-    1edb:	85 c0                	test   %eax,%eax
-    1edd:	0f 85 c6 03 00 00    	jne    22a9 <subdir+0x509>
-  if(unlink("dd/dd/ff") != 0){
-    1ee3:	83 ec 0c             	sub    $0xc,%esp
-    1ee6:	68 4e 46 00 00       	push   $0x464e
-    1eeb:	e8 e3 1a 00 00       	call   39d3 <unlink>
-    1ef0:	83 c4 10             	add    $0x10,%esp
-    1ef3:	85 c0                	test   %eax,%eax
-    1ef5:	0f 85 16 03 00 00    	jne    2211 <subdir+0x471>
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
-    1efb:	83 ec 08             	sub    $0x8,%esp
-    1efe:	6a 00                	push   $0x0
-    1f00:	68 4e 46 00 00       	push   $0x464e
-    1f05:	e8 b9 1a 00 00       	call   39c3 <open>
-    1f0a:	83 c4 10             	add    $0x10,%esp
-    1f0d:	85 c0                	test   %eax,%eax
-    1f0f:	0f 89 2c 04 00 00    	jns    2341 <subdir+0x5a1>
-  if(chdir("dd") != 0){
-    1f15:	83 ec 0c             	sub    $0xc,%esp
-    1f18:	68 18 47 00 00       	push   $0x4718
-    1f1d:	e8 d1 1a 00 00       	call   39f3 <chdir>
-    1f22:	83 c4 10             	add    $0x10,%esp
-    1f25:	85 c0                	test   %eax,%eax
-    1f27:	0f 85 01 04 00 00    	jne    232e <subdir+0x58e>
-  if(chdir("dd/../../dd") != 0){
-    1f2d:	83 ec 0c             	sub    $0xc,%esp
-    1f30:	68 e6 46 00 00       	push   $0x46e6
-    1f35:	e8 b9 1a 00 00       	call   39f3 <chdir>
-    1f3a:	83 c4 10             	add    $0x10,%esp
-    1f3d:	85 c0                	test   %eax,%eax
-    1f3f:	0f 85 b9 02 00 00    	jne    21fe <subdir+0x45e>
-  if(chdir("dd/../../../dd") != 0){
-    1f45:	83 ec 0c             	sub    $0xc,%esp
-    1f48:	68 0c 47 00 00       	push   $0x470c
-    1f4d:	e8 a1 1a 00 00       	call   39f3 <chdir>
-    1f52:	83 c4 10             	add    $0x10,%esp
-    1f55:	85 c0                	test   %eax,%eax
-    1f57:	0f 85 a1 02 00 00    	jne    21fe <subdir+0x45e>
-  if(chdir("./..") != 0){
-    1f5d:	83 ec 0c             	sub    $0xc,%esp
-    1f60:	68 1b 47 00 00       	push   $0x471b
-    1f65:	e8 89 1a 00 00       	call   39f3 <chdir>
-    1f6a:	83 c4 10             	add    $0x10,%esp
-    1f6d:	85 c0                	test   %eax,%eax
-    1f6f:	0f 85 21 03 00 00    	jne    2296 <subdir+0x4f6>
-  fd = open("dd/dd/ffff", 0);
-    1f75:	83 ec 08             	sub    $0x8,%esp
-    1f78:	6a 00                	push   $0x0
-    1f7a:	68 b2 46 00 00       	push   $0x46b2
-    1f7f:	e8 3f 1a 00 00       	call   39c3 <open>
-  if(fd < 0){
-    1f84:	83 c4 10             	add    $0x10,%esp
-  fd = open("dd/dd/ffff", 0);
-    1f87:	89 c3                	mov    %eax,%ebx
-  if(fd < 0){
-    1f89:	85 c0                	test   %eax,%eax
-    1f8b:	0f 88 e0 04 00 00    	js     2471 <subdir+0x6d1>
-  if(read(fd, buf, sizeof(buf)) != 2){
-    1f91:	83 ec 04             	sub    $0x4,%esp
-    1f94:	68 00 20 00 00       	push   $0x2000
-    1f99:	68 20 87 00 00       	push   $0x8720
-    1f9e:	50                   	push   %eax
-    1f9f:	e8 f7 19 00 00       	call   399b <read>
-    1fa4:	83 c4 10             	add    $0x10,%esp
-    1fa7:	83 f8 02             	cmp    $0x2,%eax
-    1faa:	0f 85 ae 04 00 00    	jne    245e <subdir+0x6be>
-  close(fd);
-    1fb0:	83 ec 0c             	sub    $0xc,%esp
-    1fb3:	53                   	push   %ebx
-    1fb4:	e8 f2 19 00 00       	call   39ab <close>
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
-    1fb9:	58                   	pop    %eax
-    1fba:	5a                   	pop    %edx
-    1fbb:	6a 00                	push   $0x0
-    1fbd:	68 4e 46 00 00       	push   $0x464e
-    1fc2:	e8 fc 19 00 00       	call   39c3 <open>
-    1fc7:	83 c4 10             	add    $0x10,%esp
-    1fca:	85 c0                	test   %eax,%eax
-    1fcc:	0f 89 65 02 00 00    	jns    2237 <subdir+0x497>
-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
-    1fd2:	83 ec 08             	sub    $0x8,%esp
-    1fd5:	68 02 02 00 00       	push   $0x202
-    1fda:	68 66 47 00 00       	push   $0x4766
-    1fdf:	e8 df 19 00 00       	call   39c3 <open>
-    1fe4:	83 c4 10             	add    $0x10,%esp
-    1fe7:	85 c0                	test   %eax,%eax
-    1fe9:	0f 89 35 02 00 00    	jns    2224 <subdir+0x484>
-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
-    1fef:	83 ec 08             	sub    $0x8,%esp
-    1ff2:	68 02 02 00 00       	push   $0x202
-    1ff7:	68 8b 47 00 00       	push   $0x478b
-    1ffc:	e8 c2 19 00 00       	call   39c3 <open>
-    2001:	83 c4 10             	add    $0x10,%esp
-    2004:	85 c0                	test   %eax,%eax
-    2006:	0f 89 0f 03 00 00    	jns    231b <subdir+0x57b>
-  if(open("dd", O_CREATE) >= 0){
-    200c:	83 ec 08             	sub    $0x8,%esp
-    200f:	68 00 02 00 00       	push   $0x200
-    2014:	68 18 47 00 00       	push   $0x4718
-    2019:	e8 a5 19 00 00       	call   39c3 <open>
-    201e:	83 c4 10             	add    $0x10,%esp
-    2021:	85 c0                	test   %eax,%eax
-    2023:	0f 89 df 02 00 00    	jns    2308 <subdir+0x568>
-  if(open("dd", O_RDWR) >= 0){
-    2029:	83 ec 08             	sub    $0x8,%esp
-    202c:	6a 02                	push   $0x2
-    202e:	68 18 47 00 00       	push   $0x4718
-    2033:	e8 8b 19 00 00       	call   39c3 <open>
-    2038:	83 c4 10             	add    $0x10,%esp
-    203b:	85 c0                	test   %eax,%eax
-    203d:	0f 89 b2 02 00 00    	jns    22f5 <subdir+0x555>
-  if(open("dd", O_WRONLY) >= 0){
-    2043:	83 ec 08             	sub    $0x8,%esp
-    2046:	6a 01                	push   $0x1
-    2048:	68 18 47 00 00       	push   $0x4718
-    204d:	e8 71 19 00 00       	call   39c3 <open>
-    2052:	83 c4 10             	add    $0x10,%esp
-    2055:	85 c0                	test   %eax,%eax
-    2057:	0f 89 85 02 00 00    	jns    22e2 <subdir+0x542>
-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
-    205d:	83 ec 08             	sub    $0x8,%esp
-    2060:	68 fa 47 00 00       	push   $0x47fa
-    2065:	68 66 47 00 00       	push   $0x4766
-    206a:	e8 74 19 00 00       	call   39e3 <link>
-    206f:	83 c4 10             	add    $0x10,%esp
-    2072:	85 c0                	test   %eax,%eax
-    2074:	0f 84 55 02 00 00    	je     22cf <subdir+0x52f>
-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
-    207a:	83 ec 08             	sub    $0x8,%esp
-    207d:	68 fa 47 00 00       	push   $0x47fa
-    2082:	68 8b 47 00 00       	push   $0x478b
-    2087:	e8 57 19 00 00       	call   39e3 <link>
-    208c:	83 c4 10             	add    $0x10,%esp
-    208f:	85 c0                	test   %eax,%eax
-    2091:	0f 84 25 02 00 00    	je     22bc <subdir+0x51c>
-  if(link("dd/ff", "dd/dd/ffff") == 0){
-    2097:	83 ec 08             	sub    $0x8,%esp
-    209a:	68 b2 46 00 00       	push   $0x46b2
-    209f:	68 51 46 00 00       	push   $0x4651
-    20a4:	e8 3a 19 00 00       	call   39e3 <link>
-    20a9:	83 c4 10             	add    $0x10,%esp
-    20ac:	85 c0                	test   %eax,%eax
-    20ae:	0f 84 a9 01 00 00    	je     225d <subdir+0x4bd>
-  if(mkdir("dd/ff/ff") == 0){
-    20b4:	83 ec 0c             	sub    $0xc,%esp
-    20b7:	68 66 47 00 00       	push   $0x4766
-    20bc:	e8 2a 19 00 00       	call   39eb <mkdir>
-    20c1:	83 c4 10             	add    $0x10,%esp
-    20c4:	85 c0                	test   %eax,%eax
-    20c6:	0f 84 7e 01 00 00    	je     224a <subdir+0x4aa>
-  if(mkdir("dd/xx/ff") == 0){
-    20cc:	83 ec 0c             	sub    $0xc,%esp
-    20cf:	68 8b 47 00 00       	push   $0x478b
-    20d4:	e8 12 19 00 00       	call   39eb <mkdir>
-    20d9:	83 c4 10             	add    $0x10,%esp
-    20dc:	85 c0                	test   %eax,%eax
-    20de:	0f 84 67 03 00 00    	je     244b <subdir+0x6ab>
-  if(mkdir("dd/dd/ffff") == 0){
-    20e4:	83 ec 0c             	sub    $0xc,%esp
-    20e7:	68 b2 46 00 00       	push   $0x46b2
-    20ec:	e8 fa 18 00 00       	call   39eb <mkdir>
-    20f1:	83 c4 10             	add    $0x10,%esp
-    20f4:	85 c0                	test   %eax,%eax
-    20f6:	0f 84 3c 03 00 00    	je     2438 <subdir+0x698>
-  if(unlink("dd/xx/ff") == 0){
-    20fc:	83 ec 0c             	sub    $0xc,%esp
-    20ff:	68 8b 47 00 00       	push   $0x478b
-    2104:	e8 ca 18 00 00       	call   39d3 <unlink>
-    2109:	83 c4 10             	add    $0x10,%esp
-    210c:	85 c0                	test   %eax,%eax
-    210e:	0f 84 11 03 00 00    	je     2425 <subdir+0x685>
-  if(unlink("dd/ff/ff") == 0){
-    2114:	83 ec 0c             	sub    $0xc,%esp
-    2117:	68 66 47 00 00       	push   $0x4766
-    211c:	e8 b2 18 00 00       	call   39d3 <unlink>
-    2121:	83 c4 10             	add    $0x10,%esp
-    2124:	85 c0                	test   %eax,%eax
-    2126:	0f 84 e6 02 00 00    	je     2412 <subdir+0x672>
-  if(chdir("dd/ff") == 0){
-    212c:	83 ec 0c             	sub    $0xc,%esp
-    212f:	68 51 46 00 00       	push   $0x4651
-    2134:	e8 ba 18 00 00       	call   39f3 <chdir>
-    2139:	83 c4 10             	add    $0x10,%esp
-    213c:	85 c0                	test   %eax,%eax
-    213e:	0f 84 bb 02 00 00    	je     23ff <subdir+0x65f>
-  if(chdir("dd/xx") == 0){
-    2144:	83 ec 0c             	sub    $0xc,%esp
-    2147:	68 fd 47 00 00       	push   $0x47fd
-    214c:	e8 a2 18 00 00       	call   39f3 <chdir>
-    2151:	83 c4 10             	add    $0x10,%esp
-    2154:	85 c0                	test   %eax,%eax
-    2156:	0f 84 90 02 00 00    	je     23ec <subdir+0x64c>
-  if(unlink("dd/dd/ffff") != 0){
-    215c:	83 ec 0c             	sub    $0xc,%esp
-    215f:	68 b2 46 00 00       	push   $0x46b2
-    2164:	e8 6a 18 00 00       	call   39d3 <unlink>
-    2169:	83 c4 10             	add    $0x10,%esp
-    216c:	85 c0                	test   %eax,%eax
-    216e:	0f 85 9d 00 00 00    	jne    2211 <subdir+0x471>
-  if(unlink("dd/ff") != 0){
-    2174:	83 ec 0c             	sub    $0xc,%esp
-    2177:	68 51 46 00 00       	push   $0x4651
-    217c:	e8 52 18 00 00       	call   39d3 <unlink>
-    2181:	83 c4 10             	add    $0x10,%esp
-    2184:	85 c0                	test   %eax,%eax
-    2186:	0f 85 4d 02 00 00    	jne    23d9 <subdir+0x639>
-  if(unlink("dd") == 0){
-    218c:	83 ec 0c             	sub    $0xc,%esp
-    218f:	68 18 47 00 00       	push   $0x4718
-    2194:	e8 3a 18 00 00       	call   39d3 <unlink>
-    2199:	83 c4 10             	add    $0x10,%esp
-    219c:	85 c0                	test   %eax,%eax
-    219e:	0f 84 22 02 00 00    	je     23c6 <subdir+0x626>
-  if(unlink("dd/dd") < 0){
-    21a4:	83 ec 0c             	sub    $0xc,%esp
-    21a7:	68 2d 46 00 00       	push   $0x462d
-    21ac:	e8 22 18 00 00       	call   39d3 <unlink>
-    21b1:	83 c4 10             	add    $0x10,%esp
-    21b4:	85 c0                	test   %eax,%eax
-    21b6:	0f 88 f7 01 00 00    	js     23b3 <subdir+0x613>
-  if(unlink("dd") < 0){
-    21bc:	83 ec 0c             	sub    $0xc,%esp
-    21bf:	68 18 47 00 00       	push   $0x4718
-    21c4:	e8 0a 18 00 00       	call   39d3 <unlink>
-    21c9:	83 c4 10             	add    $0x10,%esp
-    21cc:	85 c0                	test   %eax,%eax
-    21ce:	0f 88 cc 01 00 00    	js     23a0 <subdir+0x600>
-  printf(1, "subdir ok\n");
-    21d4:	83 ec 08             	sub    $0x8,%esp
-    21d7:	68 fa 48 00 00       	push   $0x48fa
-    21dc:	6a 01                	push   $0x1
-    21de:	e8 5d 19 00 00       	call   3b40 <printf>
-}
-    21e3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-    21e6:	83 c4 10             	add    $0x10,%esp
-    21e9:	c9                   	leave  
-    21ea:	c3                   	ret    
-    printf(1, "dd/dd/../ff wrong content\n");
-    21eb:	50                   	push   %eax
-    21ec:	50                   	push   %eax
-    21ed:	68 97 46 00 00       	push   $0x4697
-    21f2:	6a 01                	push   $0x1
-    21f4:	e8 47 19 00 00       	call   3b40 <printf>
-    exit();
-    21f9:	e8 85 17 00 00       	call   3983 <exit>
-    printf(1, "chdir dd/../../dd failed\n");
-    21fe:	50                   	push   %eax
-    21ff:	50                   	push   %eax
-    2200:	68 f2 46 00 00       	push   $0x46f2
-    2205:	6a 01                	push   $0x1
-    2207:	e8 34 19 00 00       	call   3b40 <printf>
-    exit();
-    220c:	e8 72 17 00 00       	call   3983 <exit>
-    printf(1, "unlink dd/dd/ff failed\n");
-    2211:	50                   	push   %eax
-    2212:	50                   	push   %eax
-    2213:	68 bd 46 00 00       	push   $0x46bd
-    2218:	6a 01                	push   $0x1
-    221a:	e8 21 19 00 00       	call   3b40 <printf>
-    exit();
-    221f:	e8 5f 17 00 00       	call   3983 <exit>
-    printf(1, "create dd/ff/ff succeeded!\n");
-    2224:	51                   	push   %ecx
-    2225:	51                   	push   %ecx
-    2226:	68 6f 47 00 00       	push   $0x476f
-    222b:	6a 01                	push   $0x1
-    222d:	e8 0e 19 00 00       	call   3b40 <printf>
-    exit();
-    2232:	e8 4c 17 00 00       	call   3983 <exit>
-    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
-    2237:	53                   	push   %ebx
-    2238:	53                   	push   %ebx
-    2239:	68 54 51 00 00       	push   $0x5154
-    223e:	6a 01                	push   $0x1
-    2240:	e8 fb 18 00 00       	call   3b40 <printf>
-    exit();
-    2245:	e8 39 17 00 00       	call   3983 <exit>
-    printf(1, "mkdir dd/ff/ff succeeded!\n");
-    224a:	51                   	push   %ecx
-    224b:	51                   	push   %ecx
-    224c:	68 03 48 00 00       	push   $0x4803
-    2251:	6a 01                	push   $0x1
-    2253:	e8 e8 18 00 00       	call   3b40 <printf>
-    exit();
-    2258:	e8 26 17 00 00       	call   3983 <exit>
-    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
-    225d:	53                   	push   %ebx
-    225e:	53                   	push   %ebx
-    225f:	68 c4 51 00 00       	push   $0x51c4
-    2264:	6a 01                	push   $0x1
-    2266:	e8 d5 18 00 00       	call   3b40 <printf>
-    exit();
-    226b:	e8 13 17 00 00       	call   3983 <exit>
-    printf(1, "open dd/dd/../ff failed\n");
-    2270:	50                   	push   %eax
-    2271:	50                   	push   %eax
-    2272:	68 7e 46 00 00       	push   $0x467e
-    2277:	6a 01                	push   $0x1
-    2279:	e8 c2 18 00 00       	call   3b40 <printf>
-    exit();
-    227e:	e8 00 17 00 00       	call   3983 <exit>
-    printf(1, "create dd/dd/ff failed\n");
-    2283:	51                   	push   %ecx
-    2284:	51                   	push   %ecx
-    2285:	68 57 46 00 00       	push   $0x4657
-    228a:	6a 01                	push   $0x1
-    228c:	e8 af 18 00 00       	call   3b40 <printf>
-    exit();
-    2291:	e8 ed 16 00 00       	call   3983 <exit>
-    printf(1, "chdir ./.. failed\n");
-    2296:	50                   	push   %eax
-    2297:	50                   	push   %eax
-    2298:	68 20 47 00 00       	push   $0x4720
-    229d:	6a 01                	push   $0x1
-    229f:	e8 9c 18 00 00       	call   3b40 <printf>
-    exit();
-    22a4:	e8 da 16 00 00       	call   3983 <exit>
-    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
-    22a9:	52                   	push   %edx
-    22aa:	52                   	push   %edx
-    22ab:	68 0c 51 00 00       	push   $0x510c
-    22b0:	6a 01                	push   $0x1
-    22b2:	e8 89 18 00 00       	call   3b40 <printf>
-    exit();
-    22b7:	e8 c7 16 00 00       	call   3983 <exit>
-    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
-    22bc:	50                   	push   %eax
-    22bd:	50                   	push   %eax
-    22be:	68 a0 51 00 00       	push   $0x51a0
-    22c3:	6a 01                	push   $0x1
-    22c5:	e8 76 18 00 00       	call   3b40 <printf>
-    exit();
-    22ca:	e8 b4 16 00 00       	call   3983 <exit>
-    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
-    22cf:	50                   	push   %eax
-    22d0:	50                   	push   %eax
-    22d1:	68 7c 51 00 00       	push   $0x517c
-    22d6:	6a 01                	push   $0x1
-    22d8:	e8 63 18 00 00       	call   3b40 <printf>
-    exit();
-    22dd:	e8 a1 16 00 00       	call   3983 <exit>
-    printf(1, "open dd wronly succeeded!\n");
-    22e2:	50                   	push   %eax
-    22e3:	50                   	push   %eax
-    22e4:	68 df 47 00 00       	push   $0x47df
-    22e9:	6a 01                	push   $0x1
-    22eb:	e8 50 18 00 00       	call   3b40 <printf>
-    exit();
-    22f0:	e8 8e 16 00 00       	call   3983 <exit>
-    printf(1, "open dd rdwr succeeded!\n");
-    22f5:	50                   	push   %eax
-    22f6:	50                   	push   %eax
-    22f7:	68 c6 47 00 00       	push   $0x47c6
-    22fc:	6a 01                	push   $0x1
-    22fe:	e8 3d 18 00 00       	call   3b40 <printf>
-    exit();
-    2303:	e8 7b 16 00 00       	call   3983 <exit>
-    printf(1, "create dd succeeded!\n");
-    2308:	50                   	push   %eax
-    2309:	50                   	push   %eax
-    230a:	68 b0 47 00 00       	push   $0x47b0
-    230f:	6a 01                	push   $0x1
-    2311:	e8 2a 18 00 00       	call   3b40 <printf>
-    exit();
-    2316:	e8 68 16 00 00       	call   3983 <exit>
-    printf(1, "create dd/xx/ff succeeded!\n");
-    231b:	52                   	push   %edx
-    231c:	52                   	push   %edx
-    231d:	68 94 47 00 00       	push   $0x4794
-    2322:	6a 01                	push   $0x1
-    2324:	e8 17 18 00 00       	call   3b40 <printf>
-    exit();
-    2329:	e8 55 16 00 00       	call   3983 <exit>
-    printf(1, "chdir dd failed\n");
-    232e:	50                   	push   %eax
-    232f:	50                   	push   %eax
-    2330:	68 d5 46 00 00       	push   $0x46d5
-    2335:	6a 01                	push   $0x1
-    2337:	e8 04 18 00 00       	call   3b40 <printf>
-    exit();
-    233c:	e8 42 16 00 00       	call   3983 <exit>
-    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
-    2341:	50                   	push   %eax
-    2342:	50                   	push   %eax
-    2343:	68 30 51 00 00       	push   $0x5130
-    2348:	6a 01                	push   $0x1
-    234a:	e8 f1 17 00 00       	call   3b40 <printf>
-    exit();
-    234f:	e8 2f 16 00 00       	call   3983 <exit>
-    printf(1, "subdir mkdir dd/dd failed\n");
-    2354:	53                   	push   %ebx
-    2355:	53                   	push   %ebx
-    2356:	68 33 46 00 00       	push   $0x4633
-    235b:	6a 01                	push   $0x1
-    235d:	e8 de 17 00 00       	call   3b40 <printf>
-    exit();
-    2362:	e8 1c 16 00 00       	call   3983 <exit>
-    printf(1, "unlink dd (non-empty dir) succeeded!\n");
-    2367:	50                   	push   %eax
-    2368:	50                   	push   %eax
-    2369:	68 e4 50 00 00       	push   $0x50e4
-    236e:	6a 01                	push   $0x1
-    2370:	e8 cb 17 00 00       	call   3b40 <printf>
-    exit();
-    2375:	e8 09 16 00 00       	call   3983 <exit>
-    printf(1, "create dd/ff failed\n");
-    237a:	50                   	push   %eax
-    237b:	50                   	push   %eax
-    237c:	68 17 46 00 00       	push   $0x4617
-    2381:	6a 01                	push   $0x1
-    2383:	e8 b8 17 00 00       	call   3b40 <printf>
-    exit();
-    2388:	e8 f6 15 00 00       	call   3983 <exit>
-    printf(1, "subdir mkdir dd failed\n");
-    238d:	50                   	push   %eax
-    238e:	50                   	push   %eax
-    238f:	68 ff 45 00 00       	push   $0x45ff
-    2394:	6a 01                	push   $0x1
-    2396:	e8 a5 17 00 00       	call   3b40 <printf>
-    exit();
-    239b:	e8 e3 15 00 00       	call   3983 <exit>
-    printf(1, "unlink dd failed\n");
-    23a0:	50                   	push   %eax
-    23a1:	50                   	push   %eax
-    23a2:	68 e8 48 00 00       	push   $0x48e8
-    23a7:	6a 01                	push   $0x1
-    23a9:	e8 92 17 00 00       	call   3b40 <printf>
-    exit();
-    23ae:	e8 d0 15 00 00       	call   3983 <exit>
-    printf(1, "unlink dd/dd failed\n");
-    23b3:	52                   	push   %edx
-    23b4:	52                   	push   %edx
-    23b5:	68 d3 48 00 00       	push   $0x48d3
-    23ba:	6a 01                	push   $0x1
-    23bc:	e8 7f 17 00 00       	call   3b40 <printf>
-    exit();
-    23c1:	e8 bd 15 00 00       	call   3983 <exit>
-    printf(1, "unlink non-empty dd succeeded!\n");
-    23c6:	51                   	push   %ecx
-    23c7:	51                   	push   %ecx
-    23c8:	68 e8 51 00 00       	push   $0x51e8
-    23cd:	6a 01                	push   $0x1
-    23cf:	e8 6c 17 00 00       	call   3b40 <printf>
-    exit();
-    23d4:	e8 aa 15 00 00       	call   3983 <exit>
-    printf(1, "unlink dd/ff failed\n");
-    23d9:	53                   	push   %ebx
-    23da:	53                   	push   %ebx
-    23db:	68 be 48 00 00       	push   $0x48be
-    23e0:	6a 01                	push   $0x1
-    23e2:	e8 59 17 00 00       	call   3b40 <printf>
-    exit();
-    23e7:	e8 97 15 00 00       	call   3983 <exit>
-    printf(1, "chdir dd/xx succeeded!\n");
-    23ec:	50                   	push   %eax
-    23ed:	50                   	push   %eax
-    23ee:	68 a6 48 00 00       	push   $0x48a6
-    23f3:	6a 01                	push   $0x1
-    23f5:	e8 46 17 00 00       	call   3b40 <printf>
-    exit();
-    23fa:	e8 84 15 00 00       	call   3983 <exit>
-    printf(1, "chdir dd/ff succeeded!\n");
-    23ff:	50                   	push   %eax
-    2400:	50                   	push   %eax
-    2401:	68 8e 48 00 00       	push   $0x488e
-    2406:	6a 01                	push   $0x1
-    2408:	e8 33 17 00 00       	call   3b40 <printf>
-    exit();
-    240d:	e8 71 15 00 00       	call   3983 <exit>
-    printf(1, "unlink dd/ff/ff succeeded!\n");
-    2412:	50                   	push   %eax
-    2413:	50                   	push   %eax
-    2414:	68 72 48 00 00       	push   $0x4872
-    2419:	6a 01                	push   $0x1
-    241b:	e8 20 17 00 00       	call   3b40 <printf>
-    exit();
-    2420:	e8 5e 15 00 00       	call   3983 <exit>
-    printf(1, "unlink dd/xx/ff succeeded!\n");
-    2425:	50                   	push   %eax
-    2426:	50                   	push   %eax
-    2427:	68 56 48 00 00       	push   $0x4856
-    242c:	6a 01                	push   $0x1
-    242e:	e8 0d 17 00 00       	call   3b40 <printf>
-    exit();
-    2433:	e8 4b 15 00 00       	call   3983 <exit>
-    printf(1, "mkdir dd/dd/ffff succeeded!\n");
-    2438:	50                   	push   %eax
-    2439:	50                   	push   %eax
-    243a:	68 39 48 00 00       	push   $0x4839
-    243f:	6a 01                	push   $0x1
-    2441:	e8 fa 16 00 00       	call   3b40 <printf>
-    exit();
-    2446:	e8 38 15 00 00       	call   3983 <exit>
-    printf(1, "mkdir dd/xx/ff succeeded!\n");
-    244b:	52                   	push   %edx
-    244c:	52                   	push   %edx
-    244d:	68 1e 48 00 00       	push   $0x481e
-    2452:	6a 01                	push   $0x1
-    2454:	e8 e7 16 00 00       	call   3b40 <printf>
-    exit();
-    2459:	e8 25 15 00 00       	call   3983 <exit>
-    printf(1, "read dd/dd/ffff wrong len\n");
-    245e:	51                   	push   %ecx
-    245f:	51                   	push   %ecx
-    2460:	68 4b 47 00 00       	push   $0x474b
-    2465:	6a 01                	push   $0x1
-    2467:	e8 d4 16 00 00       	call   3b40 <printf>
-    exit();
-    246c:	e8 12 15 00 00       	call   3983 <exit>
-    printf(1, "open dd/dd/ffff failed\n");
-    2471:	53                   	push   %ebx
-    2472:	53                   	push   %ebx
-    2473:	68 33 47 00 00       	push   $0x4733
-    2478:	6a 01                	push   $0x1
-    247a:	e8 c1 16 00 00       	call   3b40 <printf>
-    exit();
-    247f:	e8 ff 14 00 00       	call   3983 <exit>
-    2484:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    248b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    248f:	90                   	nop
-
-00002490 <bigwrite>:
-{
-    2490:	f3 0f 1e fb          	endbr32 
-    2494:	55                   	push   %ebp
-    2495:	89 e5                	mov    %esp,%ebp
-    2497:	56                   	push   %esi
-    2498:	53                   	push   %ebx
-  for(sz = 499; sz < 12*512; sz += 471){
-    2499:	bb f3 01 00 00       	mov    $0x1f3,%ebx
-  printf(1, "bigwrite test\n");
-    249e:	83 ec 08             	sub    $0x8,%esp
-    24a1:	68 05 49 00 00       	push   $0x4905
-    24a6:	6a 01                	push   $0x1
-    24a8:	e8 93 16 00 00       	call   3b40 <printf>
-  unlink("bigwrite");
-    24ad:	c7 04 24 14 49 00 00 	movl   $0x4914,(%esp)
-    24b4:	e8 1a 15 00 00       	call   39d3 <unlink>
-    24b9:	83 c4 10             	add    $0x10,%esp
-    24bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    fd = open("bigwrite", O_CREATE | O_RDWR);
-    24c0:	83 ec 08             	sub    $0x8,%esp
-    24c3:	68 02 02 00 00       	push   $0x202
-    24c8:	68 14 49 00 00       	push   $0x4914
-    24cd:	e8 f1 14 00 00       	call   39c3 <open>
-    if(fd < 0){
-    24d2:	83 c4 10             	add    $0x10,%esp
-    fd = open("bigwrite", O_CREATE | O_RDWR);
-    24d5:	89 c6                	mov    %eax,%esi
-    if(fd < 0){
-    24d7:	85 c0                	test   %eax,%eax
-    24d9:	78 7e                	js     2559 <bigwrite+0xc9>
-      int cc = write(fd, buf, sz);
-    24db:	83 ec 04             	sub    $0x4,%esp
-    24de:	53                   	push   %ebx
-    24df:	68 20 87 00 00       	push   $0x8720
-    24e4:	50                   	push   %eax
-    24e5:	e8 b9 14 00 00       	call   39a3 <write>
-      if(cc != sz){
-    24ea:	83 c4 10             	add    $0x10,%esp
-    24ed:	39 d8                	cmp    %ebx,%eax
-    24ef:	75 55                	jne    2546 <bigwrite+0xb6>
-      int cc = write(fd, buf, sz);
-    24f1:	83 ec 04             	sub    $0x4,%esp
-    24f4:	53                   	push   %ebx
-    24f5:	68 20 87 00 00       	push   $0x8720
-    24fa:	56                   	push   %esi
-    24fb:	e8 a3 14 00 00       	call   39a3 <write>
-      if(cc != sz){
-    2500:	83 c4 10             	add    $0x10,%esp
-    2503:	39 d8                	cmp    %ebx,%eax
-    2505:	75 3f                	jne    2546 <bigwrite+0xb6>
-    close(fd);
-    2507:	83 ec 0c             	sub    $0xc,%esp
-  for(sz = 499; sz < 12*512; sz += 471){
-    250a:	81 c3 d7 01 00 00    	add    $0x1d7,%ebx
-    close(fd);
-    2510:	56                   	push   %esi
-    2511:	e8 95 14 00 00       	call   39ab <close>
-    unlink("bigwrite");
-    2516:	c7 04 24 14 49 00 00 	movl   $0x4914,(%esp)
-    251d:	e8 b1 14 00 00       	call   39d3 <unlink>
-  for(sz = 499; sz < 12*512; sz += 471){
-    2522:	83 c4 10             	add    $0x10,%esp
-    2525:	81 fb 07 18 00 00    	cmp    $0x1807,%ebx
-    252b:	75 93                	jne    24c0 <bigwrite+0x30>
-  printf(1, "bigwrite ok\n");
-    252d:	83 ec 08             	sub    $0x8,%esp
-    2530:	68 47 49 00 00       	push   $0x4947
-    2535:	6a 01                	push   $0x1
-    2537:	e8 04 16 00 00       	call   3b40 <printf>
-}
-    253c:	83 c4 10             	add    $0x10,%esp
-    253f:	8d 65 f8             	lea    -0x8(%ebp),%esp
-    2542:	5b                   	pop    %ebx
-    2543:	5e                   	pop    %esi
-    2544:	5d                   	pop    %ebp
-    2545:	c3                   	ret    
-        printf(1, "write(%d) ret %d\n", sz, cc);
-    2546:	50                   	push   %eax
-    2547:	53                   	push   %ebx
-    2548:	68 35 49 00 00       	push   $0x4935
-    254d:	6a 01                	push   $0x1
-    254f:	e8 ec 15 00 00       	call   3b40 <printf>
-        exit();
-    2554:	e8 2a 14 00 00       	call   3983 <exit>
-      printf(1, "cannot create bigwrite\n");
-    2559:	83 ec 08             	sub    $0x8,%esp
-    255c:	68 1d 49 00 00       	push   $0x491d
-    2561:	6a 01                	push   $0x1
-    2563:	e8 d8 15 00 00       	call   3b40 <printf>
-      exit();
-    2568:	e8 16 14 00 00       	call   3983 <exit>
-    256d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00002570 <bigfile>:
-{
-    2570:	f3 0f 1e fb          	endbr32 
-    2574:	55                   	push   %ebp
-    2575:	89 e5                	mov    %esp,%ebp
-    2577:	57                   	push   %edi
-    2578:	56                   	push   %esi
-    2579:	53                   	push   %ebx
-    257a:	83 ec 14             	sub    $0x14,%esp
-  printf(1, "bigfile test\n");
-    257d:	68 54 49 00 00       	push   $0x4954
-    2582:	6a 01                	push   $0x1
-    2584:	e8 b7 15 00 00       	call   3b40 <printf>
-  unlink("bigfile");
-    2589:	c7 04 24 70 49 00 00 	movl   $0x4970,(%esp)
-    2590:	e8 3e 14 00 00       	call   39d3 <unlink>
-  fd = open("bigfile", O_CREATE | O_RDWR);
-    2595:	58                   	pop    %eax
-    2596:	5a                   	pop    %edx
-    2597:	68 02 02 00 00       	push   $0x202
-    259c:	68 70 49 00 00       	push   $0x4970
-    25a1:	e8 1d 14 00 00       	call   39c3 <open>
-  if(fd < 0){
-    25a6:	83 c4 10             	add    $0x10,%esp
-    25a9:	85 c0                	test   %eax,%eax
-    25ab:	0f 88 5a 01 00 00    	js     270b <bigfile+0x19b>
-    25b1:	89 c6                	mov    %eax,%esi
-  for(i = 0; i < 20; i++){
-    25b3:	31 db                	xor    %ebx,%ebx
-    25b5:	8d 76 00             	lea    0x0(%esi),%esi
-    memset(buf, i, 600);
-    25b8:	83 ec 04             	sub    $0x4,%esp
-    25bb:	68 58 02 00 00       	push   $0x258
-    25c0:	53                   	push   %ebx
-    25c1:	68 20 87 00 00       	push   $0x8720
-    25c6:	e8 15 12 00 00       	call   37e0 <memset>
-    if(write(fd, buf, 600) != 600){
-    25cb:	83 c4 0c             	add    $0xc,%esp
-    25ce:	68 58 02 00 00       	push   $0x258
-    25d3:	68 20 87 00 00       	push   $0x8720
-    25d8:	56                   	push   %esi
-    25d9:	e8 c5 13 00 00       	call   39a3 <write>
-    25de:	83 c4 10             	add    $0x10,%esp
-    25e1:	3d 58 02 00 00       	cmp    $0x258,%eax
-    25e6:	0f 85 f8 00 00 00    	jne    26e4 <bigfile+0x174>
-  for(i = 0; i < 20; i++){
-    25ec:	83 c3 01             	add    $0x1,%ebx
-    25ef:	83 fb 14             	cmp    $0x14,%ebx
-    25f2:	75 c4                	jne    25b8 <bigfile+0x48>
-  close(fd);
-    25f4:	83 ec 0c             	sub    $0xc,%esp
-    25f7:	56                   	push   %esi
-    25f8:	e8 ae 13 00 00       	call   39ab <close>
-  fd = open("bigfile", 0);
-    25fd:	5e                   	pop    %esi
-    25fe:	5f                   	pop    %edi
-    25ff:	6a 00                	push   $0x0
-    2601:	68 70 49 00 00       	push   $0x4970
-    2606:	e8 b8 13 00 00       	call   39c3 <open>
-  if(fd < 0){
-    260b:	83 c4 10             	add    $0x10,%esp
-  fd = open("bigfile", 0);
-    260e:	89 c6                	mov    %eax,%esi
-  if(fd < 0){
-    2610:	85 c0                	test   %eax,%eax
-    2612:	0f 88 e0 00 00 00    	js     26f8 <bigfile+0x188>
-  total = 0;
-    2618:	31 db                	xor    %ebx,%ebx
-  for(i = 0; ; i++){
-    261a:	31 ff                	xor    %edi,%edi
-    261c:	eb 30                	jmp    264e <bigfile+0xde>
-    261e:	66 90                	xchg   %ax,%ax
-    if(cc != 300){
-    2620:	3d 2c 01 00 00       	cmp    $0x12c,%eax
-    2625:	0f 85 91 00 00 00    	jne    26bc <bigfile+0x14c>
-    if(buf[0] != i/2 || buf[299] != i/2){
-    262b:	89 fa                	mov    %edi,%edx
-    262d:	0f be 05 20 87 00 00 	movsbl 0x8720,%eax
-    2634:	d1 fa                	sar    %edx
-    2636:	39 d0                	cmp    %edx,%eax
-    2638:	75 6e                	jne    26a8 <bigfile+0x138>
-    263a:	0f be 15 4b 88 00 00 	movsbl 0x884b,%edx
-    2641:	39 d0                	cmp    %edx,%eax
-    2643:	75 63                	jne    26a8 <bigfile+0x138>
-    total += cc;
-    2645:	81 c3 2c 01 00 00    	add    $0x12c,%ebx
-  for(i = 0; ; i++){
-    264b:	83 c7 01             	add    $0x1,%edi
-    cc = read(fd, buf, 300);
-    264e:	83 ec 04             	sub    $0x4,%esp
-    2651:	68 2c 01 00 00       	push   $0x12c
-    2656:	68 20 87 00 00       	push   $0x8720
-    265b:	56                   	push   %esi
-    265c:	e8 3a 13 00 00       	call   399b <read>
-    if(cc < 0){
-    2661:	83 c4 10             	add    $0x10,%esp
-    2664:	85 c0                	test   %eax,%eax
-    2666:	78 68                	js     26d0 <bigfile+0x160>
-    if(cc == 0)
-    2668:	75 b6                	jne    2620 <bigfile+0xb0>
-  close(fd);
-    266a:	83 ec 0c             	sub    $0xc,%esp
-    266d:	56                   	push   %esi
-    266e:	e8 38 13 00 00       	call   39ab <close>
-  if(total != 20*600){
-    2673:	83 c4 10             	add    $0x10,%esp
-    2676:	81 fb e0 2e 00 00    	cmp    $0x2ee0,%ebx
-    267c:	0f 85 9c 00 00 00    	jne    271e <bigfile+0x1ae>
-  unlink("bigfile");
-    2682:	83 ec 0c             	sub    $0xc,%esp
-    2685:	68 70 49 00 00       	push   $0x4970
-    268a:	e8 44 13 00 00       	call   39d3 <unlink>
-  printf(1, "bigfile test ok\n");
-    268f:	58                   	pop    %eax
-    2690:	5a                   	pop    %edx
-    2691:	68 ff 49 00 00       	push   $0x49ff
-    2696:	6a 01                	push   $0x1
-    2698:	e8 a3 14 00 00       	call   3b40 <printf>
-}
-    269d:	83 c4 10             	add    $0x10,%esp
-    26a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    26a3:	5b                   	pop    %ebx
-    26a4:	5e                   	pop    %esi
-    26a5:	5f                   	pop    %edi
-    26a6:	5d                   	pop    %ebp
-    26a7:	c3                   	ret    
-      printf(1, "read bigfile wrong data\n");
-    26a8:	83 ec 08             	sub    $0x8,%esp
-    26ab:	68 cc 49 00 00       	push   $0x49cc
-    26b0:	6a 01                	push   $0x1
-    26b2:	e8 89 14 00 00       	call   3b40 <printf>
-      exit();
-    26b7:	e8 c7 12 00 00       	call   3983 <exit>
-      printf(1, "short read bigfile\n");
-    26bc:	83 ec 08             	sub    $0x8,%esp
-    26bf:	68 b8 49 00 00       	push   $0x49b8
-    26c4:	6a 01                	push   $0x1
-    26c6:	e8 75 14 00 00       	call   3b40 <printf>
-      exit();
-    26cb:	e8 b3 12 00 00       	call   3983 <exit>
-      printf(1, "read bigfile failed\n");
-    26d0:	83 ec 08             	sub    $0x8,%esp
-    26d3:	68 a3 49 00 00       	push   $0x49a3
-    26d8:	6a 01                	push   $0x1
-    26da:	e8 61 14 00 00       	call   3b40 <printf>
-      exit();
-    26df:	e8 9f 12 00 00       	call   3983 <exit>
-      printf(1, "write bigfile failed\n");
-    26e4:	83 ec 08             	sub    $0x8,%esp
-    26e7:	68 78 49 00 00       	push   $0x4978
-    26ec:	6a 01                	push   $0x1
-    26ee:	e8 4d 14 00 00       	call   3b40 <printf>
-      exit();
-    26f3:	e8 8b 12 00 00       	call   3983 <exit>
-    printf(1, "cannot open bigfile\n");
-    26f8:	53                   	push   %ebx
-    26f9:	53                   	push   %ebx
-    26fa:	68 8e 49 00 00       	push   $0x498e
-    26ff:	6a 01                	push   $0x1
-    2701:	e8 3a 14 00 00       	call   3b40 <printf>
-    exit();
-    2706:	e8 78 12 00 00       	call   3983 <exit>
-    printf(1, "cannot create bigfile");
-    270b:	50                   	push   %eax
-    270c:	50                   	push   %eax
-    270d:	68 62 49 00 00       	push   $0x4962
-    2712:	6a 01                	push   $0x1
-    2714:	e8 27 14 00 00       	call   3b40 <printf>
-    exit();
-    2719:	e8 65 12 00 00       	call   3983 <exit>
-    printf(1, "read bigfile wrong total\n");
-    271e:	51                   	push   %ecx
-    271f:	51                   	push   %ecx
-    2720:	68 e5 49 00 00       	push   $0x49e5
-    2725:	6a 01                	push   $0x1
-    2727:	e8 14 14 00 00       	call   3b40 <printf>
-    exit();
-    272c:	e8 52 12 00 00       	call   3983 <exit>
-    2731:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    2738:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    273f:	90                   	nop
-
-00002740 <fourteen>:
-{
-    2740:	f3 0f 1e fb          	endbr32 
-    2744:	55                   	push   %ebp
-    2745:	89 e5                	mov    %esp,%ebp
-    2747:	83 ec 10             	sub    $0x10,%esp
-  printf(1, "fourteen test\n");
-    274a:	68 10 4a 00 00       	push   $0x4a10
-    274f:	6a 01                	push   $0x1
-    2751:	e8 ea 13 00 00       	call   3b40 <printf>
-  if(mkdir("12345678901234") != 0){
-    2756:	c7 04 24 4b 4a 00 00 	movl   $0x4a4b,(%esp)
-    275d:	e8 89 12 00 00       	call   39eb <mkdir>
-    2762:	83 c4 10             	add    $0x10,%esp
-    2765:	85 c0                	test   %eax,%eax
-    2767:	0f 85 97 00 00 00    	jne    2804 <fourteen+0xc4>
-  if(mkdir("12345678901234/123456789012345") != 0){
-    276d:	83 ec 0c             	sub    $0xc,%esp
-    2770:	68 08 52 00 00       	push   $0x5208
-    2775:	e8 71 12 00 00       	call   39eb <mkdir>
-    277a:	83 c4 10             	add    $0x10,%esp
-    277d:	85 c0                	test   %eax,%eax
-    277f:	0f 85 de 00 00 00    	jne    2863 <fourteen+0x123>
-  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
-    2785:	83 ec 08             	sub    $0x8,%esp
-    2788:	68 00 02 00 00       	push   $0x200
-    278d:	68 58 52 00 00       	push   $0x5258
-    2792:	e8 2c 12 00 00       	call   39c3 <open>
-  if(fd < 0){
-    2797:	83 c4 10             	add    $0x10,%esp
-    279a:	85 c0                	test   %eax,%eax
-    279c:	0f 88 ae 00 00 00    	js     2850 <fourteen+0x110>
-  close(fd);
-    27a2:	83 ec 0c             	sub    $0xc,%esp
-    27a5:	50                   	push   %eax
-    27a6:	e8 00 12 00 00       	call   39ab <close>
-  fd = open("12345678901234/12345678901234/12345678901234", 0);
-    27ab:	58                   	pop    %eax
-    27ac:	5a                   	pop    %edx
-    27ad:	6a 00                	push   $0x0
-    27af:	68 c8 52 00 00       	push   $0x52c8
-    27b4:	e8 0a 12 00 00       	call   39c3 <open>
-  if(fd < 0){
-    27b9:	83 c4 10             	add    $0x10,%esp
-    27bc:	85 c0                	test   %eax,%eax
-    27be:	78 7d                	js     283d <fourteen+0xfd>
-  close(fd);
-    27c0:	83 ec 0c             	sub    $0xc,%esp
-    27c3:	50                   	push   %eax
-    27c4:	e8 e2 11 00 00       	call   39ab <close>
-  if(mkdir("12345678901234/12345678901234") == 0){
-    27c9:	c7 04 24 3c 4a 00 00 	movl   $0x4a3c,(%esp)
-    27d0:	e8 16 12 00 00       	call   39eb <mkdir>
-    27d5:	83 c4 10             	add    $0x10,%esp
-    27d8:	85 c0                	test   %eax,%eax
-    27da:	74 4e                	je     282a <fourteen+0xea>
-  if(mkdir("123456789012345/12345678901234") == 0){
-    27dc:	83 ec 0c             	sub    $0xc,%esp
-    27df:	68 64 53 00 00       	push   $0x5364
-    27e4:	e8 02 12 00 00       	call   39eb <mkdir>
-    27e9:	83 c4 10             	add    $0x10,%esp
-    27ec:	85 c0                	test   %eax,%eax
-    27ee:	74 27                	je     2817 <fourteen+0xd7>
-  printf(1, "fourteen ok\n");
-    27f0:	83 ec 08             	sub    $0x8,%esp
-    27f3:	68 5a 4a 00 00       	push   $0x4a5a
-    27f8:	6a 01                	push   $0x1
-    27fa:	e8 41 13 00 00       	call   3b40 <printf>
-}
-    27ff:	83 c4 10             	add    $0x10,%esp
-    2802:	c9                   	leave  
-    2803:	c3                   	ret    
-    printf(1, "mkdir 12345678901234 failed\n");
-    2804:	50                   	push   %eax
-    2805:	50                   	push   %eax
-    2806:	68 1f 4a 00 00       	push   $0x4a1f
-    280b:	6a 01                	push   $0x1
-    280d:	e8 2e 13 00 00       	call   3b40 <printf>
-    exit();
-    2812:	e8 6c 11 00 00       	call   3983 <exit>
-    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
-    2817:	50                   	push   %eax
-    2818:	50                   	push   %eax
-    2819:	68 84 53 00 00       	push   $0x5384
-    281e:	6a 01                	push   $0x1
-    2820:	e8 1b 13 00 00       	call   3b40 <printf>
-    exit();
-    2825:	e8 59 11 00 00       	call   3983 <exit>
-    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
-    282a:	52                   	push   %edx
-    282b:	52                   	push   %edx
-    282c:	68 34 53 00 00       	push   $0x5334
-    2831:	6a 01                	push   $0x1
-    2833:	e8 08 13 00 00       	call   3b40 <printf>
-    exit();
-    2838:	e8 46 11 00 00       	call   3983 <exit>
-    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
-    283d:	51                   	push   %ecx
-    283e:	51                   	push   %ecx
-    283f:	68 f8 52 00 00       	push   $0x52f8
-    2844:	6a 01                	push   $0x1
-    2846:	e8 f5 12 00 00       	call   3b40 <printf>
-    exit();
-    284b:	e8 33 11 00 00       	call   3983 <exit>
-    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
-    2850:	51                   	push   %ecx
-    2851:	51                   	push   %ecx
-    2852:	68 88 52 00 00       	push   $0x5288
-    2857:	6a 01                	push   $0x1
-    2859:	e8 e2 12 00 00       	call   3b40 <printf>
-    exit();
-    285e:	e8 20 11 00 00       	call   3983 <exit>
-    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
-    2863:	50                   	push   %eax
-    2864:	50                   	push   %eax
-    2865:	68 28 52 00 00       	push   $0x5228
-    286a:	6a 01                	push   $0x1
-    286c:	e8 cf 12 00 00       	call   3b40 <printf>
-    exit();
-    2871:	e8 0d 11 00 00       	call   3983 <exit>
-    2876:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    287d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00002880 <rmdot>:
-{
-    2880:	f3 0f 1e fb          	endbr32 
-    2884:	55                   	push   %ebp
-    2885:	89 e5                	mov    %esp,%ebp
-    2887:	83 ec 10             	sub    $0x10,%esp
-  printf(1, "rmdot test\n");
-    288a:	68 67 4a 00 00       	push   $0x4a67
-    288f:	6a 01                	push   $0x1
-    2891:	e8 aa 12 00 00       	call   3b40 <printf>
-  if(mkdir("dots") != 0){
-    2896:	c7 04 24 73 4a 00 00 	movl   $0x4a73,(%esp)
-    289d:	e8 49 11 00 00       	call   39eb <mkdir>
-    28a2:	83 c4 10             	add    $0x10,%esp
-    28a5:	85 c0                	test   %eax,%eax
-    28a7:	0f 85 b0 00 00 00    	jne    295d <rmdot+0xdd>
-  if(chdir("dots") != 0){
-    28ad:	83 ec 0c             	sub    $0xc,%esp
-    28b0:	68 73 4a 00 00       	push   $0x4a73
-    28b5:	e8 39 11 00 00       	call   39f3 <chdir>
-    28ba:	83 c4 10             	add    $0x10,%esp
-    28bd:	85 c0                	test   %eax,%eax
-    28bf:	0f 85 1d 01 00 00    	jne    29e2 <rmdot+0x162>
-  if(unlink(".") == 0){
-    28c5:	83 ec 0c             	sub    $0xc,%esp
-    28c8:	68 1e 47 00 00       	push   $0x471e
-    28cd:	e8 01 11 00 00       	call   39d3 <unlink>
-    28d2:	83 c4 10             	add    $0x10,%esp
-    28d5:	85 c0                	test   %eax,%eax
-    28d7:	0f 84 f2 00 00 00    	je     29cf <rmdot+0x14f>
-  if(unlink("..") == 0){
-    28dd:	83 ec 0c             	sub    $0xc,%esp
-    28e0:	68 1d 47 00 00       	push   $0x471d
-    28e5:	e8 e9 10 00 00       	call   39d3 <unlink>
-    28ea:	83 c4 10             	add    $0x10,%esp
-    28ed:	85 c0                	test   %eax,%eax
-    28ef:	0f 84 c7 00 00 00    	je     29bc <rmdot+0x13c>
-  if(chdir("/") != 0){
-    28f5:	83 ec 0c             	sub    $0xc,%esp
-    28f8:	68 f1 3e 00 00       	push   $0x3ef1
-    28fd:	e8 f1 10 00 00       	call   39f3 <chdir>
-    2902:	83 c4 10             	add    $0x10,%esp
-    2905:	85 c0                	test   %eax,%eax
-    2907:	0f 85 9c 00 00 00    	jne    29a9 <rmdot+0x129>
-  if(unlink("dots/.") == 0){
-    290d:	83 ec 0c             	sub    $0xc,%esp
-    2910:	68 bb 4a 00 00       	push   $0x4abb
-    2915:	e8 b9 10 00 00       	call   39d3 <unlink>
-    291a:	83 c4 10             	add    $0x10,%esp
-    291d:	85 c0                	test   %eax,%eax
-    291f:	74 75                	je     2996 <rmdot+0x116>
-  if(unlink("dots/..") == 0){
-    2921:	83 ec 0c             	sub    $0xc,%esp
-    2924:	68 d9 4a 00 00       	push   $0x4ad9
-    2929:	e8 a5 10 00 00       	call   39d3 <unlink>
-    292e:	83 c4 10             	add    $0x10,%esp
-    2931:	85 c0                	test   %eax,%eax
-    2933:	74 4e                	je     2983 <rmdot+0x103>
-  if(unlink("dots") != 0){
-    2935:	83 ec 0c             	sub    $0xc,%esp
-    2938:	68 73 4a 00 00       	push   $0x4a73
-    293d:	e8 91 10 00 00       	call   39d3 <unlink>
-    2942:	83 c4 10             	add    $0x10,%esp
-    2945:	85 c0                	test   %eax,%eax
-    2947:	75 27                	jne    2970 <rmdot+0xf0>
-  printf(1, "rmdot ok\n");
-    2949:	83 ec 08             	sub    $0x8,%esp
-    294c:	68 0e 4b 00 00       	push   $0x4b0e
-    2951:	6a 01                	push   $0x1
-    2953:	e8 e8 11 00 00       	call   3b40 <printf>
-}
-    2958:	83 c4 10             	add    $0x10,%esp
-    295b:	c9                   	leave  
-    295c:	c3                   	ret    
-    printf(1, "mkdir dots failed\n");
-    295d:	50                   	push   %eax
-    295e:	50                   	push   %eax
-    295f:	68 78 4a 00 00       	push   $0x4a78
-    2964:	6a 01                	push   $0x1
-    2966:	e8 d5 11 00 00       	call   3b40 <printf>
-    exit();
-    296b:	e8 13 10 00 00       	call   3983 <exit>
-    printf(1, "unlink dots failed!\n");
-    2970:	50                   	push   %eax
-    2971:	50                   	push   %eax
-    2972:	68 f9 4a 00 00       	push   $0x4af9
-    2977:	6a 01                	push   $0x1
-    2979:	e8 c2 11 00 00       	call   3b40 <printf>
-    exit();
-    297e:	e8 00 10 00 00       	call   3983 <exit>
-    printf(1, "unlink dots/.. worked!\n");
-    2983:	52                   	push   %edx
-    2984:	52                   	push   %edx
-    2985:	68 e1 4a 00 00       	push   $0x4ae1
-    298a:	6a 01                	push   $0x1
-    298c:	e8 af 11 00 00       	call   3b40 <printf>
-    exit();
-    2991:	e8 ed 0f 00 00       	call   3983 <exit>
-    printf(1, "unlink dots/. worked!\n");
-    2996:	51                   	push   %ecx
-    2997:	51                   	push   %ecx
-    2998:	68 c2 4a 00 00       	push   $0x4ac2
-    299d:	6a 01                	push   $0x1
-    299f:	e8 9c 11 00 00       	call   3b40 <printf>
-    exit();
-    29a4:	e8 da 0f 00 00       	call   3983 <exit>
-    printf(1, "chdir / failed\n");
-    29a9:	50                   	push   %eax
-    29aa:	50                   	push   %eax
-    29ab:	68 f3 3e 00 00       	push   $0x3ef3
-    29b0:	6a 01                	push   $0x1
-    29b2:	e8 89 11 00 00       	call   3b40 <printf>
-    exit();
-    29b7:	e8 c7 0f 00 00       	call   3983 <exit>
-    printf(1, "rm .. worked!\n");
-    29bc:	50                   	push   %eax
-    29bd:	50                   	push   %eax
-    29be:	68 ac 4a 00 00       	push   $0x4aac
-    29c3:	6a 01                	push   $0x1
-    29c5:	e8 76 11 00 00       	call   3b40 <printf>
-    exit();
-    29ca:	e8 b4 0f 00 00       	call   3983 <exit>
-    printf(1, "rm . worked!\n");
-    29cf:	50                   	push   %eax
-    29d0:	50                   	push   %eax
-    29d1:	68 9e 4a 00 00       	push   $0x4a9e
-    29d6:	6a 01                	push   $0x1
-    29d8:	e8 63 11 00 00       	call   3b40 <printf>
-    exit();
-    29dd:	e8 a1 0f 00 00       	call   3983 <exit>
-    printf(1, "chdir dots failed\n");
-    29e2:	50                   	push   %eax
-    29e3:	50                   	push   %eax
-    29e4:	68 8b 4a 00 00       	push   $0x4a8b
-    29e9:	6a 01                	push   $0x1
-    29eb:	e8 50 11 00 00       	call   3b40 <printf>
-    exit();
-    29f0:	e8 8e 0f 00 00       	call   3983 <exit>
-    29f5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    29fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00002a00 <dirfile>:
-{
-    2a00:	f3 0f 1e fb          	endbr32 
-    2a04:	55                   	push   %ebp
-    2a05:	89 e5                	mov    %esp,%ebp
-    2a07:	53                   	push   %ebx
-    2a08:	83 ec 0c             	sub    $0xc,%esp
-  printf(1, "dir vs file\n");
-    2a0b:	68 18 4b 00 00       	push   $0x4b18
-    2a10:	6a 01                	push   $0x1
-    2a12:	e8 29 11 00 00       	call   3b40 <printf>
-  fd = open("dirfile", O_CREATE);
-    2a17:	5b                   	pop    %ebx
-    2a18:	58                   	pop    %eax
-    2a19:	68 00 02 00 00       	push   $0x200
-    2a1e:	68 25 4b 00 00       	push   $0x4b25
-    2a23:	e8 9b 0f 00 00       	call   39c3 <open>
-  if(fd < 0){
-    2a28:	83 c4 10             	add    $0x10,%esp
-    2a2b:	85 c0                	test   %eax,%eax
-    2a2d:	0f 88 43 01 00 00    	js     2b76 <dirfile+0x176>
-  close(fd);
-    2a33:	83 ec 0c             	sub    $0xc,%esp
-    2a36:	50                   	push   %eax
-    2a37:	e8 6f 0f 00 00       	call   39ab <close>
-  if(chdir("dirfile") == 0){
-    2a3c:	c7 04 24 25 4b 00 00 	movl   $0x4b25,(%esp)
-    2a43:	e8 ab 0f 00 00       	call   39f3 <chdir>
-    2a48:	83 c4 10             	add    $0x10,%esp
-    2a4b:	85 c0                	test   %eax,%eax
-    2a4d:	0f 84 10 01 00 00    	je     2b63 <dirfile+0x163>
-  fd = open("dirfile/xx", 0);
-    2a53:	83 ec 08             	sub    $0x8,%esp
-    2a56:	6a 00                	push   $0x0
-    2a58:	68 5e 4b 00 00       	push   $0x4b5e
-    2a5d:	e8 61 0f 00 00       	call   39c3 <open>
-  if(fd >= 0){
-    2a62:	83 c4 10             	add    $0x10,%esp
-    2a65:	85 c0                	test   %eax,%eax
-    2a67:	0f 89 e3 00 00 00    	jns    2b50 <dirfile+0x150>
-  fd = open("dirfile/xx", O_CREATE);
-    2a6d:	83 ec 08             	sub    $0x8,%esp
-    2a70:	68 00 02 00 00       	push   $0x200
-    2a75:	68 5e 4b 00 00       	push   $0x4b5e
-    2a7a:	e8 44 0f 00 00       	call   39c3 <open>
-  if(fd >= 0){
-    2a7f:	83 c4 10             	add    $0x10,%esp
-    2a82:	85 c0                	test   %eax,%eax
-    2a84:	0f 89 c6 00 00 00    	jns    2b50 <dirfile+0x150>
-  if(mkdir("dirfile/xx") == 0){
-    2a8a:	83 ec 0c             	sub    $0xc,%esp
-    2a8d:	68 5e 4b 00 00       	push   $0x4b5e
-    2a92:	e8 54 0f 00 00       	call   39eb <mkdir>
-    2a97:	83 c4 10             	add    $0x10,%esp
-    2a9a:	85 c0                	test   %eax,%eax
-    2a9c:	0f 84 46 01 00 00    	je     2be8 <dirfile+0x1e8>
-  if(unlink("dirfile/xx") == 0){
-    2aa2:	83 ec 0c             	sub    $0xc,%esp
-    2aa5:	68 5e 4b 00 00       	push   $0x4b5e
-    2aaa:	e8 24 0f 00 00       	call   39d3 <unlink>
-    2aaf:	83 c4 10             	add    $0x10,%esp
-    2ab2:	85 c0                	test   %eax,%eax
-    2ab4:	0f 84 1b 01 00 00    	je     2bd5 <dirfile+0x1d5>
-  if(link("README", "dirfile/xx") == 0){
-    2aba:	83 ec 08             	sub    $0x8,%esp
-    2abd:	68 5e 4b 00 00       	push   $0x4b5e
-    2ac2:	68 c2 4b 00 00       	push   $0x4bc2
-    2ac7:	e8 17 0f 00 00       	call   39e3 <link>
-    2acc:	83 c4 10             	add    $0x10,%esp
-    2acf:	85 c0                	test   %eax,%eax
-    2ad1:	0f 84 eb 00 00 00    	je     2bc2 <dirfile+0x1c2>
-  if(unlink("dirfile") != 0){
-    2ad7:	83 ec 0c             	sub    $0xc,%esp
-    2ada:	68 25 4b 00 00       	push   $0x4b25
-    2adf:	e8 ef 0e 00 00       	call   39d3 <unlink>
-    2ae4:	83 c4 10             	add    $0x10,%esp
-    2ae7:	85 c0                	test   %eax,%eax
-    2ae9:	0f 85 c0 00 00 00    	jne    2baf <dirfile+0x1af>
-  fd = open(".", O_RDWR);
-    2aef:	83 ec 08             	sub    $0x8,%esp
-    2af2:	6a 02                	push   $0x2
-    2af4:	68 1e 47 00 00       	push   $0x471e
-    2af9:	e8 c5 0e 00 00       	call   39c3 <open>
-  if(fd >= 0){
-    2afe:	83 c4 10             	add    $0x10,%esp
-    2b01:	85 c0                	test   %eax,%eax
-    2b03:	0f 89 93 00 00 00    	jns    2b9c <dirfile+0x19c>
-  fd = open(".", 0);
-    2b09:	83 ec 08             	sub    $0x8,%esp
-    2b0c:	6a 00                	push   $0x0
-    2b0e:	68 1e 47 00 00       	push   $0x471e
-    2b13:	e8 ab 0e 00 00       	call   39c3 <open>
-  if(write(fd, "x", 1) > 0){
-    2b18:	83 c4 0c             	add    $0xc,%esp
-    2b1b:	6a 01                	push   $0x1
-  fd = open(".", 0);
-    2b1d:	89 c3                	mov    %eax,%ebx
-  if(write(fd, "x", 1) > 0){
-    2b1f:	68 01 48 00 00       	push   $0x4801
-    2b24:	50                   	push   %eax
-    2b25:	e8 79 0e 00 00       	call   39a3 <write>
-    2b2a:	83 c4 10             	add    $0x10,%esp
-    2b2d:	85 c0                	test   %eax,%eax
-    2b2f:	7f 58                	jg     2b89 <dirfile+0x189>
-  close(fd);
-    2b31:	83 ec 0c             	sub    $0xc,%esp
-    2b34:	53                   	push   %ebx
-    2b35:	e8 71 0e 00 00       	call   39ab <close>
-  printf(1, "dir vs file OK\n");
-    2b3a:	58                   	pop    %eax
-    2b3b:	5a                   	pop    %edx
-    2b3c:	68 f5 4b 00 00       	push   $0x4bf5
-    2b41:	6a 01                	push   $0x1
-    2b43:	e8 f8 0f 00 00       	call   3b40 <printf>
-}
-    2b48:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-    2b4b:	83 c4 10             	add    $0x10,%esp
-    2b4e:	c9                   	leave  
-    2b4f:	c3                   	ret    
-    printf(1, "create dirfile/xx succeeded!\n");
-    2b50:	50                   	push   %eax
-    2b51:	50                   	push   %eax
-    2b52:	68 69 4b 00 00       	push   $0x4b69
-    2b57:	6a 01                	push   $0x1
-    2b59:	e8 e2 0f 00 00       	call   3b40 <printf>
-    exit();
-    2b5e:	e8 20 0e 00 00       	call   3983 <exit>
-    printf(1, "chdir dirfile succeeded!\n");
-    2b63:	52                   	push   %edx
-    2b64:	52                   	push   %edx
-    2b65:	68 44 4b 00 00       	push   $0x4b44
-    2b6a:	6a 01                	push   $0x1
-    2b6c:	e8 cf 0f 00 00       	call   3b40 <printf>
-    exit();
-    2b71:	e8 0d 0e 00 00       	call   3983 <exit>
-    printf(1, "create dirfile failed\n");
-    2b76:	51                   	push   %ecx
-    2b77:	51                   	push   %ecx
-    2b78:	68 2d 4b 00 00       	push   $0x4b2d
-    2b7d:	6a 01                	push   $0x1
-    2b7f:	e8 bc 0f 00 00       	call   3b40 <printf>
-    exit();
-    2b84:	e8 fa 0d 00 00       	call   3983 <exit>
-    printf(1, "write . succeeded!\n");
-    2b89:	51                   	push   %ecx
-    2b8a:	51                   	push   %ecx
-    2b8b:	68 e1 4b 00 00       	push   $0x4be1
-    2b90:	6a 01                	push   $0x1
-    2b92:	e8 a9 0f 00 00       	call   3b40 <printf>
-    exit();
-    2b97:	e8 e7 0d 00 00       	call   3983 <exit>
-    printf(1, "open . for writing succeeded!\n");
-    2b9c:	53                   	push   %ebx
-    2b9d:	53                   	push   %ebx
-    2b9e:	68 d8 53 00 00       	push   $0x53d8
-    2ba3:	6a 01                	push   $0x1
-    2ba5:	e8 96 0f 00 00       	call   3b40 <printf>
-    exit();
-    2baa:	e8 d4 0d 00 00       	call   3983 <exit>
-    printf(1, "unlink dirfile failed!\n");
-    2baf:	50                   	push   %eax
-    2bb0:	50                   	push   %eax
-    2bb1:	68 c9 4b 00 00       	push   $0x4bc9
-    2bb6:	6a 01                	push   $0x1
-    2bb8:	e8 83 0f 00 00       	call   3b40 <printf>
-    exit();
-    2bbd:	e8 c1 0d 00 00       	call   3983 <exit>
-    printf(1, "link to dirfile/xx succeeded!\n");
-    2bc2:	50                   	push   %eax
-    2bc3:	50                   	push   %eax
-    2bc4:	68 b8 53 00 00       	push   $0x53b8
-    2bc9:	6a 01                	push   $0x1
-    2bcb:	e8 70 0f 00 00       	call   3b40 <printf>
-    exit();
-    2bd0:	e8 ae 0d 00 00       	call   3983 <exit>
-    printf(1, "unlink dirfile/xx succeeded!\n");
-    2bd5:	50                   	push   %eax
-    2bd6:	50                   	push   %eax
-    2bd7:	68 a4 4b 00 00       	push   $0x4ba4
-    2bdc:	6a 01                	push   $0x1
-    2bde:	e8 5d 0f 00 00       	call   3b40 <printf>
-    exit();
-    2be3:	e8 9b 0d 00 00       	call   3983 <exit>
-    printf(1, "mkdir dirfile/xx succeeded!\n");
-    2be8:	50                   	push   %eax
-    2be9:	50                   	push   %eax
-    2bea:	68 87 4b 00 00       	push   $0x4b87
-    2bef:	6a 01                	push   $0x1
-    2bf1:	e8 4a 0f 00 00       	call   3b40 <printf>
-    exit();
-    2bf6:	e8 88 0d 00 00       	call   3983 <exit>
-    2bfb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    2bff:	90                   	nop
-
-00002c00 <iref>:
-{
-    2c00:	f3 0f 1e fb          	endbr32 
-    2c04:	55                   	push   %ebp
-    2c05:	89 e5                	mov    %esp,%ebp
-    2c07:	53                   	push   %ebx
-  printf(1, "empty file name\n");
-    2c08:	bb 33 00 00 00       	mov    $0x33,%ebx
-{
-    2c0d:	83 ec 0c             	sub    $0xc,%esp
-  printf(1, "empty file name\n");
-    2c10:	68 05 4c 00 00       	push   $0x4c05
-    2c15:	6a 01                	push   $0x1
-    2c17:	e8 24 0f 00 00       	call   3b40 <printf>
-    2c1c:	83 c4 10             	add    $0x10,%esp
-    2c1f:	90                   	nop
-    if(mkdir("irefd") != 0){
-    2c20:	83 ec 0c             	sub    $0xc,%esp
-    2c23:	68 16 4c 00 00       	push   $0x4c16
-    2c28:	e8 be 0d 00 00       	call   39eb <mkdir>
-    2c2d:	83 c4 10             	add    $0x10,%esp
-    2c30:	85 c0                	test   %eax,%eax
-    2c32:	0f 85 bb 00 00 00    	jne    2cf3 <iref+0xf3>
-    if(chdir("irefd") != 0){
-    2c38:	83 ec 0c             	sub    $0xc,%esp
-    2c3b:	68 16 4c 00 00       	push   $0x4c16
-    2c40:	e8 ae 0d 00 00       	call   39f3 <chdir>
-    2c45:	83 c4 10             	add    $0x10,%esp
-    2c48:	85 c0                	test   %eax,%eax
-    2c4a:	0f 85 b7 00 00 00    	jne    2d07 <iref+0x107>
-    mkdir("");
-    2c50:	83 ec 0c             	sub    $0xc,%esp
-    2c53:	68 cb 42 00 00       	push   $0x42cb
-    2c58:	e8 8e 0d 00 00       	call   39eb <mkdir>
-    link("README", "");
-    2c5d:	59                   	pop    %ecx
-    2c5e:	58                   	pop    %eax
-    2c5f:	68 cb 42 00 00       	push   $0x42cb
-    2c64:	68 c2 4b 00 00       	push   $0x4bc2
-    2c69:	e8 75 0d 00 00       	call   39e3 <link>
-    fd = open("", O_CREATE);
-    2c6e:	58                   	pop    %eax
-    2c6f:	5a                   	pop    %edx
-    2c70:	68 00 02 00 00       	push   $0x200
-    2c75:	68 cb 42 00 00       	push   $0x42cb
-    2c7a:	e8 44 0d 00 00       	call   39c3 <open>
-    if(fd >= 0)
-    2c7f:	83 c4 10             	add    $0x10,%esp
-    2c82:	85 c0                	test   %eax,%eax
-    2c84:	78 0c                	js     2c92 <iref+0x92>
-      close(fd);
-    2c86:	83 ec 0c             	sub    $0xc,%esp
-    2c89:	50                   	push   %eax
-    2c8a:	e8 1c 0d 00 00       	call   39ab <close>
-    2c8f:	83 c4 10             	add    $0x10,%esp
-    fd = open("xx", O_CREATE);
-    2c92:	83 ec 08             	sub    $0x8,%esp
-    2c95:	68 00 02 00 00       	push   $0x200
-    2c9a:	68 00 48 00 00       	push   $0x4800
-    2c9f:	e8 1f 0d 00 00       	call   39c3 <open>
-    if(fd >= 0)
-    2ca4:	83 c4 10             	add    $0x10,%esp
-    2ca7:	85 c0                	test   %eax,%eax
-    2ca9:	78 0c                	js     2cb7 <iref+0xb7>
-      close(fd);
-    2cab:	83 ec 0c             	sub    $0xc,%esp
-    2cae:	50                   	push   %eax
-    2caf:	e8 f7 0c 00 00       	call   39ab <close>
-    2cb4:	83 c4 10             	add    $0x10,%esp
-    unlink("xx");
-    2cb7:	83 ec 0c             	sub    $0xc,%esp
-    2cba:	68 00 48 00 00       	push   $0x4800
-    2cbf:	e8 0f 0d 00 00       	call   39d3 <unlink>
-  for(i = 0; i < 50 + 1; i++){
-    2cc4:	83 c4 10             	add    $0x10,%esp
-    2cc7:	83 eb 01             	sub    $0x1,%ebx
-    2cca:	0f 85 50 ff ff ff    	jne    2c20 <iref+0x20>
-  chdir("/");
-    2cd0:	83 ec 0c             	sub    $0xc,%esp
-    2cd3:	68 f1 3e 00 00       	push   $0x3ef1
-    2cd8:	e8 16 0d 00 00       	call   39f3 <chdir>
-  printf(1, "empty file name OK\n");
-    2cdd:	58                   	pop    %eax
-    2cde:	5a                   	pop    %edx
-    2cdf:	68 44 4c 00 00       	push   $0x4c44
-    2ce4:	6a 01                	push   $0x1
-    2ce6:	e8 55 0e 00 00       	call   3b40 <printf>
-}
-    2ceb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-    2cee:	83 c4 10             	add    $0x10,%esp
-    2cf1:	c9                   	leave  
-    2cf2:	c3                   	ret    
-      printf(1, "mkdir irefd failed\n");
-    2cf3:	83 ec 08             	sub    $0x8,%esp
-    2cf6:	68 1c 4c 00 00       	push   $0x4c1c
-    2cfb:	6a 01                	push   $0x1
-    2cfd:	e8 3e 0e 00 00       	call   3b40 <printf>
-      exit();
-    2d02:	e8 7c 0c 00 00       	call   3983 <exit>
-      printf(1, "chdir irefd failed\n");
-    2d07:	83 ec 08             	sub    $0x8,%esp
-    2d0a:	68 30 4c 00 00       	push   $0x4c30
-    2d0f:	6a 01                	push   $0x1
-    2d11:	e8 2a 0e 00 00       	call   3b40 <printf>
-      exit();
-    2d16:	e8 68 0c 00 00       	call   3983 <exit>
-    2d1b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    2d1f:	90                   	nop
-
-00002d20 <forktest>:
-{
-    2d20:	f3 0f 1e fb          	endbr32 
-    2d24:	55                   	push   %ebp
-    2d25:	89 e5                	mov    %esp,%ebp
-    2d27:	53                   	push   %ebx
-  for(n=0; n<1000; n++){
-    2d28:	31 db                	xor    %ebx,%ebx
-{
-    2d2a:	83 ec 0c             	sub    $0xc,%esp
-  printf(1, "fork test\n");
-    2d2d:	68 58 4c 00 00       	push   $0x4c58
-    2d32:	6a 01                	push   $0x1
-    2d34:	e8 07 0e 00 00       	call   3b40 <printf>
-    2d39:	83 c4 10             	add    $0x10,%esp
-    2d3c:	eb 0f                	jmp    2d4d <forktest+0x2d>
-    2d3e:	66 90                	xchg   %ax,%ax
-    if(pid == 0)
-    2d40:	74 4a                	je     2d8c <forktest+0x6c>
-  for(n=0; n<1000; n++){
-    2d42:	83 c3 01             	add    $0x1,%ebx
-    2d45:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
-    2d4b:	74 6b                	je     2db8 <forktest+0x98>
-    pid = fork();
-    2d4d:	e8 29 0c 00 00       	call   397b <fork>
-    if(pid < 0)
-    2d52:	85 c0                	test   %eax,%eax
-    2d54:	79 ea                	jns    2d40 <forktest+0x20>
-  for(; n > 0; n--){
-    2d56:	85 db                	test   %ebx,%ebx
-    2d58:	74 14                	je     2d6e <forktest+0x4e>
-    2d5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    if(wait() < 0){
-    2d60:	e8 26 0c 00 00       	call   398b <wait>
-    2d65:	85 c0                	test   %eax,%eax
-    2d67:	78 28                	js     2d91 <forktest+0x71>
-  for(; n > 0; n--){
-    2d69:	83 eb 01             	sub    $0x1,%ebx
-    2d6c:	75 f2                	jne    2d60 <forktest+0x40>
-  if(wait() != -1){
-    2d6e:	e8 18 0c 00 00       	call   398b <wait>
-    2d73:	83 f8 ff             	cmp    $0xffffffff,%eax
-    2d76:	75 2d                	jne    2da5 <forktest+0x85>
-  printf(1, "fork test OK\n");
-    2d78:	83 ec 08             	sub    $0x8,%esp
-    2d7b:	68 8a 4c 00 00       	push   $0x4c8a
-    2d80:	6a 01                	push   $0x1
-    2d82:	e8 b9 0d 00 00       	call   3b40 <printf>
-}
-    2d87:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-    2d8a:	c9                   	leave  
-    2d8b:	c3                   	ret    
-      exit();
-    2d8c:	e8 f2 0b 00 00       	call   3983 <exit>
-      printf(1, "wait stopped early\n");
-    2d91:	83 ec 08             	sub    $0x8,%esp
-    2d94:	68 63 4c 00 00       	push   $0x4c63
-    2d99:	6a 01                	push   $0x1
-    2d9b:	e8 a0 0d 00 00       	call   3b40 <printf>
-      exit();
-    2da0:	e8 de 0b 00 00       	call   3983 <exit>
-    printf(1, "wait got too many\n");
-    2da5:	52                   	push   %edx
-    2da6:	52                   	push   %edx
-    2da7:	68 77 4c 00 00       	push   $0x4c77
-    2dac:	6a 01                	push   $0x1
-    2dae:	e8 8d 0d 00 00       	call   3b40 <printf>
-    exit();
-    2db3:	e8 cb 0b 00 00       	call   3983 <exit>
-    printf(1, "fork claimed to work 1000 times!\n");
-    2db8:	50                   	push   %eax
-    2db9:	50                   	push   %eax
-    2dba:	68 f8 53 00 00       	push   $0x53f8
-    2dbf:	6a 01                	push   $0x1
-    2dc1:	e8 7a 0d 00 00       	call   3b40 <printf>
-    exit();
-    2dc6:	e8 b8 0b 00 00       	call   3983 <exit>
-    2dcb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    2dcf:	90                   	nop
-
-00002dd0 <sbrktest>:
-{
-    2dd0:	f3 0f 1e fb          	endbr32 
-    2dd4:	55                   	push   %ebp
-    2dd5:	89 e5                	mov    %esp,%ebp
-    2dd7:	57                   	push   %edi
-  for(i = 0; i < 5000; i++){
-    2dd8:	31 ff                	xor    %edi,%edi
-{
-    2dda:	56                   	push   %esi
-    2ddb:	53                   	push   %ebx
-    2ddc:	83 ec 54             	sub    $0x54,%esp
-  printf(stdout, "sbrk test\n");
-    2ddf:	68 98 4c 00 00       	push   $0x4c98
-    2de4:	ff 35 40 5f 00 00    	pushl  0x5f40
-    2dea:	e8 51 0d 00 00       	call   3b40 <printf>
-  oldbrk = sbrk(0);
-    2def:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
-    2df6:	e8 10 0c 00 00       	call   3a0b <sbrk>
-  a = sbrk(0);
-    2dfb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
-  oldbrk = sbrk(0);
-    2e02:	89 c3                	mov    %eax,%ebx
-  a = sbrk(0);
-    2e04:	e8 02 0c 00 00       	call   3a0b <sbrk>
-    2e09:	83 c4 10             	add    $0x10,%esp
-    2e0c:	89 c6                	mov    %eax,%esi
-  for(i = 0; i < 5000; i++){
-    2e0e:	eb 02                	jmp    2e12 <sbrktest+0x42>
-    a = b + 1;
-    2e10:	89 c6                	mov    %eax,%esi
-    b = sbrk(1);
-    2e12:	83 ec 0c             	sub    $0xc,%esp
-    2e15:	6a 01                	push   $0x1
-    2e17:	e8 ef 0b 00 00       	call   3a0b <sbrk>
-    if(b != a){
-    2e1c:	83 c4 10             	add    $0x10,%esp
-    2e1f:	39 f0                	cmp    %esi,%eax
-    2e21:	0f 85 84 02 00 00    	jne    30ab <sbrktest+0x2db>
-  for(i = 0; i < 5000; i++){
-    2e27:	83 c7 01             	add    $0x1,%edi
-    *b = 1;
-    2e2a:	c6 06 01             	movb   $0x1,(%esi)
-    a = b + 1;
-    2e2d:	8d 46 01             	lea    0x1(%esi),%eax
-  for(i = 0; i < 5000; i++){
-    2e30:	81 ff 88 13 00 00    	cmp    $0x1388,%edi
-    2e36:	75 d8                	jne    2e10 <sbrktest+0x40>
-  pid = fork();
-    2e38:	e8 3e 0b 00 00       	call   397b <fork>
-    2e3d:	89 c7                	mov    %eax,%edi
-  if(pid < 0){
-    2e3f:	85 c0                	test   %eax,%eax
-    2e41:	0f 88 91 03 00 00    	js     31d8 <sbrktest+0x408>
-  c = sbrk(1);
-    2e47:	83 ec 0c             	sub    $0xc,%esp
-  if(c != a + 1){
-    2e4a:	83 c6 02             	add    $0x2,%esi
-  c = sbrk(1);
-    2e4d:	6a 01                	push   $0x1
-    2e4f:	e8 b7 0b 00 00       	call   3a0b <sbrk>
-  c = sbrk(1);
-    2e54:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
-    2e5b:	e8 ab 0b 00 00       	call   3a0b <sbrk>
-  if(c != a + 1){
-    2e60:	83 c4 10             	add    $0x10,%esp
-    2e63:	39 c6                	cmp    %eax,%esi
-    2e65:	0f 85 56 03 00 00    	jne    31c1 <sbrktest+0x3f1>
-  if(pid == 0)
-    2e6b:	85 ff                	test   %edi,%edi
-    2e6d:	0f 84 49 03 00 00    	je     31bc <sbrktest+0x3ec>
-  wait();
-    2e73:	e8 13 0b 00 00       	call   398b <wait>
-  a = sbrk(0);
-    2e78:	83 ec 0c             	sub    $0xc,%esp
-    2e7b:	6a 00                	push   $0x0
-    2e7d:	e8 89 0b 00 00       	call   3a0b <sbrk>
-    2e82:	89 c6                	mov    %eax,%esi
-  amt = (BIG) - (uint)a;
-    2e84:	b8 00 00 40 06       	mov    $0x6400000,%eax
-    2e89:	29 f0                	sub    %esi,%eax
-  p = sbrk(amt);
-    2e8b:	89 04 24             	mov    %eax,(%esp)
-    2e8e:	e8 78 0b 00 00       	call   3a0b <sbrk>
-  if (p != a) {
-    2e93:	83 c4 10             	add    $0x10,%esp
-    2e96:	39 c6                	cmp    %eax,%esi
-    2e98:	0f 85 07 03 00 00    	jne    31a5 <sbrktest+0x3d5>
-  a = sbrk(0);
-    2e9e:	83 ec 0c             	sub    $0xc,%esp
-  *lastaddr = 99;
-    2ea1:	c6 05 ff ff 3f 06 63 	movb   $0x63,0x63fffff
-  a = sbrk(0);
-    2ea8:	6a 00                	push   $0x0
-    2eaa:	e8 5c 0b 00 00       	call   3a0b <sbrk>
-  c = sbrk(-4096);
-    2eaf:	c7 04 24 00 f0 ff ff 	movl   $0xfffff000,(%esp)
-  a = sbrk(0);
-    2eb6:	89 c6                	mov    %eax,%esi
-  c = sbrk(-4096);
-    2eb8:	e8 4e 0b 00 00       	call   3a0b <sbrk>
-  if(c == (char*)0xffffffff){
-    2ebd:	83 c4 10             	add    $0x10,%esp
-    2ec0:	83 f8 ff             	cmp    $0xffffffff,%eax
-    2ec3:	0f 84 c5 02 00 00    	je     318e <sbrktest+0x3be>
-  c = sbrk(0);
-    2ec9:	83 ec 0c             	sub    $0xc,%esp
-    2ecc:	6a 00                	push   $0x0
-    2ece:	e8 38 0b 00 00       	call   3a0b <sbrk>
-  if(c != a - 4096){
-    2ed3:	8d 96 00 f0 ff ff    	lea    -0x1000(%esi),%edx
-    2ed9:	83 c4 10             	add    $0x10,%esp
-    2edc:	39 d0                	cmp    %edx,%eax
-    2ede:	0f 85 93 02 00 00    	jne    3177 <sbrktest+0x3a7>
-  a = sbrk(0);
-    2ee4:	83 ec 0c             	sub    $0xc,%esp
-    2ee7:	6a 00                	push   $0x0
-    2ee9:	e8 1d 0b 00 00       	call   3a0b <sbrk>
-  c = sbrk(4096);
-    2eee:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
-  a = sbrk(0);
-    2ef5:	89 c6                	mov    %eax,%esi
-  c = sbrk(4096);
-    2ef7:	e8 0f 0b 00 00       	call   3a0b <sbrk>
-  if(c != a || sbrk(0) != a + 4096){
-    2efc:	83 c4 10             	add    $0x10,%esp
-  c = sbrk(4096);
-    2eff:	89 c7                	mov    %eax,%edi
-  if(c != a || sbrk(0) != a + 4096){
-    2f01:	39 c6                	cmp    %eax,%esi
-    2f03:	0f 85 57 02 00 00    	jne    3160 <sbrktest+0x390>
-    2f09:	83 ec 0c             	sub    $0xc,%esp
-    2f0c:	6a 00                	push   $0x0
-    2f0e:	e8 f8 0a 00 00       	call   3a0b <sbrk>
-    2f13:	8d 96 00 10 00 00    	lea    0x1000(%esi),%edx
-    2f19:	83 c4 10             	add    $0x10,%esp
-    2f1c:	39 c2                	cmp    %eax,%edx
-    2f1e:	0f 85 3c 02 00 00    	jne    3160 <sbrktest+0x390>
-  if(*lastaddr == 99){
-    2f24:	80 3d ff ff 3f 06 63 	cmpb   $0x63,0x63fffff
-    2f2b:	0f 84 18 02 00 00    	je     3149 <sbrktest+0x379>
-  a = sbrk(0);
-    2f31:	83 ec 0c             	sub    $0xc,%esp
-    2f34:	6a 00                	push   $0x0
-    2f36:	e8 d0 0a 00 00       	call   3a0b <sbrk>
-  c = sbrk(-(sbrk(0) - oldbrk));
-    2f3b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
-  a = sbrk(0);
-    2f42:	89 c6                	mov    %eax,%esi
-  c = sbrk(-(sbrk(0) - oldbrk));
-    2f44:	e8 c2 0a 00 00       	call   3a0b <sbrk>
-    2f49:	89 d9                	mov    %ebx,%ecx
-    2f4b:	29 c1                	sub    %eax,%ecx
-    2f4d:	89 0c 24             	mov    %ecx,(%esp)
-    2f50:	e8 b6 0a 00 00       	call   3a0b <sbrk>
-  if(c != a){
-    2f55:	83 c4 10             	add    $0x10,%esp
-    2f58:	39 c6                	cmp    %eax,%esi
-    2f5a:	0f 85 d2 01 00 00    	jne    3132 <sbrktest+0x362>
-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
-    2f60:	be 00 00 00 80       	mov    $0x80000000,%esi
-    2f65:	8d 76 00             	lea    0x0(%esi),%esi
-    ppid = getpid();
-    2f68:	e8 96 0a 00 00       	call   3a03 <getpid>
-    2f6d:	89 c7                	mov    %eax,%edi
-    pid = fork();
-    2f6f:	e8 07 0a 00 00       	call   397b <fork>
-    if(pid < 0){
-    2f74:	85 c0                	test   %eax,%eax
-    2f76:	0f 88 9e 01 00 00    	js     311a <sbrktest+0x34a>
-    if(pid == 0){
-    2f7c:	0f 84 76 01 00 00    	je     30f8 <sbrktest+0x328>
-    wait();
-    2f82:	e8 04 0a 00 00       	call   398b <wait>
-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
-    2f87:	81 c6 50 c3 00 00    	add    $0xc350,%esi
-    2f8d:	81 fe 80 84 1e 80    	cmp    $0x801e8480,%esi
-    2f93:	75 d3                	jne    2f68 <sbrktest+0x198>
-  if(pipe(fds) != 0){
-    2f95:	83 ec 0c             	sub    $0xc,%esp
-    2f98:	8d 45 b8             	lea    -0x48(%ebp),%eax
-    2f9b:	50                   	push   %eax
-    2f9c:	e8 f2 09 00 00       	call   3993 <pipe>
-    2fa1:	83 c4 10             	add    $0x10,%esp
-    2fa4:	85 c0                	test   %eax,%eax
-    2fa6:	0f 85 34 01 00 00    	jne    30e0 <sbrktest+0x310>
-    2fac:	8d 75 c0             	lea    -0x40(%ebp),%esi
-    2faf:	89 f7                	mov    %esi,%edi
-    if((pids[i] = fork()) == 0){
-    2fb1:	e8 c5 09 00 00       	call   397b <fork>
-    2fb6:	89 07                	mov    %eax,(%edi)
-    2fb8:	85 c0                	test   %eax,%eax
-    2fba:	0f 84 8f 00 00 00    	je     304f <sbrktest+0x27f>
-    if(pids[i] != -1)
-    2fc0:	83 f8 ff             	cmp    $0xffffffff,%eax
-    2fc3:	74 14                	je     2fd9 <sbrktest+0x209>
-      read(fds[0], &scratch, 1);
-    2fc5:	83 ec 04             	sub    $0x4,%esp
-    2fc8:	8d 45 b7             	lea    -0x49(%ebp),%eax
-    2fcb:	6a 01                	push   $0x1
-    2fcd:	50                   	push   %eax
-    2fce:	ff 75 b8             	pushl  -0x48(%ebp)
-    2fd1:	e8 c5 09 00 00       	call   399b <read>
-    2fd6:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    2fd9:	83 c7 04             	add    $0x4,%edi
-    2fdc:	8d 45 e8             	lea    -0x18(%ebp),%eax
-    2fdf:	39 c7                	cmp    %eax,%edi
-    2fe1:	75 ce                	jne    2fb1 <sbrktest+0x1e1>
-  c = sbrk(4096);
-    2fe3:	83 ec 0c             	sub    $0xc,%esp
-    2fe6:	68 00 10 00 00       	push   $0x1000
-    2feb:	e8 1b 0a 00 00       	call   3a0b <sbrk>
-    2ff0:	83 c4 10             	add    $0x10,%esp
-    2ff3:	89 c7                	mov    %eax,%edi
-    if(pids[i] == -1)
-    2ff5:	8b 06                	mov    (%esi),%eax
-    2ff7:	83 f8 ff             	cmp    $0xffffffff,%eax
-    2ffa:	74 11                	je     300d <sbrktest+0x23d>
-    kill(pids[i]);
-    2ffc:	83 ec 0c             	sub    $0xc,%esp
-    2fff:	50                   	push   %eax
-    3000:	e8 ae 09 00 00       	call   39b3 <kill>
-    wait();
-    3005:	e8 81 09 00 00       	call   398b <wait>
-    300a:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    300d:	83 c6 04             	add    $0x4,%esi
-    3010:	8d 45 e8             	lea    -0x18(%ebp),%eax
-    3013:	39 f0                	cmp    %esi,%eax
-    3015:	75 de                	jne    2ff5 <sbrktest+0x225>
-  if(c == (char*)0xffffffff){
-    3017:	83 ff ff             	cmp    $0xffffffff,%edi
-    301a:	0f 84 a9 00 00 00    	je     30c9 <sbrktest+0x2f9>
-  if(sbrk(0) > oldbrk)
-    3020:	83 ec 0c             	sub    $0xc,%esp
-    3023:	6a 00                	push   $0x0
-    3025:	e8 e1 09 00 00       	call   3a0b <sbrk>
-    302a:	83 c4 10             	add    $0x10,%esp
-    302d:	39 c3                	cmp    %eax,%ebx
-    302f:	72 61                	jb     3092 <sbrktest+0x2c2>
-  printf(stdout, "sbrk test OK\n");
-    3031:	83 ec 08             	sub    $0x8,%esp
-    3034:	68 40 4d 00 00       	push   $0x4d40
-    3039:	ff 35 40 5f 00 00    	pushl  0x5f40
-    303f:	e8 fc 0a 00 00       	call   3b40 <printf>
-}
-    3044:	83 c4 10             	add    $0x10,%esp
-    3047:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    304a:	5b                   	pop    %ebx
-    304b:	5e                   	pop    %esi
-    304c:	5f                   	pop    %edi
-    304d:	5d                   	pop    %ebp
-    304e:	c3                   	ret    
-      sbrk(BIG - (uint)sbrk(0));
-    304f:	83 ec 0c             	sub    $0xc,%esp
-    3052:	6a 00                	push   $0x0
-    3054:	e8 b2 09 00 00       	call   3a0b <sbrk>
-    3059:	89 c2                	mov    %eax,%edx
-    305b:	b8 00 00 40 06       	mov    $0x6400000,%eax
-    3060:	29 d0                	sub    %edx,%eax
-    3062:	89 04 24             	mov    %eax,(%esp)
-    3065:	e8 a1 09 00 00       	call   3a0b <sbrk>
-      write(fds[1], "x", 1);
-    306a:	83 c4 0c             	add    $0xc,%esp
-    306d:	6a 01                	push   $0x1
-    306f:	68 01 48 00 00       	push   $0x4801
-    3074:	ff 75 bc             	pushl  -0x44(%ebp)
-    3077:	e8 27 09 00 00       	call   39a3 <write>
-    307c:	83 c4 10             	add    $0x10,%esp
-    307f:	90                   	nop
-      for(;;) sleep(1000);
-    3080:	83 ec 0c             	sub    $0xc,%esp
-    3083:	68 e8 03 00 00       	push   $0x3e8
-    3088:	e8 86 09 00 00       	call   3a13 <sleep>
-    308d:	83 c4 10             	add    $0x10,%esp
-    3090:	eb ee                	jmp    3080 <sbrktest+0x2b0>
-    sbrk(-(sbrk(0) - oldbrk));
-    3092:	83 ec 0c             	sub    $0xc,%esp
-    3095:	6a 00                	push   $0x0
-    3097:	e8 6f 09 00 00       	call   3a0b <sbrk>
-    309c:	29 c3                	sub    %eax,%ebx
-    309e:	89 1c 24             	mov    %ebx,(%esp)
-    30a1:	e8 65 09 00 00       	call   3a0b <sbrk>
-    30a6:	83 c4 10             	add    $0x10,%esp
-    30a9:	eb 86                	jmp    3031 <sbrktest+0x261>
-      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
-    30ab:	83 ec 0c             	sub    $0xc,%esp
-    30ae:	50                   	push   %eax
-    30af:	56                   	push   %esi
-    30b0:	57                   	push   %edi
-    30b1:	68 a3 4c 00 00       	push   $0x4ca3
-    30b6:	ff 35 40 5f 00 00    	pushl  0x5f40
-    30bc:	e8 7f 0a 00 00       	call   3b40 <printf>
-      exit();
-    30c1:	83 c4 20             	add    $0x20,%esp
-    30c4:	e8 ba 08 00 00       	call   3983 <exit>
-    printf(stdout, "failed sbrk leaked memory\n");
-    30c9:	50                   	push   %eax
-    30ca:	50                   	push   %eax
-    30cb:	68 25 4d 00 00       	push   $0x4d25
-    30d0:	ff 35 40 5f 00 00    	pushl  0x5f40
-    30d6:	e8 65 0a 00 00       	call   3b40 <printf>
-    exit();
-    30db:	e8 a3 08 00 00       	call   3983 <exit>
-    printf(1, "pipe() failed\n");
-    30e0:	52                   	push   %edx
-    30e1:	52                   	push   %edx
-    30e2:	68 e1 41 00 00       	push   $0x41e1
-    30e7:	6a 01                	push   $0x1
-    30e9:	e8 52 0a 00 00       	call   3b40 <printf>
-    exit();
-    30ee:	e8 90 08 00 00       	call   3983 <exit>
-    30f3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    30f7:	90                   	nop
-      printf(stdout, "oops could read %x = %x\n", a, *a);
-    30f8:	0f be 06             	movsbl (%esi),%eax
-    30fb:	50                   	push   %eax
-    30fc:	56                   	push   %esi
-    30fd:	68 0c 4d 00 00       	push   $0x4d0c
-    3102:	ff 35 40 5f 00 00    	pushl  0x5f40
-    3108:	e8 33 0a 00 00       	call   3b40 <printf>
-      kill(ppid);
-    310d:	89 3c 24             	mov    %edi,(%esp)
-    3110:	e8 9e 08 00 00       	call   39b3 <kill>
-      exit();
-    3115:	e8 69 08 00 00       	call   3983 <exit>
-      printf(stdout, "fork failed\n");
-    311a:	83 ec 08             	sub    $0x8,%esp
-    311d:	68 e9 4d 00 00       	push   $0x4de9
-    3122:	ff 35 40 5f 00 00    	pushl  0x5f40
-    3128:	e8 13 0a 00 00       	call   3b40 <printf>
-      exit();
-    312d:	e8 51 08 00 00       	call   3983 <exit>
-    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
-    3132:	50                   	push   %eax
-    3133:	56                   	push   %esi
-    3134:	68 ec 54 00 00       	push   $0x54ec
-    3139:	ff 35 40 5f 00 00    	pushl  0x5f40
-    313f:	e8 fc 09 00 00       	call   3b40 <printf>
-    exit();
-    3144:	e8 3a 08 00 00       	call   3983 <exit>
-    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
-    3149:	51                   	push   %ecx
-    314a:	51                   	push   %ecx
-    314b:	68 bc 54 00 00       	push   $0x54bc
-    3150:	ff 35 40 5f 00 00    	pushl  0x5f40
-    3156:	e8 e5 09 00 00       	call   3b40 <printf>
-    exit();
-    315b:	e8 23 08 00 00       	call   3983 <exit>
-    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
-    3160:	57                   	push   %edi
-    3161:	56                   	push   %esi
-    3162:	68 94 54 00 00       	push   $0x5494
-    3167:	ff 35 40 5f 00 00    	pushl  0x5f40
-    316d:	e8 ce 09 00 00       	call   3b40 <printf>
-    exit();
-    3172:	e8 0c 08 00 00       	call   3983 <exit>
-    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
-    3177:	50                   	push   %eax
-    3178:	56                   	push   %esi
-    3179:	68 5c 54 00 00       	push   $0x545c
-    317e:	ff 35 40 5f 00 00    	pushl  0x5f40
-    3184:	e8 b7 09 00 00       	call   3b40 <printf>
-    exit();
-    3189:	e8 f5 07 00 00       	call   3983 <exit>
-    printf(stdout, "sbrk could not deallocate\n");
-    318e:	53                   	push   %ebx
-    318f:	53                   	push   %ebx
-    3190:	68 f1 4c 00 00       	push   $0x4cf1
-    3195:	ff 35 40 5f 00 00    	pushl  0x5f40
-    319b:	e8 a0 09 00 00       	call   3b40 <printf>
-    exit();
-    31a0:	e8 de 07 00 00       	call   3983 <exit>
-    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
-    31a5:	56                   	push   %esi
-    31a6:	56                   	push   %esi
-    31a7:	68 1c 54 00 00       	push   $0x541c
-    31ac:	ff 35 40 5f 00 00    	pushl  0x5f40
-    31b2:	e8 89 09 00 00       	call   3b40 <printf>
-    exit();
-    31b7:	e8 c7 07 00 00       	call   3983 <exit>
-    exit();
-    31bc:	e8 c2 07 00 00       	call   3983 <exit>
-    printf(stdout, "sbrk test failed post-fork\n");
-    31c1:	57                   	push   %edi
-    31c2:	57                   	push   %edi
-    31c3:	68 d5 4c 00 00       	push   $0x4cd5
-    31c8:	ff 35 40 5f 00 00    	pushl  0x5f40
-    31ce:	e8 6d 09 00 00       	call   3b40 <printf>
-    exit();
-    31d3:	e8 ab 07 00 00       	call   3983 <exit>
-    printf(stdout, "sbrk test fork failed\n");
-    31d8:	50                   	push   %eax
-    31d9:	50                   	push   %eax
-    31da:	68 be 4c 00 00       	push   $0x4cbe
-    31df:	ff 35 40 5f 00 00    	pushl  0x5f40
-    31e5:	e8 56 09 00 00       	call   3b40 <printf>
-    exit();
-    31ea:	e8 94 07 00 00       	call   3983 <exit>
-    31ef:	90                   	nop
-
-000031f0 <validateint>:
-{
-    31f0:	f3 0f 1e fb          	endbr32 
-}
-    31f4:	c3                   	ret    
-    31f5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    31fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00003200 <validatetest>:
-{
-    3200:	f3 0f 1e fb          	endbr32 
-    3204:	55                   	push   %ebp
-    3205:	89 e5                	mov    %esp,%ebp
-    3207:	56                   	push   %esi
-  for(p = 0; p <= (uint)hi; p += 4096){
-    3208:	31 f6                	xor    %esi,%esi
-{
-    320a:	53                   	push   %ebx
-  printf(stdout, "validate test\n");
-    320b:	83 ec 08             	sub    $0x8,%esp
-    320e:	68 4e 4d 00 00       	push   $0x4d4e
-    3213:	ff 35 40 5f 00 00    	pushl  0x5f40
-    3219:	e8 22 09 00 00       	call   3b40 <printf>
-    321e:	83 c4 10             	add    $0x10,%esp
-    3221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    if((pid = fork()) == 0){
-    3228:	e8 4e 07 00 00       	call   397b <fork>
-    322d:	89 c3                	mov    %eax,%ebx
-    322f:	85 c0                	test   %eax,%eax
-    3231:	74 63                	je     3296 <validatetest+0x96>
-    sleep(0);
-    3233:	83 ec 0c             	sub    $0xc,%esp
-    3236:	6a 00                	push   $0x0
-    3238:	e8 d6 07 00 00       	call   3a13 <sleep>
-    sleep(0);
-    323d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
-    3244:	e8 ca 07 00 00       	call   3a13 <sleep>
-    kill(pid);
-    3249:	89 1c 24             	mov    %ebx,(%esp)
-    324c:	e8 62 07 00 00       	call   39b3 <kill>
-    wait();
-    3251:	e8 35 07 00 00       	call   398b <wait>
-    if(link("nosuchfile", (char*)p) != -1){
-    3256:	58                   	pop    %eax
-    3257:	5a                   	pop    %edx
-    3258:	56                   	push   %esi
-    3259:	68 5d 4d 00 00       	push   $0x4d5d
-    325e:	e8 80 07 00 00       	call   39e3 <link>
-    3263:	83 c4 10             	add    $0x10,%esp
-    3266:	83 f8 ff             	cmp    $0xffffffff,%eax
-    3269:	75 30                	jne    329b <validatetest+0x9b>
-  for(p = 0; p <= (uint)hi; p += 4096){
-    326b:	81 c6 00 10 00 00    	add    $0x1000,%esi
-    3271:	81 fe 00 40 11 00    	cmp    $0x114000,%esi
-    3277:	75 af                	jne    3228 <validatetest+0x28>
-  printf(stdout, "validate ok\n");
-    3279:	83 ec 08             	sub    $0x8,%esp
-    327c:	68 81 4d 00 00       	push   $0x4d81
-    3281:	ff 35 40 5f 00 00    	pushl  0x5f40
-    3287:	e8 b4 08 00 00       	call   3b40 <printf>
-}
-    328c:	83 c4 10             	add    $0x10,%esp
-    328f:	8d 65 f8             	lea    -0x8(%ebp),%esp
-    3292:	5b                   	pop    %ebx
-    3293:	5e                   	pop    %esi
-    3294:	5d                   	pop    %ebp
-    3295:	c3                   	ret    
-      exit();
-    3296:	e8 e8 06 00 00       	call   3983 <exit>
-      printf(stdout, "link should not succeed\n");
-    329b:	83 ec 08             	sub    $0x8,%esp
-    329e:	68 68 4d 00 00       	push   $0x4d68
-    32a3:	ff 35 40 5f 00 00    	pushl  0x5f40
-    32a9:	e8 92 08 00 00       	call   3b40 <printf>
-      exit();
-    32ae:	e8 d0 06 00 00       	call   3983 <exit>
-    32b3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    32ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-000032c0 <bsstest>:
-{
-    32c0:	f3 0f 1e fb          	endbr32 
-    32c4:	55                   	push   %ebp
-    32c5:	89 e5                	mov    %esp,%ebp
-    32c7:	83 ec 10             	sub    $0x10,%esp
-  printf(stdout, "bss test\n");
-    32ca:	68 8e 4d 00 00       	push   $0x4d8e
-    32cf:	ff 35 40 5f 00 00    	pushl  0x5f40
-    32d5:	e8 66 08 00 00       	call   3b40 <printf>
-    32da:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; i < sizeof(uninit); i++){
-    32dd:	31 c0                	xor    %eax,%eax
-    32df:	90                   	nop
-    if(uninit[i] != '\0'){
-    32e0:	80 b8 00 60 00 00 00 	cmpb   $0x0,0x6000(%eax)
-    32e7:	75 22                	jne    330b <bsstest+0x4b>
-  for(i = 0; i < sizeof(uninit); i++){
-    32e9:	83 c0 01             	add    $0x1,%eax
-    32ec:	3d 10 27 00 00       	cmp    $0x2710,%eax
-    32f1:	75 ed                	jne    32e0 <bsstest+0x20>
-  printf(stdout, "bss test ok\n");
-    32f3:	83 ec 08             	sub    $0x8,%esp
-    32f6:	68 a9 4d 00 00       	push   $0x4da9
-    32fb:	ff 35 40 5f 00 00    	pushl  0x5f40
-    3301:	e8 3a 08 00 00       	call   3b40 <printf>
-}
-    3306:	83 c4 10             	add    $0x10,%esp
-    3309:	c9                   	leave  
-    330a:	c3                   	ret    
-      printf(stdout, "bss test failed\n");
-    330b:	83 ec 08             	sub    $0x8,%esp
-    330e:	68 98 4d 00 00       	push   $0x4d98
-    3313:	ff 35 40 5f 00 00    	pushl  0x5f40
-    3319:	e8 22 08 00 00       	call   3b40 <printf>
-      exit();
-    331e:	e8 60 06 00 00       	call   3983 <exit>
-    3323:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    332a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00003330 <bigargtest>:
-{
-    3330:	f3 0f 1e fb          	endbr32 
-    3334:	55                   	push   %ebp
-    3335:	89 e5                	mov    %esp,%ebp
-    3337:	83 ec 14             	sub    $0x14,%esp
-  unlink("bigarg-ok");
-    333a:	68 b6 4d 00 00       	push   $0x4db6
-    333f:	e8 8f 06 00 00       	call   39d3 <unlink>
-  pid = fork();
-    3344:	e8 32 06 00 00       	call   397b <fork>
-  if(pid == 0){
-    3349:	83 c4 10             	add    $0x10,%esp
-    334c:	85 c0                	test   %eax,%eax
-    334e:	74 40                	je     3390 <bigargtest+0x60>
-  } else if(pid < 0){
-    3350:	0f 88 c1 00 00 00    	js     3417 <bigargtest+0xe7>
-  wait();
-    3356:	e8 30 06 00 00       	call   398b <wait>
-  fd = open("bigarg-ok", 0);
-    335b:	83 ec 08             	sub    $0x8,%esp
-    335e:	6a 00                	push   $0x0
-    3360:	68 b6 4d 00 00       	push   $0x4db6
-    3365:	e8 59 06 00 00       	call   39c3 <open>
-  if(fd < 0){
-    336a:	83 c4 10             	add    $0x10,%esp
-    336d:	85 c0                	test   %eax,%eax
-    336f:	0f 88 8b 00 00 00    	js     3400 <bigargtest+0xd0>
-  close(fd);
-    3375:	83 ec 0c             	sub    $0xc,%esp
-    3378:	50                   	push   %eax
-    3379:	e8 2d 06 00 00       	call   39ab <close>
-  unlink("bigarg-ok");
-    337e:	c7 04 24 b6 4d 00 00 	movl   $0x4db6,(%esp)
-    3385:	e8 49 06 00 00       	call   39d3 <unlink>
-}
-    338a:	83 c4 10             	add    $0x10,%esp
-    338d:	c9                   	leave  
-    338e:	c3                   	ret    
-    338f:	90                   	nop
-      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
-    3390:	c7 04 85 60 5f 00 00 	movl   $0x5510,0x5f60(,%eax,4)
-    3397:	10 55 00 00 
-    for(i = 0; i < MAXARG-1; i++)
-    339b:	83 c0 01             	add    $0x1,%eax
-    339e:	83 f8 1f             	cmp    $0x1f,%eax
-    33a1:	75 ed                	jne    3390 <bigargtest+0x60>
-    printf(stdout, "bigarg test\n");
-    33a3:	51                   	push   %ecx
-    33a4:	51                   	push   %ecx
-    33a5:	68 c0 4d 00 00       	push   $0x4dc0
-    33aa:	ff 35 40 5f 00 00    	pushl  0x5f40
-    args[MAXARG-1] = 0;
-    33b0:	c7 05 dc 5f 00 00 00 	movl   $0x0,0x5fdc
-    33b7:	00 00 00 
-    printf(stdout, "bigarg test\n");
-    33ba:	e8 81 07 00 00       	call   3b40 <printf>
-    exec("echo", args);
-    33bf:	58                   	pop    %eax
-    33c0:	5a                   	pop    %edx
-    33c1:	68 60 5f 00 00       	push   $0x5f60
-    33c6:	68 8d 3f 00 00       	push   $0x3f8d
-    33cb:	e8 eb 05 00 00       	call   39bb <exec>
-    printf(stdout, "bigarg test ok\n");
-    33d0:	59                   	pop    %ecx
-    33d1:	58                   	pop    %eax
-    33d2:	68 cd 4d 00 00       	push   $0x4dcd
-    33d7:	ff 35 40 5f 00 00    	pushl  0x5f40
-    33dd:	e8 5e 07 00 00       	call   3b40 <printf>
-    fd = open("bigarg-ok", O_CREATE);
-    33e2:	58                   	pop    %eax
-    33e3:	5a                   	pop    %edx
-    33e4:	68 00 02 00 00       	push   $0x200
-    33e9:	68 b6 4d 00 00       	push   $0x4db6
-    33ee:	e8 d0 05 00 00       	call   39c3 <open>
-    close(fd);
-    33f3:	89 04 24             	mov    %eax,(%esp)
-    33f6:	e8 b0 05 00 00       	call   39ab <close>
-    exit();
-    33fb:	e8 83 05 00 00       	call   3983 <exit>
-    printf(stdout, "bigarg test failed!\n");
-    3400:	50                   	push   %eax
-    3401:	50                   	push   %eax
-    3402:	68 f6 4d 00 00       	push   $0x4df6
-    3407:	ff 35 40 5f 00 00    	pushl  0x5f40
-    340d:	e8 2e 07 00 00       	call   3b40 <printf>
-    exit();
-    3412:	e8 6c 05 00 00       	call   3983 <exit>
-    printf(stdout, "bigargtest: fork failed\n");
-    3417:	52                   	push   %edx
-    3418:	52                   	push   %edx
-    3419:	68 dd 4d 00 00       	push   $0x4ddd
-    341e:	ff 35 40 5f 00 00    	pushl  0x5f40
-    3424:	e8 17 07 00 00       	call   3b40 <printf>
-    exit();
-    3429:	e8 55 05 00 00       	call   3983 <exit>
-    342e:	66 90                	xchg   %ax,%ax
-
-00003430 <fsfull>:
-{
-    3430:	f3 0f 1e fb          	endbr32 
-    3434:	55                   	push   %ebp
-    3435:	89 e5                	mov    %esp,%ebp
-    3437:	57                   	push   %edi
-    3438:	56                   	push   %esi
-  for(nfiles = 0; ; nfiles++){
-    3439:	31 f6                	xor    %esi,%esi
-{
-    343b:	53                   	push   %ebx
-    343c:	83 ec 54             	sub    $0x54,%esp
-  printf(1, "fsfull test\n");
-    343f:	68 0b 4e 00 00       	push   $0x4e0b
-    3444:	6a 01                	push   $0x1
-    3446:	e8 f5 06 00 00       	call   3b40 <printf>
-    344b:	83 c4 10             	add    $0x10,%esp
-    344e:	66 90                	xchg   %ax,%ax
-    name[1] = '0' + nfiles / 1000;
-    3450:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
-    name[3] = '0' + (nfiles % 100) / 10;
-    3455:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
-    printf(1, "writing %s\n", name);
-    345a:	83 ec 04             	sub    $0x4,%esp
-    name[0] = 'f';
-    345d:	c6 45 a8 66          	movb   $0x66,-0x58(%ebp)
-    name[1] = '0' + nfiles / 1000;
-    3461:	f7 e6                	mul    %esi
-    name[5] = '\0';
-    3463:	c6 45 ad 00          	movb   $0x0,-0x53(%ebp)
-    name[1] = '0' + nfiles / 1000;
-    3467:	c1 ea 06             	shr    $0x6,%edx
-    346a:	8d 42 30             	lea    0x30(%edx),%eax
-    name[2] = '0' + (nfiles % 1000) / 100;
-    346d:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
-    name[1] = '0' + nfiles / 1000;
-    3473:	88 45 a9             	mov    %al,-0x57(%ebp)
-    name[2] = '0' + (nfiles % 1000) / 100;
-    3476:	89 f0                	mov    %esi,%eax
-    3478:	29 d0                	sub    %edx,%eax
-    347a:	89 c2                	mov    %eax,%edx
-    347c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
-    3481:	f7 e2                	mul    %edx
-    name[3] = '0' + (nfiles % 100) / 10;
-    3483:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
-    name[2] = '0' + (nfiles % 1000) / 100;
-    3488:	c1 ea 05             	shr    $0x5,%edx
-    348b:	83 c2 30             	add    $0x30,%edx
-    348e:	88 55 aa             	mov    %dl,-0x56(%ebp)
-    name[3] = '0' + (nfiles % 100) / 10;
-    3491:	f7 e6                	mul    %esi
-    3493:	89 f0                	mov    %esi,%eax
-    3495:	c1 ea 05             	shr    $0x5,%edx
-    3498:	6b d2 64             	imul   $0x64,%edx,%edx
-    349b:	29 d0                	sub    %edx,%eax
-    349d:	f7 e1                	mul    %ecx
-    name[4] = '0' + (nfiles % 10);
-    349f:	89 f0                	mov    %esi,%eax
-    name[3] = '0' + (nfiles % 100) / 10;
-    34a1:	c1 ea 03             	shr    $0x3,%edx
-    34a4:	83 c2 30             	add    $0x30,%edx
-    34a7:	88 55 ab             	mov    %dl,-0x55(%ebp)
-    name[4] = '0' + (nfiles % 10);
-    34aa:	f7 e1                	mul    %ecx
-    34ac:	89 f1                	mov    %esi,%ecx
-    34ae:	c1 ea 03             	shr    $0x3,%edx
-    34b1:	8d 04 92             	lea    (%edx,%edx,4),%eax
-    34b4:	01 c0                	add    %eax,%eax
-    34b6:	29 c1                	sub    %eax,%ecx
-    34b8:	89 c8                	mov    %ecx,%eax
-    34ba:	83 c0 30             	add    $0x30,%eax
-    34bd:	88 45 ac             	mov    %al,-0x54(%ebp)
-    printf(1, "writing %s\n", name);
-    34c0:	8d 45 a8             	lea    -0x58(%ebp),%eax
-    34c3:	50                   	push   %eax
-    34c4:	68 18 4e 00 00       	push   $0x4e18
-    34c9:	6a 01                	push   $0x1
-    34cb:	e8 70 06 00 00       	call   3b40 <printf>
-    int fd = open(name, O_CREATE|O_RDWR);
-    34d0:	58                   	pop    %eax
-    34d1:	8d 45 a8             	lea    -0x58(%ebp),%eax
-    34d4:	5a                   	pop    %edx
-    34d5:	68 02 02 00 00       	push   $0x202
-    34da:	50                   	push   %eax
-    34db:	e8 e3 04 00 00       	call   39c3 <open>
-    if(fd < 0){
-    34e0:	83 c4 10             	add    $0x10,%esp
-    int fd = open(name, O_CREATE|O_RDWR);
-    34e3:	89 c7                	mov    %eax,%edi
-    if(fd < 0){
-    34e5:	85 c0                	test   %eax,%eax
-    34e7:	78 4d                	js     3536 <fsfull+0x106>
-    int total = 0;
-    34e9:	31 db                	xor    %ebx,%ebx
-    34eb:	eb 05                	jmp    34f2 <fsfull+0xc2>
-    34ed:	8d 76 00             	lea    0x0(%esi),%esi
-      total += cc;
-    34f0:	01 c3                	add    %eax,%ebx
-      int cc = write(fd, buf, 512);
-    34f2:	83 ec 04             	sub    $0x4,%esp
-    34f5:	68 00 02 00 00       	push   $0x200
-    34fa:	68 20 87 00 00       	push   $0x8720
-    34ff:	57                   	push   %edi
-    3500:	e8 9e 04 00 00       	call   39a3 <write>
-      if(cc < 512)
-    3505:	83 c4 10             	add    $0x10,%esp
-    3508:	3d ff 01 00 00       	cmp    $0x1ff,%eax
-    350d:	7f e1                	jg     34f0 <fsfull+0xc0>
-    printf(1, "wrote %d bytes\n", total);
-    350f:	83 ec 04             	sub    $0x4,%esp
-    3512:	53                   	push   %ebx
-    3513:	68 34 4e 00 00       	push   $0x4e34
-    3518:	6a 01                	push   $0x1
-    351a:	e8 21 06 00 00       	call   3b40 <printf>
-    close(fd);
-    351f:	89 3c 24             	mov    %edi,(%esp)
-    3522:	e8 84 04 00 00       	call   39ab <close>
-    if(total == 0)
-    3527:	83 c4 10             	add    $0x10,%esp
-    352a:	85 db                	test   %ebx,%ebx
-    352c:	74 1e                	je     354c <fsfull+0x11c>
-  for(nfiles = 0; ; nfiles++){
-    352e:	83 c6 01             	add    $0x1,%esi
-    3531:	e9 1a ff ff ff       	jmp    3450 <fsfull+0x20>
-      printf(1, "open %s failed\n", name);
-    3536:	83 ec 04             	sub    $0x4,%esp
-    3539:	8d 45 a8             	lea    -0x58(%ebp),%eax
-    353c:	50                   	push   %eax
-    353d:	68 24 4e 00 00       	push   $0x4e24
-    3542:	6a 01                	push   $0x1
-    3544:	e8 f7 05 00 00       	call   3b40 <printf>
-      break;
-    3549:	83 c4 10             	add    $0x10,%esp
-    name[1] = '0' + nfiles / 1000;
-    354c:	bf d3 4d 62 10       	mov    $0x10624dd3,%edi
-    name[2] = '0' + (nfiles % 1000) / 100;
-    3551:	bb 1f 85 eb 51       	mov    $0x51eb851f,%ebx
-    3556:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    355d:	8d 76 00             	lea    0x0(%esi),%esi
-    name[1] = '0' + nfiles / 1000;
-    3560:	89 f0                	mov    %esi,%eax
-    3562:	89 f1                	mov    %esi,%ecx
-    unlink(name);
-    3564:	83 ec 0c             	sub    $0xc,%esp
-    name[0] = 'f';
-    3567:	c6 45 a8 66          	movb   $0x66,-0x58(%ebp)
-    name[1] = '0' + nfiles / 1000;
-    356b:	f7 ef                	imul   %edi
-    356d:	c1 f9 1f             	sar    $0x1f,%ecx
-    name[5] = '\0';
-    3570:	c6 45 ad 00          	movb   $0x0,-0x53(%ebp)
-    name[1] = '0' + nfiles / 1000;
-    3574:	c1 fa 06             	sar    $0x6,%edx
-    3577:	29 ca                	sub    %ecx,%edx
-    3579:	8d 42 30             	lea    0x30(%edx),%eax
-    name[2] = '0' + (nfiles % 1000) / 100;
-    357c:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
-    name[1] = '0' + nfiles / 1000;
-    3582:	88 45 a9             	mov    %al,-0x57(%ebp)
-    name[2] = '0' + (nfiles % 1000) / 100;
-    3585:	89 f0                	mov    %esi,%eax
-    3587:	29 d0                	sub    %edx,%eax
-    3589:	f7 e3                	mul    %ebx
-    name[3] = '0' + (nfiles % 100) / 10;
-    358b:	89 f0                	mov    %esi,%eax
-    name[2] = '0' + (nfiles % 1000) / 100;
-    358d:	c1 ea 05             	shr    $0x5,%edx
-    3590:	83 c2 30             	add    $0x30,%edx
-    3593:	88 55 aa             	mov    %dl,-0x56(%ebp)
-    name[3] = '0' + (nfiles % 100) / 10;
-    3596:	f7 eb                	imul   %ebx
-    3598:	89 f0                	mov    %esi,%eax
-    359a:	c1 fa 05             	sar    $0x5,%edx
-    359d:	29 ca                	sub    %ecx,%edx
-    359f:	6b d2 64             	imul   $0x64,%edx,%edx
-    35a2:	29 d0                	sub    %edx,%eax
-    35a4:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
-    35a9:	f7 e2                	mul    %edx
-    name[4] = '0' + (nfiles % 10);
-    35ab:	89 f0                	mov    %esi,%eax
-    name[3] = '0' + (nfiles % 100) / 10;
-    35ad:	c1 ea 03             	shr    $0x3,%edx
-    35b0:	83 c2 30             	add    $0x30,%edx
-    35b3:	88 55 ab             	mov    %dl,-0x55(%ebp)
-    name[4] = '0' + (nfiles % 10);
-    35b6:	ba 67 66 66 66       	mov    $0x66666667,%edx
-    35bb:	f7 ea                	imul   %edx
-    35bd:	c1 fa 02             	sar    $0x2,%edx
-    35c0:	29 ca                	sub    %ecx,%edx
-    35c2:	89 f1                	mov    %esi,%ecx
-    nfiles--;
-    35c4:	83 ee 01             	sub    $0x1,%esi
-    name[4] = '0' + (nfiles % 10);
-    35c7:	8d 04 92             	lea    (%edx,%edx,4),%eax
-    35ca:	01 c0                	add    %eax,%eax
-    35cc:	29 c1                	sub    %eax,%ecx
-    35ce:	89 c8                	mov    %ecx,%eax
-    35d0:	83 c0 30             	add    $0x30,%eax
-    35d3:	88 45 ac             	mov    %al,-0x54(%ebp)
-    unlink(name);
-    35d6:	8d 45 a8             	lea    -0x58(%ebp),%eax
-    35d9:	50                   	push   %eax
-    35da:	e8 f4 03 00 00       	call   39d3 <unlink>
-  while(nfiles >= 0){
-    35df:	83 c4 10             	add    $0x10,%esp
-    35e2:	83 fe ff             	cmp    $0xffffffff,%esi
-    35e5:	0f 85 75 ff ff ff    	jne    3560 <fsfull+0x130>
-  printf(1, "fsfull test finished\n");
-    35eb:	83 ec 08             	sub    $0x8,%esp
-    35ee:	68 44 4e 00 00       	push   $0x4e44
-    35f3:	6a 01                	push   $0x1
-    35f5:	e8 46 05 00 00       	call   3b40 <printf>
-}
-    35fa:	83 c4 10             	add    $0x10,%esp
-    35fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    3600:	5b                   	pop    %ebx
-    3601:	5e                   	pop    %esi
-    3602:	5f                   	pop    %edi
-    3603:	5d                   	pop    %ebp
-    3604:	c3                   	ret    
-    3605:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    360c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00003610 <uio>:
-{
-    3610:	f3 0f 1e fb          	endbr32 
-    3614:	55                   	push   %ebp
-    3615:	89 e5                	mov    %esp,%ebp
-    3617:	83 ec 10             	sub    $0x10,%esp
-  printf(1, "uio test\n");
-    361a:	68 5a 4e 00 00       	push   $0x4e5a
-    361f:	6a 01                	push   $0x1
-    3621:	e8 1a 05 00 00       	call   3b40 <printf>
-  pid = fork();
-    3626:	e8 50 03 00 00       	call   397b <fork>
-  if(pid == 0){
-    362b:	83 c4 10             	add    $0x10,%esp
-    362e:	85 c0                	test   %eax,%eax
-    3630:	74 1b                	je     364d <uio+0x3d>
-  } else if(pid < 0){
-    3632:	78 3d                	js     3671 <uio+0x61>
-  wait();
-    3634:	e8 52 03 00 00       	call   398b <wait>
-  printf(1, "uio test done\n");
-    3639:	83 ec 08             	sub    $0x8,%esp
-    363c:	68 64 4e 00 00       	push   $0x4e64
-    3641:	6a 01                	push   $0x1
-    3643:	e8 f8 04 00 00       	call   3b40 <printf>
-}
-    3648:	83 c4 10             	add    $0x10,%esp
-    364b:	c9                   	leave  
-    364c:	c3                   	ret    
-    asm volatile("outb %0,%1"::"a"(val), "d" (port));
-    364d:	b8 09 00 00 00       	mov    $0x9,%eax
-    3652:	ba 70 00 00 00       	mov    $0x70,%edx
-    3657:	ee                   	out    %al,(%dx)
-    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
-    3658:	ba 71 00 00 00       	mov    $0x71,%edx
-    365d:	ec                   	in     (%dx),%al
-    printf(1, "uio: uio succeeded; test FAILED\n");
-    365e:	52                   	push   %edx
-    365f:	52                   	push   %edx
-    3660:	68 f0 55 00 00       	push   $0x55f0
-    3665:	6a 01                	push   $0x1
-    3667:	e8 d4 04 00 00       	call   3b40 <printf>
-    exit();
-    366c:	e8 12 03 00 00       	call   3983 <exit>
-    printf (1, "fork failed\n");
-    3671:	50                   	push   %eax
-    3672:	50                   	push   %eax
-    3673:	68 e9 4d 00 00       	push   $0x4de9
-    3678:	6a 01                	push   $0x1
-    367a:	e8 c1 04 00 00       	call   3b40 <printf>
-    exit();
-    367f:	e8 ff 02 00 00       	call   3983 <exit>
-    3684:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    368b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    368f:	90                   	nop
-
-00003690 <argptest>:
-{
-    3690:	f3 0f 1e fb          	endbr32 
-    3694:	55                   	push   %ebp
-    3695:	89 e5                	mov    %esp,%ebp
-    3697:	53                   	push   %ebx
-    3698:	83 ec 0c             	sub    $0xc,%esp
-  fd = open("init", O_RDONLY);
-    369b:	6a 00                	push   $0x0
-    369d:	68 73 4e 00 00       	push   $0x4e73
-    36a2:	e8 1c 03 00 00       	call   39c3 <open>
-  if (fd < 0) {
-    36a7:	83 c4 10             	add    $0x10,%esp
-    36aa:	85 c0                	test   %eax,%eax
-    36ac:	78 39                	js     36e7 <argptest+0x57>
-  read(fd, sbrk(0) - 1, -1);
-    36ae:	83 ec 0c             	sub    $0xc,%esp
-    36b1:	89 c3                	mov    %eax,%ebx
-    36b3:	6a 00                	push   $0x0
-    36b5:	e8 51 03 00 00       	call   3a0b <sbrk>
-    36ba:	83 c4 0c             	add    $0xc,%esp
-    36bd:	83 e8 01             	sub    $0x1,%eax
-    36c0:	6a ff                	push   $0xffffffff
-    36c2:	50                   	push   %eax
-    36c3:	53                   	push   %ebx
-    36c4:	e8 d2 02 00 00       	call   399b <read>
-  close(fd);
-    36c9:	89 1c 24             	mov    %ebx,(%esp)
-    36cc:	e8 da 02 00 00       	call   39ab <close>
-  printf(1, "arg test passed\n");
-    36d1:	58                   	pop    %eax
-    36d2:	5a                   	pop    %edx
-    36d3:	68 85 4e 00 00       	push   $0x4e85
-    36d8:	6a 01                	push   $0x1
-    36da:	e8 61 04 00 00       	call   3b40 <printf>
-}
-    36df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-    36e2:	83 c4 10             	add    $0x10,%esp
-    36e5:	c9                   	leave  
-    36e6:	c3                   	ret    
-    printf(2, "open failed\n");
-    36e7:	51                   	push   %ecx
-    36e8:	51                   	push   %ecx
-    36e9:	68 78 4e 00 00       	push   $0x4e78
-    36ee:	6a 02                	push   $0x2
-    36f0:	e8 4b 04 00 00       	call   3b40 <printf>
-    exit();
-    36f5:	e8 89 02 00 00       	call   3983 <exit>
-    36fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00003700 <rand>:
-{
-    3700:	f3 0f 1e fb          	endbr32 
-  randstate = randstate * 1664525 + 1013904223;
-    3704:	69 05 3c 5f 00 00 0d 	imul   $0x19660d,0x5f3c,%eax
-    370b:	66 19 00 
-    370e:	05 5f f3 6e 3c       	add    $0x3c6ef35f,%eax
-    3713:	a3 3c 5f 00 00       	mov    %eax,0x5f3c
-}
-    3718:	c3                   	ret    
-    3719:	66 90                	xchg   %ax,%ax
-    371b:	66 90                	xchg   %ax,%ax
-    371d:	66 90                	xchg   %ax,%ax
-    371f:	90                   	nop
-
-00003720 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-    3720:	f3 0f 1e fb          	endbr32 
-    3724:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-    3725:	31 c0                	xor    %eax,%eax
-{
-    3727:	89 e5                	mov    %esp,%ebp
-    3729:	53                   	push   %ebx
-    372a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-    372d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-    3730:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-    3734:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-    3737:	83 c0 01             	add    $0x1,%eax
-    373a:	84 d2                	test   %dl,%dl
-    373c:	75 f2                	jne    3730 <strcpy+0x10>
-    ;
-  return os;
-}
-    373e:	89 c8                	mov    %ecx,%eax
-    3740:	5b                   	pop    %ebx
-    3741:	5d                   	pop    %ebp
-    3742:	c3                   	ret    
-    3743:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    374a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00003750 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-    3750:	f3 0f 1e fb          	endbr32 
-    3754:	55                   	push   %ebp
-    3755:	89 e5                	mov    %esp,%ebp
-    3757:	53                   	push   %ebx
-    3758:	8b 4d 08             	mov    0x8(%ebp),%ecx
-    375b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-    375e:	0f b6 01             	movzbl (%ecx),%eax
-    3761:	0f b6 1a             	movzbl (%edx),%ebx
-    3764:	84 c0                	test   %al,%al
-    3766:	75 19                	jne    3781 <strcmp+0x31>
-    3768:	eb 26                	jmp    3790 <strcmp+0x40>
-    376a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    3770:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-    3774:	83 c1 01             	add    $0x1,%ecx
-    3777:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-    377a:	0f b6 1a             	movzbl (%edx),%ebx
-    377d:	84 c0                	test   %al,%al
-    377f:	74 0f                	je     3790 <strcmp+0x40>
-    3781:	38 d8                	cmp    %bl,%al
-    3783:	74 eb                	je     3770 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-    3785:	29 d8                	sub    %ebx,%eax
-}
-    3787:	5b                   	pop    %ebx
-    3788:	5d                   	pop    %ebp
-    3789:	c3                   	ret    
-    378a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    3790:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-    3792:	29 d8                	sub    %ebx,%eax
-}
-    3794:	5b                   	pop    %ebx
-    3795:	5d                   	pop    %ebp
-    3796:	c3                   	ret    
-    3797:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    379e:	66 90                	xchg   %ax,%ax
-
-000037a0 <strlen>:
-
-uint
-strlen(const char *s)
-{
-    37a0:	f3 0f 1e fb          	endbr32 
-    37a4:	55                   	push   %ebp
-    37a5:	89 e5                	mov    %esp,%ebp
-    37a7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
-    37aa:	80 3a 00             	cmpb   $0x0,(%edx)
-    37ad:	74 21                	je     37d0 <strlen+0x30>
-    37af:	31 c0                	xor    %eax,%eax
-    37b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    37b8:	83 c0 01             	add    $0x1,%eax
-    37bb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
-    37bf:	89 c1                	mov    %eax,%ecx
-    37c1:	75 f5                	jne    37b8 <strlen+0x18>
-    ;
-  return n;
-}
-    37c3:	89 c8                	mov    %ecx,%eax
-    37c5:	5d                   	pop    %ebp
-    37c6:	c3                   	ret    
-    37c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    37ce:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
-    37d0:	31 c9                	xor    %ecx,%ecx
-}
-    37d2:	5d                   	pop    %ebp
-    37d3:	89 c8                	mov    %ecx,%eax
-    37d5:	c3                   	ret    
-    37d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    37dd:	8d 76 00             	lea    0x0(%esi),%esi
-
-000037e0 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
-    37e0:	f3 0f 1e fb          	endbr32 
-    37e4:	55                   	push   %ebp
-    37e5:	89 e5                	mov    %esp,%ebp
-    37e7:	57                   	push   %edi
-    37e8:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
-    37eb:	8b 4d 10             	mov    0x10(%ebp),%ecx
-    37ee:	8b 45 0c             	mov    0xc(%ebp),%eax
-    37f1:	89 d7                	mov    %edx,%edi
-    37f3:	fc                   	cld    
-    37f4:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
-    37f6:	89 d0                	mov    %edx,%eax
-    37f8:	5f                   	pop    %edi
-    37f9:	5d                   	pop    %ebp
-    37fa:	c3                   	ret    
-    37fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    37ff:	90                   	nop
-
-00003800 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
-    3800:	f3 0f 1e fb          	endbr32 
-    3804:	55                   	push   %ebp
-    3805:	89 e5                	mov    %esp,%ebp
-    3807:	8b 45 08             	mov    0x8(%ebp),%eax
-    380a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
-    380e:	0f b6 10             	movzbl (%eax),%edx
-    3811:	84 d2                	test   %dl,%dl
-    3813:	75 16                	jne    382b <strchr+0x2b>
-    3815:	eb 21                	jmp    3838 <strchr+0x38>
-    3817:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    381e:	66 90                	xchg   %ax,%ax
-    3820:	0f b6 50 01          	movzbl 0x1(%eax),%edx
-    3824:	83 c0 01             	add    $0x1,%eax
-    3827:	84 d2                	test   %dl,%dl
-    3829:	74 0d                	je     3838 <strchr+0x38>
-    if(*s == c)
-    382b:	38 d1                	cmp    %dl,%cl
-    382d:	75 f1                	jne    3820 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
-    382f:	5d                   	pop    %ebp
-    3830:	c3                   	ret    
-    3831:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
-    3838:	31 c0                	xor    %eax,%eax
-}
-    383a:	5d                   	pop    %ebp
-    383b:	c3                   	ret    
-    383c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00003840 <gets>:
-
-char*
-gets(char *buf, int max)
-{
-    3840:	f3 0f 1e fb          	endbr32 
-    3844:	55                   	push   %ebp
-    3845:	89 e5                	mov    %esp,%ebp
-    3847:	57                   	push   %edi
-    3848:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
-    3849:	31 f6                	xor    %esi,%esi
-{
-    384b:	53                   	push   %ebx
-    384c:	89 f3                	mov    %esi,%ebx
-    384e:	83 ec 1c             	sub    $0x1c,%esp
-    3851:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
-    3854:	eb 33                	jmp    3889 <gets+0x49>
-    3856:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    385d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
-    3860:	83 ec 04             	sub    $0x4,%esp
-    3863:	8d 45 e7             	lea    -0x19(%ebp),%eax
-    3866:	6a 01                	push   $0x1
-    3868:	50                   	push   %eax
-    3869:	6a 00                	push   $0x0
-    386b:	e8 2b 01 00 00       	call   399b <read>
-    if(cc < 1)
-    3870:	83 c4 10             	add    $0x10,%esp
-    3873:	85 c0                	test   %eax,%eax
-    3875:	7e 1c                	jle    3893 <gets+0x53>
-      break;
-    buf[i++] = c;
-    3877:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
-    387b:	83 c7 01             	add    $0x1,%edi
-    387e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
-    3881:	3c 0a                	cmp    $0xa,%al
-    3883:	74 23                	je     38a8 <gets+0x68>
-    3885:	3c 0d                	cmp    $0xd,%al
-    3887:	74 1f                	je     38a8 <gets+0x68>
-  for(i=0; i+1 < max; ){
-    3889:	83 c3 01             	add    $0x1,%ebx
-    388c:	89 fe                	mov    %edi,%esi
-    388e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
-    3891:	7c cd                	jl     3860 <gets+0x20>
-    3893:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
-    3895:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
-    3898:	c6 03 00             	movb   $0x0,(%ebx)
-}
-    389b:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    389e:	5b                   	pop    %ebx
-    389f:	5e                   	pop    %esi
-    38a0:	5f                   	pop    %edi
-    38a1:	5d                   	pop    %ebp
-    38a2:	c3                   	ret    
-    38a3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    38a7:	90                   	nop
-    38a8:	8b 75 08             	mov    0x8(%ebp),%esi
-    38ab:	8b 45 08             	mov    0x8(%ebp),%eax
-    38ae:	01 de                	add    %ebx,%esi
-    38b0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
-    38b2:	c6 03 00             	movb   $0x0,(%ebx)
-}
-    38b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    38b8:	5b                   	pop    %ebx
-    38b9:	5e                   	pop    %esi
-    38ba:	5f                   	pop    %edi
-    38bb:	5d                   	pop    %ebp
-    38bc:	c3                   	ret    
-    38bd:	8d 76 00             	lea    0x0(%esi),%esi
-
-000038c0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
-    38c0:	f3 0f 1e fb          	endbr32 
-    38c4:	55                   	push   %ebp
-    38c5:	89 e5                	mov    %esp,%ebp
-    38c7:	56                   	push   %esi
-    38c8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
-    38c9:	83 ec 08             	sub    $0x8,%esp
-    38cc:	6a 00                	push   $0x0
-    38ce:	ff 75 08             	pushl  0x8(%ebp)
-    38d1:	e8 ed 00 00 00       	call   39c3 <open>
-  if(fd < 0)
-    38d6:	83 c4 10             	add    $0x10,%esp
-    38d9:	85 c0                	test   %eax,%eax
-    38db:	78 2b                	js     3908 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
-    38dd:	83 ec 08             	sub    $0x8,%esp
-    38e0:	ff 75 0c             	pushl  0xc(%ebp)
-    38e3:	89 c3                	mov    %eax,%ebx
-    38e5:	50                   	push   %eax
-    38e6:	e8 f0 00 00 00       	call   39db <fstat>
-  close(fd);
-    38eb:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
-    38ee:	89 c6                	mov    %eax,%esi
-  close(fd);
-    38f0:	e8 b6 00 00 00       	call   39ab <close>
-  return r;
-    38f5:	83 c4 10             	add    $0x10,%esp
-}
-    38f8:	8d 65 f8             	lea    -0x8(%ebp),%esp
-    38fb:	89 f0                	mov    %esi,%eax
-    38fd:	5b                   	pop    %ebx
-    38fe:	5e                   	pop    %esi
-    38ff:	5d                   	pop    %ebp
-    3900:	c3                   	ret    
-    3901:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
-    3908:	be ff ff ff ff       	mov    $0xffffffff,%esi
-    390d:	eb e9                	jmp    38f8 <stat+0x38>
-    390f:	90                   	nop
-
-00003910 <atoi>:
-
-int
-atoi(const char *s)
-{
-    3910:	f3 0f 1e fb          	endbr32 
-    3914:	55                   	push   %ebp
-    3915:	89 e5                	mov    %esp,%ebp
-    3917:	53                   	push   %ebx
-    3918:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
-    391b:	0f be 02             	movsbl (%edx),%eax
-    391e:	8d 48 d0             	lea    -0x30(%eax),%ecx
-    3921:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
-    3924:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
-    3929:	77 1a                	ja     3945 <atoi+0x35>
-    392b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    392f:	90                   	nop
-    n = n*10 + *s++ - '0';
-    3930:	83 c2 01             	add    $0x1,%edx
-    3933:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
-    3936:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
-    393a:	0f be 02             	movsbl (%edx),%eax
-    393d:	8d 58 d0             	lea    -0x30(%eax),%ebx
-    3940:	80 fb 09             	cmp    $0x9,%bl
-    3943:	76 eb                	jbe    3930 <atoi+0x20>
-  return n;
-}
-    3945:	89 c8                	mov    %ecx,%eax
-    3947:	5b                   	pop    %ebx
-    3948:	5d                   	pop    %ebp
-    3949:	c3                   	ret    
-    394a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00003950 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
-    3950:	f3 0f 1e fb          	endbr32 
-    3954:	55                   	push   %ebp
-    3955:	89 e5                	mov    %esp,%ebp
-    3957:	57                   	push   %edi
-    3958:	8b 45 10             	mov    0x10(%ebp),%eax
-    395b:	8b 55 08             	mov    0x8(%ebp),%edx
-    395e:	56                   	push   %esi
-    395f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
-    3962:	85 c0                	test   %eax,%eax
-    3964:	7e 0f                	jle    3975 <memmove+0x25>
-    3966:	01 d0                	add    %edx,%eax
-  dst = vdst;
-    3968:	89 d7                	mov    %edx,%edi
-    396a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
-    3970:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
-    3971:	39 f8                	cmp    %edi,%eax
-    3973:	75 fb                	jne    3970 <memmove+0x20>
-  return vdst;
-}
-    3975:	5e                   	pop    %esi
-    3976:	89 d0                	mov    %edx,%eax
-    3978:	5f                   	pop    %edi
-    3979:	5d                   	pop    %ebp
-    397a:	c3                   	ret    
-
-0000397b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
-    397b:	b8 01 00 00 00       	mov    $0x1,%eax
-    3980:	cd 40                	int    $0x40
-    3982:	c3                   	ret    
-
-00003983 <exit>:
-SYSCALL(exit)
-    3983:	b8 02 00 00 00       	mov    $0x2,%eax
-    3988:	cd 40                	int    $0x40
-    398a:	c3                   	ret    
-
-0000398b <wait>:
-SYSCALL(wait)
-    398b:	b8 03 00 00 00       	mov    $0x3,%eax
-    3990:	cd 40                	int    $0x40
-    3992:	c3                   	ret    
-
-00003993 <pipe>:
-SYSCALL(pipe)
-    3993:	b8 04 00 00 00       	mov    $0x4,%eax
-    3998:	cd 40                	int    $0x40
-    399a:	c3                   	ret    
-
-0000399b <read>:
-SYSCALL(read)
-    399b:	b8 05 00 00 00       	mov    $0x5,%eax
-    39a0:	cd 40                	int    $0x40
-    39a2:	c3                   	ret    
-
-000039a3 <write>:
-SYSCALL(write)
-    39a3:	b8 10 00 00 00       	mov    $0x10,%eax
-    39a8:	cd 40                	int    $0x40
-    39aa:	c3                   	ret    
-
-000039ab <close>:
-SYSCALL(close)
-    39ab:	b8 15 00 00 00       	mov    $0x15,%eax
-    39b0:	cd 40                	int    $0x40
-    39b2:	c3                   	ret    
-
-000039b3 <kill>:
-SYSCALL(kill)
-    39b3:	b8 06 00 00 00       	mov    $0x6,%eax
-    39b8:	cd 40                	int    $0x40
-    39ba:	c3                   	ret    
-
-000039bb <exec>:
-SYSCALL(exec)
-    39bb:	b8 07 00 00 00       	mov    $0x7,%eax
-    39c0:	cd 40                	int    $0x40
-    39c2:	c3                   	ret    
-
-000039c3 <open>:
-SYSCALL(open)
-    39c3:	b8 0f 00 00 00       	mov    $0xf,%eax
-    39c8:	cd 40                	int    $0x40
-    39ca:	c3                   	ret    
-
-000039cb <mknod>:
-SYSCALL(mknod)
-    39cb:	b8 11 00 00 00       	mov    $0x11,%eax
-    39d0:	cd 40                	int    $0x40
-    39d2:	c3                   	ret    
-
-000039d3 <unlink>:
-SYSCALL(unlink)
-    39d3:	b8 12 00 00 00       	mov    $0x12,%eax
-    39d8:	cd 40                	int    $0x40
-    39da:	c3                   	ret    
-
-000039db <fstat>:
-SYSCALL(fstat)
-    39db:	b8 08 00 00 00       	mov    $0x8,%eax
-    39e0:	cd 40                	int    $0x40
-    39e2:	c3                   	ret    
-
-000039e3 <link>:
-SYSCALL(link)
-    39e3:	b8 13 00 00 00       	mov    $0x13,%eax
-    39e8:	cd 40                	int    $0x40
-    39ea:	c3                   	ret    
-
-000039eb <mkdir>:
-SYSCALL(mkdir)
-    39eb:	b8 14 00 00 00       	mov    $0x14,%eax
-    39f0:	cd 40                	int    $0x40
-    39f2:	c3                   	ret    
-
-000039f3 <chdir>:
-SYSCALL(chdir)
-    39f3:	b8 09 00 00 00       	mov    $0x9,%eax
-    39f8:	cd 40                	int    $0x40
-    39fa:	c3                   	ret    
-
-000039fb <dup>:
-SYSCALL(dup)
-    39fb:	b8 0a 00 00 00       	mov    $0xa,%eax
-    3a00:	cd 40                	int    $0x40
-    3a02:	c3                   	ret    
-
-00003a03 <getpid>:
-SYSCALL(getpid)
-    3a03:	b8 0b 00 00 00       	mov    $0xb,%eax
-    3a08:	cd 40                	int    $0x40
-    3a0a:	c3                   	ret    
-
-00003a0b <sbrk>:
-SYSCALL(sbrk)
-    3a0b:	b8 0c 00 00 00       	mov    $0xc,%eax
-    3a10:	cd 40                	int    $0x40
-    3a12:	c3                   	ret    
-
-00003a13 <sleep>:
-SYSCALL(sleep)
-    3a13:	b8 0d 00 00 00       	mov    $0xd,%eax
-    3a18:	cd 40                	int    $0x40
-    3a1a:	c3                   	ret    
-
-00003a1b <uptime>:
-SYSCALL(uptime)
-    3a1b:	b8 0e 00 00 00       	mov    $0xe,%eax
-    3a20:	cd 40                	int    $0x40
-    3a22:	c3                   	ret    
-
-00003a23 <getParentID>:
-SYSCALL(getParentID)
-    3a23:	b8 16 00 00 00       	mov    $0x16,%eax
-    3a28:	cd 40                	int    $0x40
-    3a2a:	c3                   	ret    
-
-00003a2b <getChildren>:
-SYSCALL(getChildren)
-    3a2b:	b8 17 00 00 00       	mov    $0x17,%eax
-    3a30:	cd 40                	int    $0x40
-    3a32:	c3                   	ret    
-
-00003a33 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
-    3a33:	b8 18 00 00 00       	mov    $0x18,%eax
-    3a38:	cd 40                	int    $0x40
-    3a3a:	c3                   	ret    
-
-00003a3b <setPriority>:
-SYSCALL(setPriority)
-    3a3b:	b8 19 00 00 00       	mov    $0x19,%eax
-    3a40:	cd 40                	int    $0x40
-    3a42:	c3                   	ret    
-
-00003a43 <changePolicy>:
-SYSCALL(changePolicy)
-    3a43:	b8 1a 00 00 00       	mov    $0x1a,%eax
-    3a48:	cd 40                	int    $0x40
-    3a4a:	c3                   	ret    
-
-00003a4b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
-    3a4b:	b8 1b 00 00 00       	mov    $0x1b,%eax
-    3a50:	cd 40                	int    $0x40
-    3a52:	c3                   	ret    
-
-00003a53 <getWaitingTime>:
-SYSCALL(getWaitingTime)
-    3a53:	b8 1c 00 00 00       	mov    $0x1c,%eax
-    3a58:	cd 40                	int    $0x40
-    3a5a:	c3                   	ret    
-
-00003a5b <getCBT>:
-SYSCALL(getCBT)
-    3a5b:	b8 1d 00 00 00       	mov    $0x1d,%eax
-    3a60:	cd 40                	int    $0x40
-    3a62:	c3                   	ret    
-
-00003a63 <customWait>:
-SYSCALL(customWait)
-    3a63:	b8 1e 00 00 00       	mov    $0x1e,%eax
-    3a68:	cd 40                	int    $0x40
-    3a6a:	c3                   	ret    
-
-00003a6b <setQueue>:
-SYSCALL(setQueue)
-    3a6b:	b8 1f 00 00 00       	mov    $0x1f,%eax
-    3a70:	cd 40                	int    $0x40
-    3a72:	c3                   	ret    
-
-00003a73 <getBurstTime>:
-SYSCALL(getBurstTime)
-    3a73:	b8 20 00 00 00       	mov    $0x20,%eax
-    3a78:	cd 40                	int    $0x40
-    3a7a:	c3                   	ret    
-
-00003a7b <getCreationTime>:
-    3a7b:	b8 21 00 00 00       	mov    $0x21,%eax
-    3a80:	cd 40                	int    $0x40
-    3a82:	c3                   	ret    
-    3a83:	66 90                	xchg   %ax,%ax
-    3a85:	66 90                	xchg   %ax,%ax
-    3a87:	66 90                	xchg   %ax,%ax
-    3a89:	66 90                	xchg   %ax,%ax
-    3a8b:	66 90                	xchg   %ax,%ax
-    3a8d:	66 90                	xchg   %ax,%ax
-    3a8f:	90                   	nop
-
-00003a90 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
-    3a90:	55                   	push   %ebp
-    3a91:	89 e5                	mov    %esp,%ebp
-    3a93:	57                   	push   %edi
-    3a94:	56                   	push   %esi
-    3a95:	53                   	push   %ebx
-    3a96:	83 ec 3c             	sub    $0x3c,%esp
-    3a99:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
-    3a9c:	89 d1                	mov    %edx,%ecx
-{
-    3a9e:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
-    3aa1:	85 d2                	test   %edx,%edx
-    3aa3:	0f 89 7f 00 00 00    	jns    3b28 <printint+0x98>
-    3aa9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
-    3aad:	74 79                	je     3b28 <printint+0x98>
-    neg = 1;
-    3aaf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
-    3ab6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
-    3ab8:	31 db                	xor    %ebx,%ebx
-    3aba:	8d 75 d7             	lea    -0x29(%ebp),%esi
-    3abd:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
-    3ac0:	89 c8                	mov    %ecx,%eax
-    3ac2:	31 d2                	xor    %edx,%edx
-    3ac4:	89 cf                	mov    %ecx,%edi
-    3ac6:	f7 75 c4             	divl   -0x3c(%ebp)
-    3ac9:	0f b6 92 48 56 00 00 	movzbl 0x5648(%edx),%edx
-    3ad0:	89 45 c0             	mov    %eax,-0x40(%ebp)
-    3ad3:	89 d8                	mov    %ebx,%eax
-    3ad5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
-    3ad8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
-    3adb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
-    3ade:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
-    3ae1:	76 dd                	jbe    3ac0 <printint+0x30>
-  if(neg)
-    3ae3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
-    3ae6:	85 c9                	test   %ecx,%ecx
-    3ae8:	74 0c                	je     3af6 <printint+0x66>
-    buf[i++] = '-';
-    3aea:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
-    3aef:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
-    3af1:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
-    3af6:	8b 7d b8             	mov    -0x48(%ebp),%edi
-    3af9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
-    3afd:	eb 07                	jmp    3b06 <printint+0x76>
-    3aff:	90                   	nop
-    3b00:	0f b6 13             	movzbl (%ebx),%edx
-    3b03:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
-    3b06:	83 ec 04             	sub    $0x4,%esp
-    3b09:	88 55 d7             	mov    %dl,-0x29(%ebp)
-    3b0c:	6a 01                	push   $0x1
-    3b0e:	56                   	push   %esi
-    3b0f:	57                   	push   %edi
-    3b10:	e8 8e fe ff ff       	call   39a3 <write>
-  while(--i >= 0)
-    3b15:	83 c4 10             	add    $0x10,%esp
-    3b18:	39 de                	cmp    %ebx,%esi
-    3b1a:	75 e4                	jne    3b00 <printint+0x70>
-    putc(fd, buf[i]);
-}
-    3b1c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    3b1f:	5b                   	pop    %ebx
-    3b20:	5e                   	pop    %esi
-    3b21:	5f                   	pop    %edi
-    3b22:	5d                   	pop    %ebp
-    3b23:	c3                   	ret    
-    3b24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
-    3b28:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
-    3b2f:	eb 87                	jmp    3ab8 <printint+0x28>
-    3b31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    3b38:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    3b3f:	90                   	nop
-
-00003b40 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
-    3b40:	f3 0f 1e fb          	endbr32 
-    3b44:	55                   	push   %ebp
-    3b45:	89 e5                	mov    %esp,%ebp
-    3b47:	57                   	push   %edi
-    3b48:	56                   	push   %esi
-    3b49:	53                   	push   %ebx
-    3b4a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
-    3b4d:	8b 75 0c             	mov    0xc(%ebp),%esi
-    3b50:	0f b6 1e             	movzbl (%esi),%ebx
-    3b53:	84 db                	test   %bl,%bl
-    3b55:	0f 84 b4 00 00 00    	je     3c0f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
-    3b5b:	8d 45 10             	lea    0x10(%ebp),%eax
-    3b5e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
-    3b61:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
-    3b64:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
-    3b66:	89 45 d0             	mov    %eax,-0x30(%ebp)
-    3b69:	eb 33                	jmp    3b9e <printf+0x5e>
-    3b6b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    3b6f:	90                   	nop
-    3b70:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
-    3b73:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
-    3b78:	83 f8 25             	cmp    $0x25,%eax
-    3b7b:	74 17                	je     3b94 <printf+0x54>
-  write(fd, &c, 1);
-    3b7d:	83 ec 04             	sub    $0x4,%esp
-    3b80:	88 5d e7             	mov    %bl,-0x19(%ebp)
-    3b83:	6a 01                	push   $0x1
-    3b85:	57                   	push   %edi
-    3b86:	ff 75 08             	pushl  0x8(%ebp)
-    3b89:	e8 15 fe ff ff       	call   39a3 <write>
-    3b8e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
-    3b91:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
-    3b94:	0f b6 1e             	movzbl (%esi),%ebx
-    3b97:	83 c6 01             	add    $0x1,%esi
-    3b9a:	84 db                	test   %bl,%bl
-    3b9c:	74 71                	je     3c0f <printf+0xcf>
-    c = fmt[i] & 0xff;
-    3b9e:	0f be cb             	movsbl %bl,%ecx
-    3ba1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
-    3ba4:	85 d2                	test   %edx,%edx
-    3ba6:	74 c8                	je     3b70 <printf+0x30>
-      }
-    } else if(state == '%'){
-    3ba8:	83 fa 25             	cmp    $0x25,%edx
-    3bab:	75 e7                	jne    3b94 <printf+0x54>
-      if(c == 'd'){
-    3bad:	83 f8 64             	cmp    $0x64,%eax
-    3bb0:	0f 84 9a 00 00 00    	je     3c50 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
-    3bb6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
-    3bbc:	83 f9 70             	cmp    $0x70,%ecx
-    3bbf:	74 5f                	je     3c20 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
-    3bc1:	83 f8 73             	cmp    $0x73,%eax
-    3bc4:	0f 84 d6 00 00 00    	je     3ca0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
-    3bca:	83 f8 63             	cmp    $0x63,%eax
-    3bcd:	0f 84 8d 00 00 00    	je     3c60 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
-    3bd3:	83 f8 25             	cmp    $0x25,%eax
-    3bd6:	0f 84 b4 00 00 00    	je     3c90 <printf+0x150>
-  write(fd, &c, 1);
-    3bdc:	83 ec 04             	sub    $0x4,%esp
-    3bdf:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
-    3be3:	6a 01                	push   $0x1
-    3be5:	57                   	push   %edi
-    3be6:	ff 75 08             	pushl  0x8(%ebp)
-    3be9:	e8 b5 fd ff ff       	call   39a3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
-    3bee:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
-    3bf1:	83 c4 0c             	add    $0xc,%esp
-    3bf4:	6a 01                	push   $0x1
-    3bf6:	83 c6 01             	add    $0x1,%esi
-    3bf9:	57                   	push   %edi
-    3bfa:	ff 75 08             	pushl  0x8(%ebp)
-    3bfd:	e8 a1 fd ff ff       	call   39a3 <write>
-  for(i = 0; fmt[i]; i++){
-    3c02:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
-    3c06:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
-    3c09:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
-    3c0b:	84 db                	test   %bl,%bl
-    3c0d:	75 8f                	jne    3b9e <printf+0x5e>
-    }
-  }
-}
-    3c0f:	8d 65 f4             	lea    -0xc(%ebp),%esp
-    3c12:	5b                   	pop    %ebx
-    3c13:	5e                   	pop    %esi
-    3c14:	5f                   	pop    %edi
-    3c15:	5d                   	pop    %ebp
-    3c16:	c3                   	ret    
-    3c17:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    3c1e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
-    3c20:	83 ec 0c             	sub    $0xc,%esp
-    3c23:	b9 10 00 00 00       	mov    $0x10,%ecx
-    3c28:	6a 00                	push   $0x0
-    3c2a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-    3c2d:	8b 45 08             	mov    0x8(%ebp),%eax
-    3c30:	8b 13                	mov    (%ebx),%edx
-    3c32:	e8 59 fe ff ff       	call   3a90 <printint>
-        ap++;
-    3c37:	89 d8                	mov    %ebx,%eax
-    3c39:	83 c4 10             	add    $0x10,%esp
-      state = 0;
-    3c3c:	31 d2                	xor    %edx,%edx
-        ap++;
-    3c3e:	83 c0 04             	add    $0x4,%eax
-    3c41:	89 45 d0             	mov    %eax,-0x30(%ebp)
-    3c44:	e9 4b ff ff ff       	jmp    3b94 <printf+0x54>
-    3c49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
-    3c50:	83 ec 0c             	sub    $0xc,%esp
-    3c53:	b9 0a 00 00 00       	mov    $0xa,%ecx
-    3c58:	6a 01                	push   $0x1
-    3c5a:	eb ce                	jmp    3c2a <printf+0xea>
-    3c5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
-    3c60:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
-    3c63:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
-    3c66:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
-    3c68:	6a 01                	push   $0x1
-        ap++;
-    3c6a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
-    3c6d:	57                   	push   %edi
-    3c6e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
-    3c71:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
-    3c74:	e8 2a fd ff ff       	call   39a3 <write>
-        ap++;
-    3c79:	89 5d d0             	mov    %ebx,-0x30(%ebp)
-    3c7c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
-    3c7f:	31 d2                	xor    %edx,%edx
-    3c81:	e9 0e ff ff ff       	jmp    3b94 <printf+0x54>
-    3c86:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    3c8d:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
-    3c90:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
-    3c93:	83 ec 04             	sub    $0x4,%esp
-    3c96:	e9 59 ff ff ff       	jmp    3bf4 <printf+0xb4>
-    3c9b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    3c9f:	90                   	nop
-        s = (char*)*ap;
-    3ca0:	8b 45 d0             	mov    -0x30(%ebp),%eax
-    3ca3:	8b 18                	mov    (%eax),%ebx
-        ap++;
-    3ca5:	83 c0 04             	add    $0x4,%eax
-    3ca8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
-    3cab:	85 db                	test   %ebx,%ebx
-    3cad:	74 17                	je     3cc6 <printf+0x186>
-        while(*s != 0){
-    3caf:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
-    3cb2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
-    3cb4:	84 c0                	test   %al,%al
-    3cb6:	0f 84 d8 fe ff ff    	je     3b94 <printf+0x54>
-    3cbc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
-    3cbf:	89 de                	mov    %ebx,%esi
-    3cc1:	8b 5d 08             	mov    0x8(%ebp),%ebx
-    3cc4:	eb 1a                	jmp    3ce0 <printf+0x1a0>
-          s = "(null)";
-    3cc6:	bb 3e 56 00 00       	mov    $0x563e,%ebx
-        while(*s != 0){
-    3ccb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
-    3cce:	b8 28 00 00 00       	mov    $0x28,%eax
-    3cd3:	89 de                	mov    %ebx,%esi
-    3cd5:	8b 5d 08             	mov    0x8(%ebp),%ebx
-    3cd8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    3cdf:	90                   	nop
-  write(fd, &c, 1);
-    3ce0:	83 ec 04             	sub    $0x4,%esp
-          s++;
-    3ce3:	83 c6 01             	add    $0x1,%esi
-    3ce6:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
-    3ce9:	6a 01                	push   $0x1
-    3ceb:	57                   	push   %edi
-    3cec:	53                   	push   %ebx
-    3ced:	e8 b1 fc ff ff       	call   39a3 <write>
-        while(*s != 0){
-    3cf2:	0f b6 06             	movzbl (%esi),%eax
-    3cf5:	83 c4 10             	add    $0x10,%esp
-    3cf8:	84 c0                	test   %al,%al
-    3cfa:	75 e4                	jne    3ce0 <printf+0x1a0>
-    3cfc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
-    3cff:	31 d2                	xor    %edx,%edx
-    3d01:	e9 8e fe ff ff       	jmp    3b94 <printf+0x54>
-    3d06:	66 90                	xchg   %ax,%ax
-    3d08:	66 90                	xchg   %ax,%ax
-    3d0a:	66 90                	xchg   %ax,%ax
-    3d0c:	66 90                	xchg   %ax,%ax
-    3d0e:	66 90                	xchg   %ax,%ax
-
-00003d10 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
-    3d10:	f3 0f 1e fb          	endbr32 
-    3d14:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
-    3d15:	a1 e0 5f 00 00       	mov    0x5fe0,%eax
-{
-    3d1a:	89 e5                	mov    %esp,%ebp
-    3d1c:	57                   	push   %edi
-    3d1d:	56                   	push   %esi
-    3d1e:	53                   	push   %ebx
-    3d1f:	8b 5d 08             	mov    0x8(%ebp),%ebx
-    3d22:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
-    3d24:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
-    3d27:	39 c8                	cmp    %ecx,%eax
-    3d29:	73 15                	jae    3d40 <free+0x30>
-    3d2b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    3d2f:	90                   	nop
-    3d30:	39 d1                	cmp    %edx,%ecx
-    3d32:	72 14                	jb     3d48 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
-    3d34:	39 d0                	cmp    %edx,%eax
-    3d36:	73 10                	jae    3d48 <free+0x38>
-{
-    3d38:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
-    3d3a:	8b 10                	mov    (%eax),%edx
-    3d3c:	39 c8                	cmp    %ecx,%eax
-    3d3e:	72 f0                	jb     3d30 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
-    3d40:	39 d0                	cmp    %edx,%eax
-    3d42:	72 f4                	jb     3d38 <free+0x28>
-    3d44:	39 d1                	cmp    %edx,%ecx
-    3d46:	73 f0                	jae    3d38 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
-    3d48:	8b 73 fc             	mov    -0x4(%ebx),%esi
-    3d4b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
-    3d4e:	39 fa                	cmp    %edi,%edx
-    3d50:	74 1e                	je     3d70 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
-    3d52:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
-    3d55:	8b 50 04             	mov    0x4(%eax),%edx
-    3d58:	8d 34 d0             	lea    (%eax,%edx,8),%esi
-    3d5b:	39 f1                	cmp    %esi,%ecx
-    3d5d:	74 28                	je     3d87 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
-    3d5f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
-    3d61:	5b                   	pop    %ebx
-  freep = p;
-    3d62:	a3 e0 5f 00 00       	mov    %eax,0x5fe0
-}
-    3d67:	5e                   	pop    %esi
-    3d68:	5f                   	pop    %edi
-    3d69:	5d                   	pop    %ebp
-    3d6a:	c3                   	ret    
-    3d6b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-    3d6f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
-    3d70:	03 72 04             	add    0x4(%edx),%esi
-    3d73:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
-    3d76:	8b 10                	mov    (%eax),%edx
-    3d78:	8b 12                	mov    (%edx),%edx
-    3d7a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
-    3d7d:	8b 50 04             	mov    0x4(%eax),%edx
-    3d80:	8d 34 d0             	lea    (%eax,%edx,8),%esi
-    3d83:	39 f1                	cmp    %esi,%ecx
-    3d85:	75 d8                	jne    3d5f <free+0x4f>
-    p->s.size += bp->s.size;
-    3d87:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
-    3d8a:	a3 e0 5f 00 00       	mov    %eax,0x5fe0
-    p->s.size += bp->s.size;
-    3d8f:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
-    3d92:	8b 53 f8             	mov    -0x8(%ebx),%edx
-    3d95:	89 10                	mov    %edx,(%eax)
-}
-    3d97:	5b                   	pop    %ebx
-    3d98:	5e                   	pop    %esi
-    3d99:	5f                   	pop    %edi
-    3d9a:	5d                   	pop    %ebp
-    3d9b:	c3                   	ret    
-    3d9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00003da0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
-    3da0:	f3 0f 1e fb          	endbr32 
-    3da4:	55                   	push   %ebp
-    3da5:	89 e5                	mov    %esp,%ebp
-    3da7:	57                   	push   %edi
-    3da8:	56                   	push   %esi
-    3da9:	53                   	push   %ebx
-    3daa:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
-    3dad:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
-    3db0:	8b 3d e0 5f 00 00    	mov    0x5fe0,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
-    3db6:	8d 70 07             	lea    0x7(%eax),%esi
-    3db9:	c1 ee 03             	shr    $0x3,%esi
-    3dbc:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
-    3dbf:	85 ff                	test   %edi,%edi
-    3dc1:	0f 84 a9 00 00 00    	je     3e70 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
-    3dc7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
-    3dc9:	8b 48 04             	mov    0x4(%eax),%ecx
-    3dcc:	39 f1                	cmp    %esi,%ecx
-    3dce:	73 6d                	jae    3e3d <malloc+0x9d>
-    3dd0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
-    3dd6:	bb 00 10 00 00       	mov    $0x1000,%ebx
-    3ddb:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
-    3dde:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
-    3de5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
-    3de8:	eb 17                	jmp    3e01 <malloc+0x61>
-    3dea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
-    3df0:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
-    3df2:	8b 4a 04             	mov    0x4(%edx),%ecx
-    3df5:	39 f1                	cmp    %esi,%ecx
-    3df7:	73 4f                	jae    3e48 <malloc+0xa8>
-    3df9:	8b 3d e0 5f 00 00    	mov    0x5fe0,%edi
-    3dff:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
-    3e01:	39 c7                	cmp    %eax,%edi
-    3e03:	75 eb                	jne    3df0 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
-    3e05:	83 ec 0c             	sub    $0xc,%esp
-    3e08:	ff 75 e4             	pushl  -0x1c(%ebp)
-    3e0b:	e8 fb fb ff ff       	call   3a0b <sbrk>
-  if(p == (char*)-1)
-    3e10:	83 c4 10             	add    $0x10,%esp
-    3e13:	83 f8 ff             	cmp    $0xffffffff,%eax
-    3e16:	74 1b                	je     3e33 <malloc+0x93>
-  hp->s.size = nu;
-    3e18:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
-    3e1b:	83 ec 0c             	sub    $0xc,%esp
-    3e1e:	83 c0 08             	add    $0x8,%eax
-    3e21:	50                   	push   %eax
-    3e22:	e8 e9 fe ff ff       	call   3d10 <free>
-  return freep;
-    3e27:	a1 e0 5f 00 00       	mov    0x5fe0,%eax
-      if((p = morecore(nunits)) == 0)
-    3e2c:	83 c4 10             	add    $0x10,%esp
-    3e2f:	85 c0                	test   %eax,%eax
-    3e31:	75 bd                	jne    3df0 <malloc+0x50>
-        return 0;
-  }
-}
-    3e33:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
-    3e36:	31 c0                	xor    %eax,%eax
-}
-    3e38:	5b                   	pop    %ebx
-    3e39:	5e                   	pop    %esi
-    3e3a:	5f                   	pop    %edi
-    3e3b:	5d                   	pop    %ebp
-    3e3c:	c3                   	ret    
-    if(p->s.size >= nunits){
-    3e3d:	89 c2                	mov    %eax,%edx
-    3e3f:	89 f8                	mov    %edi,%eax
-    3e41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
-    3e48:	39 ce                	cmp    %ecx,%esi
-    3e4a:	74 54                	je     3ea0 <malloc+0x100>
-        p->s.size -= nunits;
-    3e4c:	29 f1                	sub    %esi,%ecx
-    3e4e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
-    3e51:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
-    3e54:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
-    3e57:	a3 e0 5f 00 00       	mov    %eax,0x5fe0
-}
-    3e5c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
-    3e5f:	8d 42 08             	lea    0x8(%edx),%eax
-}
-    3e62:	5b                   	pop    %ebx
-    3e63:	5e                   	pop    %esi
-    3e64:	5f                   	pop    %edi
-    3e65:	5d                   	pop    %ebp
-    3e66:	c3                   	ret    
-    3e67:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    3e6e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
-    3e70:	c7 05 e0 5f 00 00 e4 	movl   $0x5fe4,0x5fe0
-    3e77:	5f 00 00 
-    base.s.size = 0;
-    3e7a:	bf e4 5f 00 00       	mov    $0x5fe4,%edi
-    base.s.ptr = freep = prevp = &base;
-    3e7f:	c7 05 e4 5f 00 00 e4 	movl   $0x5fe4,0x5fe4
-    3e86:	5f 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
-    3e89:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
-    3e8b:	c7 05 e8 5f 00 00 00 	movl   $0x0,0x5fe8
-    3e92:	00 00 00 
-    if(p->s.size >= nunits){
-    3e95:	e9 36 ff ff ff       	jmp    3dd0 <malloc+0x30>
-    3e9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
-    3ea0:	8b 0a                	mov    (%edx),%ecx
-    3ea2:	89 08                	mov    %ecx,(%eax)
-    3ea4:	eb b1                	jmp    3e57 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/usertests.c b/xv6-public/Operating-System-Project/usertests.c
deleted file mode 100644
index a1e97e7..0000000
--- a/xv6-public/Operating-System-Project/usertests.c
+++ /dev/null
@@ -1,1803 +0,0 @@
-#include "param.h"
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-#include "fcntl.h"
-#include "syscall.h"
-#include "traps.h"
-#include "memlayout.h"
-
-char buf[8192];
-char name[3];
-char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
-int stdout = 1;
-
-// does chdir() call iput(p->cwd) in a transaction?
-void
-iputtest(void)
-{
-  printf(stdout, "iput test\n");
-
-  if(mkdir("iputdir") < 0){
-    printf(stdout, "mkdir failed\n");
-    exit();
-  }
-  if(chdir("iputdir") < 0){
-    printf(stdout, "chdir iputdir failed\n");
-    exit();
-  }
-  if(unlink("../iputdir") < 0){
-    printf(stdout, "unlink ../iputdir failed\n");
-    exit();
-  }
-  if(chdir("/") < 0){
-    printf(stdout, "chdir / failed\n");
-    exit();
-  }
-  printf(stdout, "iput test ok\n");
-}
-
-// does exit() call iput(p->cwd) in a transaction?
-void
-exitiputtest(void)
-{
-  int pid;
-
-  printf(stdout, "exitiput test\n");
-
-  pid = fork();
-  if(pid < 0){
-    printf(stdout, "fork failed\n");
-    exit();
-  }
-  if(pid == 0){
-    if(mkdir("iputdir") < 0){
-      printf(stdout, "mkdir failed\n");
-      exit();
-    }
-    if(chdir("iputdir") < 0){
-      printf(stdout, "child chdir failed\n");
-      exit();
-    }
-    if(unlink("../iputdir") < 0){
-      printf(stdout, "unlink ../iputdir failed\n");
-      exit();
-    }
-    exit();
-  }
-  wait();
-  printf(stdout, "exitiput test ok\n");
-}
-
-// does the error path in open() for attempt to write a
-// directory call iput() in a transaction?
-// needs a hacked kernel that pauses just after the namei()
-// call in sys_open():
-//    if((ip = namei(path)) == 0)
-//      return -1;
-//    {
-//      int i;
-//      for(i = 0; i < 10000; i++)
-//        yield();
-//    }
-void
-openiputtest(void)
-{
-  int pid;
-
-  printf(stdout, "openiput test\n");
-  if(mkdir("oidir") < 0){
-    printf(stdout, "mkdir oidir failed\n");
-    exit();
-  }
-  pid = fork();
-  if(pid < 0){
-    printf(stdout, "fork failed\n");
-    exit();
-  }
-  if(pid == 0){
-    int fd = open("oidir", O_RDWR);
-    if(fd >= 0){
-      printf(stdout, "open directory for write succeeded\n");
-      exit();
-    }
-    exit();
-  }
-  sleep(1);
-  if(unlink("oidir") != 0){
-    printf(stdout, "unlink failed\n");
-    exit();
-  }
-  wait();
-  printf(stdout, "openiput test ok\n");
-}
-
-// simple file system tests
-
-void
-opentest(void)
-{
-  int fd;
-
-  printf(stdout, "open test\n");
-  fd = open("echo", 0);
-  if(fd < 0){
-    printf(stdout, "open echo failed!\n");
-    exit();
-  }
-  close(fd);
-  fd = open("doesnotexist", 0);
-  if(fd >= 0){
-    printf(stdout, "open doesnotexist succeeded!\n");
-    exit();
-  }
-  printf(stdout, "open test ok\n");
-}
-
-void
-writetest(void)
-{
-  int fd;
-  int i;
-
-  printf(stdout, "small file test\n");
-  fd = open("small", O_CREATE|O_RDWR);
-  if(fd >= 0){
-    printf(stdout, "creat small succeeded; ok\n");
-  } else {
-    printf(stdout, "error: creat small failed!\n");
-    exit();
-  }
-  for(i = 0; i < 100; i++){
-    if(write(fd, "aaaaaaaaaa", 10) != 10){
-      printf(stdout, "error: write aa %d new file failed\n", i);
-      exit();
-    }
-    if(write(fd, "bbbbbbbbbb", 10) != 10){
-      printf(stdout, "error: write bb %d new file failed\n", i);
-      exit();
-    }
-  }
-  printf(stdout, "writes ok\n");
-  close(fd);
-  fd = open("small", O_RDONLY);
-  if(fd >= 0){
-    printf(stdout, "open small succeeded ok\n");
-  } else {
-    printf(stdout, "error: open small failed!\n");
-    exit();
-  }
-  i = read(fd, buf, 2000);
-  if(i == 2000){
-    printf(stdout, "read succeeded ok\n");
-  } else {
-    printf(stdout, "read failed\n");
-    exit();
-  }
-  close(fd);
-
-  if(unlink("small") < 0){
-    printf(stdout, "unlink small failed\n");
-    exit();
-  }
-  printf(stdout, "small file test ok\n");
-}
-
-void
-writetest1(void)
-{
-  int i, fd, n;
-
-  printf(stdout, "big files test\n");
-
-  fd = open("big", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf(stdout, "error: creat big failed!\n");
-    exit();
-  }
-
-  for(i = 0; i < MAXFILE; i++){
-    ((int*)buf)[0] = i;
-    if(write(fd, buf, 512) != 512){
-      printf(stdout, "error: write big file failed\n", i);
-      exit();
-    }
-  }
-
-  close(fd);
-
-  fd = open("big", O_RDONLY);
-  if(fd < 0){
-    printf(stdout, "error: open big failed!\n");
-    exit();
-  }
-
-  n = 0;
-  for(;;){
-    i = read(fd, buf, 512);
-    if(i == 0){
-      if(n == MAXFILE - 1){
-        printf(stdout, "read only %d blocks from big", n);
-        exit();
-      }
-      break;
-    } else if(i != 512){
-      printf(stdout, "read failed %d\n", i);
-      exit();
-    }
-    if(((int*)buf)[0] != n){
-      printf(stdout, "read content of block %d is %d\n",
-             n, ((int*)buf)[0]);
-      exit();
-    }
-    n++;
-  }
-  close(fd);
-  if(unlink("big") < 0){
-    printf(stdout, "unlink big failed\n");
-    exit();
-  }
-  printf(stdout, "big files ok\n");
-}
-
-void
-createtest(void)
-{
-  int i, fd;
-
-  printf(stdout, "many creates, followed by unlink test\n");
-
-  name[0] = 'a';
-  name[2] = '\0';
-  for(i = 0; i < 52; i++){
-    name[1] = '0' + i;
-    fd = open(name, O_CREATE|O_RDWR);
-    close(fd);
-  }
-  name[0] = 'a';
-  name[2] = '\0';
-  for(i = 0; i < 52; i++){
-    name[1] = '0' + i;
-    unlink(name);
-  }
-  printf(stdout, "many creates, followed by unlink; ok\n");
-}
-
-void dirtest(void)
-{
-  printf(stdout, "mkdir test\n");
-
-  if(mkdir("dir0") < 0){
-    printf(stdout, "mkdir failed\n");
-    exit();
-  }
-
-  if(chdir("dir0") < 0){
-    printf(stdout, "chdir dir0 failed\n");
-    exit();
-  }
-
-  if(chdir("..") < 0){
-    printf(stdout, "chdir .. failed\n");
-    exit();
-  }
-
-  if(unlink("dir0") < 0){
-    printf(stdout, "unlink dir0 failed\n");
-    exit();
-  }
-  printf(stdout, "mkdir test ok\n");
-}
-
-void
-exectest(void)
-{
-  printf(stdout, "exec test\n");
-  if(exec("echo", echoargv) < 0){
-    printf(stdout, "exec echo failed\n");
-    exit();
-  }
-}
-
-// simple fork and pipe read/write
-
-void
-pipe1(void)
-{
-  int fds[2], pid;
-  int seq, i, n, cc, total;
-
-  if(pipe(fds) != 0){
-    printf(1, "pipe() failed\n");
-    exit();
-  }
-  pid = fork();
-  seq = 0;
-  if(pid == 0){
-    close(fds[0]);
-    for(n = 0; n < 5; n++){
-      for(i = 0; i < 1033; i++)
-        buf[i] = seq++;
-      if(write(fds[1], buf, 1033) != 1033){
-        printf(1, "pipe1 oops 1\n");
-        exit();
-      }
-    }
-    exit();
-  } else if(pid > 0){
-    close(fds[1]);
-    total = 0;
-    cc = 1;
-    while((n = read(fds[0], buf, cc)) > 0){
-      for(i = 0; i < n; i++){
-        if((buf[i] & 0xff) != (seq++ & 0xff)){
-          printf(1, "pipe1 oops 2\n");
-          return;
-        }
-      }
-      total += n;
-      cc = cc * 2;
-      if(cc > sizeof(buf))
-        cc = sizeof(buf);
-    }
-    if(total != 5 * 1033){
-      printf(1, "pipe1 oops 3 total %d\n", total);
-      exit();
-    }
-    close(fds[0]);
-    wait();
-  } else {
-    printf(1, "fork() failed\n");
-    exit();
-  }
-  printf(1, "pipe1 ok\n");
-}
-
-// meant to be run w/ at most two CPUs
-void
-preempt(void)
-{
-  int pid1, pid2, pid3;
-  int pfds[2];
-
-  printf(1, "preempt: ");
-  pid1 = fork();
-  if(pid1 == 0)
-    for(;;)
-      ;
-
-  pid2 = fork();
-  if(pid2 == 0)
-    for(;;)
-      ;
-
-  pipe(pfds);
-  pid3 = fork();
-  if(pid3 == 0){
-    close(pfds[0]);
-    if(write(pfds[1], "x", 1) != 1)
-      printf(1, "preempt write error");
-    close(pfds[1]);
-    for(;;)
-      ;
-  }
-
-  close(pfds[1]);
-  if(read(pfds[0], buf, sizeof(buf)) != 1){
-    printf(1, "preempt read error");
-    return;
-  }
-  close(pfds[0]);
-  printf(1, "kill... ");
-  kill(pid1);
-  kill(pid2);
-  kill(pid3);
-  printf(1, "wait... ");
-  wait();
-  wait();
-  wait();
-  printf(1, "preempt ok\n");
-}
-
-// try to find any races between exit and wait
-void
-exitwait(void)
-{
-  int i, pid;
-
-  for(i = 0; i < 100; i++){
-    pid = fork();
-    if(pid < 0){
-      printf(1, "fork failed\n");
-      return;
-    }
-    if(pid){
-      if(wait() != pid){
-        printf(1, "wait wrong pid\n");
-        return;
-      }
-    } else {
-      exit();
-    }
-  }
-  printf(1, "exitwait ok\n");
-}
-
-void
-mem(void)
-{
-  void *m1, *m2;
-  int pid, ppid;
-
-  printf(1, "mem test\n");
-  ppid = getpid();
-  if((pid = fork()) == 0){
-    m1 = 0;
-    while((m2 = malloc(10001)) != 0){
-      *(char**)m2 = m1;
-      m1 = m2;
-    }
-    while(m1){
-      m2 = *(char**)m1;
-      free(m1);
-      m1 = m2;
-    }
-    m1 = malloc(1024*20);
-    if(m1 == 0){
-      printf(1, "couldn't allocate mem?!!\n");
-      kill(ppid);
-      exit();
-    }
-    free(m1);
-    printf(1, "mem ok\n");
-    exit();
-  } else {
-    wait();
-  }
-}
-
-// More file system tests
-
-// two processes write to the same file descriptor
-// is the offset shared? does inode locking work?
-void
-sharedfd(void)
-{
-  int fd, pid, i, n, nc, np;
-  char buf[10];
-
-  printf(1, "sharedfd test\n");
-
-  unlink("sharedfd");
-  fd = open("sharedfd", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf(1, "fstests: cannot open sharedfd for writing");
-    return;
-  }
-  pid = fork();
-  memset(buf, pid==0?'c':'p', sizeof(buf));
-  for(i = 0; i < 1000; i++){
-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
-      printf(1, "fstests: write sharedfd failed\n");
-      break;
-    }
-  }
-  if(pid == 0)
-    exit();
-  else
-    wait();
-  close(fd);
-  fd = open("sharedfd", 0);
-  if(fd < 0){
-    printf(1, "fstests: cannot open sharedfd for reading\n");
-    return;
-  }
-  nc = np = 0;
-  while((n = read(fd, buf, sizeof(buf))) > 0){
-    for(i = 0; i < sizeof(buf); i++){
-      if(buf[i] == 'c')
-        nc++;
-      if(buf[i] == 'p')
-        np++;
-    }
-  }
-  close(fd);
-  unlink("sharedfd");
-  if(nc == 10000 && np == 10000){
-    printf(1, "sharedfd ok\n");
-  } else {
-    printf(1, "sharedfd oops %d %d\n", nc, np);
-    exit();
-  }
-}
-
-// four processes write different files at the same
-// time, to test block allocation.
-void
-fourfiles(void)
-{
-  int fd, pid, i, j, n, total, pi;
-  char *names[] = { "f0", "f1", "f2", "f3" };
-  char *fname;
-
-  printf(1, "fourfiles test\n");
-
-  for(pi = 0; pi < 4; pi++){
-    fname = names[pi];
-    unlink(fname);
-
-    pid = fork();
-    if(pid < 0){
-      printf(1, "fork failed\n");
-      exit();
-    }
-
-    if(pid == 0){
-      fd = open(fname, O_CREATE | O_RDWR);
-      if(fd < 0){
-        printf(1, "create failed\n");
-        exit();
-      }
-
-      memset(buf, '0'+pi, 512);
-      for(i = 0; i < 12; i++){
-        if((n = write(fd, buf, 500)) != 500){
-          printf(1, "write failed %d\n", n);
-          exit();
-        }
-      }
-      exit();
-    }
-  }
-
-  for(pi = 0; pi < 4; pi++){
-    wait();
-  }
-
-  for(i = 0; i < 2; i++){
-    fname = names[i];
-    fd = open(fname, 0);
-    total = 0;
-    while((n = read(fd, buf, sizeof(buf))) > 0){
-      for(j = 0; j < n; j++){
-        if(buf[j] != '0'+i){
-          printf(1, "wrong char\n");
-          exit();
-        }
-      }
-      total += n;
-    }
-    close(fd);
-    if(total != 12*500){
-      printf(1, "wrong length %d\n", total);
-      exit();
-    }
-    unlink(fname);
-  }
-
-  printf(1, "fourfiles ok\n");
-}
-
-// four processes create and delete different files in same directory
-void
-createdelete(void)
-{
-  enum { N = 20 };
-  int pid, i, fd, pi;
-  char name[32];
-
-  printf(1, "createdelete test\n");
-
-  for(pi = 0; pi < 4; pi++){
-    pid = fork();
-    if(pid < 0){
-      printf(1, "fork failed\n");
-      exit();
-    }
-
-    if(pid == 0){
-      name[0] = 'p' + pi;
-      name[2] = '\0';
-      for(i = 0; i < N; i++){
-        name[1] = '0' + i;
-        fd = open(name, O_CREATE | O_RDWR);
-        if(fd < 0){
-          printf(1, "create failed\n");
-          exit();
-        }
-        close(fd);
-        if(i > 0 && (i % 2 ) == 0){
-          name[1] = '0' + (i / 2);
-          if(unlink(name) < 0){
-            printf(1, "unlink failed\n");
-            exit();
-          }
-        }
-      }
-      exit();
-    }
-  }
-
-  for(pi = 0; pi < 4; pi++){
-    wait();
-  }
-
-  name[0] = name[1] = name[2] = 0;
-  for(i = 0; i < N; i++){
-    for(pi = 0; pi < 4; pi++){
-      name[0] = 'p' + pi;
-      name[1] = '0' + i;
-      fd = open(name, 0);
-      if((i == 0 || i >= N/2) && fd < 0){
-        printf(1, "oops createdelete %s didn't exist\n", name);
-        exit();
-      } else if((i >= 1 && i < N/2) && fd >= 0){
-        printf(1, "oops createdelete %s did exist\n", name);
-        exit();
-      }
-      if(fd >= 0)
-        close(fd);
-    }
-  }
-
-  for(i = 0; i < N; i++){
-    for(pi = 0; pi < 4; pi++){
-      name[0] = 'p' + i;
-      name[1] = '0' + i;
-      unlink(name);
-    }
-  }
-
-  printf(1, "createdelete ok\n");
-}
-
-// can I unlink a file and still read it?
-void
-unlinkread(void)
-{
-  int fd, fd1;
-
-  printf(1, "unlinkread test\n");
-  fd = open("unlinkread", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf(1, "create unlinkread failed\n");
-    exit();
-  }
-  write(fd, "hello", 5);
-  close(fd);
-
-  fd = open("unlinkread", O_RDWR);
-  if(fd < 0){
-    printf(1, "open unlinkread failed\n");
-    exit();
-  }
-  if(unlink("unlinkread") != 0){
-    printf(1, "unlink unlinkread failed\n");
-    exit();
-  }
-
-  fd1 = open("unlinkread", O_CREATE | O_RDWR);
-  write(fd1, "yyy", 3);
-  close(fd1);
-
-  if(read(fd, buf, sizeof(buf)) != 5){
-    printf(1, "unlinkread read failed");
-    exit();
-  }
-  if(buf[0] != 'h'){
-    printf(1, "unlinkread wrong data\n");
-    exit();
-  }
-  if(write(fd, buf, 10) != 10){
-    printf(1, "unlinkread write failed\n");
-    exit();
-  }
-  close(fd);
-  unlink("unlinkread");
-  printf(1, "unlinkread ok\n");
-}
-
-void
-linktest(void)
-{
-  int fd;
-
-  printf(1, "linktest\n");
-
-  unlink("lf1");
-  unlink("lf2");
-
-  fd = open("lf1", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf(1, "create lf1 failed\n");
-    exit();
-  }
-  if(write(fd, "hello", 5) != 5){
-    printf(1, "write lf1 failed\n");
-    exit();
-  }
-  close(fd);
-
-  if(link("lf1", "lf2") < 0){
-    printf(1, "link lf1 lf2 failed\n");
-    exit();
-  }
-  unlink("lf1");
-
-  if(open("lf1", 0) >= 0){
-    printf(1, "unlinked lf1 but it is still there!\n");
-    exit();
-  }
-
-  fd = open("lf2", 0);
-  if(fd < 0){
-    printf(1, "open lf2 failed\n");
-    exit();
-  }
-  if(read(fd, buf, sizeof(buf)) != 5){
-    printf(1, "read lf2 failed\n");
-    exit();
-  }
-  close(fd);
-
-  if(link("lf2", "lf2") >= 0){
-    printf(1, "link lf2 lf2 succeeded! oops\n");
-    exit();
-  }
-
-  unlink("lf2");
-  if(link("lf2", "lf1") >= 0){
-    printf(1, "link non-existant succeeded! oops\n");
-    exit();
-  }
-
-  if(link(".", "lf1") >= 0){
-    printf(1, "link . lf1 succeeded! oops\n");
-    exit();
-  }
-
-  printf(1, "linktest ok\n");
-}
-
-// test concurrent create/link/unlink of the same file
-void
-concreate(void)
-{
-  char file[3];
-  int i, pid, n, fd;
-  char fa[40];
-  struct {
-    ushort inum;
-    char name[14];
-  } de;
-
-  printf(1, "concreate test\n");
-  file[0] = 'C';
-  file[2] = '\0';
-  for(i = 0; i < 40; i++){
-    file[1] = '0' + i;
-    unlink(file);
-    pid = fork();
-    if(pid && (i % 3) == 1){
-      link("C0", file);
-    } else if(pid == 0 && (i % 5) == 1){
-      link("C0", file);
-    } else {
-      fd = open(file, O_CREATE | O_RDWR);
-      if(fd < 0){
-        printf(1, "concreate create %s failed\n", file);
-        exit();
-      }
-      close(fd);
-    }
-    if(pid == 0)
-      exit();
-    else
-      wait();
-  }
-
-  memset(fa, 0, sizeof(fa));
-  fd = open(".", 0);
-  n = 0;
-  while(read(fd, &de, sizeof(de)) > 0){
-    if(de.inum == 0)
-      continue;
-    if(de.name[0] == 'C' && de.name[2] == '\0'){
-      i = de.name[1] - '0';
-      if(i < 0 || i >= sizeof(fa)){
-        printf(1, "concreate weird file %s\n", de.name);
-        exit();
-      }
-      if(fa[i]){
-        printf(1, "concreate duplicate file %s\n", de.name);
-        exit();
-      }
-      fa[i] = 1;
-      n++;
-    }
-  }
-  close(fd);
-
-  if(n != 40){
-    printf(1, "concreate not enough files in directory listing\n");
-    exit();
-  }
-
-  for(i = 0; i < 40; i++){
-    file[1] = '0' + i;
-    pid = fork();
-    if(pid < 0){
-      printf(1, "fork failed\n");
-      exit();
-    }
-    if(((i % 3) == 0 && pid == 0) ||
-       ((i % 3) == 1 && pid != 0)){
-      close(open(file, 0));
-      close(open(file, 0));
-      close(open(file, 0));
-      close(open(file, 0));
-    } else {
-      unlink(file);
-      unlink(file);
-      unlink(file);
-      unlink(file);
-    }
-    if(pid == 0)
-      exit();
-    else
-      wait();
-  }
-
-  printf(1, "concreate ok\n");
-}
-
-// another concurrent link/unlink/create test,
-// to look for deadlocks.
-void
-linkunlink()
-{
-  int pid, i;
-
-  printf(1, "linkunlink test\n");
-
-  unlink("x");
-  pid = fork();
-  if(pid < 0){
-    printf(1, "fork failed\n");
-    exit();
-  }
-
-  unsigned int x = (pid ? 1 : 97);
-  for(i = 0; i < 100; i++){
-    x = x * 1103515245 + 12345;
-    if((x % 3) == 0){
-      close(open("x", O_RDWR | O_CREATE));
-    } else if((x % 3) == 1){
-      link("cat", "x");
-    } else {
-      unlink("x");
-    }
-  }
-
-  if(pid)
-    wait();
-  else
-    exit();
-
-  printf(1, "linkunlink ok\n");
-}
-
-// directory that uses indirect blocks
-void
-bigdir(void)
-{
-  int i, fd;
-  char name[10];
-
-  printf(1, "bigdir test\n");
-  unlink("bd");
-
-  fd = open("bd", O_CREATE);
-  if(fd < 0){
-    printf(1, "bigdir create failed\n");
-    exit();
-  }
-  close(fd);
-
-  for(i = 0; i < 500; i++){
-    name[0] = 'x';
-    name[1] = '0' + (i / 64);
-    name[2] = '0' + (i % 64);
-    name[3] = '\0';
-    if(link("bd", name) != 0){
-      printf(1, "bigdir link failed\n");
-      exit();
-    }
-  }
-
-  unlink("bd");
-  for(i = 0; i < 500; i++){
-    name[0] = 'x';
-    name[1] = '0' + (i / 64);
-    name[2] = '0' + (i % 64);
-    name[3] = '\0';
-    if(unlink(name) != 0){
-      printf(1, "bigdir unlink failed");
-      exit();
-    }
-  }
-
-  printf(1, "bigdir ok\n");
-}
-
-void
-subdir(void)
-{
-  int fd, cc;
-
-  printf(1, "subdir test\n");
-
-  unlink("ff");
-  if(mkdir("dd") != 0){
-    printf(1, "subdir mkdir dd failed\n");
-    exit();
-  }
-
-  fd = open("dd/ff", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf(1, "create dd/ff failed\n");
-    exit();
-  }
-  write(fd, "ff", 2);
-  close(fd);
-
-  if(unlink("dd") >= 0){
-    printf(1, "unlink dd (non-empty dir) succeeded!\n");
-    exit();
-  }
-
-  if(mkdir("/dd/dd") != 0){
-    printf(1, "subdir mkdir dd/dd failed\n");
-    exit();
-  }
-
-  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf(1, "create dd/dd/ff failed\n");
-    exit();
-  }
-  write(fd, "FF", 2);
-  close(fd);
-
-  fd = open("dd/dd/../ff", 0);
-  if(fd < 0){
-    printf(1, "open dd/dd/../ff failed\n");
-    exit();
-  }
-  cc = read(fd, buf, sizeof(buf));
-  if(cc != 2 || buf[0] != 'f'){
-    printf(1, "dd/dd/../ff wrong content\n");
-    exit();
-  }
-  close(fd);
-
-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
-    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
-    exit();
-  }
-
-  if(unlink("dd/dd/ff") != 0){
-    printf(1, "unlink dd/dd/ff failed\n");
-    exit();
-  }
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
-    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
-    exit();
-  }
-
-  if(chdir("dd") != 0){
-    printf(1, "chdir dd failed\n");
-    exit();
-  }
-  if(chdir("dd/../../dd") != 0){
-    printf(1, "chdir dd/../../dd failed\n");
-    exit();
-  }
-  if(chdir("dd/../../../dd") != 0){
-    printf(1, "chdir dd/../../dd failed\n");
-    exit();
-  }
-  if(chdir("./..") != 0){
-    printf(1, "chdir ./.. failed\n");
-    exit();
-  }
-
-  fd = open("dd/dd/ffff", 0);
-  if(fd < 0){
-    printf(1, "open dd/dd/ffff failed\n");
-    exit();
-  }
-  if(read(fd, buf, sizeof(buf)) != 2){
-    printf(1, "read dd/dd/ffff wrong len\n");
-    exit();
-  }
-  close(fd);
-
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
-    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
-    exit();
-  }
-
-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
-    printf(1, "create dd/ff/ff succeeded!\n");
-    exit();
-  }
-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
-    printf(1, "create dd/xx/ff succeeded!\n");
-    exit();
-  }
-  if(open("dd", O_CREATE) >= 0){
-    printf(1, "create dd succeeded!\n");
-    exit();
-  }
-  if(open("dd", O_RDWR) >= 0){
-    printf(1, "open dd rdwr succeeded!\n");
-    exit();
-  }
-  if(open("dd", O_WRONLY) >= 0){
-    printf(1, "open dd wronly succeeded!\n");
-    exit();
-  }
-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
-    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
-    exit();
-  }
-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
-    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
-    exit();
-  }
-  if(link("dd/ff", "dd/dd/ffff") == 0){
-    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
-    exit();
-  }
-  if(mkdir("dd/ff/ff") == 0){
-    printf(1, "mkdir dd/ff/ff succeeded!\n");
-    exit();
-  }
-  if(mkdir("dd/xx/ff") == 0){
-    printf(1, "mkdir dd/xx/ff succeeded!\n");
-    exit();
-  }
-  if(mkdir("dd/dd/ffff") == 0){
-    printf(1, "mkdir dd/dd/ffff succeeded!\n");
-    exit();
-  }
-  if(unlink("dd/xx/ff") == 0){
-    printf(1, "unlink dd/xx/ff succeeded!\n");
-    exit();
-  }
-  if(unlink("dd/ff/ff") == 0){
-    printf(1, "unlink dd/ff/ff succeeded!\n");
-    exit();
-  }
-  if(chdir("dd/ff") == 0){
-    printf(1, "chdir dd/ff succeeded!\n");
-    exit();
-  }
-  if(chdir("dd/xx") == 0){
-    printf(1, "chdir dd/xx succeeded!\n");
-    exit();
-  }
-
-  if(unlink("dd/dd/ffff") != 0){
-    printf(1, "unlink dd/dd/ff failed\n");
-    exit();
-  }
-  if(unlink("dd/ff") != 0){
-    printf(1, "unlink dd/ff failed\n");
-    exit();
-  }
-  if(unlink("dd") == 0){
-    printf(1, "unlink non-empty dd succeeded!\n");
-    exit();
-  }
-  if(unlink("dd/dd") < 0){
-    printf(1, "unlink dd/dd failed\n");
-    exit();
-  }
-  if(unlink("dd") < 0){
-    printf(1, "unlink dd failed\n");
-    exit();
-  }
-
-  printf(1, "subdir ok\n");
-}
-
-// test writes that are larger than the log.
-void
-bigwrite(void)
-{
-  int fd, sz;
-
-  printf(1, "bigwrite test\n");
-
-  unlink("bigwrite");
-  for(sz = 499; sz < 12*512; sz += 471){
-    fd = open("bigwrite", O_CREATE | O_RDWR);
-    if(fd < 0){
-      printf(1, "cannot create bigwrite\n");
-      exit();
-    }
-    int i;
-    for(i = 0; i < 2; i++){
-      int cc = write(fd, buf, sz);
-      if(cc != sz){
-        printf(1, "write(%d) ret %d\n", sz, cc);
-        exit();
-      }
-    }
-    close(fd);
-    unlink("bigwrite");
-  }
-
-  printf(1, "bigwrite ok\n");
-}
-
-void
-bigfile(void)
-{
-  int fd, i, total, cc;
-
-  printf(1, "bigfile test\n");
-
-  unlink("bigfile");
-  fd = open("bigfile", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf(1, "cannot create bigfile");
-    exit();
-  }
-  for(i = 0; i < 20; i++){
-    memset(buf, i, 600);
-    if(write(fd, buf, 600) != 600){
-      printf(1, "write bigfile failed\n");
-      exit();
-    }
-  }
-  close(fd);
-
-  fd = open("bigfile", 0);
-  if(fd < 0){
-    printf(1, "cannot open bigfile\n");
-    exit();
-  }
-  total = 0;
-  for(i = 0; ; i++){
-    cc = read(fd, buf, 300);
-    if(cc < 0){
-      printf(1, "read bigfile failed\n");
-      exit();
-    }
-    if(cc == 0)
-      break;
-    if(cc != 300){
-      printf(1, "short read bigfile\n");
-      exit();
-    }
-    if(buf[0] != i/2 || buf[299] != i/2){
-      printf(1, "read bigfile wrong data\n");
-      exit();
-    }
-    total += cc;
-  }
-  close(fd);
-  if(total != 20*600){
-    printf(1, "read bigfile wrong total\n");
-    exit();
-  }
-  unlink("bigfile");
-
-  printf(1, "bigfile test ok\n");
-}
-
-void
-fourteen(void)
-{
-  int fd;
-
-  // DIRSIZ is 14.
-  printf(1, "fourteen test\n");
-
-  if(mkdir("12345678901234") != 0){
-    printf(1, "mkdir 12345678901234 failed\n");
-    exit();
-  }
-  if(mkdir("12345678901234/123456789012345") != 0){
-    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
-    exit();
-  }
-  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
-  if(fd < 0){
-    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
-    exit();
-  }
-  close(fd);
-  fd = open("12345678901234/12345678901234/12345678901234", 0);
-  if(fd < 0){
-    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
-    exit();
-  }
-  close(fd);
-
-  if(mkdir("12345678901234/12345678901234") == 0){
-    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
-    exit();
-  }
-  if(mkdir("123456789012345/12345678901234") == 0){
-    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
-    exit();
-  }
-
-  printf(1, "fourteen ok\n");
-}
-
-void
-rmdot(void)
-{
-  printf(1, "rmdot test\n");
-  if(mkdir("dots") != 0){
-    printf(1, "mkdir dots failed\n");
-    exit();
-  }
-  if(chdir("dots") != 0){
-    printf(1, "chdir dots failed\n");
-    exit();
-  }
-  if(unlink(".") == 0){
-    printf(1, "rm . worked!\n");
-    exit();
-  }
-  if(unlink("..") == 0){
-    printf(1, "rm .. worked!\n");
-    exit();
-  }
-  if(chdir("/") != 0){
-    printf(1, "chdir / failed\n");
-    exit();
-  }
-  if(unlink("dots/.") == 0){
-    printf(1, "unlink dots/. worked!\n");
-    exit();
-  }
-  if(unlink("dots/..") == 0){
-    printf(1, "unlink dots/.. worked!\n");
-    exit();
-  }
-  if(unlink("dots") != 0){
-    printf(1, "unlink dots failed!\n");
-    exit();
-  }
-  printf(1, "rmdot ok\n");
-}
-
-void
-dirfile(void)
-{
-  int fd;
-
-  printf(1, "dir vs file\n");
-
-  fd = open("dirfile", O_CREATE);
-  if(fd < 0){
-    printf(1, "create dirfile failed\n");
-    exit();
-  }
-  close(fd);
-  if(chdir("dirfile") == 0){
-    printf(1, "chdir dirfile succeeded!\n");
-    exit();
-  }
-  fd = open("dirfile/xx", 0);
-  if(fd >= 0){
-    printf(1, "create dirfile/xx succeeded!\n");
-    exit();
-  }
-  fd = open("dirfile/xx", O_CREATE);
-  if(fd >= 0){
-    printf(1, "create dirfile/xx succeeded!\n");
-    exit();
-  }
-  if(mkdir("dirfile/xx") == 0){
-    printf(1, "mkdir dirfile/xx succeeded!\n");
-    exit();
-  }
-  if(unlink("dirfile/xx") == 0){
-    printf(1, "unlink dirfile/xx succeeded!\n");
-    exit();
-  }
-  if(link("README", "dirfile/xx") == 0){
-    printf(1, "link to dirfile/xx succeeded!\n");
-    exit();
-  }
-  if(unlink("dirfile") != 0){
-    printf(1, "unlink dirfile failed!\n");
-    exit();
-  }
-
-  fd = open(".", O_RDWR);
-  if(fd >= 0){
-    printf(1, "open . for writing succeeded!\n");
-    exit();
-  }
-  fd = open(".", 0);
-  if(write(fd, "x", 1) > 0){
-    printf(1, "write . succeeded!\n");
-    exit();
-  }
-  close(fd);
-
-  printf(1, "dir vs file OK\n");
-}
-
-// test that iput() is called at the end of _namei()
-void
-iref(void)
-{
-  int i, fd;
-
-  printf(1, "empty file name\n");
-
-  // the 50 is NINODE
-  for(i = 0; i < 50 + 1; i++){
-    if(mkdir("irefd") != 0){
-      printf(1, "mkdir irefd failed\n");
-      exit();
-    }
-    if(chdir("irefd") != 0){
-      printf(1, "chdir irefd failed\n");
-      exit();
-    }
-
-    mkdir("");
-    link("README", "");
-    fd = open("", O_CREATE);
-    if(fd >= 0)
-      close(fd);
-    fd = open("xx", O_CREATE);
-    if(fd >= 0)
-      close(fd);
-    unlink("xx");
-  }
-
-  chdir("/");
-  printf(1, "empty file name OK\n");
-}
-
-// test that fork fails gracefully
-// the forktest binary also does this, but it runs out of proc entries first.
-// inside the bigger usertests binary, we run out of memory first.
-void
-forktest(void)
-{
-  int n, pid;
-
-  printf(1, "fork test\n");
-
-  for(n=0; n<1000; n++){
-    pid = fork();
-    if(pid < 0)
-      break;
-    if(pid == 0)
-      exit();
-  }
-
-  if(n == 1000){
-    printf(1, "fork claimed to work 1000 times!\n");
-    exit();
-  }
-
-  for(; n > 0; n--){
-    if(wait() < 0){
-      printf(1, "wait stopped early\n");
-      exit();
-    }
-  }
-
-  if(wait() != -1){
-    printf(1, "wait got too many\n");
-    exit();
-  }
-
-  printf(1, "fork test OK\n");
-}
-
-void
-sbrktest(void)
-{
-  int fds[2], pid, pids[10], ppid;
-  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
-  uint amt;
-
-  printf(stdout, "sbrk test\n");
-  oldbrk = sbrk(0);
-
-  // can one sbrk() less than a page?
-  a = sbrk(0);
-  int i;
-  for(i = 0; i < 5000; i++){
-    b = sbrk(1);
-    if(b != a){
-      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
-      exit();
-    }
-    *b = 1;
-    a = b + 1;
-  }
-  pid = fork();
-  if(pid < 0){
-    printf(stdout, "sbrk test fork failed\n");
-    exit();
-  }
-  c = sbrk(1);
-  c = sbrk(1);
-  if(c != a + 1){
-    printf(stdout, "sbrk test failed post-fork\n");
-    exit();
-  }
-  if(pid == 0)
-    exit();
-  wait();
-
-  // can one grow address space to something big?
-#define BIG (100*1024*1024)
-  a = sbrk(0);
-  amt = (BIG) - (uint)a;
-  p = sbrk(amt);
-  if (p != a) {
-    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
-    exit();
-  }
-  lastaddr = (char*) (BIG-1);
-  *lastaddr = 99;
-
-  // can one de-allocate?
-  a = sbrk(0);
-  c = sbrk(-4096);
-  if(c == (char*)0xffffffff){
-    printf(stdout, "sbrk could not deallocate\n");
-    exit();
-  }
-  c = sbrk(0);
-  if(c != a - 4096){
-    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
-    exit();
-  }
-
-  // can one re-allocate that page?
-  a = sbrk(0);
-  c = sbrk(4096);
-  if(c != a || sbrk(0) != a + 4096){
-    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
-    exit();
-  }
-  if(*lastaddr == 99){
-    // should be zero
-    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
-    exit();
-  }
-
-  a = sbrk(0);
-  c = sbrk(-(sbrk(0) - oldbrk));
-  if(c != a){
-    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
-    exit();
-  }
-
-  // can we read the kernel's memory?
-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
-    ppid = getpid();
-    pid = fork();
-    if(pid < 0){
-      printf(stdout, "fork failed\n");
-      exit();
-    }
-    if(pid == 0){
-      printf(stdout, "oops could read %x = %x\n", a, *a);
-      kill(ppid);
-      exit();
-    }
-    wait();
-  }
-
-  // if we run the system out of memory, does it clean up the last
-  // failed allocation?
-  if(pipe(fds) != 0){
-    printf(1, "pipe() failed\n");
-    exit();
-  }
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    if((pids[i] = fork()) == 0){
-      // allocate a lot of memory
-      sbrk(BIG - (uint)sbrk(0));
-      write(fds[1], "x", 1);
-      // sit around until killed
-      for(;;) sleep(1000);
-    }
-    if(pids[i] != -1)
-      read(fds[0], &scratch, 1);
-  }
-  // if those failed allocations freed up the pages they did allocate,
-  // we'll be able to allocate here
-  c = sbrk(4096);
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    if(pids[i] == -1)
-      continue;
-    kill(pids[i]);
-    wait();
-  }
-  if(c == (char*)0xffffffff){
-    printf(stdout, "failed sbrk leaked memory\n");
-    exit();
-  }
-
-  if(sbrk(0) > oldbrk)
-    sbrk(-(sbrk(0) - oldbrk));
-
-  printf(stdout, "sbrk test OK\n");
-}
-
-void
-validateint(int *p)
-{
-  int res;
-  asm("mov %%esp, %%ebx\n\t"
-      "mov %3, %%esp\n\t"
-      "int %2\n\t"
-      "mov %%ebx, %%esp" :
-      "=a" (res) :
-      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
-      "ebx");
-}
-
-void
-validatetest(void)
-{
-  int hi, pid;
-  uint p;
-
-  printf(stdout, "validate test\n");
-  hi = 1100*1024;
-
-  for(p = 0; p <= (uint)hi; p += 4096){
-    if((pid = fork()) == 0){
-      // try to crash the kernel by passing in a badly placed integer
-      validateint((int*)p);
-      exit();
-    }
-    sleep(0);
-    sleep(0);
-    kill(pid);
-    wait();
-
-    // try to crash the kernel by passing in a bad string pointer
-    if(link("nosuchfile", (char*)p) != -1){
-      printf(stdout, "link should not succeed\n");
-      exit();
-    }
-  }
-
-  printf(stdout, "validate ok\n");
-}
-
-// does unintialized data start out zero?
-char uninit[10000];
-void
-bsstest(void)
-{
-  int i;
-
-  printf(stdout, "bss test\n");
-  for(i = 0; i < sizeof(uninit); i++){
-    if(uninit[i] != '\0'){
-      printf(stdout, "bss test failed\n");
-      exit();
-    }
-  }
-  printf(stdout, "bss test ok\n");
-}
-
-// does exec return an error if the arguments
-// are larger than a page? or does it write
-// below the stack and wreck the instructions/data?
-void
-bigargtest(void)
-{
-  int pid, fd;
-
-  unlink("bigarg-ok");
-  pid = fork();
-  if(pid == 0){
-    static char *args[MAXARG];
-    int i;
-    for(i = 0; i < MAXARG-1; i++)
-      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
-    args[MAXARG-1] = 0;
-    printf(stdout, "bigarg test\n");
-    exec("echo", args);
-    printf(stdout, "bigarg test ok\n");
-    fd = open("bigarg-ok", O_CREATE);
-    close(fd);
-    exit();
-  } else if(pid < 0){
-    printf(stdout, "bigargtest: fork failed\n");
-    exit();
-  }
-  wait();
-  fd = open("bigarg-ok", 0);
-  if(fd < 0){
-    printf(stdout, "bigarg test failed!\n");
-    exit();
-  }
-  close(fd);
-  unlink("bigarg-ok");
-}
-
-// what happens when the file system runs out of blocks?
-// answer: balloc panics, so this test is not useful.
-void
-fsfull()
-{
-  int nfiles;
-  int fsblocks = 0;
-
-  printf(1, "fsfull test\n");
-
-  for(nfiles = 0; ; nfiles++){
-    char name[64];
-    name[0] = 'f';
-    name[1] = '0' + nfiles / 1000;
-    name[2] = '0' + (nfiles % 1000) / 100;
-    name[3] = '0' + (nfiles % 100) / 10;
-    name[4] = '0' + (nfiles % 10);
-    name[5] = '\0';
-    printf(1, "writing %s\n", name);
-    int fd = open(name, O_CREATE|O_RDWR);
-    if(fd < 0){
-      printf(1, "open %s failed\n", name);
-      break;
-    }
-    int total = 0;
-    while(1){
-      int cc = write(fd, buf, 512);
-      if(cc < 512)
-        break;
-      total += cc;
-      fsblocks++;
-    }
-    printf(1, "wrote %d bytes\n", total);
-    close(fd);
-    if(total == 0)
-      break;
-  }
-
-  while(nfiles >= 0){
-    char name[64];
-    name[0] = 'f';
-    name[1] = '0' + nfiles / 1000;
-    name[2] = '0' + (nfiles % 1000) / 100;
-    name[3] = '0' + (nfiles % 100) / 10;
-    name[4] = '0' + (nfiles % 10);
-    name[5] = '\0';
-    unlink(name);
-    nfiles--;
-  }
-
-  printf(1, "fsfull test finished\n");
-}
-
-void
-uio()
-{
-  #define RTC_ADDR 0x70
-  #define RTC_DATA 0x71
-
-  ushort port = 0;
-  uchar val = 0;
-  int pid;
-
-  printf(1, "uio test\n");
-  pid = fork();
-  if(pid == 0){
-    port = RTC_ADDR;
-    val = 0x09;  /* year */
-    /* http://wiki.osdev.org/Inline_Assembly/Examples */
-    asm volatile("outb %0,%1"::"a"(val), "d" (port));
-    port = RTC_DATA;
-    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
-    printf(1, "uio: uio succeeded; test FAILED\n");
-    exit();
-  } else if(pid < 0){
-    printf (1, "fork failed\n");
-    exit();
-  }
-  wait();
-  printf(1, "uio test done\n");
-}
-
-void argptest()
-{
-  int fd;
-  fd = open("init", O_RDONLY);
-  if (fd < 0) {
-    printf(2, "open failed\n");
-    exit();
-  }
-  read(fd, sbrk(0) - 1, -1);
-  close(fd);
-  printf(1, "arg test passed\n");
-}
-
-unsigned long randstate = 1;
-unsigned int
-rand()
-{
-  randstate = randstate * 1664525 + 1013904223;
-  return randstate;
-}
-
-int
-main(int argc, char *argv[])
-{
-  printf(1, "usertests starting\n");
-
-  if(open("usertests.ran", 0) >= 0){
-    printf(1, "already ran user tests -- rebuild fs.img\n");
-    exit();
-  }
-  close(open("usertests.ran", O_CREATE));
-
-  argptest();
-  createdelete();
-  linkunlink();
-  concreate();
-  fourfiles();
-  sharedfd();
-
-  bigargtest();
-  bigwrite();
-  bigargtest();
-  bsstest();
-  sbrktest();
-  validatetest();
-
-  opentest();
-  writetest();
-  writetest1();
-  createtest();
-
-  openiputtest();
-  exitiputtest();
-  iputtest();
-
-  mem();
-  pipe1();
-  preempt();
-  exitwait();
-
-  rmdot();
-  fourteen();
-  bigfile();
-  subdir();
-  linktest();
-  unlinkread();
-  dirfile();
-  iref();
-  forktest();
-  bigdir(); // slow
-
-  uio();
-
-  exectest();
-
-  exit();
-}
diff --git a/xv6-public/Operating-System-Project/usertests.d b/xv6-public/Operating-System-Project/usertests.d
deleted file mode 100644
index a4933d3..0000000
--- a/xv6-public/Operating-System-Project/usertests.d
+++ /dev/null
@@ -1,2 +0,0 @@
-usertests.o: usertests.c /usr/include/stdc-predef.h param.h types.h \
- stat.h user.h fs.h fcntl.h syscall.h traps.h memlayout.h
diff --git a/xv6-public/Operating-System-Project/usertests.o b/xv6-public/Operating-System-Project/usertests.o
deleted file mode 100644
index 7b9eb9d..0000000
Binary files a/xv6-public/Operating-System-Project/usertests.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/usertests.sym b/xv6-public/Operating-System-Project/usertests.sym
deleted file mode 100644
index 8e1785a..0000000
--- a/xv6-public/Operating-System-Project/usertests.sym
+++ /dev/null
@@ -1,115 +0,0 @@
-00000000 .text
-00003ea8 .rodata
-0000565c .eh_frame
-00005f3c .data
-00005f60 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 usertests.c
-00005f60 args.1473
-00000000 ulib.c
-00000000 printf.c
-00003a90 printint
-00005648 digits.1109
-00000000 umalloc.c
-00005fe0 freep
-00005fe4 base
-00003720 strcpy
-00000d60 exitwait
-00003a2b getChildren
-00003b40 printf
-00005f40 stdout
-00003330 bigargtest
-00003950 memmove
-00000310 openiputtest
-000039cb mknod
-00003840 gets
-00003a03 getpid
-00003a63 customWait
-00000a60 pipe1
-00002c00 iref
-00003a5b getCBT
-00003da0 malloc
-00003a13 sleep
-00000210 exitiputtest
-00003430 fsfull
-00001c60 bigdir
-00002d20 forktest
-00000690 writetest1
-00002490 bigwrite
-00000eb0 sharedfd
-00005f3c randstate
-00003993 pipe
-00003a43 changePolicy
-00006000 uninit
-00002a00 dirfile
-000039a3 write
-000032c0 bsstest
-00005f44 echoargv
-000039db fstat
-000039b3 kill
-00003200 validatetest
-00002880 rmdot
-000039f3 chdir
-00003a6b setQueue
-00000a10 exectest
-000039bb exec
-0000398b wait
-00003700 rand
-0000399b read
-00000c00 preempt
-00003a73 getBurstTime
-000039d3 unlink
-00003690 argptest
-00000de0 mem
-0000397b fork
-00003a4b getTurnAroundTime
-00003a0b sbrk
-00003a1b uptime
-00005f58 __bss_start
-000037e0 memset
-00000860 createtest
-00000000 main
-00001270 createdelete
-00003750 strcmp
-000004b0 writetest
-000039fb dup
-00003a33 getSyscallCounter
-00002dd0 sbrktest
-00000410 opentest
-00001da0 subdir
-00003610 uio
-00001630 linktest
-00008720 buf
-00000920 dirtest
-00003a23 getParentID
-00000120 iputtest
-000038c0 stat
-00002570 bigfile
-00005f58 _edata
-0000a724 _end
-000014a0 unlinkread
-000039e3 link
-00003983 exit
-00003a3b setPriority
-00003910 atoi
-00001b50 linkunlink
-00003a7b getCreationTime
-0000a720 name
-000037a0 strlen
-000039c3 open
-00003800 strchr
-00001850 concreate
-00002740 fourteen
-000031f0 validateint
-00001070 fourfiles
-000039eb mkdir
-000039ab close
-00003a53 getWaitingTime
-00003d10 free
diff --git a/xv6-public/Operating-System-Project/usys.S b/xv6-public/Operating-System-Project/usys.S
deleted file mode 100644
index d0ef08e..0000000
--- a/xv6-public/Operating-System-Project/usys.S
+++ /dev/null
@@ -1,43 +0,0 @@
-#include "syscall.h"
-#include "traps.h"
-
-#define SYSCALL(name) \
-  .globl name; \
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
-SYSCALL(exit)
-SYSCALL(wait)
-SYSCALL(pipe)
-SYSCALL(read)
-SYSCALL(write)
-SYSCALL(close)
-SYSCALL(kill)
-SYSCALL(exec)
-SYSCALL(open)
-SYSCALL(mknod)
-SYSCALL(unlink)
-SYSCALL(fstat)
-SYSCALL(link)
-SYSCALL(mkdir)
-SYSCALL(chdir)
-SYSCALL(dup)
-SYSCALL(getpid)
-SYSCALL(sbrk)
-SYSCALL(sleep)
-SYSCALL(uptime)
-SYSCALL(getParentID)
-SYSCALL(getChildren)
-SYSCALL(getSyscallCounter)
-SYSCALL(setPriority)
-SYSCALL(changePolicy)
-SYSCALL(getTurnAroundTime)
-SYSCALL(getWaitingTime)
-SYSCALL(getCBT)
-SYSCALL(customWait)
-SYSCALL(setQueue)
-SYSCALL(getBurstTime)
-SYSCALL(getCreationTime)
\ No newline at end of file
diff --git a/xv6-public/Operating-System-Project/usys.o b/xv6-public/Operating-System-Project/usys.o
deleted file mode 100644
index f22d169..0000000
Binary files a/xv6-public/Operating-System-Project/usys.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/vectors.S b/xv6-public/Operating-System-Project/vectors.S
deleted file mode 100644
index 9e4041a..0000000
--- a/xv6-public/Operating-System-Project/vectors.S
+++ /dev/null
@@ -1,1537 +0,0 @@
-# generated by vectors.pl - do not edit
-# handlers
-.globl alltraps
-.globl vector0
-vector0:
-  pushl $0
-  pushl $0
-  jmp alltraps
-.globl vector1
-vector1:
-  pushl $0
-  pushl $1
-  jmp alltraps
-.globl vector2
-vector2:
-  pushl $0
-  pushl $2
-  jmp alltraps
-.globl vector3
-vector3:
-  pushl $0
-  pushl $3
-  jmp alltraps
-.globl vector4
-vector4:
-  pushl $0
-  pushl $4
-  jmp alltraps
-.globl vector5
-vector5:
-  pushl $0
-  pushl $5
-  jmp alltraps
-.globl vector6
-vector6:
-  pushl $0
-  pushl $6
-  jmp alltraps
-.globl vector7
-vector7:
-  pushl $0
-  pushl $7
-  jmp alltraps
-.globl vector8
-vector8:
-  pushl $8
-  jmp alltraps
-.globl vector9
-vector9:
-  pushl $0
-  pushl $9
-  jmp alltraps
-.globl vector10
-vector10:
-  pushl $10
-  jmp alltraps
-.globl vector11
-vector11:
-  pushl $11
-  jmp alltraps
-.globl vector12
-vector12:
-  pushl $12
-  jmp alltraps
-.globl vector13
-vector13:
-  pushl $13
-  jmp alltraps
-.globl vector14
-vector14:
-  pushl $14
-  jmp alltraps
-.globl vector15
-vector15:
-  pushl $0
-  pushl $15
-  jmp alltraps
-.globl vector16
-vector16:
-  pushl $0
-  pushl $16
-  jmp alltraps
-.globl vector17
-vector17:
-  pushl $17
-  jmp alltraps
-.globl vector18
-vector18:
-  pushl $0
-  pushl $18
-  jmp alltraps
-.globl vector19
-vector19:
-  pushl $0
-  pushl $19
-  jmp alltraps
-.globl vector20
-vector20:
-  pushl $0
-  pushl $20
-  jmp alltraps
-.globl vector21
-vector21:
-  pushl $0
-  pushl $21
-  jmp alltraps
-.globl vector22
-vector22:
-  pushl $0
-  pushl $22
-  jmp alltraps
-.globl vector23
-vector23:
-  pushl $0
-  pushl $23
-  jmp alltraps
-.globl vector24
-vector24:
-  pushl $0
-  pushl $24
-  jmp alltraps
-.globl vector25
-vector25:
-  pushl $0
-  pushl $25
-  jmp alltraps
-.globl vector26
-vector26:
-  pushl $0
-  pushl $26
-  jmp alltraps
-.globl vector27
-vector27:
-  pushl $0
-  pushl $27
-  jmp alltraps
-.globl vector28
-vector28:
-  pushl $0
-  pushl $28
-  jmp alltraps
-.globl vector29
-vector29:
-  pushl $0
-  pushl $29
-  jmp alltraps
-.globl vector30
-vector30:
-  pushl $0
-  pushl $30
-  jmp alltraps
-.globl vector31
-vector31:
-  pushl $0
-  pushl $31
-  jmp alltraps
-.globl vector32
-vector32:
-  pushl $0
-  pushl $32
-  jmp alltraps
-.globl vector33
-vector33:
-  pushl $0
-  pushl $33
-  jmp alltraps
-.globl vector34
-vector34:
-  pushl $0
-  pushl $34
-  jmp alltraps
-.globl vector35
-vector35:
-  pushl $0
-  pushl $35
-  jmp alltraps
-.globl vector36
-vector36:
-  pushl $0
-  pushl $36
-  jmp alltraps
-.globl vector37
-vector37:
-  pushl $0
-  pushl $37
-  jmp alltraps
-.globl vector38
-vector38:
-  pushl $0
-  pushl $38
-  jmp alltraps
-.globl vector39
-vector39:
-  pushl $0
-  pushl $39
-  jmp alltraps
-.globl vector40
-vector40:
-  pushl $0
-  pushl $40
-  jmp alltraps
-.globl vector41
-vector41:
-  pushl $0
-  pushl $41
-  jmp alltraps
-.globl vector42
-vector42:
-  pushl $0
-  pushl $42
-  jmp alltraps
-.globl vector43
-vector43:
-  pushl $0
-  pushl $43
-  jmp alltraps
-.globl vector44
-vector44:
-  pushl $0
-  pushl $44
-  jmp alltraps
-.globl vector45
-vector45:
-  pushl $0
-  pushl $45
-  jmp alltraps
-.globl vector46
-vector46:
-  pushl $0
-  pushl $46
-  jmp alltraps
-.globl vector47
-vector47:
-  pushl $0
-  pushl $47
-  jmp alltraps
-.globl vector48
-vector48:
-  pushl $0
-  pushl $48
-  jmp alltraps
-.globl vector49
-vector49:
-  pushl $0
-  pushl $49
-  jmp alltraps
-.globl vector50
-vector50:
-  pushl $0
-  pushl $50
-  jmp alltraps
-.globl vector51
-vector51:
-  pushl $0
-  pushl $51
-  jmp alltraps
-.globl vector52
-vector52:
-  pushl $0
-  pushl $52
-  jmp alltraps
-.globl vector53
-vector53:
-  pushl $0
-  pushl $53
-  jmp alltraps
-.globl vector54
-vector54:
-  pushl $0
-  pushl $54
-  jmp alltraps
-.globl vector55
-vector55:
-  pushl $0
-  pushl $55
-  jmp alltraps
-.globl vector56
-vector56:
-  pushl $0
-  pushl $56
-  jmp alltraps
-.globl vector57
-vector57:
-  pushl $0
-  pushl $57
-  jmp alltraps
-.globl vector58
-vector58:
-  pushl $0
-  pushl $58
-  jmp alltraps
-.globl vector59
-vector59:
-  pushl $0
-  pushl $59
-  jmp alltraps
-.globl vector60
-vector60:
-  pushl $0
-  pushl $60
-  jmp alltraps
-.globl vector61
-vector61:
-  pushl $0
-  pushl $61
-  jmp alltraps
-.globl vector62
-vector62:
-  pushl $0
-  pushl $62
-  jmp alltraps
-.globl vector63
-vector63:
-  pushl $0
-  pushl $63
-  jmp alltraps
-.globl vector64
-vector64:
-  pushl $0
-  pushl $64
-  jmp alltraps
-.globl vector65
-vector65:
-  pushl $0
-  pushl $65
-  jmp alltraps
-.globl vector66
-vector66:
-  pushl $0
-  pushl $66
-  jmp alltraps
-.globl vector67
-vector67:
-  pushl $0
-  pushl $67
-  jmp alltraps
-.globl vector68
-vector68:
-  pushl $0
-  pushl $68
-  jmp alltraps
-.globl vector69
-vector69:
-  pushl $0
-  pushl $69
-  jmp alltraps
-.globl vector70
-vector70:
-  pushl $0
-  pushl $70
-  jmp alltraps
-.globl vector71
-vector71:
-  pushl $0
-  pushl $71
-  jmp alltraps
-.globl vector72
-vector72:
-  pushl $0
-  pushl $72
-  jmp alltraps
-.globl vector73
-vector73:
-  pushl $0
-  pushl $73
-  jmp alltraps
-.globl vector74
-vector74:
-  pushl $0
-  pushl $74
-  jmp alltraps
-.globl vector75
-vector75:
-  pushl $0
-  pushl $75
-  jmp alltraps
-.globl vector76
-vector76:
-  pushl $0
-  pushl $76
-  jmp alltraps
-.globl vector77
-vector77:
-  pushl $0
-  pushl $77
-  jmp alltraps
-.globl vector78
-vector78:
-  pushl $0
-  pushl $78
-  jmp alltraps
-.globl vector79
-vector79:
-  pushl $0
-  pushl $79
-  jmp alltraps
-.globl vector80
-vector80:
-  pushl $0
-  pushl $80
-  jmp alltraps
-.globl vector81
-vector81:
-  pushl $0
-  pushl $81
-  jmp alltraps
-.globl vector82
-vector82:
-  pushl $0
-  pushl $82
-  jmp alltraps
-.globl vector83
-vector83:
-  pushl $0
-  pushl $83
-  jmp alltraps
-.globl vector84
-vector84:
-  pushl $0
-  pushl $84
-  jmp alltraps
-.globl vector85
-vector85:
-  pushl $0
-  pushl $85
-  jmp alltraps
-.globl vector86
-vector86:
-  pushl $0
-  pushl $86
-  jmp alltraps
-.globl vector87
-vector87:
-  pushl $0
-  pushl $87
-  jmp alltraps
-.globl vector88
-vector88:
-  pushl $0
-  pushl $88
-  jmp alltraps
-.globl vector89
-vector89:
-  pushl $0
-  pushl $89
-  jmp alltraps
-.globl vector90
-vector90:
-  pushl $0
-  pushl $90
-  jmp alltraps
-.globl vector91
-vector91:
-  pushl $0
-  pushl $91
-  jmp alltraps
-.globl vector92
-vector92:
-  pushl $0
-  pushl $92
-  jmp alltraps
-.globl vector93
-vector93:
-  pushl $0
-  pushl $93
-  jmp alltraps
-.globl vector94
-vector94:
-  pushl $0
-  pushl $94
-  jmp alltraps
-.globl vector95
-vector95:
-  pushl $0
-  pushl $95
-  jmp alltraps
-.globl vector96
-vector96:
-  pushl $0
-  pushl $96
-  jmp alltraps
-.globl vector97
-vector97:
-  pushl $0
-  pushl $97
-  jmp alltraps
-.globl vector98
-vector98:
-  pushl $0
-  pushl $98
-  jmp alltraps
-.globl vector99
-vector99:
-  pushl $0
-  pushl $99
-  jmp alltraps
-.globl vector100
-vector100:
-  pushl $0
-  pushl $100
-  jmp alltraps
-.globl vector101
-vector101:
-  pushl $0
-  pushl $101
-  jmp alltraps
-.globl vector102
-vector102:
-  pushl $0
-  pushl $102
-  jmp alltraps
-.globl vector103
-vector103:
-  pushl $0
-  pushl $103
-  jmp alltraps
-.globl vector104
-vector104:
-  pushl $0
-  pushl $104
-  jmp alltraps
-.globl vector105
-vector105:
-  pushl $0
-  pushl $105
-  jmp alltraps
-.globl vector106
-vector106:
-  pushl $0
-  pushl $106
-  jmp alltraps
-.globl vector107
-vector107:
-  pushl $0
-  pushl $107
-  jmp alltraps
-.globl vector108
-vector108:
-  pushl $0
-  pushl $108
-  jmp alltraps
-.globl vector109
-vector109:
-  pushl $0
-  pushl $109
-  jmp alltraps
-.globl vector110
-vector110:
-  pushl $0
-  pushl $110
-  jmp alltraps
-.globl vector111
-vector111:
-  pushl $0
-  pushl $111
-  jmp alltraps
-.globl vector112
-vector112:
-  pushl $0
-  pushl $112
-  jmp alltraps
-.globl vector113
-vector113:
-  pushl $0
-  pushl $113
-  jmp alltraps
-.globl vector114
-vector114:
-  pushl $0
-  pushl $114
-  jmp alltraps
-.globl vector115
-vector115:
-  pushl $0
-  pushl $115
-  jmp alltraps
-.globl vector116
-vector116:
-  pushl $0
-  pushl $116
-  jmp alltraps
-.globl vector117
-vector117:
-  pushl $0
-  pushl $117
-  jmp alltraps
-.globl vector118
-vector118:
-  pushl $0
-  pushl $118
-  jmp alltraps
-.globl vector119
-vector119:
-  pushl $0
-  pushl $119
-  jmp alltraps
-.globl vector120
-vector120:
-  pushl $0
-  pushl $120
-  jmp alltraps
-.globl vector121
-vector121:
-  pushl $0
-  pushl $121
-  jmp alltraps
-.globl vector122
-vector122:
-  pushl $0
-  pushl $122
-  jmp alltraps
-.globl vector123
-vector123:
-  pushl $0
-  pushl $123
-  jmp alltraps
-.globl vector124
-vector124:
-  pushl $0
-  pushl $124
-  jmp alltraps
-.globl vector125
-vector125:
-  pushl $0
-  pushl $125
-  jmp alltraps
-.globl vector126
-vector126:
-  pushl $0
-  pushl $126
-  jmp alltraps
-.globl vector127
-vector127:
-  pushl $0
-  pushl $127
-  jmp alltraps
-.globl vector128
-vector128:
-  pushl $0
-  pushl $128
-  jmp alltraps
-.globl vector129
-vector129:
-  pushl $0
-  pushl $129
-  jmp alltraps
-.globl vector130
-vector130:
-  pushl $0
-  pushl $130
-  jmp alltraps
-.globl vector131
-vector131:
-  pushl $0
-  pushl $131
-  jmp alltraps
-.globl vector132
-vector132:
-  pushl $0
-  pushl $132
-  jmp alltraps
-.globl vector133
-vector133:
-  pushl $0
-  pushl $133
-  jmp alltraps
-.globl vector134
-vector134:
-  pushl $0
-  pushl $134
-  jmp alltraps
-.globl vector135
-vector135:
-  pushl $0
-  pushl $135
-  jmp alltraps
-.globl vector136
-vector136:
-  pushl $0
-  pushl $136
-  jmp alltraps
-.globl vector137
-vector137:
-  pushl $0
-  pushl $137
-  jmp alltraps
-.globl vector138
-vector138:
-  pushl $0
-  pushl $138
-  jmp alltraps
-.globl vector139
-vector139:
-  pushl $0
-  pushl $139
-  jmp alltraps
-.globl vector140
-vector140:
-  pushl $0
-  pushl $140
-  jmp alltraps
-.globl vector141
-vector141:
-  pushl $0
-  pushl $141
-  jmp alltraps
-.globl vector142
-vector142:
-  pushl $0
-  pushl $142
-  jmp alltraps
-.globl vector143
-vector143:
-  pushl $0
-  pushl $143
-  jmp alltraps
-.globl vector144
-vector144:
-  pushl $0
-  pushl $144
-  jmp alltraps
-.globl vector145
-vector145:
-  pushl $0
-  pushl $145
-  jmp alltraps
-.globl vector146
-vector146:
-  pushl $0
-  pushl $146
-  jmp alltraps
-.globl vector147
-vector147:
-  pushl $0
-  pushl $147
-  jmp alltraps
-.globl vector148
-vector148:
-  pushl $0
-  pushl $148
-  jmp alltraps
-.globl vector149
-vector149:
-  pushl $0
-  pushl $149
-  jmp alltraps
-.globl vector150
-vector150:
-  pushl $0
-  pushl $150
-  jmp alltraps
-.globl vector151
-vector151:
-  pushl $0
-  pushl $151
-  jmp alltraps
-.globl vector152
-vector152:
-  pushl $0
-  pushl $152
-  jmp alltraps
-.globl vector153
-vector153:
-  pushl $0
-  pushl $153
-  jmp alltraps
-.globl vector154
-vector154:
-  pushl $0
-  pushl $154
-  jmp alltraps
-.globl vector155
-vector155:
-  pushl $0
-  pushl $155
-  jmp alltraps
-.globl vector156
-vector156:
-  pushl $0
-  pushl $156
-  jmp alltraps
-.globl vector157
-vector157:
-  pushl $0
-  pushl $157
-  jmp alltraps
-.globl vector158
-vector158:
-  pushl $0
-  pushl $158
-  jmp alltraps
-.globl vector159
-vector159:
-  pushl $0
-  pushl $159
-  jmp alltraps
-.globl vector160
-vector160:
-  pushl $0
-  pushl $160
-  jmp alltraps
-.globl vector161
-vector161:
-  pushl $0
-  pushl $161
-  jmp alltraps
-.globl vector162
-vector162:
-  pushl $0
-  pushl $162
-  jmp alltraps
-.globl vector163
-vector163:
-  pushl $0
-  pushl $163
-  jmp alltraps
-.globl vector164
-vector164:
-  pushl $0
-  pushl $164
-  jmp alltraps
-.globl vector165
-vector165:
-  pushl $0
-  pushl $165
-  jmp alltraps
-.globl vector166
-vector166:
-  pushl $0
-  pushl $166
-  jmp alltraps
-.globl vector167
-vector167:
-  pushl $0
-  pushl $167
-  jmp alltraps
-.globl vector168
-vector168:
-  pushl $0
-  pushl $168
-  jmp alltraps
-.globl vector169
-vector169:
-  pushl $0
-  pushl $169
-  jmp alltraps
-.globl vector170
-vector170:
-  pushl $0
-  pushl $170
-  jmp alltraps
-.globl vector171
-vector171:
-  pushl $0
-  pushl $171
-  jmp alltraps
-.globl vector172
-vector172:
-  pushl $0
-  pushl $172
-  jmp alltraps
-.globl vector173
-vector173:
-  pushl $0
-  pushl $173
-  jmp alltraps
-.globl vector174
-vector174:
-  pushl $0
-  pushl $174
-  jmp alltraps
-.globl vector175
-vector175:
-  pushl $0
-  pushl $175
-  jmp alltraps
-.globl vector176
-vector176:
-  pushl $0
-  pushl $176
-  jmp alltraps
-.globl vector177
-vector177:
-  pushl $0
-  pushl $177
-  jmp alltraps
-.globl vector178
-vector178:
-  pushl $0
-  pushl $178
-  jmp alltraps
-.globl vector179
-vector179:
-  pushl $0
-  pushl $179
-  jmp alltraps
-.globl vector180
-vector180:
-  pushl $0
-  pushl $180
-  jmp alltraps
-.globl vector181
-vector181:
-  pushl $0
-  pushl $181
-  jmp alltraps
-.globl vector182
-vector182:
-  pushl $0
-  pushl $182
-  jmp alltraps
-.globl vector183
-vector183:
-  pushl $0
-  pushl $183
-  jmp alltraps
-.globl vector184
-vector184:
-  pushl $0
-  pushl $184
-  jmp alltraps
-.globl vector185
-vector185:
-  pushl $0
-  pushl $185
-  jmp alltraps
-.globl vector186
-vector186:
-  pushl $0
-  pushl $186
-  jmp alltraps
-.globl vector187
-vector187:
-  pushl $0
-  pushl $187
-  jmp alltraps
-.globl vector188
-vector188:
-  pushl $0
-  pushl $188
-  jmp alltraps
-.globl vector189
-vector189:
-  pushl $0
-  pushl $189
-  jmp alltraps
-.globl vector190
-vector190:
-  pushl $0
-  pushl $190
-  jmp alltraps
-.globl vector191
-vector191:
-  pushl $0
-  pushl $191
-  jmp alltraps
-.globl vector192
-vector192:
-  pushl $0
-  pushl $192
-  jmp alltraps
-.globl vector193
-vector193:
-  pushl $0
-  pushl $193
-  jmp alltraps
-.globl vector194
-vector194:
-  pushl $0
-  pushl $194
-  jmp alltraps
-.globl vector195
-vector195:
-  pushl $0
-  pushl $195
-  jmp alltraps
-.globl vector196
-vector196:
-  pushl $0
-  pushl $196
-  jmp alltraps
-.globl vector197
-vector197:
-  pushl $0
-  pushl $197
-  jmp alltraps
-.globl vector198
-vector198:
-  pushl $0
-  pushl $198
-  jmp alltraps
-.globl vector199
-vector199:
-  pushl $0
-  pushl $199
-  jmp alltraps
-.globl vector200
-vector200:
-  pushl $0
-  pushl $200
-  jmp alltraps
-.globl vector201
-vector201:
-  pushl $0
-  pushl $201
-  jmp alltraps
-.globl vector202
-vector202:
-  pushl $0
-  pushl $202
-  jmp alltraps
-.globl vector203
-vector203:
-  pushl $0
-  pushl $203
-  jmp alltraps
-.globl vector204
-vector204:
-  pushl $0
-  pushl $204
-  jmp alltraps
-.globl vector205
-vector205:
-  pushl $0
-  pushl $205
-  jmp alltraps
-.globl vector206
-vector206:
-  pushl $0
-  pushl $206
-  jmp alltraps
-.globl vector207
-vector207:
-  pushl $0
-  pushl $207
-  jmp alltraps
-.globl vector208
-vector208:
-  pushl $0
-  pushl $208
-  jmp alltraps
-.globl vector209
-vector209:
-  pushl $0
-  pushl $209
-  jmp alltraps
-.globl vector210
-vector210:
-  pushl $0
-  pushl $210
-  jmp alltraps
-.globl vector211
-vector211:
-  pushl $0
-  pushl $211
-  jmp alltraps
-.globl vector212
-vector212:
-  pushl $0
-  pushl $212
-  jmp alltraps
-.globl vector213
-vector213:
-  pushl $0
-  pushl $213
-  jmp alltraps
-.globl vector214
-vector214:
-  pushl $0
-  pushl $214
-  jmp alltraps
-.globl vector215
-vector215:
-  pushl $0
-  pushl $215
-  jmp alltraps
-.globl vector216
-vector216:
-  pushl $0
-  pushl $216
-  jmp alltraps
-.globl vector217
-vector217:
-  pushl $0
-  pushl $217
-  jmp alltraps
-.globl vector218
-vector218:
-  pushl $0
-  pushl $218
-  jmp alltraps
-.globl vector219
-vector219:
-  pushl $0
-  pushl $219
-  jmp alltraps
-.globl vector220
-vector220:
-  pushl $0
-  pushl $220
-  jmp alltraps
-.globl vector221
-vector221:
-  pushl $0
-  pushl $221
-  jmp alltraps
-.globl vector222
-vector222:
-  pushl $0
-  pushl $222
-  jmp alltraps
-.globl vector223
-vector223:
-  pushl $0
-  pushl $223
-  jmp alltraps
-.globl vector224
-vector224:
-  pushl $0
-  pushl $224
-  jmp alltraps
-.globl vector225
-vector225:
-  pushl $0
-  pushl $225
-  jmp alltraps
-.globl vector226
-vector226:
-  pushl $0
-  pushl $226
-  jmp alltraps
-.globl vector227
-vector227:
-  pushl $0
-  pushl $227
-  jmp alltraps
-.globl vector228
-vector228:
-  pushl $0
-  pushl $228
-  jmp alltraps
-.globl vector229
-vector229:
-  pushl $0
-  pushl $229
-  jmp alltraps
-.globl vector230
-vector230:
-  pushl $0
-  pushl $230
-  jmp alltraps
-.globl vector231
-vector231:
-  pushl $0
-  pushl $231
-  jmp alltraps
-.globl vector232
-vector232:
-  pushl $0
-  pushl $232
-  jmp alltraps
-.globl vector233
-vector233:
-  pushl $0
-  pushl $233
-  jmp alltraps
-.globl vector234
-vector234:
-  pushl $0
-  pushl $234
-  jmp alltraps
-.globl vector235
-vector235:
-  pushl $0
-  pushl $235
-  jmp alltraps
-.globl vector236
-vector236:
-  pushl $0
-  pushl $236
-  jmp alltraps
-.globl vector237
-vector237:
-  pushl $0
-  pushl $237
-  jmp alltraps
-.globl vector238
-vector238:
-  pushl $0
-  pushl $238
-  jmp alltraps
-.globl vector239
-vector239:
-  pushl $0
-  pushl $239
-  jmp alltraps
-.globl vector240
-vector240:
-  pushl $0
-  pushl $240
-  jmp alltraps
-.globl vector241
-vector241:
-  pushl $0
-  pushl $241
-  jmp alltraps
-.globl vector242
-vector242:
-  pushl $0
-  pushl $242
-  jmp alltraps
-.globl vector243
-vector243:
-  pushl $0
-  pushl $243
-  jmp alltraps
-.globl vector244
-vector244:
-  pushl $0
-  pushl $244
-  jmp alltraps
-.globl vector245
-vector245:
-  pushl $0
-  pushl $245
-  jmp alltraps
-.globl vector246
-vector246:
-  pushl $0
-  pushl $246
-  jmp alltraps
-.globl vector247
-vector247:
-  pushl $0
-  pushl $247
-  jmp alltraps
-.globl vector248
-vector248:
-  pushl $0
-  pushl $248
-  jmp alltraps
-.globl vector249
-vector249:
-  pushl $0
-  pushl $249
-  jmp alltraps
-.globl vector250
-vector250:
-  pushl $0
-  pushl $250
-  jmp alltraps
-.globl vector251
-vector251:
-  pushl $0
-  pushl $251
-  jmp alltraps
-.globl vector252
-vector252:
-  pushl $0
-  pushl $252
-  jmp alltraps
-.globl vector253
-vector253:
-  pushl $0
-  pushl $253
-  jmp alltraps
-.globl vector254
-vector254:
-  pushl $0
-  pushl $254
-  jmp alltraps
-.globl vector255
-vector255:
-  pushl $0
-  pushl $255
-  jmp alltraps
-
-# vector table
-.data
-.globl vectors
-vectors:
-  .long vector0
-  .long vector1
-  .long vector2
-  .long vector3
-  .long vector4
-  .long vector5
-  .long vector6
-  .long vector7
-  .long vector8
-  .long vector9
-  .long vector10
-  .long vector11
-  .long vector12
-  .long vector13
-  .long vector14
-  .long vector15
-  .long vector16
-  .long vector17
-  .long vector18
-  .long vector19
-  .long vector20
-  .long vector21
-  .long vector22
-  .long vector23
-  .long vector24
-  .long vector25
-  .long vector26
-  .long vector27
-  .long vector28
-  .long vector29
-  .long vector30
-  .long vector31
-  .long vector32
-  .long vector33
-  .long vector34
-  .long vector35
-  .long vector36
-  .long vector37
-  .long vector38
-  .long vector39
-  .long vector40
-  .long vector41
-  .long vector42
-  .long vector43
-  .long vector44
-  .long vector45
-  .long vector46
-  .long vector47
-  .long vector48
-  .long vector49
-  .long vector50
-  .long vector51
-  .long vector52
-  .long vector53
-  .long vector54
-  .long vector55
-  .long vector56
-  .long vector57
-  .long vector58
-  .long vector59
-  .long vector60
-  .long vector61
-  .long vector62
-  .long vector63
-  .long vector64
-  .long vector65
-  .long vector66
-  .long vector67
-  .long vector68
-  .long vector69
-  .long vector70
-  .long vector71
-  .long vector72
-  .long vector73
-  .long vector74
-  .long vector75
-  .long vector76
-  .long vector77
-  .long vector78
-  .long vector79
-  .long vector80
-  .long vector81
-  .long vector82
-  .long vector83
-  .long vector84
-  .long vector85
-  .long vector86
-  .long vector87
-  .long vector88
-  .long vector89
-  .long vector90
-  .long vector91
-  .long vector92
-  .long vector93
-  .long vector94
-  .long vector95
-  .long vector96
-  .long vector97
-  .long vector98
-  .long vector99
-  .long vector100
-  .long vector101
-  .long vector102
-  .long vector103
-  .long vector104
-  .long vector105
-  .long vector106
-  .long vector107
-  .long vector108
-  .long vector109
-  .long vector110
-  .long vector111
-  .long vector112
-  .long vector113
-  .long vector114
-  .long vector115
-  .long vector116
-  .long vector117
-  .long vector118
-  .long vector119
-  .long vector120
-  .long vector121
-  .long vector122
-  .long vector123
-  .long vector124
-  .long vector125
-  .long vector126
-  .long vector127
-  .long vector128
-  .long vector129
-  .long vector130
-  .long vector131
-  .long vector132
-  .long vector133
-  .long vector134
-  .long vector135
-  .long vector136
-  .long vector137
-  .long vector138
-  .long vector139
-  .long vector140
-  .long vector141
-  .long vector142
-  .long vector143
-  .long vector144
-  .long vector145
-  .long vector146
-  .long vector147
-  .long vector148
-  .long vector149
-  .long vector150
-  .long vector151
-  .long vector152
-  .long vector153
-  .long vector154
-  .long vector155
-  .long vector156
-  .long vector157
-  .long vector158
-  .long vector159
-  .long vector160
-  .long vector161
-  .long vector162
-  .long vector163
-  .long vector164
-  .long vector165
-  .long vector166
-  .long vector167
-  .long vector168
-  .long vector169
-  .long vector170
-  .long vector171
-  .long vector172
-  .long vector173
-  .long vector174
-  .long vector175
-  .long vector176
-  .long vector177
-  .long vector178
-  .long vector179
-  .long vector180
-  .long vector181
-  .long vector182
-  .long vector183
-  .long vector184
-  .long vector185
-  .long vector186
-  .long vector187
-  .long vector188
-  .long vector189
-  .long vector190
-  .long vector191
-  .long vector192
-  .long vector193
-  .long vector194
-  .long vector195
-  .long vector196
-  .long vector197
-  .long vector198
-  .long vector199
-  .long vector200
-  .long vector201
-  .long vector202
-  .long vector203
-  .long vector204
-  .long vector205
-  .long vector206
-  .long vector207
-  .long vector208
-  .long vector209
-  .long vector210
-  .long vector211
-  .long vector212
-  .long vector213
-  .long vector214
-  .long vector215
-  .long vector216
-  .long vector217
-  .long vector218
-  .long vector219
-  .long vector220
-  .long vector221
-  .long vector222
-  .long vector223
-  .long vector224
-  .long vector225
-  .long vector226
-  .long vector227
-  .long vector228
-  .long vector229
-  .long vector230
-  .long vector231
-  .long vector232
-  .long vector233
-  .long vector234
-  .long vector235
-  .long vector236
-  .long vector237
-  .long vector238
-  .long vector239
-  .long vector240
-  .long vector241
-  .long vector242
-  .long vector243
-  .long vector244
-  .long vector245
-  .long vector246
-  .long vector247
-  .long vector248
-  .long vector249
-  .long vector250
-  .long vector251
-  .long vector252
-  .long vector253
-  .long vector254
-  .long vector255
diff --git a/xv6-public/Operating-System-Project/vectors.o b/xv6-public/Operating-System-Project/vectors.o
deleted file mode 100644
index 1377672..0000000
Binary files a/xv6-public/Operating-System-Project/vectors.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/vectors.pl b/xv6-public/Operating-System-Project/vectors.pl
deleted file mode 100644
index 57b49dd..0000000
--- a/xv6-public/Operating-System-Project/vectors.pl
+++ /dev/null
@@ -1,47 +0,0 @@
-#!/usr/bin/perl -w
-
-# Generate vectors.S, the trap/interrupt entry points.
-# There has to be one entry point per interrupt number
-# since otherwise there's no way for trap() to discover
-# the interrupt number.
-
-print "# generated by vectors.pl - do not edit\n";
-print "# handlers\n";
-print ".globl alltraps\n";
-for(my $i = 0; $i < 256; $i++){
-    print ".globl vector$i\n";
-    print "vector$i:\n";
-    if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
-        print "  pushl \$0\n";
-    }
-    print "  pushl \$$i\n";
-    print "  jmp alltraps\n";
-}
-
-print "\n# vector table\n";
-print ".data\n";
-print ".globl vectors\n";
-print "vectors:\n";
-for(my $i = 0; $i < 256; $i++){
-    print "  .long vector$i\n";
-}
-
-# sample output:
-#   # handlers
-#   .globl alltraps
-#   .globl vector0
-#   vector0:
-#     pushl $0
-#     pushl $0
-#     jmp alltraps
-#   ...
-#   
-#   # vector table
-#   .data
-#   .globl vectors
-#   vectors:
-#     .long vector0
-#     .long vector1
-#     .long vector2
-#   ...
-
diff --git a/xv6-public/Operating-System-Project/vm.c b/xv6-public/Operating-System-Project/vm.c
deleted file mode 100644
index 7134cff..0000000
--- a/xv6-public/Operating-System-Project/vm.c
+++ /dev/null
@@ -1,394 +0,0 @@
-#include "param.h"
-#include "types.h"
-#include "defs.h"
-#include "x86.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "elf.h"
-
-extern char data[];  // defined by kernel.ld
-pde_t *kpgdir;  // for use in scheduler()
-
-// Set up CPU's kernel segment descriptors.
-// Run once on entry on each CPU.
-void
-seginit(void)
-{
-  struct cpu *c;
-
-  // Map "logical" addresses to virtual addresses using identity map.
-  // Cannot share a CODE descriptor for both kernel and user
-  // because it would have to have DPL_USR, but the CPU forbids
-  // an interrupt from CPL=0 to DPL=3.
-  c = &cpus[cpuid()];
-  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
-  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
-  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
-  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
-  lgdt(c->gdt, sizeof(c->gdt));
-}
-
-// Return the address of the PTE in page table pgdir
-// that corresponds to virtual address va.  If alloc!=0,
-// create any required page table pages.
-static pte_t *
-walkpgdir(pde_t *pgdir, const void *va, int alloc)
-{
-  pde_t *pde;
-  pte_t *pgtab;
-
-  pde = &pgdir[PDX(va)];
-  if(*pde & PTE_P){
-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
-  } else {
-    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
-      return 0;
-    // Make sure all those PTE_P bits are zero.
-    memset(pgtab, 0, PGSIZE);
-    // The permissions here are overly generous, but they can
-    // be further restricted by the permissions in the page table
-    // entries, if necessary.
-    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
-  }
-  return &pgtab[PTX(va)];
-}
-
-// Create PTEs for virtual addresses starting at va that refer to
-// physical addresses starting at pa. va and size might not
-// be page-aligned.
-static int
-mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
-{
-  char *a, *last;
-  pte_t *pte;
-
-  a = (char*)PGROUNDDOWN((uint)va);
-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
-  for(;;){
-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
-      return -1;
-    if(*pte & PTE_P)
-      panic("remap");
-    *pte = pa | perm | PTE_P;
-    if(a == last)
-      break;
-    a += PGSIZE;
-    pa += PGSIZE;
-  }
-  return 0;
-}
-
-// There is one page table per process, plus one that's used when
-// a CPU is not running any process (kpgdir). The kernel uses the
-// current process's page table during system calls and interrupts;
-// page protection bits prevent user code from using the kernel's
-// mappings.
-//
-// setupkvm() and exec() set up every page table like this:
-//
-//   0..KERNBASE: user memory (text+data+stack+heap), mapped to
-//                phys memory allocated by the kernel
-//   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)
-//   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
-//                for the kernel's instructions and r/o data
-//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,
-//                                  rw data + free physical memory
-//   0xfe000000..0: mapped direct (devices such as ioapic)
-//
-// The kernel allocates physical memory for its heap and for user memory
-// between V2P(end) and the end of physical memory (PHYSTOP)
-// (directly addressable from end..P2V(PHYSTOP)).
-
-// This table defines the kernel's mappings, which are present in
-// every process's page table.
-static struct kmap {
-  void *virt;
-  uint phys_start;
-  uint phys_end;
-  int perm;
-} kmap[] = {
- { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
- { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
- { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
- { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
-};
-
-// Set up kernel part of a page table.
-pde_t*
-setupkvm(void)
-{
-  pde_t *pgdir;
-  struct kmap *k;
-
-  if((pgdir = (pde_t*)kalloc()) == 0)
-    return 0;
-  memset(pgdir, 0, PGSIZE);
-  if (P2V(PHYSTOP) > (void*)DEVSPACE)
-    panic("PHYSTOP too high");
-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
-    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
-                (uint)k->phys_start, k->perm) < 0) {
-      freevm(pgdir);
-      return 0;
-    }
-  return pgdir;
-}
-
-// Allocate one page table for the machine for the kernel address
-// space for scheduler processes.
-void
-kvmalloc(void)
-{
-  kpgdir = setupkvm();
-  switchkvm();
-}
-
-// Switch h/w page table register to the kernel-only page table,
-// for when no process is running.
-void
-switchkvm(void)
-{
-  lcr3(V2P(kpgdir));   // switch to the kernel page table
-}
-
-// Switch TSS and h/w page table to correspond to process p.
-void
-switchuvm(struct proc *p)
-{
-  if(p == 0)
-    panic("switchuvm: no process");
-  if(p->kstack == 0)
-    panic("switchuvm: no kstack");
-  if(p->pgdir == 0)
-    panic("switchuvm: no pgdir");
-
-  pushcli();
-  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
-                                sizeof(mycpu()->ts)-1, 0);
-  mycpu()->gdt[SEG_TSS].s = 0;
-  mycpu()->ts.ss0 = SEG_KDATA << 3;
-  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
-  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
-  // forbids I/O instructions (e.g., inb and outb) from user space
-  mycpu()->ts.iomb = (ushort) 0xFFFF;
-  ltr(SEG_TSS << 3);
-  lcr3(V2P(p->pgdir));  // switch to process's address space
-  popcli();
-}
-
-// Load the initcode into address 0 of pgdir.
-// sz must be less than a page.
-void
-inituvm(pde_t *pgdir, char *init, uint sz)
-{
-  char *mem;
-
-  if(sz >= PGSIZE)
-    panic("inituvm: more than a page");
-  mem = kalloc();
-  memset(mem, 0, PGSIZE);
-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
-  memmove(mem, init, sz);
-}
-
-// Load a program segment into pgdir.  addr must be page-aligned
-// and the pages from addr to addr+sz must already be mapped.
-int
-loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
-{
-  uint i, pa, n;
-  pte_t *pte;
-
-  if((uint) addr % PGSIZE != 0)
-    panic("loaduvm: addr must be page aligned");
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
-      panic("loaduvm: address should exist");
-    pa = PTE_ADDR(*pte);
-    if(sz - i < PGSIZE)
-      n = sz - i;
-    else
-      n = PGSIZE;
-    if(readi(ip, P2V(pa), offset+i, n) != n)
-      return -1;
-  }
-  return 0;
-}
-
-// Allocate page tables and physical memory to grow process from oldsz to
-// newsz, which need not be page aligned.  Returns new size or 0 on error.
-int
-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
-{
-  char *mem;
-  uint a;
-
-  if(newsz >= KERNBASE)
-    return 0;
-  if(newsz < oldsz)
-    return oldsz;
-
-  a = PGROUNDUP(oldsz);
-  for(; a < newsz; a += PGSIZE){
-    mem = kalloc();
-    if(mem == 0){
-      cprintf("allocuvm out of memory\n");
-      deallocuvm(pgdir, newsz, oldsz);
-      return 0;
-    }
-    memset(mem, 0, PGSIZE);
-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
-      cprintf("allocuvm out of memory (2)\n");
-      deallocuvm(pgdir, newsz, oldsz);
-      kfree(mem);
-      return 0;
-    }
-  }
-  return newsz;
-}
-
-// Deallocate user pages to bring the process size from oldsz to
-// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
-// need to be less than oldsz.  oldsz can be larger than the actual
-// process size.  Returns the new process size.
-int
-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
-{
-  pte_t *pte;
-  uint a, pa;
-
-  if(newsz >= oldsz)
-    return oldsz;
-
-  a = PGROUNDUP(newsz);
-  for(; a  < oldsz; a += PGSIZE){
-    pte = walkpgdir(pgdir, (char*)a, 0);
-    if(!pte)
-      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
-    else if((*pte & PTE_P) != 0){
-      pa = PTE_ADDR(*pte);
-      if(pa == 0)
-        panic("kfree");
-      char *v = P2V(pa);
-      kfree(v);
-      *pte = 0;
-    }
-  }
-  return newsz;
-}
-
-// Free a page table and all the physical memory pages
-// in the user part.
-void
-freevm(pde_t *pgdir)
-{
-  uint i;
-
-  if(pgdir == 0)
-    panic("freevm: no pgdir");
-  deallocuvm(pgdir, KERNBASE, 0);
-  for(i = 0; i < NPDENTRIES; i++){
-    if(pgdir[i] & PTE_P){
-      char * v = P2V(PTE_ADDR(pgdir[i]));
-      kfree(v);
-    }
-  }
-  kfree((char*)pgdir);
-}
-
-// Clear PTE_U on a page. Used to create an inaccessible
-// page beneath the user stack.
-void
-clearpteu(pde_t *pgdir, char *uva)
-{
-  pte_t *pte;
-
-  pte = walkpgdir(pgdir, uva, 0);
-  if(pte == 0)
-    panic("clearpteu");
-  *pte &= ~PTE_U;
-}
-
-// Given a parent process's page table, create a copy
-// of it for a child.
-pde_t*
-copyuvm(pde_t *pgdir, uint sz)
-{
-  pde_t *d;
-  pte_t *pte;
-  uint pa, i, flags;
-  char *mem;
-
-  if((d = setupkvm()) == 0)
-    return 0;
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
-      panic("copyuvm: pte should exist");
-    if(!(*pte & PTE_P))
-      panic("copyuvm: page not present");
-    pa = PTE_ADDR(*pte);
-    flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto bad;
-    memmove(mem, (char*)P2V(pa), PGSIZE);
-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
-      kfree(mem);
-      goto bad;
-    }
-  }
-  return d;
-
-bad:
-  freevm(d);
-  return 0;
-}
-
-//PAGEBREAK!
-// Map user virtual address to kernel address.
-char*
-uva2ka(pde_t *pgdir, char *uva)
-{
-  pte_t *pte;
-
-  pte = walkpgdir(pgdir, uva, 0);
-  if((*pte & PTE_P) == 0)
-    return 0;
-  if((*pte & PTE_U) == 0)
-    return 0;
-  return (char*)P2V(PTE_ADDR(*pte));
-}
-
-// Copy len bytes from p to user address va in page table pgdir.
-// Most useful when pgdir is not the current page table.
-// uva2ka ensures this only works for PTE_U pages.
-int
-copyout(pde_t *pgdir, uint va, void *p, uint len)
-{
-  char *buf, *pa0;
-  uint n, va0;
-
-  buf = (char*)p;
-  while(len > 0){
-    va0 = (uint)PGROUNDDOWN(va);
-    pa0 = uva2ka(pgdir, (char*)va0);
-    if(pa0 == 0)
-      return -1;
-    n = PGSIZE - (va - va0);
-    if(n > len)
-      n = len;
-    memmove(pa0 + (va - va0), buf, n);
-    len -= n;
-    buf += n;
-    va = va0 + PGSIZE;
-  }
-  return 0;
-}
-
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-
diff --git a/xv6-public/Operating-System-Project/vm.d b/xv6-public/Operating-System-Project/vm.d
deleted file mode 100644
index 51631b1..0000000
--- a/xv6-public/Operating-System-Project/vm.d
+++ /dev/null
@@ -1,2 +0,0 @@
-vm.o: vm.c /usr/include/stdc-predef.h param.h types.h defs.h x86.h \
- memlayout.h mmu.h proc.h elf.h
diff --git a/xv6-public/Operating-System-Project/vm.o b/xv6-public/Operating-System-Project/vm.o
deleted file mode 100644
index b9bd0d8..0000000
Binary files a/xv6-public/Operating-System-Project/vm.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/wc.asm b/xv6-public/Operating-System-Project/wc.asm
deleted file mode 100644
index aa7f35d..0000000
--- a/xv6-public/Operating-System-Project/wc.asm
+++ /dev/null
@@ -1,1406 +0,0 @@
-
-_wc:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-  printf(1, "%d %d %d %s\n", l, w, c, name);
-}
-
-int
-main(int argc, char *argv[])
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	57                   	push   %edi
-  12:	56                   	push   %esi
-  13:	be 01 00 00 00       	mov    $0x1,%esi
-  18:	53                   	push   %ebx
-  19:	51                   	push   %ecx
-  1a:	83 ec 18             	sub    $0x18,%esp
-  1d:	8b 01                	mov    (%ecx),%eax
-  1f:	8b 59 04             	mov    0x4(%ecx),%ebx
-  22:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-  25:	83 c3 04             	add    $0x4,%ebx
-  int fd, i;
-
-  if(argc <= 1){
-  28:	83 f8 01             	cmp    $0x1,%eax
-  2b:	7e 52                	jle    7f <main+0x7f>
-  2d:	8d 76 00             	lea    0x0(%esi),%esi
-    wc(0, "");
-    exit();
-  }
-
-  for(i = 1; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
-  30:	83 ec 08             	sub    $0x8,%esp
-  33:	6a 00                	push   $0x0
-  35:	ff 33                	pushl  (%ebx)
-  37:	e8 f7 03 00 00       	call   433 <open>
-  3c:	83 c4 10             	add    $0x10,%esp
-  3f:	89 c7                	mov    %eax,%edi
-  41:	85 c0                	test   %eax,%eax
-  43:	78 26                	js     6b <main+0x6b>
-      printf(1, "wc: cannot open %s\n", argv[i]);
-      exit();
-    }
-    wc(fd, argv[i]);
-  45:	83 ec 08             	sub    $0x8,%esp
-  48:	ff 33                	pushl  (%ebx)
-  for(i = 1; i < argc; i++){
-  4a:	83 c6 01             	add    $0x1,%esi
-  4d:	83 c3 04             	add    $0x4,%ebx
-    wc(fd, argv[i]);
-  50:	50                   	push   %eax
-  51:	e8 4a 00 00 00       	call   a0 <wc>
-    close(fd);
-  56:	89 3c 24             	mov    %edi,(%esp)
-  59:	e8 bd 03 00 00       	call   41b <close>
-  for(i = 1; i < argc; i++){
-  5e:	83 c4 10             	add    $0x10,%esp
-  61:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
-  64:	75 ca                	jne    30 <main+0x30>
-  }
-  exit();
-  66:	e8 88 03 00 00       	call   3f3 <exit>
-      printf(1, "wc: cannot open %s\n", argv[i]);
-  6b:	50                   	push   %eax
-  6c:	ff 33                	pushl  (%ebx)
-  6e:	68 3b 09 00 00       	push   $0x93b
-  73:	6a 01                	push   $0x1
-  75:	e8 36 05 00 00       	call   5b0 <printf>
-      exit();
-  7a:	e8 74 03 00 00       	call   3f3 <exit>
-    wc(0, "");
-  7f:	52                   	push   %edx
-  80:	52                   	push   %edx
-  81:	68 2d 09 00 00       	push   $0x92d
-  86:	6a 00                	push   $0x0
-  88:	e8 13 00 00 00       	call   a0 <wc>
-    exit();
-  8d:	e8 61 03 00 00       	call   3f3 <exit>
-  92:	66 90                	xchg   %ax,%ax
-  94:	66 90                	xchg   %ax,%ax
-  96:	66 90                	xchg   %ax,%ax
-  98:	66 90                	xchg   %ax,%ax
-  9a:	66 90                	xchg   %ax,%ax
-  9c:	66 90                	xchg   %ax,%ax
-  9e:	66 90                	xchg   %ax,%ax
-
-000000a0 <wc>:
-{
-  a0:	f3 0f 1e fb          	endbr32 
-  a4:	55                   	push   %ebp
-  a5:	89 e5                	mov    %esp,%ebp
-  a7:	57                   	push   %edi
-  a8:	56                   	push   %esi
-  a9:	53                   	push   %ebx
-  l = w = c = 0;
-  aa:	31 db                	xor    %ebx,%ebx
-{
-  ac:	83 ec 1c             	sub    $0x1c,%esp
-  inword = 0;
-  af:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
-  l = w = c = 0;
-  b6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
-  bd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
-  c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  while((n = read(fd, buf, sizeof(buf))) > 0){
-  c8:	83 ec 04             	sub    $0x4,%esp
-  cb:	68 00 02 00 00       	push   $0x200
-  d0:	68 60 0c 00 00       	push   $0xc60
-  d5:	ff 75 08             	pushl  0x8(%ebp)
-  d8:	e8 2e 03 00 00       	call   40b <read>
-  dd:	83 c4 10             	add    $0x10,%esp
-  e0:	89 c6                	mov    %eax,%esi
-  e2:	85 c0                	test   %eax,%eax
-  e4:	7e 62                	jle    148 <wc+0xa8>
-    for(i=0; i<n; i++){
-  e6:	31 ff                	xor    %edi,%edi
-  e8:	eb 14                	jmp    fe <wc+0x5e>
-  ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        inword = 0;
-  f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
-    for(i=0; i<n; i++){
-  f7:	83 c7 01             	add    $0x1,%edi
-  fa:	39 fe                	cmp    %edi,%esi
-  fc:	74 42                	je     140 <wc+0xa0>
-      if(buf[i] == '\n')
-  fe:	0f be 87 60 0c 00 00 	movsbl 0xc60(%edi),%eax
-        l++;
- 105:	31 c9                	xor    %ecx,%ecx
- 107:	3c 0a                	cmp    $0xa,%al
- 109:	0f 94 c1             	sete   %cl
-      if(strchr(" \r\t\n\v", buf[i]))
- 10c:	83 ec 08             	sub    $0x8,%esp
- 10f:	50                   	push   %eax
-        l++;
- 110:	01 cb                	add    %ecx,%ebx
-      if(strchr(" \r\t\n\v", buf[i]))
- 112:	68 18 09 00 00       	push   $0x918
- 117:	e8 54 01 00 00       	call   270 <strchr>
- 11c:	83 c4 10             	add    $0x10,%esp
- 11f:	85 c0                	test   %eax,%eax
- 121:	75 cd                	jne    f0 <wc+0x50>
-      else if(!inword){
- 123:	8b 55 e4             	mov    -0x1c(%ebp),%edx
- 126:	85 d2                	test   %edx,%edx
- 128:	75 cd                	jne    f7 <wc+0x57>
-    for(i=0; i<n; i++){
- 12a:	83 c7 01             	add    $0x1,%edi
-        w++;
- 12d:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
-        inword = 1;
- 131:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
-    for(i=0; i<n; i++){
- 138:	39 fe                	cmp    %edi,%esi
- 13a:	75 c2                	jne    fe <wc+0x5e>
- 13c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 140:	01 75 dc             	add    %esi,-0x24(%ebp)
- 143:	eb 83                	jmp    c8 <wc+0x28>
- 145:	8d 76 00             	lea    0x0(%esi),%esi
-  if(n < 0){
- 148:	75 24                	jne    16e <wc+0xce>
-  printf(1, "%d %d %d %s\n", l, w, c, name);
- 14a:	83 ec 08             	sub    $0x8,%esp
- 14d:	ff 75 0c             	pushl  0xc(%ebp)
- 150:	ff 75 dc             	pushl  -0x24(%ebp)
- 153:	ff 75 e0             	pushl  -0x20(%ebp)
- 156:	53                   	push   %ebx
- 157:	68 2e 09 00 00       	push   $0x92e
- 15c:	6a 01                	push   $0x1
- 15e:	e8 4d 04 00 00       	call   5b0 <printf>
-}
- 163:	83 c4 20             	add    $0x20,%esp
- 166:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 169:	5b                   	pop    %ebx
- 16a:	5e                   	pop    %esi
- 16b:	5f                   	pop    %edi
- 16c:	5d                   	pop    %ebp
- 16d:	c3                   	ret    
-    printf(1, "wc: read error\n");
- 16e:	50                   	push   %eax
- 16f:	50                   	push   %eax
- 170:	68 1e 09 00 00       	push   $0x91e
- 175:	6a 01                	push   $0x1
- 177:	e8 34 04 00 00       	call   5b0 <printf>
-    exit();
- 17c:	e8 72 02 00 00       	call   3f3 <exit>
- 181:	66 90                	xchg   %ax,%ax
- 183:	66 90                	xchg   %ax,%ax
- 185:	66 90                	xchg   %ax,%ax
- 187:	66 90                	xchg   %ax,%ax
- 189:	66 90                	xchg   %ax,%ax
- 18b:	66 90                	xchg   %ax,%ax
- 18d:	66 90                	xchg   %ax,%ax
- 18f:	90                   	nop
-
-00000190 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
- 190:	f3 0f 1e fb          	endbr32 
- 194:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
- 195:	31 c0                	xor    %eax,%eax
-{
- 197:	89 e5                	mov    %esp,%ebp
- 199:	53                   	push   %ebx
- 19a:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 19d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
- 1a0:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
- 1a4:	88 14 01             	mov    %dl,(%ecx,%eax,1)
- 1a7:	83 c0 01             	add    $0x1,%eax
- 1aa:	84 d2                	test   %dl,%dl
- 1ac:	75 f2                	jne    1a0 <strcpy+0x10>
-    ;
-  return os;
-}
- 1ae:	89 c8                	mov    %ecx,%eax
- 1b0:	5b                   	pop    %ebx
- 1b1:	5d                   	pop    %ebp
- 1b2:	c3                   	ret    
- 1b3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 1ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-000001c0 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
- 1c0:	f3 0f 1e fb          	endbr32 
- 1c4:	55                   	push   %ebp
- 1c5:	89 e5                	mov    %esp,%ebp
- 1c7:	53                   	push   %ebx
- 1c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
- 1cb:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
- 1ce:	0f b6 01             	movzbl (%ecx),%eax
- 1d1:	0f b6 1a             	movzbl (%edx),%ebx
- 1d4:	84 c0                	test   %al,%al
- 1d6:	75 19                	jne    1f1 <strcmp+0x31>
- 1d8:	eb 26                	jmp    200 <strcmp+0x40>
- 1da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 1e0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
- 1e4:	83 c1 01             	add    $0x1,%ecx
- 1e7:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
- 1ea:	0f b6 1a             	movzbl (%edx),%ebx
- 1ed:	84 c0                	test   %al,%al
- 1ef:	74 0f                	je     200 <strcmp+0x40>
- 1f1:	38 d8                	cmp    %bl,%al
- 1f3:	74 eb                	je     1e0 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
- 1f5:	29 d8                	sub    %ebx,%eax
-}
- 1f7:	5b                   	pop    %ebx
- 1f8:	5d                   	pop    %ebp
- 1f9:	c3                   	ret    
- 1fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
- 200:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
- 202:	29 d8                	sub    %ebx,%eax
-}
- 204:	5b                   	pop    %ebx
- 205:	5d                   	pop    %ebp
- 206:	c3                   	ret    
- 207:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 20e:	66 90                	xchg   %ax,%ax
-
-00000210 <strlen>:
-
-uint
-strlen(const char *s)
-{
- 210:	f3 0f 1e fb          	endbr32 
- 214:	55                   	push   %ebp
- 215:	89 e5                	mov    %esp,%ebp
- 217:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
- 21a:	80 3a 00             	cmpb   $0x0,(%edx)
- 21d:	74 21                	je     240 <strlen+0x30>
- 21f:	31 c0                	xor    %eax,%eax
- 221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 228:	83 c0 01             	add    $0x1,%eax
- 22b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
- 22f:	89 c1                	mov    %eax,%ecx
- 231:	75 f5                	jne    228 <strlen+0x18>
-    ;
-  return n;
-}
- 233:	89 c8                	mov    %ecx,%eax
- 235:	5d                   	pop    %ebp
- 236:	c3                   	ret    
- 237:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 23e:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
- 240:	31 c9                	xor    %ecx,%ecx
-}
- 242:	5d                   	pop    %ebp
- 243:	89 c8                	mov    %ecx,%eax
- 245:	c3                   	ret    
- 246:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 24d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000250 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
- 250:	f3 0f 1e fb          	endbr32 
- 254:	55                   	push   %ebp
- 255:	89 e5                	mov    %esp,%ebp
- 257:	57                   	push   %edi
- 258:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
- 25b:	8b 4d 10             	mov    0x10(%ebp),%ecx
- 25e:	8b 45 0c             	mov    0xc(%ebp),%eax
- 261:	89 d7                	mov    %edx,%edi
- 263:	fc                   	cld    
- 264:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 266:	89 d0                	mov    %edx,%eax
- 268:	5f                   	pop    %edi
- 269:	5d                   	pop    %ebp
- 26a:	c3                   	ret    
- 26b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 26f:	90                   	nop
-
-00000270 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 270:	f3 0f 1e fb          	endbr32 
- 274:	55                   	push   %ebp
- 275:	89 e5                	mov    %esp,%ebp
- 277:	8b 45 08             	mov    0x8(%ebp),%eax
- 27a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 27e:	0f b6 10             	movzbl (%eax),%edx
- 281:	84 d2                	test   %dl,%dl
- 283:	75 16                	jne    29b <strchr+0x2b>
- 285:	eb 21                	jmp    2a8 <strchr+0x38>
- 287:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 28e:	66 90                	xchg   %ax,%ax
- 290:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 294:	83 c0 01             	add    $0x1,%eax
- 297:	84 d2                	test   %dl,%dl
- 299:	74 0d                	je     2a8 <strchr+0x38>
-    if(*s == c)
- 29b:	38 d1                	cmp    %dl,%cl
- 29d:	75 f1                	jne    290 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 29f:	5d                   	pop    %ebp
- 2a0:	c3                   	ret    
- 2a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 2a8:	31 c0                	xor    %eax,%eax
-}
- 2aa:	5d                   	pop    %ebp
- 2ab:	c3                   	ret    
- 2ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000002b0 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 2b0:	f3 0f 1e fb          	endbr32 
- 2b4:	55                   	push   %ebp
- 2b5:	89 e5                	mov    %esp,%ebp
- 2b7:	57                   	push   %edi
- 2b8:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 2b9:	31 f6                	xor    %esi,%esi
-{
- 2bb:	53                   	push   %ebx
- 2bc:	89 f3                	mov    %esi,%ebx
- 2be:	83 ec 1c             	sub    $0x1c,%esp
- 2c1:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 2c4:	eb 33                	jmp    2f9 <gets+0x49>
- 2c6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 2cd:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 2d0:	83 ec 04             	sub    $0x4,%esp
- 2d3:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 2d6:	6a 01                	push   $0x1
- 2d8:	50                   	push   %eax
- 2d9:	6a 00                	push   $0x0
- 2db:	e8 2b 01 00 00       	call   40b <read>
-    if(cc < 1)
- 2e0:	83 c4 10             	add    $0x10,%esp
- 2e3:	85 c0                	test   %eax,%eax
- 2e5:	7e 1c                	jle    303 <gets+0x53>
-      break;
-    buf[i++] = c;
- 2e7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 2eb:	83 c7 01             	add    $0x1,%edi
- 2ee:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 2f1:	3c 0a                	cmp    $0xa,%al
- 2f3:	74 23                	je     318 <gets+0x68>
- 2f5:	3c 0d                	cmp    $0xd,%al
- 2f7:	74 1f                	je     318 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 2f9:	83 c3 01             	add    $0x1,%ebx
- 2fc:	89 fe                	mov    %edi,%esi
- 2fe:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 301:	7c cd                	jl     2d0 <gets+0x20>
- 303:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 305:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 308:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 30b:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 30e:	5b                   	pop    %ebx
- 30f:	5e                   	pop    %esi
- 310:	5f                   	pop    %edi
- 311:	5d                   	pop    %ebp
- 312:	c3                   	ret    
- 313:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 317:	90                   	nop
- 318:	8b 75 08             	mov    0x8(%ebp),%esi
- 31b:	8b 45 08             	mov    0x8(%ebp),%eax
- 31e:	01 de                	add    %ebx,%esi
- 320:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 322:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 325:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 328:	5b                   	pop    %ebx
- 329:	5e                   	pop    %esi
- 32a:	5f                   	pop    %edi
- 32b:	5d                   	pop    %ebp
- 32c:	c3                   	ret    
- 32d:	8d 76 00             	lea    0x0(%esi),%esi
-
-00000330 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 330:	f3 0f 1e fb          	endbr32 
- 334:	55                   	push   %ebp
- 335:	89 e5                	mov    %esp,%ebp
- 337:	56                   	push   %esi
- 338:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 339:	83 ec 08             	sub    $0x8,%esp
- 33c:	6a 00                	push   $0x0
- 33e:	ff 75 08             	pushl  0x8(%ebp)
- 341:	e8 ed 00 00 00       	call   433 <open>
-  if(fd < 0)
- 346:	83 c4 10             	add    $0x10,%esp
- 349:	85 c0                	test   %eax,%eax
- 34b:	78 2b                	js     378 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 34d:	83 ec 08             	sub    $0x8,%esp
- 350:	ff 75 0c             	pushl  0xc(%ebp)
- 353:	89 c3                	mov    %eax,%ebx
- 355:	50                   	push   %eax
- 356:	e8 f0 00 00 00       	call   44b <fstat>
-  close(fd);
- 35b:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 35e:	89 c6                	mov    %eax,%esi
-  close(fd);
- 360:	e8 b6 00 00 00       	call   41b <close>
-  return r;
- 365:	83 c4 10             	add    $0x10,%esp
-}
- 368:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 36b:	89 f0                	mov    %esi,%eax
- 36d:	5b                   	pop    %ebx
- 36e:	5e                   	pop    %esi
- 36f:	5d                   	pop    %ebp
- 370:	c3                   	ret    
- 371:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 378:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 37d:	eb e9                	jmp    368 <stat+0x38>
- 37f:	90                   	nop
-
-00000380 <atoi>:
-
-int
-atoi(const char *s)
-{
- 380:	f3 0f 1e fb          	endbr32 
- 384:	55                   	push   %ebp
- 385:	89 e5                	mov    %esp,%ebp
- 387:	53                   	push   %ebx
- 388:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 38b:	0f be 02             	movsbl (%edx),%eax
- 38e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 391:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 394:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 399:	77 1a                	ja     3b5 <atoi+0x35>
- 39b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 39f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 3a0:	83 c2 01             	add    $0x1,%edx
- 3a3:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 3a6:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 3aa:	0f be 02             	movsbl (%edx),%eax
- 3ad:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 3b0:	80 fb 09             	cmp    $0x9,%bl
- 3b3:	76 eb                	jbe    3a0 <atoi+0x20>
-  return n;
-}
- 3b5:	89 c8                	mov    %ecx,%eax
- 3b7:	5b                   	pop    %ebx
- 3b8:	5d                   	pop    %ebp
- 3b9:	c3                   	ret    
- 3ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-000003c0 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 3c0:	f3 0f 1e fb          	endbr32 
- 3c4:	55                   	push   %ebp
- 3c5:	89 e5                	mov    %esp,%ebp
- 3c7:	57                   	push   %edi
- 3c8:	8b 45 10             	mov    0x10(%ebp),%eax
- 3cb:	8b 55 08             	mov    0x8(%ebp),%edx
- 3ce:	56                   	push   %esi
- 3cf:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 3d2:	85 c0                	test   %eax,%eax
- 3d4:	7e 0f                	jle    3e5 <memmove+0x25>
- 3d6:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 3d8:	89 d7                	mov    %edx,%edi
- 3da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 3e0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 3e1:	39 f8                	cmp    %edi,%eax
- 3e3:	75 fb                	jne    3e0 <memmove+0x20>
-  return vdst;
-}
- 3e5:	5e                   	pop    %esi
- 3e6:	89 d0                	mov    %edx,%eax
- 3e8:	5f                   	pop    %edi
- 3e9:	5d                   	pop    %ebp
- 3ea:	c3                   	ret    
-
-000003eb <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 3eb:	b8 01 00 00 00       	mov    $0x1,%eax
- 3f0:	cd 40                	int    $0x40
- 3f2:	c3                   	ret    
-
-000003f3 <exit>:
-SYSCALL(exit)
- 3f3:	b8 02 00 00 00       	mov    $0x2,%eax
- 3f8:	cd 40                	int    $0x40
- 3fa:	c3                   	ret    
-
-000003fb <wait>:
-SYSCALL(wait)
- 3fb:	b8 03 00 00 00       	mov    $0x3,%eax
- 400:	cd 40                	int    $0x40
- 402:	c3                   	ret    
-
-00000403 <pipe>:
-SYSCALL(pipe)
- 403:	b8 04 00 00 00       	mov    $0x4,%eax
- 408:	cd 40                	int    $0x40
- 40a:	c3                   	ret    
-
-0000040b <read>:
-SYSCALL(read)
- 40b:	b8 05 00 00 00       	mov    $0x5,%eax
- 410:	cd 40                	int    $0x40
- 412:	c3                   	ret    
-
-00000413 <write>:
-SYSCALL(write)
- 413:	b8 10 00 00 00       	mov    $0x10,%eax
- 418:	cd 40                	int    $0x40
- 41a:	c3                   	ret    
-
-0000041b <close>:
-SYSCALL(close)
- 41b:	b8 15 00 00 00       	mov    $0x15,%eax
- 420:	cd 40                	int    $0x40
- 422:	c3                   	ret    
-
-00000423 <kill>:
-SYSCALL(kill)
- 423:	b8 06 00 00 00       	mov    $0x6,%eax
- 428:	cd 40                	int    $0x40
- 42a:	c3                   	ret    
-
-0000042b <exec>:
-SYSCALL(exec)
- 42b:	b8 07 00 00 00       	mov    $0x7,%eax
- 430:	cd 40                	int    $0x40
- 432:	c3                   	ret    
-
-00000433 <open>:
-SYSCALL(open)
- 433:	b8 0f 00 00 00       	mov    $0xf,%eax
- 438:	cd 40                	int    $0x40
- 43a:	c3                   	ret    
-
-0000043b <mknod>:
-SYSCALL(mknod)
- 43b:	b8 11 00 00 00       	mov    $0x11,%eax
- 440:	cd 40                	int    $0x40
- 442:	c3                   	ret    
-
-00000443 <unlink>:
-SYSCALL(unlink)
- 443:	b8 12 00 00 00       	mov    $0x12,%eax
- 448:	cd 40                	int    $0x40
- 44a:	c3                   	ret    
-
-0000044b <fstat>:
-SYSCALL(fstat)
- 44b:	b8 08 00 00 00       	mov    $0x8,%eax
- 450:	cd 40                	int    $0x40
- 452:	c3                   	ret    
-
-00000453 <link>:
-SYSCALL(link)
- 453:	b8 13 00 00 00       	mov    $0x13,%eax
- 458:	cd 40                	int    $0x40
- 45a:	c3                   	ret    
-
-0000045b <mkdir>:
-SYSCALL(mkdir)
- 45b:	b8 14 00 00 00       	mov    $0x14,%eax
- 460:	cd 40                	int    $0x40
- 462:	c3                   	ret    
-
-00000463 <chdir>:
-SYSCALL(chdir)
- 463:	b8 09 00 00 00       	mov    $0x9,%eax
- 468:	cd 40                	int    $0x40
- 46a:	c3                   	ret    
-
-0000046b <dup>:
-SYSCALL(dup)
- 46b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 470:	cd 40                	int    $0x40
- 472:	c3                   	ret    
-
-00000473 <getpid>:
-SYSCALL(getpid)
- 473:	b8 0b 00 00 00       	mov    $0xb,%eax
- 478:	cd 40                	int    $0x40
- 47a:	c3                   	ret    
-
-0000047b <sbrk>:
-SYSCALL(sbrk)
- 47b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 480:	cd 40                	int    $0x40
- 482:	c3                   	ret    
-
-00000483 <sleep>:
-SYSCALL(sleep)
- 483:	b8 0d 00 00 00       	mov    $0xd,%eax
- 488:	cd 40                	int    $0x40
- 48a:	c3                   	ret    
-
-0000048b <uptime>:
-SYSCALL(uptime)
- 48b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 490:	cd 40                	int    $0x40
- 492:	c3                   	ret    
-
-00000493 <getParentID>:
-SYSCALL(getParentID)
- 493:	b8 16 00 00 00       	mov    $0x16,%eax
- 498:	cd 40                	int    $0x40
- 49a:	c3                   	ret    
-
-0000049b <getChildren>:
-SYSCALL(getChildren)
- 49b:	b8 17 00 00 00       	mov    $0x17,%eax
- 4a0:	cd 40                	int    $0x40
- 4a2:	c3                   	ret    
-
-000004a3 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 4a3:	b8 18 00 00 00       	mov    $0x18,%eax
- 4a8:	cd 40                	int    $0x40
- 4aa:	c3                   	ret    
-
-000004ab <setPriority>:
-SYSCALL(setPriority)
- 4ab:	b8 19 00 00 00       	mov    $0x19,%eax
- 4b0:	cd 40                	int    $0x40
- 4b2:	c3                   	ret    
-
-000004b3 <changePolicy>:
-SYSCALL(changePolicy)
- 4b3:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 4b8:	cd 40                	int    $0x40
- 4ba:	c3                   	ret    
-
-000004bb <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 4bb:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 4c0:	cd 40                	int    $0x40
- 4c2:	c3                   	ret    
-
-000004c3 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 4c3:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 4c8:	cd 40                	int    $0x40
- 4ca:	c3                   	ret    
-
-000004cb <getCBT>:
-SYSCALL(getCBT)
- 4cb:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 4d0:	cd 40                	int    $0x40
- 4d2:	c3                   	ret    
-
-000004d3 <customWait>:
-SYSCALL(customWait)
- 4d3:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 4d8:	cd 40                	int    $0x40
- 4da:	c3                   	ret    
-
-000004db <setQueue>:
-SYSCALL(setQueue)
- 4db:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 4e0:	cd 40                	int    $0x40
- 4e2:	c3                   	ret    
-
-000004e3 <getBurstTime>:
-SYSCALL(getBurstTime)
- 4e3:	b8 20 00 00 00       	mov    $0x20,%eax
- 4e8:	cd 40                	int    $0x40
- 4ea:	c3                   	ret    
-
-000004eb <getCreationTime>:
- 4eb:	b8 21 00 00 00       	mov    $0x21,%eax
- 4f0:	cd 40                	int    $0x40
- 4f2:	c3                   	ret    
- 4f3:	66 90                	xchg   %ax,%ax
- 4f5:	66 90                	xchg   %ax,%ax
- 4f7:	66 90                	xchg   %ax,%ax
- 4f9:	66 90                	xchg   %ax,%ax
- 4fb:	66 90                	xchg   %ax,%ax
- 4fd:	66 90                	xchg   %ax,%ax
- 4ff:	90                   	nop
-
-00000500 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 500:	55                   	push   %ebp
- 501:	89 e5                	mov    %esp,%ebp
- 503:	57                   	push   %edi
- 504:	56                   	push   %esi
- 505:	53                   	push   %ebx
- 506:	83 ec 3c             	sub    $0x3c,%esp
- 509:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 50c:	89 d1                	mov    %edx,%ecx
-{
- 50e:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 511:	85 d2                	test   %edx,%edx
- 513:	0f 89 7f 00 00 00    	jns    598 <printint+0x98>
- 519:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 51d:	74 79                	je     598 <printint+0x98>
-    neg = 1;
- 51f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 526:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 528:	31 db                	xor    %ebx,%ebx
- 52a:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 52d:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 530:	89 c8                	mov    %ecx,%eax
- 532:	31 d2                	xor    %edx,%edx
- 534:	89 cf                	mov    %ecx,%edi
- 536:	f7 75 c4             	divl   -0x3c(%ebp)
- 539:	0f b6 92 58 09 00 00 	movzbl 0x958(%edx),%edx
- 540:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 543:	89 d8                	mov    %ebx,%eax
- 545:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 548:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 54b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 54e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 551:	76 dd                	jbe    530 <printint+0x30>
-  if(neg)
- 553:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 556:	85 c9                	test   %ecx,%ecx
- 558:	74 0c                	je     566 <printint+0x66>
-    buf[i++] = '-';
- 55a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 55f:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 561:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 566:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 569:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 56d:	eb 07                	jmp    576 <printint+0x76>
- 56f:	90                   	nop
- 570:	0f b6 13             	movzbl (%ebx),%edx
- 573:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 576:	83 ec 04             	sub    $0x4,%esp
- 579:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 57c:	6a 01                	push   $0x1
- 57e:	56                   	push   %esi
- 57f:	57                   	push   %edi
- 580:	e8 8e fe ff ff       	call   413 <write>
-  while(--i >= 0)
- 585:	83 c4 10             	add    $0x10,%esp
- 588:	39 de                	cmp    %ebx,%esi
- 58a:	75 e4                	jne    570 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 58c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 58f:	5b                   	pop    %ebx
- 590:	5e                   	pop    %esi
- 591:	5f                   	pop    %edi
- 592:	5d                   	pop    %ebp
- 593:	c3                   	ret    
- 594:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 598:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 59f:	eb 87                	jmp    528 <printint+0x28>
- 5a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5a8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5af:	90                   	nop
-
-000005b0 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 5b0:	f3 0f 1e fb          	endbr32 
- 5b4:	55                   	push   %ebp
- 5b5:	89 e5                	mov    %esp,%ebp
- 5b7:	57                   	push   %edi
- 5b8:	56                   	push   %esi
- 5b9:	53                   	push   %ebx
- 5ba:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 5bd:	8b 75 0c             	mov    0xc(%ebp),%esi
- 5c0:	0f b6 1e             	movzbl (%esi),%ebx
- 5c3:	84 db                	test   %bl,%bl
- 5c5:	0f 84 b4 00 00 00    	je     67f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 5cb:	8d 45 10             	lea    0x10(%ebp),%eax
- 5ce:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 5d1:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 5d4:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 5d6:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 5d9:	eb 33                	jmp    60e <printf+0x5e>
- 5db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 5df:	90                   	nop
- 5e0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 5e3:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 5e8:	83 f8 25             	cmp    $0x25,%eax
- 5eb:	74 17                	je     604 <printf+0x54>
-  write(fd, &c, 1);
- 5ed:	83 ec 04             	sub    $0x4,%esp
- 5f0:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 5f3:	6a 01                	push   $0x1
- 5f5:	57                   	push   %edi
- 5f6:	ff 75 08             	pushl  0x8(%ebp)
- 5f9:	e8 15 fe ff ff       	call   413 <write>
- 5fe:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 601:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 604:	0f b6 1e             	movzbl (%esi),%ebx
- 607:	83 c6 01             	add    $0x1,%esi
- 60a:	84 db                	test   %bl,%bl
- 60c:	74 71                	je     67f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 60e:	0f be cb             	movsbl %bl,%ecx
- 611:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 614:	85 d2                	test   %edx,%edx
- 616:	74 c8                	je     5e0 <printf+0x30>
-      }
-    } else if(state == '%'){
- 618:	83 fa 25             	cmp    $0x25,%edx
- 61b:	75 e7                	jne    604 <printf+0x54>
-      if(c == 'd'){
- 61d:	83 f8 64             	cmp    $0x64,%eax
- 620:	0f 84 9a 00 00 00    	je     6c0 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 626:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 62c:	83 f9 70             	cmp    $0x70,%ecx
- 62f:	74 5f                	je     690 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 631:	83 f8 73             	cmp    $0x73,%eax
- 634:	0f 84 d6 00 00 00    	je     710 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 63a:	83 f8 63             	cmp    $0x63,%eax
- 63d:	0f 84 8d 00 00 00    	je     6d0 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 643:	83 f8 25             	cmp    $0x25,%eax
- 646:	0f 84 b4 00 00 00    	je     700 <printf+0x150>
-  write(fd, &c, 1);
- 64c:	83 ec 04             	sub    $0x4,%esp
- 64f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 653:	6a 01                	push   $0x1
- 655:	57                   	push   %edi
- 656:	ff 75 08             	pushl  0x8(%ebp)
- 659:	e8 b5 fd ff ff       	call   413 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 65e:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 661:	83 c4 0c             	add    $0xc,%esp
- 664:	6a 01                	push   $0x1
- 666:	83 c6 01             	add    $0x1,%esi
- 669:	57                   	push   %edi
- 66a:	ff 75 08             	pushl  0x8(%ebp)
- 66d:	e8 a1 fd ff ff       	call   413 <write>
-  for(i = 0; fmt[i]; i++){
- 672:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 676:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 679:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 67b:	84 db                	test   %bl,%bl
- 67d:	75 8f                	jne    60e <printf+0x5e>
-    }
-  }
-}
- 67f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 682:	5b                   	pop    %ebx
- 683:	5e                   	pop    %esi
- 684:	5f                   	pop    %edi
- 685:	5d                   	pop    %ebp
- 686:	c3                   	ret    
- 687:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 68e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 690:	83 ec 0c             	sub    $0xc,%esp
- 693:	b9 10 00 00 00       	mov    $0x10,%ecx
- 698:	6a 00                	push   $0x0
- 69a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 69d:	8b 45 08             	mov    0x8(%ebp),%eax
- 6a0:	8b 13                	mov    (%ebx),%edx
- 6a2:	e8 59 fe ff ff       	call   500 <printint>
-        ap++;
- 6a7:	89 d8                	mov    %ebx,%eax
- 6a9:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 6ac:	31 d2                	xor    %edx,%edx
-        ap++;
- 6ae:	83 c0 04             	add    $0x4,%eax
- 6b1:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 6b4:	e9 4b ff ff ff       	jmp    604 <printf+0x54>
- 6b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 6c0:	83 ec 0c             	sub    $0xc,%esp
- 6c3:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 6c8:	6a 01                	push   $0x1
- 6ca:	eb ce                	jmp    69a <printf+0xea>
- 6cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 6d0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 6d3:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 6d6:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 6d8:	6a 01                	push   $0x1
-        ap++;
- 6da:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 6dd:	57                   	push   %edi
- 6de:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 6e1:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 6e4:	e8 2a fd ff ff       	call   413 <write>
-        ap++;
- 6e9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 6ec:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 6ef:	31 d2                	xor    %edx,%edx
- 6f1:	e9 0e ff ff ff       	jmp    604 <printf+0x54>
- 6f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 6fd:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 700:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 703:	83 ec 04             	sub    $0x4,%esp
- 706:	e9 59 ff ff ff       	jmp    664 <printf+0xb4>
- 70b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 70f:	90                   	nop
-        s = (char*)*ap;
- 710:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 713:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 715:	83 c0 04             	add    $0x4,%eax
- 718:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 71b:	85 db                	test   %ebx,%ebx
- 71d:	74 17                	je     736 <printf+0x186>
-        while(*s != 0){
- 71f:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 722:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 724:	84 c0                	test   %al,%al
- 726:	0f 84 d8 fe ff ff    	je     604 <printf+0x54>
- 72c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 72f:	89 de                	mov    %ebx,%esi
- 731:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 734:	eb 1a                	jmp    750 <printf+0x1a0>
-          s = "(null)";
- 736:	bb 4f 09 00 00       	mov    $0x94f,%ebx
-        while(*s != 0){
- 73b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 73e:	b8 28 00 00 00       	mov    $0x28,%eax
- 743:	89 de                	mov    %ebx,%esi
- 745:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 748:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 74f:	90                   	nop
-  write(fd, &c, 1);
- 750:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 753:	83 c6 01             	add    $0x1,%esi
- 756:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 759:	6a 01                	push   $0x1
- 75b:	57                   	push   %edi
- 75c:	53                   	push   %ebx
- 75d:	e8 b1 fc ff ff       	call   413 <write>
-        while(*s != 0){
- 762:	0f b6 06             	movzbl (%esi),%eax
- 765:	83 c4 10             	add    $0x10,%esp
- 768:	84 c0                	test   %al,%al
- 76a:	75 e4                	jne    750 <printf+0x1a0>
- 76c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 76f:	31 d2                	xor    %edx,%edx
- 771:	e9 8e fe ff ff       	jmp    604 <printf+0x54>
- 776:	66 90                	xchg   %ax,%ax
- 778:	66 90                	xchg   %ax,%ax
- 77a:	66 90                	xchg   %ax,%ax
- 77c:	66 90                	xchg   %ax,%ax
- 77e:	66 90                	xchg   %ax,%ax
-
-00000780 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 780:	f3 0f 1e fb          	endbr32 
- 784:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 785:	a1 40 0c 00 00       	mov    0xc40,%eax
-{
- 78a:	89 e5                	mov    %esp,%ebp
- 78c:	57                   	push   %edi
- 78d:	56                   	push   %esi
- 78e:	53                   	push   %ebx
- 78f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 792:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 794:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 797:	39 c8                	cmp    %ecx,%eax
- 799:	73 15                	jae    7b0 <free+0x30>
- 79b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 79f:	90                   	nop
- 7a0:	39 d1                	cmp    %edx,%ecx
- 7a2:	72 14                	jb     7b8 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 7a4:	39 d0                	cmp    %edx,%eax
- 7a6:	73 10                	jae    7b8 <free+0x38>
-{
- 7a8:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 7aa:	8b 10                	mov    (%eax),%edx
- 7ac:	39 c8                	cmp    %ecx,%eax
- 7ae:	72 f0                	jb     7a0 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 7b0:	39 d0                	cmp    %edx,%eax
- 7b2:	72 f4                	jb     7a8 <free+0x28>
- 7b4:	39 d1                	cmp    %edx,%ecx
- 7b6:	73 f0                	jae    7a8 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 7b8:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 7bb:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 7be:	39 fa                	cmp    %edi,%edx
- 7c0:	74 1e                	je     7e0 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 7c2:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 7c5:	8b 50 04             	mov    0x4(%eax),%edx
- 7c8:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 7cb:	39 f1                	cmp    %esi,%ecx
- 7cd:	74 28                	je     7f7 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 7cf:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 7d1:	5b                   	pop    %ebx
-  freep = p;
- 7d2:	a3 40 0c 00 00       	mov    %eax,0xc40
-}
- 7d7:	5e                   	pop    %esi
- 7d8:	5f                   	pop    %edi
- 7d9:	5d                   	pop    %ebp
- 7da:	c3                   	ret    
- 7db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 7df:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 7e0:	03 72 04             	add    0x4(%edx),%esi
- 7e3:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 7e6:	8b 10                	mov    (%eax),%edx
- 7e8:	8b 12                	mov    (%edx),%edx
- 7ea:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 7ed:	8b 50 04             	mov    0x4(%eax),%edx
- 7f0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 7f3:	39 f1                	cmp    %esi,%ecx
- 7f5:	75 d8                	jne    7cf <free+0x4f>
-    p->s.size += bp->s.size;
- 7f7:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 7fa:	a3 40 0c 00 00       	mov    %eax,0xc40
-    p->s.size += bp->s.size;
- 7ff:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 802:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 805:	89 10                	mov    %edx,(%eax)
-}
- 807:	5b                   	pop    %ebx
- 808:	5e                   	pop    %esi
- 809:	5f                   	pop    %edi
- 80a:	5d                   	pop    %ebp
- 80b:	c3                   	ret    
- 80c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000810 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 810:	f3 0f 1e fb          	endbr32 
- 814:	55                   	push   %ebp
- 815:	89 e5                	mov    %esp,%ebp
- 817:	57                   	push   %edi
- 818:	56                   	push   %esi
- 819:	53                   	push   %ebx
- 81a:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 81d:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 820:	8b 3d 40 0c 00 00    	mov    0xc40,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 826:	8d 70 07             	lea    0x7(%eax),%esi
- 829:	c1 ee 03             	shr    $0x3,%esi
- 82c:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 82f:	85 ff                	test   %edi,%edi
- 831:	0f 84 a9 00 00 00    	je     8e0 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 837:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 839:	8b 48 04             	mov    0x4(%eax),%ecx
- 83c:	39 f1                	cmp    %esi,%ecx
- 83e:	73 6d                	jae    8ad <malloc+0x9d>
- 840:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 846:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 84b:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 84e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 855:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 858:	eb 17                	jmp    871 <malloc+0x61>
- 85a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 860:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 862:	8b 4a 04             	mov    0x4(%edx),%ecx
- 865:	39 f1                	cmp    %esi,%ecx
- 867:	73 4f                	jae    8b8 <malloc+0xa8>
- 869:	8b 3d 40 0c 00 00    	mov    0xc40,%edi
- 86f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 871:	39 c7                	cmp    %eax,%edi
- 873:	75 eb                	jne    860 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 875:	83 ec 0c             	sub    $0xc,%esp
- 878:	ff 75 e4             	pushl  -0x1c(%ebp)
- 87b:	e8 fb fb ff ff       	call   47b <sbrk>
-  if(p == (char*)-1)
- 880:	83 c4 10             	add    $0x10,%esp
- 883:	83 f8 ff             	cmp    $0xffffffff,%eax
- 886:	74 1b                	je     8a3 <malloc+0x93>
-  hp->s.size = nu;
- 888:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 88b:	83 ec 0c             	sub    $0xc,%esp
- 88e:	83 c0 08             	add    $0x8,%eax
- 891:	50                   	push   %eax
- 892:	e8 e9 fe ff ff       	call   780 <free>
-  return freep;
- 897:	a1 40 0c 00 00       	mov    0xc40,%eax
-      if((p = morecore(nunits)) == 0)
- 89c:	83 c4 10             	add    $0x10,%esp
- 89f:	85 c0                	test   %eax,%eax
- 8a1:	75 bd                	jne    860 <malloc+0x50>
-        return 0;
-  }
-}
- 8a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 8a6:	31 c0                	xor    %eax,%eax
-}
- 8a8:	5b                   	pop    %ebx
- 8a9:	5e                   	pop    %esi
- 8aa:	5f                   	pop    %edi
- 8ab:	5d                   	pop    %ebp
- 8ac:	c3                   	ret    
-    if(p->s.size >= nunits){
- 8ad:	89 c2                	mov    %eax,%edx
- 8af:	89 f8                	mov    %edi,%eax
- 8b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 8b8:	39 ce                	cmp    %ecx,%esi
- 8ba:	74 54                	je     910 <malloc+0x100>
-        p->s.size -= nunits;
- 8bc:	29 f1                	sub    %esi,%ecx
- 8be:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 8c1:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 8c4:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 8c7:	a3 40 0c 00 00       	mov    %eax,0xc40
-}
- 8cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 8cf:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 8d2:	5b                   	pop    %ebx
- 8d3:	5e                   	pop    %esi
- 8d4:	5f                   	pop    %edi
- 8d5:	5d                   	pop    %ebp
- 8d6:	c3                   	ret    
- 8d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 8de:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 8e0:	c7 05 40 0c 00 00 44 	movl   $0xc44,0xc40
- 8e7:	0c 00 00 
-    base.s.size = 0;
- 8ea:	bf 44 0c 00 00       	mov    $0xc44,%edi
-    base.s.ptr = freep = prevp = &base;
- 8ef:	c7 05 44 0c 00 00 44 	movl   $0xc44,0xc44
- 8f6:	0c 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 8f9:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 8fb:	c7 05 48 0c 00 00 00 	movl   $0x0,0xc48
- 902:	00 00 00 
-    if(p->s.size >= nunits){
- 905:	e9 36 ff ff ff       	jmp    840 <malloc+0x30>
- 90a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 910:	8b 0a                	mov    (%edx),%ecx
- 912:	89 08                	mov    %ecx,(%eax)
- 914:	eb b1                	jmp    8c7 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/wc.c b/xv6-public/Operating-System-Project/wc.c
deleted file mode 100644
index d6a54df..0000000
--- a/xv6-public/Operating-System-Project/wc.c
+++ /dev/null
@@ -1,54 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-char buf[512];
-
-void
-wc(int fd, char *name)
-{
-  int i, n;
-  int l, w, c, inword;
-
-  l = w = c = 0;
-  inword = 0;
-  while((n = read(fd, buf, sizeof(buf))) > 0){
-    for(i=0; i<n; i++){
-      c++;
-      if(buf[i] == '\n')
-        l++;
-      if(strchr(" \r\t\n\v", buf[i]))
-        inword = 0;
-      else if(!inword){
-        w++;
-        inword = 1;
-      }
-    }
-  }
-  if(n < 0){
-    printf(1, "wc: read error\n");
-    exit();
-  }
-  printf(1, "%d %d %d %s\n", l, w, c, name);
-}
-
-int
-main(int argc, char *argv[])
-{
-  int fd, i;
-
-  if(argc <= 1){
-    wc(0, "");
-    exit();
-  }
-
-  for(i = 1; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
-      printf(1, "wc: cannot open %s\n", argv[i]);
-      exit();
-    }
-    wc(fd, argv[i]);
-    close(fd);
-  }
-  exit();
-}
diff --git a/xv6-public/Operating-System-Project/wc.d b/xv6-public/Operating-System-Project/wc.d
deleted file mode 100644
index 6adc498..0000000
--- a/xv6-public/Operating-System-Project/wc.d
+++ /dev/null
@@ -1 +0,0 @@
-wc.o: wc.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/wc.o b/xv6-public/Operating-System-Project/wc.o
deleted file mode 100644
index 3061d0b..0000000
Binary files a/xv6-public/Operating-System-Project/wc.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/wc.sym b/xv6-public/Operating-System-Project/wc.sym
deleted file mode 100644
index 9ef867c..0000000
--- a/xv6-public/Operating-System-Project/wc.sym
+++ /dev/null
@@ -1,71 +0,0 @@
-00000000 .text
-00000918 .rodata
-0000096c .eh_frame
-00000c40 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 wc.c
-00000000 ulib.c
-00000000 printf.c
-00000500 printint
-00000958 digits.1109
-00000000 umalloc.c
-00000c40 freep
-00000c44 base
-00000190 strcpy
-0000049b getChildren
-000005b0 printf
-000003c0 memmove
-0000043b mknod
-000002b0 gets
-00000473 getpid
-000004d3 customWait
-000004cb getCBT
-00000810 malloc
-00000483 sleep
-00000403 pipe
-000004b3 changePolicy
-00000413 write
-0000044b fstat
-00000423 kill
-00000463 chdir
-000004db setQueue
-0000042b exec
-000003fb wait
-0000040b read
-000004e3 getBurstTime
-00000443 unlink
-000000a0 wc
-000003eb fork
-000004bb getTurnAroundTime
-0000047b sbrk
-0000048b uptime
-00000c40 __bss_start
-00000250 memset
-00000000 main
-000001c0 strcmp
-0000046b dup
-000004a3 getSyscallCounter
-00000c60 buf
-00000493 getParentID
-00000330 stat
-00000c40 _edata
-00000e60 _end
-00000453 link
-000003f3 exit
-000004ab setPriority
-00000380 atoi
-000004eb getCreationTime
-00000210 strlen
-00000433 open
-00000270 strchr
-0000045b mkdir
-0000041b close
-000004c3 getWaitingTime
-00000780 free
diff --git a/xv6-public/Operating-System-Project/x86.h b/xv6-public/Operating-System-Project/x86.h
deleted file mode 100644
index 07312a5..0000000
--- a/xv6-public/Operating-System-Project/x86.h
+++ /dev/null
@@ -1,183 +0,0 @@
-// Routines to let C code use special x86 instructions.
-
-static inline uchar
-inb(ushort port)
-{
-  uchar data;
-
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-  return data;
-}
-
-static inline void
-insl(int port, void *addr, int cnt)
-{
-  asm volatile("cld; rep insl" :
-               "=D" (addr), "=c" (cnt) :
-               "d" (port), "0" (addr), "1" (cnt) :
-               "memory", "cc");
-}
-
-static inline void
-outb(ushort port, uchar data)
-{
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-}
-
-static inline void
-outw(ushort port, ushort data)
-{
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-}
-
-static inline void
-outsl(int port, const void *addr, int cnt)
-{
-  asm volatile("cld; rep outsl" :
-               "=S" (addr), "=c" (cnt) :
-               "d" (port), "0" (addr), "1" (cnt) :
-               "cc");
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
-               "=D" (addr), "=c" (cnt) :
-               "0" (addr), "1" (cnt), "a" (data) :
-               "memory", "cc");
-}
-
-static inline void
-stosl(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosl" :
-               "=D" (addr), "=c" (cnt) :
-               "0" (addr), "1" (cnt), "a" (data) :
-               "memory", "cc");
-}
-
-struct segdesc;
-
-static inline void
-lgdt(struct segdesc *p, int size)
-{
-  volatile ushort pd[3];
-
-  pd[0] = size-1;
-  pd[1] = (uint)p;
-  pd[2] = (uint)p >> 16;
-
-  asm volatile("lgdt (%0)" : : "r" (pd));
-}
-
-struct gatedesc;
-
-static inline void
-lidt(struct gatedesc *p, int size)
-{
-  volatile ushort pd[3];
-
-  pd[0] = size-1;
-  pd[1] = (uint)p;
-  pd[2] = (uint)p >> 16;
-
-  asm volatile("lidt (%0)" : : "r" (pd));
-}
-
-static inline void
-ltr(ushort sel)
-{
-  asm volatile("ltr %0" : : "r" (sel));
-}
-
-static inline uint
-readeflags(void)
-{
-  uint eflags;
-  asm volatile("pushfl; popl %0" : "=r" (eflags));
-  return eflags;
-}
-
-static inline void
-loadgs(ushort v)
-{
-  asm volatile("movw %0, %%gs" : : "r" (v));
-}
-
-static inline void
-cli(void)
-{
-  asm volatile("cli");
-}
-
-static inline void
-sti(void)
-{
-  asm volatile("sti");
-}
-
-static inline uint
-xchg(volatile uint *addr, uint newval)
-{
-  uint result;
-
-  // The + in "+m" denotes a read-modify-write operand.
-  asm volatile("lock; xchgl %0, %1" :
-               "+m" (*addr), "=a" (result) :
-               "1" (newval) :
-               "cc");
-  return result;
-}
-
-static inline uint
-rcr2(void)
-{
-  uint val;
-  asm volatile("movl %%cr2,%0" : "=r" (val));
-  return val;
-}
-
-static inline void
-lcr3(uint val)
-{
-  asm volatile("movl %0,%%cr3" : : "r" (val));
-}
-
-//PAGEBREAK: 36
-// Layout of the trap frame built on the stack by the
-// hardware and by trapasm.S, and passed to trap().
-struct trapframe {
-  // registers as pushed by pusha
-  uint edi;
-  uint esi;
-  uint ebp;
-  uint oesp;      // useless & ignored
-  uint ebx;
-  uint edx;
-  uint ecx;
-  uint eax;
-
-  // rest of trap frame
-  ushort gs;
-  ushort padding1;
-  ushort fs;
-  ushort padding2;
-  ushort es;
-  ushort padding3;
-  ushort ds;
-  ushort padding4;
-  uint trapno;
-
-  // below here defined by x86 hardware
-  uint err;
-  uint eip;
-  ushort cs;
-  ushort padding5;
-  uint eflags;
-
-  // below here only when crossing rings, such as from user to kernel
-  uint esp;
-  ushort ss;
-  ushort padding6;
-};
diff --git a/xv6-public/Operating-System-Project/xv6.img b/xv6-public/Operating-System-Project/xv6.img
deleted file mode 100644
index 121ba0a..0000000
Binary files a/xv6-public/Operating-System-Project/xv6.img and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/zombie.asm b/xv6-public/Operating-System-Project/zombie.asm
deleted file mode 100644
index 5fd69a3..0000000
--- a/xv6-public/Operating-System-Project/zombie.asm
+++ /dev/null
@@ -1,1236 +0,0 @@
-
-_zombie:     file format elf32-i386
-
-
-Disassembly of section .text:
-
-00000000 <main>:
-#include "stat.h"
-#include "user.h"
-
-int
-main(void)
-{
-   0:	f3 0f 1e fb          	endbr32 
-   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
-   8:	83 e4 f0             	and    $0xfffffff0,%esp
-   b:	ff 71 fc             	pushl  -0x4(%ecx)
-   e:	55                   	push   %ebp
-   f:	89 e5                	mov    %esp,%ebp
-  11:	51                   	push   %ecx
-  12:	83 ec 04             	sub    $0x4,%esp
-  if(fork() > 0)
-  15:	e8 71 02 00 00       	call   28b <fork>
-  1a:	85 c0                	test   %eax,%eax
-  1c:	7e 0d                	jle    2b <main+0x2b>
-    sleep(5);  // Let child exit before parent.
-  1e:	83 ec 0c             	sub    $0xc,%esp
-  21:	6a 05                	push   $0x5
-  23:	e8 fb 02 00 00       	call   323 <sleep>
-  28:	83 c4 10             	add    $0x10,%esp
-  exit();
-  2b:	e8 63 02 00 00       	call   293 <exit>
-
-00000030 <strcpy>:
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  30:	f3 0f 1e fb          	endbr32 
-  34:	55                   	push   %ebp
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-  35:	31 c0                	xor    %eax,%eax
-{
-  37:	89 e5                	mov    %esp,%ebp
-  39:	53                   	push   %ebx
-  3a:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  3d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
-  while((*s++ = *t++) != 0)
-  40:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
-  44:	88 14 01             	mov    %dl,(%ecx,%eax,1)
-  47:	83 c0 01             	add    $0x1,%eax
-  4a:	84 d2                	test   %dl,%dl
-  4c:	75 f2                	jne    40 <strcpy+0x10>
-    ;
-  return os;
-}
-  4e:	89 c8                	mov    %ecx,%eax
-  50:	5b                   	pop    %ebx
-  51:	5d                   	pop    %ebp
-  52:	c3                   	ret    
-  53:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000060 <strcmp>:
-
-int
-strcmp(const char *p, const char *q)
-{
-  60:	f3 0f 1e fb          	endbr32 
-  64:	55                   	push   %ebp
-  65:	89 e5                	mov    %esp,%ebp
-  67:	53                   	push   %ebx
-  68:	8b 4d 08             	mov    0x8(%ebp),%ecx
-  6b:	8b 55 0c             	mov    0xc(%ebp),%edx
-  while(*p && *p == *q)
-  6e:	0f b6 01             	movzbl (%ecx),%eax
-  71:	0f b6 1a             	movzbl (%edx),%ebx
-  74:	84 c0                	test   %al,%al
-  76:	75 19                	jne    91 <strcmp+0x31>
-  78:	eb 26                	jmp    a0 <strcmp+0x40>
-  7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  80:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
-    p++, q++;
-  84:	83 c1 01             	add    $0x1,%ecx
-  87:	83 c2 01             	add    $0x1,%edx
-  while(*p && *p == *q)
-  8a:	0f b6 1a             	movzbl (%edx),%ebx
-  8d:	84 c0                	test   %al,%al
-  8f:	74 0f                	je     a0 <strcmp+0x40>
-  91:	38 d8                	cmp    %bl,%al
-  93:	74 eb                	je     80 <strcmp+0x20>
-  return (uchar)*p - (uchar)*q;
-  95:	29 d8                	sub    %ebx,%eax
-}
-  97:	5b                   	pop    %ebx
-  98:	5d                   	pop    %ebp
-  99:	c3                   	ret    
-  9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  a0:	31 c0                	xor    %eax,%eax
-  return (uchar)*p - (uchar)*q;
-  a2:	29 d8                	sub    %ebx,%eax
-}
-  a4:	5b                   	pop    %ebx
-  a5:	5d                   	pop    %ebp
-  a6:	c3                   	ret    
-  a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  ae:	66 90                	xchg   %ax,%ax
-
-000000b0 <strlen>:
-
-uint
-strlen(const char *s)
-{
-  b0:	f3 0f 1e fb          	endbr32 
-  b4:	55                   	push   %ebp
-  b5:	89 e5                	mov    %esp,%ebp
-  b7:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  for(n = 0; s[n]; n++)
-  ba:	80 3a 00             	cmpb   $0x0,(%edx)
-  bd:	74 21                	je     e0 <strlen+0x30>
-  bf:	31 c0                	xor    %eax,%eax
-  c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  c8:	83 c0 01             	add    $0x1,%eax
-  cb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
-  cf:	89 c1                	mov    %eax,%ecx
-  d1:	75 f5                	jne    c8 <strlen+0x18>
-    ;
-  return n;
-}
-  d3:	89 c8                	mov    %ecx,%eax
-  d5:	5d                   	pop    %ebp
-  d6:	c3                   	ret    
-  d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  de:	66 90                	xchg   %ax,%ax
-  for(n = 0; s[n]; n++)
-  e0:	31 c9                	xor    %ecx,%ecx
-}
-  e2:	5d                   	pop    %ebp
-  e3:	89 c8                	mov    %ecx,%eax
-  e5:	c3                   	ret    
-  e6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  ed:	8d 76 00             	lea    0x0(%esi),%esi
-
-000000f0 <memset>:
-
-void*
-memset(void *dst, int c, uint n)
-{
-  f0:	f3 0f 1e fb          	endbr32 
-  f4:	55                   	push   %ebp
-  f5:	89 e5                	mov    %esp,%ebp
-  f7:	57                   	push   %edi
-  f8:	8b 55 08             	mov    0x8(%ebp),%edx
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
-  fb:	8b 4d 10             	mov    0x10(%ebp),%ecx
-  fe:	8b 45 0c             	mov    0xc(%ebp),%eax
- 101:	89 d7                	mov    %edx,%edi
- 103:	fc                   	cld    
- 104:	f3 aa                	rep stos %al,%es:(%edi)
-  stosb(dst, c, n);
-  return dst;
-}
- 106:	89 d0                	mov    %edx,%eax
- 108:	5f                   	pop    %edi
- 109:	5d                   	pop    %ebp
- 10a:	c3                   	ret    
- 10b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 10f:	90                   	nop
-
-00000110 <strchr>:
-
-char*
-strchr(const char *s, char c)
-{
- 110:	f3 0f 1e fb          	endbr32 
- 114:	55                   	push   %ebp
- 115:	89 e5                	mov    %esp,%ebp
- 117:	8b 45 08             	mov    0x8(%ebp),%eax
- 11a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
-  for(; *s; s++)
- 11e:	0f b6 10             	movzbl (%eax),%edx
- 121:	84 d2                	test   %dl,%dl
- 123:	75 16                	jne    13b <strchr+0x2b>
- 125:	eb 21                	jmp    148 <strchr+0x38>
- 127:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 12e:	66 90                	xchg   %ax,%ax
- 130:	0f b6 50 01          	movzbl 0x1(%eax),%edx
- 134:	83 c0 01             	add    $0x1,%eax
- 137:	84 d2                	test   %dl,%dl
- 139:	74 0d                	je     148 <strchr+0x38>
-    if(*s == c)
- 13b:	38 d1                	cmp    %dl,%cl
- 13d:	75 f1                	jne    130 <strchr+0x20>
-      return (char*)s;
-  return 0;
-}
- 13f:	5d                   	pop    %ebp
- 140:	c3                   	ret    
- 141:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-  return 0;
- 148:	31 c0                	xor    %eax,%eax
-}
- 14a:	5d                   	pop    %ebp
- 14b:	c3                   	ret    
- 14c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-00000150 <gets>:
-
-char*
-gets(char *buf, int max)
-{
- 150:	f3 0f 1e fb          	endbr32 
- 154:	55                   	push   %ebp
- 155:	89 e5                	mov    %esp,%ebp
- 157:	57                   	push   %edi
- 158:	56                   	push   %esi
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
- 159:	31 f6                	xor    %esi,%esi
-{
- 15b:	53                   	push   %ebx
- 15c:	89 f3                	mov    %esi,%ebx
- 15e:	83 ec 1c             	sub    $0x1c,%esp
- 161:	8b 7d 08             	mov    0x8(%ebp),%edi
-  for(i=0; i+1 < max; ){
- 164:	eb 33                	jmp    199 <gets+0x49>
- 166:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 16d:	8d 76 00             	lea    0x0(%esi),%esi
-    cc = read(0, &c, 1);
- 170:	83 ec 04             	sub    $0x4,%esp
- 173:	8d 45 e7             	lea    -0x19(%ebp),%eax
- 176:	6a 01                	push   $0x1
- 178:	50                   	push   %eax
- 179:	6a 00                	push   $0x0
- 17b:	e8 2b 01 00 00       	call   2ab <read>
-    if(cc < 1)
- 180:	83 c4 10             	add    $0x10,%esp
- 183:	85 c0                	test   %eax,%eax
- 185:	7e 1c                	jle    1a3 <gets+0x53>
-      break;
-    buf[i++] = c;
- 187:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
- 18b:	83 c7 01             	add    $0x1,%edi
- 18e:	88 47 ff             	mov    %al,-0x1(%edi)
-    if(c == '\n' || c == '\r')
- 191:	3c 0a                	cmp    $0xa,%al
- 193:	74 23                	je     1b8 <gets+0x68>
- 195:	3c 0d                	cmp    $0xd,%al
- 197:	74 1f                	je     1b8 <gets+0x68>
-  for(i=0; i+1 < max; ){
- 199:	83 c3 01             	add    $0x1,%ebx
- 19c:	89 fe                	mov    %edi,%esi
- 19e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
- 1a1:	7c cd                	jl     170 <gets+0x20>
- 1a3:	89 f3                	mov    %esi,%ebx
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
- 1a5:	8b 45 08             	mov    0x8(%ebp),%eax
-  buf[i] = '\0';
- 1a8:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1ae:	5b                   	pop    %ebx
- 1af:	5e                   	pop    %esi
- 1b0:	5f                   	pop    %edi
- 1b1:	5d                   	pop    %ebp
- 1b2:	c3                   	ret    
- 1b3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 1b7:	90                   	nop
- 1b8:	8b 75 08             	mov    0x8(%ebp),%esi
- 1bb:	8b 45 08             	mov    0x8(%ebp),%eax
- 1be:	01 de                	add    %ebx,%esi
- 1c0:	89 f3                	mov    %esi,%ebx
-  buf[i] = '\0';
- 1c2:	c6 03 00             	movb   $0x0,(%ebx)
-}
- 1c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 1c8:	5b                   	pop    %ebx
- 1c9:	5e                   	pop    %esi
- 1ca:	5f                   	pop    %edi
- 1cb:	5d                   	pop    %ebp
- 1cc:	c3                   	ret    
- 1cd:	8d 76 00             	lea    0x0(%esi),%esi
-
-000001d0 <stat>:
-
-int
-stat(const char *n, struct stat *st)
-{
- 1d0:	f3 0f 1e fb          	endbr32 
- 1d4:	55                   	push   %ebp
- 1d5:	89 e5                	mov    %esp,%ebp
- 1d7:	56                   	push   %esi
- 1d8:	53                   	push   %ebx
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
- 1d9:	83 ec 08             	sub    $0x8,%esp
- 1dc:	6a 00                	push   $0x0
- 1de:	ff 75 08             	pushl  0x8(%ebp)
- 1e1:	e8 ed 00 00 00       	call   2d3 <open>
-  if(fd < 0)
- 1e6:	83 c4 10             	add    $0x10,%esp
- 1e9:	85 c0                	test   %eax,%eax
- 1eb:	78 2b                	js     218 <stat+0x48>
-    return -1;
-  r = fstat(fd, st);
- 1ed:	83 ec 08             	sub    $0x8,%esp
- 1f0:	ff 75 0c             	pushl  0xc(%ebp)
- 1f3:	89 c3                	mov    %eax,%ebx
- 1f5:	50                   	push   %eax
- 1f6:	e8 f0 00 00 00       	call   2eb <fstat>
-  close(fd);
- 1fb:	89 1c 24             	mov    %ebx,(%esp)
-  r = fstat(fd, st);
- 1fe:	89 c6                	mov    %eax,%esi
-  close(fd);
- 200:	e8 b6 00 00 00       	call   2bb <close>
-  return r;
- 205:	83 c4 10             	add    $0x10,%esp
-}
- 208:	8d 65 f8             	lea    -0x8(%ebp),%esp
- 20b:	89 f0                	mov    %esi,%eax
- 20d:	5b                   	pop    %ebx
- 20e:	5e                   	pop    %esi
- 20f:	5d                   	pop    %ebp
- 210:	c3                   	ret    
- 211:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-    return -1;
- 218:	be ff ff ff ff       	mov    $0xffffffff,%esi
- 21d:	eb e9                	jmp    208 <stat+0x38>
- 21f:	90                   	nop
-
-00000220 <atoi>:
-
-int
-atoi(const char *s)
-{
- 220:	f3 0f 1e fb          	endbr32 
- 224:	55                   	push   %ebp
- 225:	89 e5                	mov    %esp,%ebp
- 227:	53                   	push   %ebx
- 228:	8b 55 08             	mov    0x8(%ebp),%edx
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
- 22b:	0f be 02             	movsbl (%edx),%eax
- 22e:	8d 48 d0             	lea    -0x30(%eax),%ecx
- 231:	80 f9 09             	cmp    $0x9,%cl
-  n = 0;
- 234:	b9 00 00 00 00       	mov    $0x0,%ecx
-  while('0' <= *s && *s <= '9')
- 239:	77 1a                	ja     255 <atoi+0x35>
- 23b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 23f:	90                   	nop
-    n = n*10 + *s++ - '0';
- 240:	83 c2 01             	add    $0x1,%edx
- 243:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
- 246:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
-  while('0' <= *s && *s <= '9')
- 24a:	0f be 02             	movsbl (%edx),%eax
- 24d:	8d 58 d0             	lea    -0x30(%eax),%ebx
- 250:	80 fb 09             	cmp    $0x9,%bl
- 253:	76 eb                	jbe    240 <atoi+0x20>
-  return n;
-}
- 255:	89 c8                	mov    %ecx,%eax
- 257:	5b                   	pop    %ebx
- 258:	5d                   	pop    %ebp
- 259:	c3                   	ret    
- 25a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-
-00000260 <memmove>:
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
- 260:	f3 0f 1e fb          	endbr32 
- 264:	55                   	push   %ebp
- 265:	89 e5                	mov    %esp,%ebp
- 267:	57                   	push   %edi
- 268:	8b 45 10             	mov    0x10(%ebp),%eax
- 26b:	8b 55 08             	mov    0x8(%ebp),%edx
- 26e:	56                   	push   %esi
- 26f:	8b 75 0c             	mov    0xc(%ebp),%esi
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
- 272:	85 c0                	test   %eax,%eax
- 274:	7e 0f                	jle    285 <memmove+0x25>
- 276:	01 d0                	add    %edx,%eax
-  dst = vdst;
- 278:	89 d7                	mov    %edx,%edi
- 27a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-    *dst++ = *src++;
- 280:	a4                   	movsb  %ds:(%esi),%es:(%edi)
-  while(n-- > 0)
- 281:	39 f8                	cmp    %edi,%eax
- 283:	75 fb                	jne    280 <memmove+0x20>
-  return vdst;
-}
- 285:	5e                   	pop    %esi
- 286:	89 d0                	mov    %edx,%eax
- 288:	5f                   	pop    %edi
- 289:	5d                   	pop    %ebp
- 28a:	c3                   	ret    
-
-0000028b <fork>:
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
- 28b:	b8 01 00 00 00       	mov    $0x1,%eax
- 290:	cd 40                	int    $0x40
- 292:	c3                   	ret    
-
-00000293 <exit>:
-SYSCALL(exit)
- 293:	b8 02 00 00 00       	mov    $0x2,%eax
- 298:	cd 40                	int    $0x40
- 29a:	c3                   	ret    
-
-0000029b <wait>:
-SYSCALL(wait)
- 29b:	b8 03 00 00 00       	mov    $0x3,%eax
- 2a0:	cd 40                	int    $0x40
- 2a2:	c3                   	ret    
-
-000002a3 <pipe>:
-SYSCALL(pipe)
- 2a3:	b8 04 00 00 00       	mov    $0x4,%eax
- 2a8:	cd 40                	int    $0x40
- 2aa:	c3                   	ret    
-
-000002ab <read>:
-SYSCALL(read)
- 2ab:	b8 05 00 00 00       	mov    $0x5,%eax
- 2b0:	cd 40                	int    $0x40
- 2b2:	c3                   	ret    
-
-000002b3 <write>:
-SYSCALL(write)
- 2b3:	b8 10 00 00 00       	mov    $0x10,%eax
- 2b8:	cd 40                	int    $0x40
- 2ba:	c3                   	ret    
-
-000002bb <close>:
-SYSCALL(close)
- 2bb:	b8 15 00 00 00       	mov    $0x15,%eax
- 2c0:	cd 40                	int    $0x40
- 2c2:	c3                   	ret    
-
-000002c3 <kill>:
-SYSCALL(kill)
- 2c3:	b8 06 00 00 00       	mov    $0x6,%eax
- 2c8:	cd 40                	int    $0x40
- 2ca:	c3                   	ret    
-
-000002cb <exec>:
-SYSCALL(exec)
- 2cb:	b8 07 00 00 00       	mov    $0x7,%eax
- 2d0:	cd 40                	int    $0x40
- 2d2:	c3                   	ret    
-
-000002d3 <open>:
-SYSCALL(open)
- 2d3:	b8 0f 00 00 00       	mov    $0xf,%eax
- 2d8:	cd 40                	int    $0x40
- 2da:	c3                   	ret    
-
-000002db <mknod>:
-SYSCALL(mknod)
- 2db:	b8 11 00 00 00       	mov    $0x11,%eax
- 2e0:	cd 40                	int    $0x40
- 2e2:	c3                   	ret    
-
-000002e3 <unlink>:
-SYSCALL(unlink)
- 2e3:	b8 12 00 00 00       	mov    $0x12,%eax
- 2e8:	cd 40                	int    $0x40
- 2ea:	c3                   	ret    
-
-000002eb <fstat>:
-SYSCALL(fstat)
- 2eb:	b8 08 00 00 00       	mov    $0x8,%eax
- 2f0:	cd 40                	int    $0x40
- 2f2:	c3                   	ret    
-
-000002f3 <link>:
-SYSCALL(link)
- 2f3:	b8 13 00 00 00       	mov    $0x13,%eax
- 2f8:	cd 40                	int    $0x40
- 2fa:	c3                   	ret    
-
-000002fb <mkdir>:
-SYSCALL(mkdir)
- 2fb:	b8 14 00 00 00       	mov    $0x14,%eax
- 300:	cd 40                	int    $0x40
- 302:	c3                   	ret    
-
-00000303 <chdir>:
-SYSCALL(chdir)
- 303:	b8 09 00 00 00       	mov    $0x9,%eax
- 308:	cd 40                	int    $0x40
- 30a:	c3                   	ret    
-
-0000030b <dup>:
-SYSCALL(dup)
- 30b:	b8 0a 00 00 00       	mov    $0xa,%eax
- 310:	cd 40                	int    $0x40
- 312:	c3                   	ret    
-
-00000313 <getpid>:
-SYSCALL(getpid)
- 313:	b8 0b 00 00 00       	mov    $0xb,%eax
- 318:	cd 40                	int    $0x40
- 31a:	c3                   	ret    
-
-0000031b <sbrk>:
-SYSCALL(sbrk)
- 31b:	b8 0c 00 00 00       	mov    $0xc,%eax
- 320:	cd 40                	int    $0x40
- 322:	c3                   	ret    
-
-00000323 <sleep>:
-SYSCALL(sleep)
- 323:	b8 0d 00 00 00       	mov    $0xd,%eax
- 328:	cd 40                	int    $0x40
- 32a:	c3                   	ret    
-
-0000032b <uptime>:
-SYSCALL(uptime)
- 32b:	b8 0e 00 00 00       	mov    $0xe,%eax
- 330:	cd 40                	int    $0x40
- 332:	c3                   	ret    
-
-00000333 <getParentID>:
-SYSCALL(getParentID)
- 333:	b8 16 00 00 00       	mov    $0x16,%eax
- 338:	cd 40                	int    $0x40
- 33a:	c3                   	ret    
-
-0000033b <getChildren>:
-SYSCALL(getChildren)
- 33b:	b8 17 00 00 00       	mov    $0x17,%eax
- 340:	cd 40                	int    $0x40
- 342:	c3                   	ret    
-
-00000343 <getSyscallCounter>:
-SYSCALL(getSyscallCounter)
- 343:	b8 18 00 00 00       	mov    $0x18,%eax
- 348:	cd 40                	int    $0x40
- 34a:	c3                   	ret    
-
-0000034b <setPriority>:
-SYSCALL(setPriority)
- 34b:	b8 19 00 00 00       	mov    $0x19,%eax
- 350:	cd 40                	int    $0x40
- 352:	c3                   	ret    
-
-00000353 <changePolicy>:
-SYSCALL(changePolicy)
- 353:	b8 1a 00 00 00       	mov    $0x1a,%eax
- 358:	cd 40                	int    $0x40
- 35a:	c3                   	ret    
-
-0000035b <getTurnAroundTime>:
-SYSCALL(getTurnAroundTime)
- 35b:	b8 1b 00 00 00       	mov    $0x1b,%eax
- 360:	cd 40                	int    $0x40
- 362:	c3                   	ret    
-
-00000363 <getWaitingTime>:
-SYSCALL(getWaitingTime)
- 363:	b8 1c 00 00 00       	mov    $0x1c,%eax
- 368:	cd 40                	int    $0x40
- 36a:	c3                   	ret    
-
-0000036b <getCBT>:
-SYSCALL(getCBT)
- 36b:	b8 1d 00 00 00       	mov    $0x1d,%eax
- 370:	cd 40                	int    $0x40
- 372:	c3                   	ret    
-
-00000373 <customWait>:
-SYSCALL(customWait)
- 373:	b8 1e 00 00 00       	mov    $0x1e,%eax
- 378:	cd 40                	int    $0x40
- 37a:	c3                   	ret    
-
-0000037b <setQueue>:
-SYSCALL(setQueue)
- 37b:	b8 1f 00 00 00       	mov    $0x1f,%eax
- 380:	cd 40                	int    $0x40
- 382:	c3                   	ret    
-
-00000383 <getBurstTime>:
-SYSCALL(getBurstTime)
- 383:	b8 20 00 00 00       	mov    $0x20,%eax
- 388:	cd 40                	int    $0x40
- 38a:	c3                   	ret    
-
-0000038b <getCreationTime>:
- 38b:	b8 21 00 00 00       	mov    $0x21,%eax
- 390:	cd 40                	int    $0x40
- 392:	c3                   	ret    
- 393:	66 90                	xchg   %ax,%ax
- 395:	66 90                	xchg   %ax,%ax
- 397:	66 90                	xchg   %ax,%ax
- 399:	66 90                	xchg   %ax,%ax
- 39b:	66 90                	xchg   %ax,%ax
- 39d:	66 90                	xchg   %ax,%ax
- 39f:	90                   	nop
-
-000003a0 <printint>:
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
- 3a0:	55                   	push   %ebp
- 3a1:	89 e5                	mov    %esp,%ebp
- 3a3:	57                   	push   %edi
- 3a4:	56                   	push   %esi
- 3a5:	53                   	push   %ebx
- 3a6:	83 ec 3c             	sub    $0x3c,%esp
- 3a9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
- 3ac:	89 d1                	mov    %edx,%ecx
-{
- 3ae:	89 45 b8             	mov    %eax,-0x48(%ebp)
-  if(sgn && xx < 0){
- 3b1:	85 d2                	test   %edx,%edx
- 3b3:	0f 89 7f 00 00 00    	jns    438 <printint+0x98>
- 3b9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
- 3bd:	74 79                	je     438 <printint+0x98>
-    neg = 1;
- 3bf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-    x = -xx;
- 3c6:	f7 d9                	neg    %ecx
-  } else {
-    x = xx;
-  }
-
-  i = 0;
- 3c8:	31 db                	xor    %ebx,%ebx
- 3ca:	8d 75 d7             	lea    -0x29(%ebp),%esi
- 3cd:	8d 76 00             	lea    0x0(%esi),%esi
-  do{
-    buf[i++] = digits[x % base];
- 3d0:	89 c8                	mov    %ecx,%eax
- 3d2:	31 d2                	xor    %edx,%edx
- 3d4:	89 cf                	mov    %ecx,%edi
- 3d6:	f7 75 c4             	divl   -0x3c(%ebp)
- 3d9:	0f b6 92 c0 07 00 00 	movzbl 0x7c0(%edx),%edx
- 3e0:	89 45 c0             	mov    %eax,-0x40(%ebp)
- 3e3:	89 d8                	mov    %ebx,%eax
- 3e5:	8d 5b 01             	lea    0x1(%ebx),%ebx
-  }while((x /= base) != 0);
- 3e8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-    buf[i++] = digits[x % base];
- 3eb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
-  }while((x /= base) != 0);
- 3ee:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
- 3f1:	76 dd                	jbe    3d0 <printint+0x30>
-  if(neg)
- 3f3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
- 3f6:	85 c9                	test   %ecx,%ecx
- 3f8:	74 0c                	je     406 <printint+0x66>
-    buf[i++] = '-';
- 3fa:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
-    buf[i++] = digits[x % base];
- 3ff:	89 d8                	mov    %ebx,%eax
-    buf[i++] = '-';
- 401:	ba 2d 00 00 00       	mov    $0x2d,%edx
-
-  while(--i >= 0)
- 406:	8b 7d b8             	mov    -0x48(%ebp),%edi
- 409:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
- 40d:	eb 07                	jmp    416 <printint+0x76>
- 40f:	90                   	nop
- 410:	0f b6 13             	movzbl (%ebx),%edx
- 413:	83 eb 01             	sub    $0x1,%ebx
-  write(fd, &c, 1);
- 416:	83 ec 04             	sub    $0x4,%esp
- 419:	88 55 d7             	mov    %dl,-0x29(%ebp)
- 41c:	6a 01                	push   $0x1
- 41e:	56                   	push   %esi
- 41f:	57                   	push   %edi
- 420:	e8 8e fe ff ff       	call   2b3 <write>
-  while(--i >= 0)
- 425:	83 c4 10             	add    $0x10,%esp
- 428:	39 de                	cmp    %ebx,%esi
- 42a:	75 e4                	jne    410 <printint+0x70>
-    putc(fd, buf[i]);
-}
- 42c:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 42f:	5b                   	pop    %ebx
- 430:	5e                   	pop    %esi
- 431:	5f                   	pop    %edi
- 432:	5d                   	pop    %ebp
- 433:	c3                   	ret    
- 434:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-  neg = 0;
- 438:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
- 43f:	eb 87                	jmp    3c8 <printint+0x28>
- 441:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 448:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 44f:	90                   	nop
-
-00000450 <printf>:
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
- 450:	f3 0f 1e fb          	endbr32 
- 454:	55                   	push   %ebp
- 455:	89 e5                	mov    %esp,%ebp
- 457:	57                   	push   %edi
- 458:	56                   	push   %esi
- 459:	53                   	push   %ebx
- 45a:	83 ec 2c             	sub    $0x2c,%esp
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
- 45d:	8b 75 0c             	mov    0xc(%ebp),%esi
- 460:	0f b6 1e             	movzbl (%esi),%ebx
- 463:	84 db                	test   %bl,%bl
- 465:	0f 84 b4 00 00 00    	je     51f <printf+0xcf>
-  ap = (uint*)(void*)&fmt + 1;
- 46b:	8d 45 10             	lea    0x10(%ebp),%eax
- 46e:	83 c6 01             	add    $0x1,%esi
-  write(fd, &c, 1);
- 471:	8d 7d e7             	lea    -0x19(%ebp),%edi
-  state = 0;
- 474:	31 d2                	xor    %edx,%edx
-  ap = (uint*)(void*)&fmt + 1;
- 476:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 479:	eb 33                	jmp    4ae <printf+0x5e>
- 47b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 47f:	90                   	nop
- 480:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
- 483:	ba 25 00 00 00       	mov    $0x25,%edx
-      if(c == '%'){
- 488:	83 f8 25             	cmp    $0x25,%eax
- 48b:	74 17                	je     4a4 <printf+0x54>
-  write(fd, &c, 1);
- 48d:	83 ec 04             	sub    $0x4,%esp
- 490:	88 5d e7             	mov    %bl,-0x19(%ebp)
- 493:	6a 01                	push   $0x1
- 495:	57                   	push   %edi
- 496:	ff 75 08             	pushl  0x8(%ebp)
- 499:	e8 15 fe ff ff       	call   2b3 <write>
- 49e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-      } else {
-        putc(fd, c);
- 4a1:	83 c4 10             	add    $0x10,%esp
-  for(i = 0; fmt[i]; i++){
- 4a4:	0f b6 1e             	movzbl (%esi),%ebx
- 4a7:	83 c6 01             	add    $0x1,%esi
- 4aa:	84 db                	test   %bl,%bl
- 4ac:	74 71                	je     51f <printf+0xcf>
-    c = fmt[i] & 0xff;
- 4ae:	0f be cb             	movsbl %bl,%ecx
- 4b1:	0f b6 c3             	movzbl %bl,%eax
-    if(state == 0){
- 4b4:	85 d2                	test   %edx,%edx
- 4b6:	74 c8                	je     480 <printf+0x30>
-      }
-    } else if(state == '%'){
- 4b8:	83 fa 25             	cmp    $0x25,%edx
- 4bb:	75 e7                	jne    4a4 <printf+0x54>
-      if(c == 'd'){
- 4bd:	83 f8 64             	cmp    $0x64,%eax
- 4c0:	0f 84 9a 00 00 00    	je     560 <printf+0x110>
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
- 4c6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
- 4cc:	83 f9 70             	cmp    $0x70,%ecx
- 4cf:	74 5f                	je     530 <printf+0xe0>
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
- 4d1:	83 f8 73             	cmp    $0x73,%eax
- 4d4:	0f 84 d6 00 00 00    	je     5b0 <printf+0x160>
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
- 4da:	83 f8 63             	cmp    $0x63,%eax
- 4dd:	0f 84 8d 00 00 00    	je     570 <printf+0x120>
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
- 4e3:	83 f8 25             	cmp    $0x25,%eax
- 4e6:	0f 84 b4 00 00 00    	je     5a0 <printf+0x150>
-  write(fd, &c, 1);
- 4ec:	83 ec 04             	sub    $0x4,%esp
- 4ef:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
- 4f3:	6a 01                	push   $0x1
- 4f5:	57                   	push   %edi
- 4f6:	ff 75 08             	pushl  0x8(%ebp)
- 4f9:	e8 b5 fd ff ff       	call   2b3 <write>
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
- 4fe:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 501:	83 c4 0c             	add    $0xc,%esp
- 504:	6a 01                	push   $0x1
- 506:	83 c6 01             	add    $0x1,%esi
- 509:	57                   	push   %edi
- 50a:	ff 75 08             	pushl  0x8(%ebp)
- 50d:	e8 a1 fd ff ff       	call   2b3 <write>
-  for(i = 0; fmt[i]; i++){
- 512:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
-        putc(fd, c);
- 516:	83 c4 10             	add    $0x10,%esp
-      }
-      state = 0;
- 519:	31 d2                	xor    %edx,%edx
-  for(i = 0; fmt[i]; i++){
- 51b:	84 db                	test   %bl,%bl
- 51d:	75 8f                	jne    4ae <printf+0x5e>
-    }
-  }
-}
- 51f:	8d 65 f4             	lea    -0xc(%ebp),%esp
- 522:	5b                   	pop    %ebx
- 523:	5e                   	pop    %esi
- 524:	5f                   	pop    %edi
- 525:	5d                   	pop    %ebp
- 526:	c3                   	ret    
- 527:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 52e:	66 90                	xchg   %ax,%ax
-        printint(fd, *ap, 16, 0);
- 530:	83 ec 0c             	sub    $0xc,%esp
- 533:	b9 10 00 00 00       	mov    $0x10,%ecx
- 538:	6a 00                	push   $0x0
- 53a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
- 53d:	8b 45 08             	mov    0x8(%ebp),%eax
- 540:	8b 13                	mov    (%ebx),%edx
- 542:	e8 59 fe ff ff       	call   3a0 <printint>
-        ap++;
- 547:	89 d8                	mov    %ebx,%eax
- 549:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 54c:	31 d2                	xor    %edx,%edx
-        ap++;
- 54e:	83 c0 04             	add    $0x4,%eax
- 551:	89 45 d0             	mov    %eax,-0x30(%ebp)
- 554:	e9 4b ff ff ff       	jmp    4a4 <printf+0x54>
- 559:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-        printint(fd, *ap, 10, 1);
- 560:	83 ec 0c             	sub    $0xc,%esp
- 563:	b9 0a 00 00 00       	mov    $0xa,%ecx
- 568:	6a 01                	push   $0x1
- 56a:	eb ce                	jmp    53a <printf+0xea>
- 56c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-        putc(fd, *ap);
- 570:	8b 5d d0             	mov    -0x30(%ebp),%ebx
-  write(fd, &c, 1);
- 573:	83 ec 04             	sub    $0x4,%esp
-        putc(fd, *ap);
- 576:	8b 03                	mov    (%ebx),%eax
-  write(fd, &c, 1);
- 578:	6a 01                	push   $0x1
-        ap++;
- 57a:	83 c3 04             	add    $0x4,%ebx
-  write(fd, &c, 1);
- 57d:	57                   	push   %edi
- 57e:	ff 75 08             	pushl  0x8(%ebp)
-        putc(fd, *ap);
- 581:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 584:	e8 2a fd ff ff       	call   2b3 <write>
-        ap++;
- 589:	89 5d d0             	mov    %ebx,-0x30(%ebp)
- 58c:	83 c4 10             	add    $0x10,%esp
-      state = 0;
- 58f:	31 d2                	xor    %edx,%edx
- 591:	e9 0e ff ff ff       	jmp    4a4 <printf+0x54>
- 596:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 59d:	8d 76 00             	lea    0x0(%esi),%esi
-        putc(fd, c);
- 5a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
-  write(fd, &c, 1);
- 5a3:	83 ec 04             	sub    $0x4,%esp
- 5a6:	e9 59 ff ff ff       	jmp    504 <printf+0xb4>
- 5ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 5af:	90                   	nop
-        s = (char*)*ap;
- 5b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
- 5b3:	8b 18                	mov    (%eax),%ebx
-        ap++;
- 5b5:	83 c0 04             	add    $0x4,%eax
- 5b8:	89 45 d0             	mov    %eax,-0x30(%ebp)
-        if(s == 0)
- 5bb:	85 db                	test   %ebx,%ebx
- 5bd:	74 17                	je     5d6 <printf+0x186>
-        while(*s != 0){
- 5bf:	0f b6 03             	movzbl (%ebx),%eax
-      state = 0;
- 5c2:	31 d2                	xor    %edx,%edx
-        while(*s != 0){
- 5c4:	84 c0                	test   %al,%al
- 5c6:	0f 84 d8 fe ff ff    	je     4a4 <printf+0x54>
- 5cc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5cf:	89 de                	mov    %ebx,%esi
- 5d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 5d4:	eb 1a                	jmp    5f0 <printf+0x1a0>
-          s = "(null)";
- 5d6:	bb b8 07 00 00       	mov    $0x7b8,%ebx
-        while(*s != 0){
- 5db:	89 75 d4             	mov    %esi,-0x2c(%ebp)
- 5de:	b8 28 00 00 00       	mov    $0x28,%eax
- 5e3:	89 de                	mov    %ebx,%esi
- 5e5:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 5e8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 5ef:	90                   	nop
-  write(fd, &c, 1);
- 5f0:	83 ec 04             	sub    $0x4,%esp
-          s++;
- 5f3:	83 c6 01             	add    $0x1,%esi
- 5f6:	88 45 e7             	mov    %al,-0x19(%ebp)
-  write(fd, &c, 1);
- 5f9:	6a 01                	push   $0x1
- 5fb:	57                   	push   %edi
- 5fc:	53                   	push   %ebx
- 5fd:	e8 b1 fc ff ff       	call   2b3 <write>
-        while(*s != 0){
- 602:	0f b6 06             	movzbl (%esi),%eax
- 605:	83 c4 10             	add    $0x10,%esp
- 608:	84 c0                	test   %al,%al
- 60a:	75 e4                	jne    5f0 <printf+0x1a0>
- 60c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-      state = 0;
- 60f:	31 d2                	xor    %edx,%edx
- 611:	e9 8e fe ff ff       	jmp    4a4 <printf+0x54>
- 616:	66 90                	xchg   %ax,%ax
- 618:	66 90                	xchg   %ax,%ax
- 61a:	66 90                	xchg   %ax,%ax
- 61c:	66 90                	xchg   %ax,%ax
- 61e:	66 90                	xchg   %ax,%ax
-
-00000620 <free>:
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
- 620:	f3 0f 1e fb          	endbr32 
- 624:	55                   	push   %ebp
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 625:	a1 68 0a 00 00       	mov    0xa68,%eax
-{
- 62a:	89 e5                	mov    %esp,%ebp
- 62c:	57                   	push   %edi
- 62d:	56                   	push   %esi
- 62e:	53                   	push   %ebx
- 62f:	8b 5d 08             	mov    0x8(%ebp),%ebx
- 632:	8b 10                	mov    (%eax),%edx
-  bp = (Header*)ap - 1;
- 634:	8d 4b f8             	lea    -0x8(%ebx),%ecx
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 637:	39 c8                	cmp    %ecx,%eax
- 639:	73 15                	jae    650 <free+0x30>
- 63b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 63f:	90                   	nop
- 640:	39 d1                	cmp    %edx,%ecx
- 642:	72 14                	jb     658 <free+0x38>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 644:	39 d0                	cmp    %edx,%eax
- 646:	73 10                	jae    658 <free+0x38>
-{
- 648:	89 d0                	mov    %edx,%eax
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
- 64a:	8b 10                	mov    (%eax),%edx
- 64c:	39 c8                	cmp    %ecx,%eax
- 64e:	72 f0                	jb     640 <free+0x20>
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
- 650:	39 d0                	cmp    %edx,%eax
- 652:	72 f4                	jb     648 <free+0x28>
- 654:	39 d1                	cmp    %edx,%ecx
- 656:	73 f0                	jae    648 <free+0x28>
-      break;
-  if(bp + bp->s.size == p->s.ptr){
- 658:	8b 73 fc             	mov    -0x4(%ebx),%esi
- 65b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
- 65e:	39 fa                	cmp    %edi,%edx
- 660:	74 1e                	je     680 <free+0x60>
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
- 662:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 665:	8b 50 04             	mov    0x4(%eax),%edx
- 668:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 66b:	39 f1                	cmp    %esi,%ecx
- 66d:	74 28                	je     697 <free+0x77>
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
- 66f:	89 08                	mov    %ecx,(%eax)
-  freep = p;
-}
- 671:	5b                   	pop    %ebx
-  freep = p;
- 672:	a3 68 0a 00 00       	mov    %eax,0xa68
-}
- 677:	5e                   	pop    %esi
- 678:	5f                   	pop    %edi
- 679:	5d                   	pop    %ebp
- 67a:	c3                   	ret    
- 67b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
- 67f:	90                   	nop
-    bp->s.size += p->s.ptr->s.size;
- 680:	03 72 04             	add    0x4(%edx),%esi
- 683:	89 73 fc             	mov    %esi,-0x4(%ebx)
-    bp->s.ptr = p->s.ptr->s.ptr;
- 686:	8b 10                	mov    (%eax),%edx
- 688:	8b 12                	mov    (%edx),%edx
- 68a:	89 53 f8             	mov    %edx,-0x8(%ebx)
-  if(p + p->s.size == bp){
- 68d:	8b 50 04             	mov    0x4(%eax),%edx
- 690:	8d 34 d0             	lea    (%eax,%edx,8),%esi
- 693:	39 f1                	cmp    %esi,%ecx
- 695:	75 d8                	jne    66f <free+0x4f>
-    p->s.size += bp->s.size;
- 697:	03 53 fc             	add    -0x4(%ebx),%edx
-  freep = p;
- 69a:	a3 68 0a 00 00       	mov    %eax,0xa68
-    p->s.size += bp->s.size;
- 69f:	89 50 04             	mov    %edx,0x4(%eax)
-    p->s.ptr = bp->s.ptr;
- 6a2:	8b 53 f8             	mov    -0x8(%ebx),%edx
- 6a5:	89 10                	mov    %edx,(%eax)
-}
- 6a7:	5b                   	pop    %ebx
- 6a8:	5e                   	pop    %esi
- 6a9:	5f                   	pop    %edi
- 6aa:	5d                   	pop    %ebp
- 6ab:	c3                   	ret    
- 6ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
-
-000006b0 <malloc>:
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
- 6b0:	f3 0f 1e fb          	endbr32 
- 6b4:	55                   	push   %ebp
- 6b5:	89 e5                	mov    %esp,%ebp
- 6b7:	57                   	push   %edi
- 6b8:	56                   	push   %esi
- 6b9:	53                   	push   %ebx
- 6ba:	83 ec 1c             	sub    $0x1c,%esp
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6bd:	8b 45 08             	mov    0x8(%ebp),%eax
-  if((prevp = freep) == 0){
- 6c0:	8b 3d 68 0a 00 00    	mov    0xa68,%edi
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
- 6c6:	8d 70 07             	lea    0x7(%eax),%esi
- 6c9:	c1 ee 03             	shr    $0x3,%esi
- 6cc:	83 c6 01             	add    $0x1,%esi
-  if((prevp = freep) == 0){
- 6cf:	85 ff                	test   %edi,%edi
- 6d1:	0f 84 a9 00 00 00    	je     780 <malloc+0xd0>
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 6d7:	8b 07                	mov    (%edi),%eax
-    if(p->s.size >= nunits){
- 6d9:	8b 48 04             	mov    0x4(%eax),%ecx
- 6dc:	39 f1                	cmp    %esi,%ecx
- 6de:	73 6d                	jae    74d <malloc+0x9d>
- 6e0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
- 6e6:	bb 00 10 00 00       	mov    $0x1000,%ebx
- 6eb:	0f 43 de             	cmovae %esi,%ebx
-  p = sbrk(nu * sizeof(Header));
- 6ee:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
- 6f5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
- 6f8:	eb 17                	jmp    711 <malloc+0x61>
- 6fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 700:	8b 10                	mov    (%eax),%edx
-    if(p->s.size >= nunits){
- 702:	8b 4a 04             	mov    0x4(%edx),%ecx
- 705:	39 f1                	cmp    %esi,%ecx
- 707:	73 4f                	jae    758 <malloc+0xa8>
- 709:	8b 3d 68 0a 00 00    	mov    0xa68,%edi
- 70f:	89 d0                	mov    %edx,%eax
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
- 711:	39 c7                	cmp    %eax,%edi
- 713:	75 eb                	jne    700 <malloc+0x50>
-  p = sbrk(nu * sizeof(Header));
- 715:	83 ec 0c             	sub    $0xc,%esp
- 718:	ff 75 e4             	pushl  -0x1c(%ebp)
- 71b:	e8 fb fb ff ff       	call   31b <sbrk>
-  if(p == (char*)-1)
- 720:	83 c4 10             	add    $0x10,%esp
- 723:	83 f8 ff             	cmp    $0xffffffff,%eax
- 726:	74 1b                	je     743 <malloc+0x93>
-  hp->s.size = nu;
- 728:	89 58 04             	mov    %ebx,0x4(%eax)
-  free((void*)(hp + 1));
- 72b:	83 ec 0c             	sub    $0xc,%esp
- 72e:	83 c0 08             	add    $0x8,%eax
- 731:	50                   	push   %eax
- 732:	e8 e9 fe ff ff       	call   620 <free>
-  return freep;
- 737:	a1 68 0a 00 00       	mov    0xa68,%eax
-      if((p = morecore(nunits)) == 0)
- 73c:	83 c4 10             	add    $0x10,%esp
- 73f:	85 c0                	test   %eax,%eax
- 741:	75 bd                	jne    700 <malloc+0x50>
-        return 0;
-  }
-}
- 743:	8d 65 f4             	lea    -0xc(%ebp),%esp
-        return 0;
- 746:	31 c0                	xor    %eax,%eax
-}
- 748:	5b                   	pop    %ebx
- 749:	5e                   	pop    %esi
- 74a:	5f                   	pop    %edi
- 74b:	5d                   	pop    %ebp
- 74c:	c3                   	ret    
-    if(p->s.size >= nunits){
- 74d:	89 c2                	mov    %eax,%edx
- 74f:	89 f8                	mov    %edi,%eax
- 751:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
-      if(p->s.size == nunits)
- 758:	39 ce                	cmp    %ecx,%esi
- 75a:	74 54                	je     7b0 <malloc+0x100>
-        p->s.size -= nunits;
- 75c:	29 f1                	sub    %esi,%ecx
- 75e:	89 4a 04             	mov    %ecx,0x4(%edx)
-        p += p->s.size;
- 761:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
-        p->s.size = nunits;
- 764:	89 72 04             	mov    %esi,0x4(%edx)
-      freep = prevp;
- 767:	a3 68 0a 00 00       	mov    %eax,0xa68
-}
- 76c:	8d 65 f4             	lea    -0xc(%ebp),%esp
-      return (void*)(p + 1);
- 76f:	8d 42 08             	lea    0x8(%edx),%eax
-}
- 772:	5b                   	pop    %ebx
- 773:	5e                   	pop    %esi
- 774:	5f                   	pop    %edi
- 775:	5d                   	pop    %ebp
- 776:	c3                   	ret    
- 777:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
- 77e:	66 90                	xchg   %ax,%ax
-    base.s.ptr = freep = prevp = &base;
- 780:	c7 05 68 0a 00 00 6c 	movl   $0xa6c,0xa68
- 787:	0a 00 00 
-    base.s.size = 0;
- 78a:	bf 6c 0a 00 00       	mov    $0xa6c,%edi
-    base.s.ptr = freep = prevp = &base;
- 78f:	c7 05 6c 0a 00 00 6c 	movl   $0xa6c,0xa6c
- 796:	0a 00 00 
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
- 799:	89 f8                	mov    %edi,%eax
-    base.s.size = 0;
- 79b:	c7 05 70 0a 00 00 00 	movl   $0x0,0xa70
- 7a2:	00 00 00 
-    if(p->s.size >= nunits){
- 7a5:	e9 36 ff ff ff       	jmp    6e0 <malloc+0x30>
- 7aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
-        prevp->s.ptr = p->s.ptr;
- 7b0:	8b 0a                	mov    (%edx),%ecx
- 7b2:	89 08                	mov    %ecx,(%eax)
- 7b4:	eb b1                	jmp    767 <malloc+0xb7>
diff --git a/xv6-public/Operating-System-Project/zombie.c b/xv6-public/Operating-System-Project/zombie.c
deleted file mode 100644
index ee817da..0000000
--- a/xv6-public/Operating-System-Project/zombie.c
+++ /dev/null
@@ -1,14 +0,0 @@
-// Create a zombie process that
-// must be reparented at exit.
-
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int
-main(void)
-{
-  if(fork() > 0)
-    sleep(5);  // Let child exit before parent.
-  exit();
-}
diff --git a/xv6-public/Operating-System-Project/zombie.d b/xv6-public/Operating-System-Project/zombie.d
deleted file mode 100644
index c3e36f5..0000000
--- a/xv6-public/Operating-System-Project/zombie.d
+++ /dev/null
@@ -1 +0,0 @@
-zombie.o: zombie.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/xv6-public/Operating-System-Project/zombie.o b/xv6-public/Operating-System-Project/zombie.o
deleted file mode 100644
index be60848..0000000
Binary files a/xv6-public/Operating-System-Project/zombie.o and /dev/null differ
diff --git a/xv6-public/Operating-System-Project/zombie.sym b/xv6-public/Operating-System-Project/zombie.sym
deleted file mode 100644
index b5b6689..0000000
--- a/xv6-public/Operating-System-Project/zombie.sym
+++ /dev/null
@@ -1,69 +0,0 @@
-00000000 .text
-000007b8 .rodata
-000007d4 .eh_frame
-00000a68 .bss
-00000000 .comment
-00000000 .debug_aranges
-00000000 .debug_info
-00000000 .debug_abbrev
-00000000 .debug_line
-00000000 .debug_str
-00000000 .debug_loc
-00000000 .debug_ranges
-00000000 zombie.c
-00000000 ulib.c
-00000000 printf.c
-000003a0 printint
-000007c0 digits.1109
-00000000 umalloc.c
-00000a68 freep
-00000a6c base
-00000030 strcpy
-0000033b getChildren
-00000450 printf
-00000260 memmove
-000002db mknod
-00000150 gets
-00000313 getpid
-00000373 customWait
-0000036b getCBT
-000006b0 malloc
-00000323 sleep
-000002a3 pipe
-00000353 changePolicy
-000002b3 write
-000002eb fstat
-000002c3 kill
-00000303 chdir
-0000037b setQueue
-000002cb exec
-0000029b wait
-000002ab read
-00000383 getBurstTime
-000002e3 unlink
-0000028b fork
-0000035b getTurnAroundTime
-0000031b sbrk
-0000032b uptime
-00000a68 __bss_start
-000000f0 memset
-00000000 main
-00000060 strcmp
-0000030b dup
-00000343 getSyscallCounter
-00000333 getParentID
-000001d0 stat
-00000a68 _edata
-00000a74 _end
-000002f3 link
-00000293 exit
-0000034b setPriority
-00000220 atoi
-0000038b getCreationTime
-000000b0 strlen
-000002d3 open
-00000110 strchr
-000002fb mkdir
-000002bb close
-00000363 getWaitingTime
-00000620 free
diff --git a/xv6-public/README b/xv6-paging/README
index 923e0a4..6dd3102 100644
--- a/xv6-public/README
+++ b/xv6-paging/README
@@ -1,7 +1,30 @@
-NOTE: we have stopped maintaining the x86 version of xv6, and switched
-our efforts to the RISC-V version
-(https://github.com/mit-pdos/xv6-riscv.git)
+~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-
+xv6 memory paging
 
+
+This project is part of an Operating Systems course taken in BGU. We introduce a 2-level paging mechanism. There are 4 paging policies: NONE, FIFO, SCFIFO and NFU.
+These policies are invoked with the SELECTION flag when launching, i.e.
+
+$ make clean qemu SELECTION=FIFO
+
+If the flag isn't defined at launch, then NFU is used.
+
+There are three places where the level of printing can be decided for the tests (in addition to the flag VERBOSE_PRINT) by setting the DEBUG constant to either a zero or a non-zero value.
+The default for all three is zero, which means minimal printing. Setting a non-zero variable would enable verbose printing.
+The options are as follows:
+
+1. proc.c - would print out info about the pages that are in memory.
+2. myMemTest.c - would perform more memory I-O and print accordingly.
+3. vm.c - would print out the chosen pages to be paged out by the current policy.
+
+
+For further information, consult the assignment description at https://www.cs.bgu.ac.il/~os162/Assignments/Assignment_3
+
+The original README is left intact below.
+
+Copyright 2016 Asaf Chelouche, Asaf Benjamin
+
+~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-
 xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
 Version 6 (v6).  xv6 loosely follows the structure and style of v6,
 but is implemented for a modern x86-based multiprocessor using ANSI C.
@@ -10,7 +33,7 @@ ACKNOWLEDGMENTS
 
 xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
 to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
-2000)). See also https://pdos.csail.mit.edu/6.828/, which
+2000)). See also http://pdos.csail.mit.edu/6.828/2014/xv6.html, which
 provides pointers to on-line resources for v6.
 
 xv6 borrows code from the following sources:
@@ -19,33 +42,35 @@ xv6 borrows code from the following sources:
     FreeBSD (ioapic.c)
     NetBSD (console.c)
 
-The following people have made contributions: Russ Cox (context switching,
-locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
-Clements.
-
-We are also grateful for the bug reports and patches contributed by Silas
-Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
-Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter
-Froehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander
-Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin
-Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi
-Merimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,
-Eldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren
-Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
-Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.
+The following people have made contributions:
+    Russ Cox (context switching, locking)
+    Cliff Frey (MP)
+    Xiao Yu (MP)
+    Nickolai Zeldovich
+    Austin Clements
+
+In addition, we are grateful for the bug reports and patches contributed by
+Silas Boyd-Wickizer, Peter Froehlich, Shivam Handa, Anders Kaseorg, Eddie
+Kohler, Yandong Mao, Hitoshi Mitake, Carmi Merimovich, Joel Nider, Greg Price,
+Eldar Sehayek, Yongming Shen, Stephen Tu, and Zouchangwei.
 
 The code in the files that constitute xv6 is
-Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.
+Copyright 2006-2014 Frans Kaashoek, Robert Morris, and Russ Cox.
 
 ERROR REPORTS
 
-We don't process error reports (see note on top of this file).
+If you spot errors or have suggestions for improvement, please send
+email to Frans Kaashoek and Robert Morris (kaashoek,rtm@csail.mit.edu). 
 
 BUILDING AND RUNNING XV6
 
-To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
-"make". On non-x86 or non-ELF machines (like OS X, even on x86), you
-will need to install a cross-compiler gcc suite capable of producing
-x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
-Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
-simulator and run "make qemu".
\ No newline at end of file
+To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run "make".
+On non-x86 or non-ELF machines (like OS X, even on x86), you will
+need to install a cross-compiler gcc suite capable of producing x86 ELF
+binaries.  See http://pdos.csail.mit.edu/6.828/2014/tools.html.
+Then run "make TOOLPREFIX=i386-jos-elf-".
+
+To run xv6, install the QEMU PC simulators.  To run in QEMU, run "make qemu".
+
+To create a typeset version of the code, run "make xv6.pdf".  This
+requires the "mpage" utility.  See http://www.mesa.nl/pub/mpage/.
diff --git a/xv6-public/asm.h b/xv6-paging/asm.h
index b8a7353..68210d7 100644
--- a/xv6-public/asm.h
+++ b/xv6-paging/asm.h
@@ -14,5 +14,8 @@
                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
 
 #define STA_X     0x8       // Executable segment
+#define STA_E     0x4       // Expand down (non-executable segments)
+#define STA_C     0x4       // Conforming code segment (executable only)
 #define STA_W     0x2       // Writeable (non-executable segments)
 #define STA_R     0x2       // Readable (executable segments)
+#define STA_A     0x1       // Accessed
diff --git a/xv6-public/bio.c b/xv6-paging/bio.c
index a45ff3e..629bb2c 100644
--- a/xv6-public/bio.c
+++ b/xv6-paging/bio.c
@@ -4,7 +4,7 @@
 // cached copies of disk block contents.  Caching disk blocks
 // in memory reduces the number of disk reads and also provides
 // a synchronization point for disk blocks used by multiple processes.
-//
+// 
 // Interface:
 // * To get a buffer for a particular disk block, call bread.
 // * After changing buffer data, call bwrite to write it to disk.
@@ -12,8 +12,10 @@
 // * Do not use the buffer after calling brelse.
 // * Only one process at a time can use a buffer,
 //     so do not keep them longer than necessary.
-//
-// The implementation uses two state flags internally:
+// 
+// The implementation uses three state flags internally:
+// * B_BUSY: the block has been returned from bread
+//     and has not been passed back to brelse.  
 // * B_VALID: the buffer data has been read from the disk.
 // * B_DIRTY: the buffer data has been modified
 //     and needs to be written to disk.
@@ -22,7 +24,6 @@
 #include "defs.h"
 #include "param.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "buf.h"
 
@@ -49,7 +50,7 @@ binit(void)
   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
     b->next = bcache.head.next;
     b->prev = &bcache.head;
-    initsleeplock(&b->lock, "buffer");
+    b->dev = -1;
     bcache.head.next->prev = b;
     bcache.head.next = b;
   }
@@ -57,7 +58,7 @@ binit(void)
 
 // Look through buffer cache for block on device dev.
 // If not found, allocate a buffer.
-// In either case, return locked buffer.
+// In either case, return B_BUSY buffer.
 static struct buf*
 bget(uint dev, uint blockno)
 {
@@ -65,78 +66,78 @@ bget(uint dev, uint blockno)
 
   acquire(&bcache.lock);
 
+ loop:
   // Is the block already cached?
   for(b = bcache.head.next; b != &bcache.head; b = b->next){
     if(b->dev == dev && b->blockno == blockno){
-      b->refcnt++;
-      release(&bcache.lock);
-      acquiresleep(&b->lock);
-      return b;
+      if(!(b->flags & B_BUSY)){
+        b->flags |= B_BUSY;
+        release(&bcache.lock);
+        return b;
+      }
+      sleep(b, &bcache.lock);
+      goto loop;
     }
   }
 
-  // Not cached; recycle an unused buffer.
-  // Even if refcnt==0, B_DIRTY indicates a buffer is in use
-  // because log.c has modified it but not yet committed it.
+  // Not cached; recycle some non-busy and clean buffer.
+  // "clean" because B_DIRTY and !B_BUSY means log.c
+  // hasn't yet committed the changes to the buffer.
   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
-    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+    if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){
       b->dev = dev;
       b->blockno = blockno;
-      b->flags = 0;
-      b->refcnt = 1;
+      b->flags = B_BUSY;
       release(&bcache.lock);
-      acquiresleep(&b->lock);
       return b;
     }
   }
   panic("bget: no buffers");
 }
 
-// Return a locked buf with the contents of the indicated block.
+// Return a B_BUSY buf with the contents of the indicated block.
 struct buf*
 bread(uint dev, uint blockno)
 {
   struct buf *b;
 
   b = bget(dev, blockno);
-  if((b->flags & B_VALID) == 0) {
+  if(!(b->flags & B_VALID)) {
     iderw(b);
   }
   return b;
 }
 
-// Write b's contents to disk.  Must be locked.
+// Write b's contents to disk.  Must be B_BUSY.
 void
 bwrite(struct buf *b)
 {
-  if(!holdingsleep(&b->lock))
+  if((b->flags & B_BUSY) == 0)
     panic("bwrite");
   b->flags |= B_DIRTY;
   iderw(b);
 }
 
-// Release a locked buffer.
+// Release a B_BUSY buffer.
 // Move to the head of the MRU list.
 void
 brelse(struct buf *b)
 {
-  if(!holdingsleep(&b->lock))
+  if((b->flags & B_BUSY) == 0)
     panic("brelse");
 
-  releasesleep(&b->lock);
-
   acquire(&bcache.lock);
-  b->refcnt--;
-  if (b->refcnt == 0) {
-    // no one is waiting for it.
-    b->next->prev = b->prev;
-    b->prev->next = b->next;
-    b->next = bcache.head.next;
-    b->prev = &bcache.head;
-    bcache.head.next->prev = b;
-    bcache.head.next = b;
-  }
-  
+
+  b->next->prev = b->prev;
+  b->prev->next = b->next;
+  b->next = bcache.head.next;
+  b->prev = &bcache.head;
+  bcache.head.next->prev = b;
+  bcache.head.next = b;
+
+  b->flags &= ~B_BUSY;
+  wakeup(b);
+
   release(&bcache.lock);
 }
 //PAGEBREAK!
diff --git a/xv6-public/bootasm.S b/xv6-paging/bootasm.S
index 257867c..91a595e 100644
--- a/xv6-public/bootasm.S
+++ b/xv6-paging/bootasm.S
@@ -45,7 +45,7 @@ seta20.2:
   movl    %eax, %cr0
 
 //PAGEBREAK!
-  # Complete the transition to 32-bit protected mode by using a long jmp
+  # Complete transition to 32-bit protected mode by using long jmp
   # to reload %cs and %eip.  The segment descriptors are set up with no
   # translation, so that the mapping is still the identity mapping.
   ljmp    $(SEG_KCODE<<3), $start32
diff --git a/xv6-public/bootmain.c b/xv6-paging/bootmain.c
index 1f20e5b..97d5258 100644
--- a/xv6-public/bootmain.c
+++ b/xv6-paging/bootmain.c
@@ -1,5 +1,5 @@
 // Boot loader.
-//
+// 
 // Part of the boot block, along with bootasm.S, which calls bootmain().
 // bootasm.S has put the processor into protected 32-bit mode.
 // bootmain() loads an ELF kernel image from the disk starting at
diff --git a/xv6-public/buf.h b/xv6-paging/buf.h
index 3266495..f18fd87 100644
--- a/xv6-public/buf.h
+++ b/xv6-paging/buf.h
@@ -2,13 +2,12 @@ struct buf {
   int flags;
   uint dev;
   uint blockno;
-  struct sleeplock lock;
-  uint refcnt;
   struct buf *prev; // LRU cache list
   struct buf *next;
   struct buf *qnext; // disk queue
   uchar data[BSIZE];
 };
+#define B_BUSY  0x1  // buffer is locked by some process
 #define B_VALID 0x2  // buffer has been read from disk
 #define B_DIRTY 0x4  // buffer needs to be written to disk
 
diff --git a/xv6-public/cat.c b/xv6-paging/cat.c
index 5ddc820..2b2dcc7 100644
--- a/xv6-public/cat.c
+++ b/xv6-paging/cat.c
@@ -9,12 +9,8 @@ cat(int fd)
 {
   int n;
 
-  while((n = read(fd, buf, sizeof(buf))) > 0) {
-    if (write(1, buf, n) != n) {
-      printf(1, "cat: write error\n");
-      exit();
-    }
-  }
+  while((n = read(fd, buf, sizeof(buf))) > 0)
+    write(1, buf, n);
   if(n < 0){
     printf(1, "cat: read error\n");
     exit();
diff --git a/xv6-public/console.c b/xv6-paging/console.c
index a280d2b..35f221d 100644
--- a/xv6-public/console.c
+++ b/xv6-paging/console.c
@@ -7,7 +7,6 @@
 #include "param.h"
 #include "traps.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "file.h"
 #include "memlayout.h"
@@ -108,11 +107,10 @@ panic(char *s)
 {
   int i;
   uint pcs[10];
-
+  
   cli();
   cons.locking = 0;
-  // use lapiccpunum so that we can call panic from mycpu()
-  cprintf("lapicid %d: panic: ", lapicid());
+  cprintf("cpu%d: panic: ", cpu->id);
   cprintf(s);
   cprintf("\n");
   getcallerpcs(&s, pcs);
@@ -132,7 +130,7 @@ static void
 cgaputc(int c)
 {
   int pos;
-
+  
   // Cursor position: col + 80*row.
   outb(CRTPORT, 14);
   pos = inb(CRTPORT+1) << 8;
@@ -148,13 +146,13 @@ cgaputc(int c)
 
   if(pos < 0 || pos > 25*80)
     panic("pos under/overflow");
-
+  
   if((pos/80) >= 24){  // Scroll up.
     memmove(crt, crt+80, sizeof(crt[0])*23*80);
     pos -= 80;
     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
   }
-
+  
   outb(CRTPORT, 14);
   outb(CRTPORT+1, pos>>8);
   outb(CRTPORT, 15);
@@ -197,8 +195,7 @@ consoleintr(int (*getc)(void))
   while((c = getc()) >= 0){
     switch(c){
     case C('P'):  // Process listing.
-      // procdump() locks cons.lock indirectly; invoke later
-      doprocdump = 1;
+      doprocdump = 1;   // procdump() locks cons.lock indirectly; invoke later
       break;
     case C('U'):  // Kill line.
       while(input.e != input.w &&
@@ -243,7 +240,7 @@ consoleread(struct inode *ip, char *dst, int n)
   acquire(&cons.lock);
   while(n > 0){
     while(input.r == input.w){
-      if(myproc()->killed){
+      if(proc->killed){
         release(&cons.lock);
         ilock(ip);
         return -1;
@@ -294,6 +291,7 @@ consoleinit(void)
   devsw[CONSOLE].read = consoleread;
   cons.locking = 1;
 
+  picenable(IRQ_KBD);
   ioapicenable(IRQ_KBD, 0);
 }
 
diff --git a/xv6-public/cuth b/xv6-paging/cuth
old mode 100755
new mode 100644
diff --git a/xv6-public/defs.h b/xv6-paging/defs.h
index 82fb982..766171d 100644
--- a/xv6-public/defs.h
+++ b/xv6-paging/defs.h
@@ -6,7 +6,6 @@ struct pipe;
 struct proc;
 struct rtcdate;
 struct spinlock;
-struct sleeplock;
 struct stat;
 struct superblock;
 
@@ -52,7 +51,10 @@ struct inode*   nameiparent(char*, char*);
 int             readi(struct inode*, char*, uint, uint);
 void            stati(struct inode*, struct stat*);
 int             writei(struct inode*, char*, uint, uint);
-
+int				createSwapFile(struct proc* p);
+int				readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size);
+int				writeToSwapFile(struct proc* p, char* buffer, uint placeOnFile, uint size);
+int				removeSwapFile(struct proc* p);
 // ide.c
 void            ideinit(void);
 void            ideintr(void);
@@ -74,7 +76,7 @@ void            kbdintr(void);
 
 // lapic.c
 void            cmostime(struct rtcdate *r);
-int             lapicid(void);
+int             cpunum(void);
 extern volatile uint*    lapic;
 void            lapiceoi(void);
 void            lapicinit(void);
@@ -89,7 +91,9 @@ void            end_op();
 
 // mp.c
 extern int      ismp;
+int             mpbcpu(void);
 void            mpinit(void);
+void            mpstartthem(void);
 
 // picirq.c
 void            picenable(int);
@@ -103,18 +107,16 @@ int             pipewrite(struct pipe*, char*, int);
 
 //PAGEBREAK: 16
 // proc.c
-int             cpuid(void);
+void			NFUupdate();
+struct proc*    copyproc(struct proc*);
 void            exit(void);
 int             fork(void);
 int             growproc(int);
 int             kill(int);
-struct cpu*     mycpu(void);
-struct proc*    myproc();
 void            pinit(void);
 void            procdump(void);
 void            scheduler(void) __attribute__((noreturn));
 void            sched(void);
-void            setproc(struct proc*);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
 int             wait(void);
@@ -124,6 +126,10 @@ void            yield(void);
 // swtch.S
 void            swtch(struct context**, struct context*);
 
+// sysfile
+struct inode*	create(char *path, short type, short major, short minor);
+int				isdirempty(struct inode *dp);
+
 // spinlock.c
 void            acquire(struct spinlock*);
 void            getcallerpcs(void*, uint*);
@@ -133,12 +139,6 @@ void            release(struct spinlock*);
 void            pushcli(void);
 void            popcli(void);
 
-// sleeplock.c
-void            acquiresleep(struct sleeplock*);
-void            releasesleep(struct sleeplock*);
-int             holdingsleep(struct sleeplock*);
-void            initsleeplock(struct sleeplock*, char*);
-
 // string.c
 int             memcmp(const void*, const void*, uint);
 void*           memmove(void*, const void*, uint);
@@ -147,6 +147,7 @@ char*           safestrcpy(char*, const char*, int);
 int             strlen(const char*);
 int             strncmp(const char*, const char*, uint);
 char*           strncpy(char*, const char*, int);
+int             strcmp(const char *, const char *);
 
 // syscall.c
 int             argint(int, int*);
@@ -171,8 +172,10 @@ void            uartintr(void);
 void            uartputc(int);
 
 // vm.c
+void 			checkProcAccBit();
 void            seginit(void);
 void            kvmalloc(void);
+void            vmenable(void);
 pde_t*          setupkvm(void);
 char*           uva2ka(pde_t*, char*);
 int             allocuvm(pde_t*, uint, uint);
@@ -185,6 +188,7 @@ void            switchuvm(struct proc*);
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
+void            swapPages(uint);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/xv6-public/difTask2.txt b/xv6-public/difTask2.txt
deleted file mode 100644
index e69de29..0000000
diff --git a/xv6-public/dot-bochsrc b/xv6-paging/dot-bochsrc
old mode 100755
new mode 100644
diff --git a/xv6-public/entry.S b/xv6-paging/entry.S
index bc79bab..5f4e124 100644
--- a/xv6-public/entry.S
+++ b/xv6-paging/entry.S
@@ -1,7 +1,3 @@
-# The xv6 kernel starts executing in this file. This file is linked with
-# the kernel C code, so it can refer to kernel symbols such as main().
-# The boot block (bootasm.S and bootmain.c) jumps to entry below.
-        
 # Multiboot header, for multiboot boot loaders like GNU Grub.
 # http://www.gnu.org/software/grub/manual/multiboot/multiboot.html
 #
diff --git a/xv6-public/entryother.S b/xv6-paging/entryother.S
index a3b6dc2..9f94cd3 100644
--- a/xv6-public/entryother.S
+++ b/xv6-paging/entryother.S
@@ -17,49 +17,43 @@
 # place to jump to (mpenter) in start-8, and the physical address
 # of entrypgdir in start-12.
 #
-# This code combines elements of bootasm.S and entry.S.
+# This code is identical to bootasm.S except:
+#   - it does not need to enable A20
+#   - it uses the address at start-4, start-8, and start-12
 
 .code16           
 .globl start
 start:
   cli            
 
-  # Zero data segment registers DS, ES, and SS.
   xorw    %ax,%ax
   movw    %ax,%ds
   movw    %ax,%es
   movw    %ax,%ss
 
-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
-  # virtual addresses map directly to physical addresses so that the
-  # effective memory map doesn't change during the transition.
   lgdt    gdtdesc
   movl    %cr0, %eax
   orl     $CR0_PE, %eax
   movl    %eax, %cr0
 
-  # Complete the transition to 32-bit protected mode by using a long jmp
-  # to reload %cs and %eip.  The segment descriptors are set up with no
-  # translation, so that the mapping is still the identity mapping.
+//PAGEBREAK!
   ljmpl    $(SEG_KCODE<<3), $(start32)
 
-//PAGEBREAK!
-.code32  # Tell assembler to generate 32-bit code now.
+.code32
 start32:
-  # Set up the protected-mode data segment registers
-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
-  movw    %ax, %ds                # -> DS: Data Segment
-  movw    %ax, %es                # -> ES: Extra Segment
-  movw    %ax, %ss                # -> SS: Stack Segment
-  movw    $0, %ax                 # Zero segments not ready for use
-  movw    %ax, %fs                # -> FS
-  movw    %ax, %gs                # -> GS
+  movw    $(SEG_KDATA<<3), %ax
+  movw    %ax, %ds
+  movw    %ax, %es
+  movw    %ax, %ss
+  movw    $0, %ax
+  movw    %ax, %fs
+  movw    %ax, %gs
 
   # Turn on page size extension for 4Mbyte pages
   movl    %cr4, %eax
   orl     $(CR4_PSE), %eax
   movl    %eax, %cr4
-  # Use entrypgdir as our initial page table
+  # Use enterpgdir as our initial page table
   movl    (start-12), %eax
   movl    %eax, %cr3
   # Turn on paging.
diff --git a/xv6-public/exec.c b/xv6-paging/exec.c
index b40134f..ef1e32d 100644
--- a/xv6-public/exec.c
+++ b/xv6-paging/exec.c
@@ -17,20 +17,17 @@ exec(char *path, char **argv)
   struct inode *ip;
   struct proghdr ph;
   pde_t *pgdir, *oldpgdir;
-  struct proc *curproc = myproc();
 
   begin_op();
-
   if((ip = namei(path)) == 0){
     end_op();
-    cprintf("exec: fail\n");
     return -1;
   }
   ilock(ip);
   pgdir = 0;
 
   // Check ELF header
-  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
+  if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
     goto bad;
   if(elf.magic != ELF_MAGIC)
     goto bad;
@@ -38,6 +35,42 @@ exec(char *path, char **argv)
   if((pgdir = setupkvm()) == 0)
     goto bad;
 
+
+  // backup and reset proc fields
+#ifndef NONE
+  //TODO delete   cprintf("EXEC: NONE undefined (proc = %s)- backing up page info \n", proc->name);
+  int pagesinmem = proc->pagesinmem;
+  int pagesinswapfile = proc->pagesinswapfile;
+  int totalPageFaultCount = proc->totalPageFaultCount;
+  int totalPagedOutCount = proc->totalPagedOutCount;
+  struct freepg freepages[MAX_PSYC_PAGES];
+  struct pgdesc swappedpages[MAX_PSYC_PAGES];
+  for (i = 0; i < MAX_PSYC_PAGES; i++) {
+    freepages[i].va = proc->freepages[i].va;
+    proc->freepages[i].va = (char*)0xffffffff;
+    freepages[i].next = proc->freepages[i].next;
+    proc->freepages[i].next = 0;
+    freepages[i].prev = proc->freepages[i].prev;
+    proc->freepages[i].prev = 0;
+    freepages[i].age = proc->freepages[i].age;
+    proc->freepages[i].age = 0;
+    swappedpages[i].age = proc->swappedpages[i].age;
+    proc->swappedpages[i].age = 0;
+    swappedpages[i].va = proc->swappedpages[i].va;
+    proc->swappedpages[i].va = (char*)0xffffffff;
+    swappedpages[i].swaploc = proc->swappedpages[i].swaploc;
+    proc->swappedpages[i].swaploc = 0;
+  }
+  struct freepg *head = proc->head;
+  struct freepg *tail = proc->tail;
+  proc->pagesinmem = 0;
+  proc->pagesinswapfile = 0;
+  proc->totalPageFaultCount = 0;
+  proc->totalPagedOutCount = 0;
+  proc->head = 0;
+  proc->tail = 0;
+#endif
+
   // Load program into memory.
   sz = 0;
   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
@@ -47,12 +80,8 @@ exec(char *path, char **argv)
       continue;
     if(ph.memsz < ph.filesz)
       goto bad;
-    if(ph.vaddr + ph.memsz < ph.vaddr)
-      goto bad;
     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
       goto bad;
-    if(ph.vaddr % PGSIZE != 0)
-      goto bad;
     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
       goto bad;
   }
@@ -91,16 +120,25 @@ exec(char *path, char **argv)
   for(last=s=path; *s; s++)
     if(*s == '/')
       last = s+1;
-  safestrcpy(curproc->name, last, sizeof(curproc->name));
+  safestrcpy(proc->name, last, sizeof(proc->name));
 
   // Commit to the user image.
-  oldpgdir = curproc->pgdir;
-  curproc->pgdir = pgdir;
-  curproc->sz = sz;
-  curproc->tf->eip = elf.entry;  // main
-  curproc->tf->esp = sp;
-  switchuvm(curproc);
+  oldpgdir = proc->pgdir;
+  proc->pgdir = pgdir;
+  proc->sz = sz;
+  proc->tf->eip = elf.entry;  // main
+  proc->tf->esp = sp;
+  // a swap file has been created in fork(), but its content was of the
+  // parent process, and is no longer relevant.
+  removeSwapFile(proc);
+  createSwapFile(proc);
+  switchuvm(proc);
+  // TODO delete cprintf("freevm(oldpgdir)\n");
   freevm(oldpgdir);
+  cprintf("no. of pages allocated on exec:%d, pid:%d, name:%s\n", proc->pagesinmem, proc->pid, proc->name);
+  //if(strcmp(proc->name, "sh") == 0)
+    // if(SELECTION == FIFO)
+    //   cprintf("\n\n SHELL PRINTING FIFO\n\n");
   return 0;
 
  bad:
@@ -110,5 +148,22 @@ exec(char *path, char **argv)
     iunlockput(ip);
     end_op();
   }
+#ifndef NONE
+  proc->pagesinmem = pagesinmem;
+  proc->pagesinswapfile = pagesinswapfile;
+  proc->totalPageFaultCount = totalPageFaultCount;
+  proc->totalPagedOutCount = totalPagedOutCount;
+  proc->head = head;
+  proc->tail = tail;
+  for (i = 0; i < MAX_PSYC_PAGES; i++) {
+    proc->freepages[i].va = freepages[i].va;
+    proc->freepages[i].next = freepages[i].next;
+    proc->freepages[i].prev = freepages[i].prev;
+    proc->freepages[i].age = freepages[i].age;
+    proc->swappedpages[i].age = swappedpages[i].age;
+    proc->swappedpages[i].va = swappedpages[i].va;
+    proc->swappedpages[i].swaploc = swappedpages[i].swaploc;
+  }
+#endif
   return -1;
 }
diff --git a/xv6-public/file.c b/xv6-paging/file.c
index 24b32c2..558a330 100644
--- a/xv6-public/file.c
+++ b/xv6-paging/file.c
@@ -6,9 +6,8 @@
 #include "defs.h"
 #include "param.h"
 #include "fs.h"
-#include "spinlock.h"
-#include "sleeplock.h"
 #include "file.h"
+#include "spinlock.h"
 
 struct devsw devsw[NDEV];
 struct {
@@ -130,7 +129,7 @@ filewrite(struct file *f, char *addr, int n)
     // and 2 blocks of slop for non-aligned writes.
     // this really belongs lower down, since writei()
     // might be writing a device like the console.
-    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
+    int max = ((LOGSIZE-1-1-2) / 2) * 512;
     int i = 0;
     while(i < n){
       int n1 = n - i;
@@ -154,4 +153,3 @@ filewrite(struct file *f, char *addr, int n)
   }
   panic("filewrite");
 }
-
diff --git a/xv6-public/file.h b/xv6-paging/file.h
index 0990c82..5a4a463 100644
--- a/xv6-public/file.h
+++ b/xv6-paging/file.h
@@ -14,8 +14,7 @@ struct inode {
   uint dev;           // Device number
   uint inum;          // Inode number
   int ref;            // Reference count
-  struct sleeplock lock; // protects everything below here
-  int valid;          // inode has been read from disk?
+  int flags;          // I_BUSY, I_VALID
 
   short type;         // copy of disk inode
   short major;
@@ -24,6 +23,8 @@ struct inode {
   uint size;
   uint addrs[NDIRECT+1];
 };
+#define I_BUSY 0x1
+#define I_VALID 0x2
 
 // table mapping major device number to
 // device functions
@@ -35,3 +36,6 @@ struct devsw {
 extern struct devsw devsw[];
 
 #define CONSOLE 1
+
+//PAGEBREAK!
+// Blank page.
diff --git a/xv6-public/forktest.c b/xv6-paging/forktest.c
index 8bc984d..bb286e6 100644
--- a/xv6-public/forktest.c
+++ b/xv6-paging/forktest.c
@@ -8,7 +8,7 @@
 #define N  1000
 
 void
-printf(int fd, const char *s, ...)
+printf(int fd, char *s, ...)
 {
   write(fd, s, strlen(s));
 }
@@ -27,24 +27,24 @@ forktest(void)
     if(pid == 0)
       exit();
   }
-
+  
   if(n == N){
     printf(1, "fork claimed to work N times!\n", N);
     exit();
   }
-
+  
   for(; n > 0; n--){
     if(wait() < 0){
       printf(1, "wait stopped early\n");
       exit();
     }
   }
-
+  
   if(wait() != -1){
     printf(1, "wait got too many\n");
     exit();
   }
-
+  
   printf(1, "fork test OK\n");
 }
 
diff --git a/xv6-public/fs.c b/xv6-paging/fs.c
index f77275f..7cff550 100644
--- a/xv6-public/fs.c
+++ b/xv6-paging/fs.c
@@ -16,16 +16,13 @@
 #include "mmu.h"
 #include "proc.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "buf.h"
 #include "file.h"
 
 #define min(a, b) ((a) < (b) ? (a) : (b))
 static void itrunc(struct inode*);
-// there should be one superblock per disk device, but we run with
-// only one device
-struct superblock sb; 
+struct superblock sb;   // there should be one per dev, but we run with one dev
 
 // Read the super block.
 void
@@ -84,6 +81,7 @@ bfree(int dev, uint b)
   struct buf *bp;
   int bi, m;
 
+  readsb(dev, &sb);
   bp = bread(dev, BBLOCK(b, sb));
   bi = b % BPB;
   m = 1 << (bi % 8);
@@ -109,32 +107,34 @@ bfree(int dev, uint b)
 // to provide a place for synchronizing access
 // to inodes used by multiple processes. The cached
 // inodes include book-keeping information that is
-// not stored on disk: ip->ref and ip->valid.
+// not stored on disk: ip->ref and ip->flags.
 //
-// An inode and its in-memory representation go through a
+// An inode and its in-memory represtative go through a
 // sequence of states before they can be used by the
 // rest of the file system code.
 //
 // * Allocation: an inode is allocated if its type (on disk)
-//   is non-zero. ialloc() allocates, and iput() frees if
-//   the reference and link counts have fallen to zero.
+//   is non-zero. ialloc() allocates, iput() frees if
+//   the link count has fallen to zero.
 //
 // * Referencing in cache: an entry in the inode cache
 //   is free if ip->ref is zero. Otherwise ip->ref tracks
 //   the number of in-memory pointers to the entry (open
-//   files and current directories). iget() finds or
-//   creates a cache entry and increments its ref; iput()
-//   decrements ref.
+//   files and current directories). iget() to find or
+//   create a cache entry and increment its ref, iput()
+//   to decrement ref.
 //
 // * Valid: the information (type, size, &c) in an inode
-//   cache entry is only correct when ip->valid is 1.
-//   ilock() reads the inode from
-//   the disk and sets ip->valid, while iput() clears
-//   ip->valid if ip->ref has fallen to zero.
+//   cache entry is only correct when the I_VALID bit
+//   is set in ip->flags. ilock() reads the inode from
+//   the disk and sets I_VALID, while iput() clears
+//   I_VALID if ip->ref has fallen to zero.
 //
 // * Locked: file system code may only examine and modify
 //   the information in an inode and its content if it
-//   has first locked the inode.
+//   has first locked the inode. The I_BUSY flag indicates
+//   that the inode is locked. ilock() sets I_BUSY,
+//   while iunlock clears it.
 //
 // Thus a typical sequence is:
 //   ip = iget(dev, inum)
@@ -153,15 +153,6 @@ bfree(int dev, uint b)
 // Many internal file system functions expect the caller to
 // have locked the inodes involved; this lets callers create
 // multi-step atomic operations.
-//
-// The icache.lock spin-lock protects the allocation of icache
-// entries. Since ip->ref indicates whether an entry is free,
-// and ip->dev and ip->inum indicate which i-node an entry
-// holds, one must hold icache.lock while using any of those fields.
-//
-// An ip->lock sleep-lock protects all ip-> fields other than ref,
-// dev, and inum.  One must hold ip->lock in order to
-// read or write that inode's ip->valid, ip->size, ip->type, &c.
 
 struct {
   struct spinlock lock;
@@ -171,26 +162,17 @@ struct {
 void
 iinit(int dev)
 {
-  int i = 0;
-  
   initlock(&icache.lock, "icache");
-  for(i = 0; i < NINODE; i++) {
-    initsleeplock(&icache.inode[i].lock, "inode");
-  }
-
   readsb(dev, &sb);
-  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
- inodestart %d bmap start %d\n", sb.size, sb.nblocks,
-          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
-          sb.bmapstart);
+  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d inodestart %d bmap start %d\n", sb.size,
+          sb.nblocks, sb.ninodes, sb.nlog, sb.logstart, sb.inodestart, sb.bmapstart);
 }
 
 static struct inode* iget(uint dev, uint inum);
 
 //PAGEBREAK!
-// Allocate an inode on device dev.
-// Mark it as allocated by  giving it type type.
-// Returns an unlocked but allocated and referenced inode.
+// Allocate a new inode with the given type on device dev.
+// A free inode has a type of zero.
 struct inode*
 ialloc(uint dev, short type)
 {
@@ -214,9 +196,6 @@ ialloc(uint dev, short type)
 }
 
 // Copy a modified in-memory inode to disk.
-// Must be called after every change to an ip->xxx field
-// that lives on disk, since i-node cache is write-through.
-// Caller must hold ip->lock.
 void
 iupdate(struct inode *ip)
 {
@@ -265,7 +244,7 @@ iget(uint dev, uint inum)
   ip->dev = dev;
   ip->inum = inum;
   ip->ref = 1;
-  ip->valid = 0;
+  ip->flags = 0;
   release(&icache.lock);
 
   return ip;
@@ -293,9 +272,13 @@ ilock(struct inode *ip)
   if(ip == 0 || ip->ref < 1)
     panic("ilock");
 
-  acquiresleep(&ip->lock);
+  acquire(&icache.lock);
+  while(ip->flags & I_BUSY)
+    sleep(ip, &icache.lock);
+  ip->flags |= I_BUSY;
+  release(&icache.lock);
 
-  if(ip->valid == 0){
+  if(!(ip->flags & I_VALID)){
     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
     dip = (struct dinode*)bp->data + ip->inum%IPB;
     ip->type = dip->type;
@@ -305,7 +288,7 @@ ilock(struct inode *ip)
     ip->size = dip->size;
     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
     brelse(bp);
-    ip->valid = 1;
+    ip->flags |= I_VALID;
     if(ip->type == 0)
       panic("ilock: no type");
   }
@@ -315,10 +298,13 @@ ilock(struct inode *ip)
 void
 iunlock(struct inode *ip)
 {
-  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+  if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
     panic("iunlock");
 
-  releasesleep(&ip->lock);
+  acquire(&icache.lock);
+  ip->flags &= ~I_BUSY;
+  wakeup(ip);
+  release(&icache.lock);
 }
 
 // Drop a reference to an in-memory inode.
@@ -331,22 +317,20 @@ iunlock(struct inode *ip)
 void
 iput(struct inode *ip)
 {
-  acquiresleep(&ip->lock);
-  if(ip->valid && ip->nlink == 0){
-    acquire(&icache.lock);
-    int r = ip->ref;
+  acquire(&icache.lock);
+  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+    // inode has no links and no other references: truncate and free.
+    if(ip->flags & I_BUSY)
+      panic("iput busy");
+    ip->flags |= I_BUSY;
     release(&icache.lock);
-    if(r == 1){
-      // inode has no links and no other references: truncate and free.
-      itrunc(ip);
-      ip->type = 0;
-      iupdate(ip);
-      ip->valid = 0;
-    }
+    itrunc(ip);
+    ip->type = 0;
+    iupdate(ip);
+    acquire(&icache.lock);
+    ip->flags = 0;
+    wakeup(ip);
   }
-  releasesleep(&ip->lock);
-
-  acquire(&icache.lock);
   ip->ref--;
   release(&icache.lock);
 }
@@ -435,7 +419,6 @@ itrunc(struct inode *ip)
 }
 
 // Copy stat information from inode.
-// Caller must hold ip->lock.
 void
 stati(struct inode *ip, struct stat *st)
 {
@@ -448,7 +431,6 @@ stati(struct inode *ip, struct stat *st)
 
 //PAGEBREAK!
 // Read data from inode.
-// Caller must hold ip->lock.
 int
 readi(struct inode *ip, char *dst, uint off, uint n)
 {
@@ -477,7 +459,6 @@ readi(struct inode *ip, char *dst, uint off, uint n)
 
 // PAGEBREAK!
 // Write data to inode.
-// Caller must hold ip->lock.
 int
 writei(struct inode *ip, char *src, uint off, uint n)
 {
@@ -532,7 +513,7 @@ dirlookup(struct inode *dp, char *name, uint *poff)
 
   for(off = 0; off < dp->size; off += sizeof(de)){
     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-      panic("dirlookup read");
+      panic("dirlink read");
     if(de.inum == 0)
       continue;
     if(namecmp(name, de.name) == 0){
@@ -629,7 +610,7 @@ namex(char *path, int nameiparent, char *name)
   if(*path == '/')
     ip = iget(ROOTDEV, ROOTINO);
   else
-    ip = idup(myproc()->cwd);
+    ip = idup(proc->cwd);
 
   while((path = skipelem(path, name)) != 0){
     ilock(ip);
@@ -668,3 +649,139 @@ nameiparent(char *path, char *name)
 {
   return namex(path, 1, name);
 }
+
+#include "fcntl.h"
+#define DIGITS 14
+
+char* itoa(int i, char b[]){
+    char const digit[] = "0123456789";
+    char* p = b;
+    if(i<0){
+        *p++ = '-';
+        i *= -1;
+    }
+    int shifter = i;
+    do{ //Move to where representation ends
+        ++p;
+        shifter = shifter/10;
+    }while(shifter);
+    *p = '\0';
+    do{ //Move back, inserting digits as u go
+        *--p = digit[i%10];
+        i = i/10;
+    }while(i);
+    return b;
+}
+//remove swap file of proc p;
+int
+removeSwapFile(struct proc* p)
+{
+	//path of proccess
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+	struct inode *ip, *dp;
+	struct dirent de;
+	char name[DIRSIZ];
+	uint off;
+
+  if(0 == p->swapFile) {
+    return -1;
+  }
+  fileclose(p->swapFile);
+
+	begin_op();
+	if((dp = nameiparent(path, name)) == 0)
+	{
+		end_op();
+		return -1;
+	}
+
+	ilock(dp);
+
+	  // Cannot unlink "." or "..".
+	if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+	   goto bad;
+
+	if((ip = dirlookup(dp, name, &off)) == 0)
+		goto bad;
+	ilock(ip);
+
+	if(ip->nlink < 1)
+		panic("unlink: nlink < 1");
+	if(ip->type == T_DIR && !isdirempty(ip)){
+		iunlockput(ip);
+		goto bad;
+	}
+
+	memset(&de, 0, sizeof(de));
+	if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+		panic("unlink: writei");
+	if(ip->type == T_DIR){
+		dp->nlink--;
+		iupdate(dp);
+	}
+	iunlockput(dp);
+
+	ip->nlink--;
+	iupdate(ip);
+	iunlockput(ip);
+
+	end_op();
+
+	return 0;
+
+	bad:
+		iunlockput(dp);
+		end_op();
+		return -1;
+
+}
+
+
+//return 0 on success
+int
+createSwapFile(struct proc* p)
+{
+
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+    begin_op();
+    struct inode * in = create(path, T_FILE, 0, 0);
+	iunlock(in);
+
+	p->swapFile = filealloc();
+	if (p->swapFile == 0)
+		panic("no slot for files on /store");
+
+	p->swapFile->ip = in;
+	p->swapFile->type = FD_INODE;
+	p->swapFile->off = 0;
+	p->swapFile->readable = O_WRONLY;
+	p->swapFile->writable = O_RDWR;
+    end_op();
+
+    return 0;
+}
+
+//return as sys_write (-1 when error)
+int
+writeToSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+  // cprintf("writeToSwapFile: buffer:0x%x placeOnFile:%x size:%d\n", buffer, placeOnFile, size);//TODO delete
+	return filewrite(p->swapFile, buffer, size);
+
+}
+
+//return as sys_read (-1 when error)
+int
+readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+  // cprintf("readFromSwapFile: buffer:0x%x placeOnFile:%x size:%d\n", buffer, placeOnFile, size);//TODO delete
+	return fileread(p->swapFile, buffer,  size);
+}
diff --git a/xv6-public/fs.h b/xv6-paging/fs.h
index 3214f1d..e1d7d09 100644
--- a/xv6-public/fs.h
+++ b/xv6-paging/fs.h
@@ -1,4 +1,4 @@
-// On-disk file system format.
+// On-disk file system format. 
 // Both the kernel and user programs use this header file.
 
 
@@ -6,11 +6,10 @@
 #define BSIZE 512  // block size
 
 // Disk layout:
-// [ boot block | super block | log | inode blocks |
-//                                          free bit map | data blocks]
+// [ boot block | super block | log | inode blocks | free bit map | data blocks ]
 //
-// mkfs computes the super block and builds an initial file system. The
-// super block describes the disk layout:
+// mkfs computes the super block and builds an initial file system. The super describes
+// the disk layout:
 struct superblock {
   uint size;         // Size of file system image (blocks)
   uint nblocks;      // Number of data blocks
diff --git a/xv6-public/grep.c b/xv6-paging/grep.c
index adc4835..28ff11a 100644
--- a/xv6-public/grep.c
+++ b/xv6-paging/grep.c
@@ -12,7 +12,7 @@ grep(char *pattern, int fd)
 {
   int n, m;
   char *p, *q;
-
+  
   m = 0;
   while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
     m += n;
@@ -40,13 +40,13 @@ main(int argc, char *argv[])
 {
   int fd, i;
   char *pattern;
-
+  
   if(argc <= 1){
     printf(2, "usage: grep pattern [file ...]\n");
     exit();
   }
   pattern = argv[1];
-
+  
   if(argc <= 2){
     grep(pattern, 0);
     exit();
diff --git a/xv6-public/ide.c b/xv6-paging/ide.c
index b4c0b1f..ed5a572 100644
--- a/xv6-public/ide.c
+++ b/xv6-paging/ide.c
@@ -9,7 +9,6 @@
 #include "x86.h"
 #include "traps.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "buf.h"
 
@@ -21,8 +20,6 @@
 
 #define IDE_CMD_READ  0x20
 #define IDE_CMD_WRITE 0x30
-#define IDE_CMD_RDMUL 0xc4
-#define IDE_CMD_WRMUL 0xc5
 
 // idequeue points to the buf now being read/written to the disk.
 // idequeue->qnext points to the next buf to be processed.
@@ -40,7 +37,7 @@ idewait(int checkerr)
 {
   int r;
 
-  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY) 
     ;
   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
     return -1;
@@ -51,11 +48,12 @@ void
 ideinit(void)
 {
   int i;
-
+  
   initlock(&idelock, "ide");
+  picenable(IRQ_IDE);
   ioapicenable(IRQ_IDE, ncpu - 1);
   idewait(0);
-
+  
   // Check if disk 1 is present
   outb(0x1f6, 0xe0 | (1<<4));
   for(i=0; i<1000; i++){
@@ -64,7 +62,7 @@ ideinit(void)
       break;
     }
   }
-
+  
   // Switch back to disk 0.
   outb(0x1f6, 0xe0 | (0<<4));
 }
@@ -79,11 +77,9 @@ idestart(struct buf *b)
     panic("incorrect blockno");
   int sector_per_block =  BSIZE/SECTOR_SIZE;
   int sector = b->blockno * sector_per_block;
-  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
-  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
 
   if (sector_per_block > 7) panic("idestart");
-
+  
   idewait(0);
   outb(0x3f6, 0);  // generate interrupt
   outb(0x1f2, sector_per_block);  // number of sectors
@@ -92,10 +88,10 @@ idestart(struct buf *b)
   outb(0x1f5, (sector >> 16) & 0xff);
   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
   if(b->flags & B_DIRTY){
-    outb(0x1f7, write_cmd);
+    outb(0x1f7, IDE_CMD_WRITE);
     outsl(0x1f0, b->data, BSIZE/4);
   } else {
-    outb(0x1f7, read_cmd);
+    outb(0x1f7, IDE_CMD_READ);
   }
 }
 
@@ -107,9 +103,9 @@ ideintr(void)
 
   // First queued buffer is the active request.
   acquire(&idelock);
-
   if((b = idequeue) == 0){
     release(&idelock);
+    // cprintf("spurious IDE interrupt\n");
     return;
   }
   idequeue = b->qnext;
@@ -117,12 +113,12 @@ ideintr(void)
   // Read data if needed.
   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
     insl(0x1f0, b->data, BSIZE/4);
-
+  
   // Wake process waiting for this buf.
   b->flags |= B_VALID;
   b->flags &= ~B_DIRTY;
   wakeup(b);
-
+  
   // Start disk on next buf in queue.
   if(idequeue != 0)
     idestart(idequeue);
@@ -131,7 +127,7 @@ ideintr(void)
 }
 
 //PAGEBREAK!
-// Sync buf with disk.
+// Sync buf with disk. 
 // If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
 // Else if B_VALID is not set, read buf from disk, set B_VALID.
 void
@@ -139,8 +135,8 @@ iderw(struct buf *b)
 {
   struct buf **pp;
 
-  if(!holdingsleep(&b->lock))
-    panic("iderw: buf not locked");
+  if(!(b->flags & B_BUSY))
+    panic("iderw: buf not busy");
   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
     panic("iderw: nothing to do");
   if(b->dev != 0 && !havedisk1)
@@ -153,16 +149,15 @@ iderw(struct buf *b)
   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
     ;
   *pp = b;
-
+  
   // Start disk if necessary.
   if(idequeue == b)
     idestart(b);
-
+  
   // Wait for request to finish.
   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
     sleep(b, &idelock);
   }
 
-
   release(&idelock);
 }
diff --git a/xv6-public/initcode.S b/xv6-paging/initcode.S
index 80ac5d8..109341a 100644
--- a/xv6-public/initcode.S
+++ b/xv6-paging/initcode.S
@@ -1,5 +1,4 @@
 # Initial process execs /init.
-# This code runs in user space.
 
 #include "syscall.h"
 #include "traps.h"
diff --git a/xv6-public/ioapic.c b/xv6-paging/ioapic.c
index cb0f015..d343611 100644
--- a/xv6-public/ioapic.c
+++ b/xv6-paging/ioapic.c
@@ -13,7 +13,7 @@
 #define REG_TABLE  0x10  // Redirection table base
 
 // The redirection table starts at REG_TABLE and uses
-// two registers to configure each interrupt.
+// two registers to configure each interrupt.  
 // The first (low) register in a pair contains configuration bits.
 // The second (high) register contains a bitmask telling which
 // CPUs can serve that interrupt.
@@ -50,6 +50,9 @@ ioapicinit(void)
 {
   int i, id, maxintr;
 
+  if(!ismp)
+    return;
+
   ioapic = (volatile struct ioapic*)IOAPIC;
   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
   id = ioapicread(REG_ID) >> 24;
@@ -67,6 +70,9 @@ ioapicinit(void)
 void
 ioapicenable(int irq, int cpunum)
 {
+  if(!ismp)
+    return;
+
   // Mark interrupt edge-triggered, active high,
   // enabled, and routed to the given cpunum,
   // which happens to be that cpu's APIC ID.
diff --git a/xv6-public/kalloc.c b/xv6-paging/kalloc.c
index 14cd4f4..e6bd7b4 100644
--- a/xv6-public/kalloc.c
+++ b/xv6-paging/kalloc.c
@@ -8,10 +8,12 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "spinlock.h"
+#include "kalloc.h"
+
+struct physPagesCounts physPagesCounts;
 
 void freerange(void *vstart, void *vend);
 extern char end[]; // first address after kernel loaded from ELF file
-                   // defined by the kernel linker script in kernel.ld
 
 struct run {
   struct run *next;
@@ -23,6 +25,7 @@ struct {
   struct run *freelist;
 } kmem;
 
+
 // Initialization happens in two phases.
 // 1. main() calls kinit1() while still using entrypgdir to place just
 // the pages mapped by entrypgdir on free list.
@@ -34,12 +37,26 @@ kinit1(void *vstart, void *vend)
   initlock(&kmem.lock, "kmem");
   kmem.use_lock = 0;
   freerange(vstart, vend);
+
+  // physPagesCounts is a struct defined in kalloc.h to hold info needed to cumpute percent of free physcal pages
+  // all physical pages allocated to the kernel's allocator's "freelist" are allocated in kinit1 & kinit2
+  // here we update the # of pages inserted to free list in kinit1
+  physPagesCounts.initPagesNo = (PGROUNDDOWN((uint)vend) - PGROUNDUP((uint)vstart)) / PGSIZE;
+  cprintf("physPagesCounts->initPagesNo = %d\n", physPagesCounts.initPagesNo );
+  //cprintf("physPagesCounts->currentFreePagesNo = %d\n", physPagesCounts.currentFreePagesNo );
 }
 
 void
 kinit2(void *vstart, void *vend)
 {
   freerange(vstart, vend);
+  // update the # of pages inserted to free list in kinit2
+  physPagesCounts.initPagesNo += (PGROUNDDOWN((uint)vend) - PGROUNDUP((uint)vstart)) / PGSIZE;
+  
+  //cprintf("physPagesCounts->initPagesNo = %d\n", physPagesCounts.initPagesNo );
+  //cprintf("physPagesCounts->currentFreePagesNo = %d\n", physPagesCounts.currentFreePagesNo );
+  //cprintf("percent of free physical pages: %d\n", physPagesCounts.currentFreePagesNo * 100 / physPagesCounts.initPagesNo);
+
   kmem.use_lock = 1;
 }
 
@@ -51,6 +68,7 @@ freerange(void *vstart, void *vend)
   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
     kfree(p);
 }
+
 //PAGEBREAK: 21
 // Free the page of physical memory pointed at by v,
 // which normally should have been returned by a
@@ -61,7 +79,7 @@ kfree(char *v)
 {
   struct run *r;
 
-  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
+  if((uint)v % PGSIZE || v < end || v2p(v) >= PHYSTOP)
     panic("kfree");
 
   // Fill with junk to catch dangling refs.
@@ -72,6 +90,7 @@ kfree(char *v)
   r = (struct run*)v;
   r->next = kmem.freelist;
   kmem.freelist = r;
+  physPagesCounts.currentFreePagesNo++;
   if(kmem.use_lock)
     release(&kmem.lock);
 }
@@ -87,10 +106,11 @@ kalloc(void)
   if(kmem.use_lock)
     acquire(&kmem.lock);
   r = kmem.freelist;
-  if(r)
+  if(r){
     kmem.freelist = r->next;
+    physPagesCounts.currentFreePagesNo--;
+  }
   if(kmem.use_lock)
     release(&kmem.lock);
   return (char*)r;
 }
-
diff --git a/xv6-paging/kalloc.h b/xv6-paging/kalloc.h
new file mode 100644
index 0000000..9477fda
--- /dev/null
+++ b/xv6-paging/kalloc.h
@@ -0,0 +1,7 @@
+// struct for keeping track of the percent of free physical pages
+struct physPagesCounts{
+  uint initPagesNo;
+  uint currentFreePagesNo;
+};
+
+extern struct physPagesCounts physPagesCounts;
diff --git a/xv6-public/kernel.ld b/xv6-paging/kernel.ld
index 4e12e14..e24c860 100644
--- a/xv6-public/kernel.ld
+++ b/xv6-paging/kernel.ld
@@ -26,12 +26,16 @@ SECTIONS
 		PROVIDE(__STAB_BEGIN__ = .);
 		*(.stab);
 		PROVIDE(__STAB_END__ = .);
+		BYTE(0)		/* Force the linker to allocate space
+				   for this section */
 	}
 
 	.stabstr : {
 		PROVIDE(__STABSTR_BEGIN__ = .);
 		*(.stabstr);
 		PROVIDE(__STABSTR_END__ = .);
+		BYTE(0)		/* Force the linker to allocate space
+				   for this section */
 	}
 
 	/* Adjust the address for the data segment to the next page */
diff --git a/xv6-public/lapic.c b/xv6-paging/lapic.c
index b22bbd7..4da4214 100644
--- a/xv6-public/lapic.c
+++ b/xv6-paging/lapic.c
@@ -1,7 +1,6 @@
 // The local APIC manages internal (non-I/O) interrupts.
 // See Chapter 8 & Appendix C of Intel processor manual volume 3.
 
-#include "param.h"
 #include "types.h"
 #include "defs.h"
 #include "date.h"
@@ -43,30 +42,30 @@
 
 volatile uint *lapic;  // Initialized in mp.c
 
-//PAGEBREAK!
 static void
 lapicw(int index, int value)
 {
   lapic[index] = value;
   lapic[ID];  // wait for write to finish, by reading
 }
+//PAGEBREAK!
 
 void
 lapicinit(void)
 {
-  if(!lapic)
+  if(!lapic) 
     return;
 
   // Enable local APIC; set spurious interrupt vector.
   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
 
   // The timer repeatedly counts down at bus frequency
-  // from lapic[TICR] and then issues an interrupt.
+  // from lapic[TICR] and then issues an interrupt.  
   // If xv6 cared more about precise timekeeping,
   // TICR would be calibrated using an external time source.
   lapicw(TDCR, X1);
   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
-  lapicw(TICR, 10000000);
+  lapicw(TICR, 10000000); 
 
   // Disable logical interrupt lines.
   lapicw(LINT0, MASKED);
@@ -98,11 +97,23 @@ lapicinit(void)
 }
 
 int
-lapicid(void)
+cpunum(void)
 {
-  if (!lapic)
-    return 0;
-  return lapic[ID] >> 24;
+  // Cannot call cpu when interrupts are enabled:
+  // result not guaranteed to last long enough to be used!
+  // Would prefer to panic but even printing is chancy here:
+  // almost everything, including cprintf and panic, calls cpu,
+  // often indirectly through acquire and release.
+  if(readeflags()&FL_IF){
+    static int n;
+    if(n++ == 0)
+      cprintf("cpu called from %x with interrupts enabled\n",
+        __builtin_return_address(0));
+  }
+
+  if(lapic)
+    return lapic[ID]>>24;
+  return 0;
 }
 
 // Acknowledge interrupt.
@@ -130,7 +141,7 @@ lapicstartap(uchar apicid, uint addr)
 {
   int i;
   ushort *wrv;
-
+  
   // "The BSP must initialize CMOS shutdown code to 0AH
   // and the warm reset vector (DWORD based at 40:67) to point at
   // the AP startup code prior to the [universal startup algorithm]."
@@ -147,7 +158,7 @@ lapicstartap(uchar apicid, uint addr)
   microdelay(200);
   lapicw(ICRLO, INIT | LEVEL);
   microdelay(100);    // should be 10ms, but too slow in Bochs!
-
+  
   // Send startup IPI (twice!) to enter code.
   // Regular hardware is supposed to only accept a STARTUP
   // when it is in the halted state due to an INIT.  So the second
@@ -171,8 +182,7 @@ lapicstartap(uchar apicid, uint addr)
 #define MONTH   0x08
 #define YEAR    0x09
 
-static uint
-cmos_read(uint reg)
+static uint cmos_read(uint reg)
 {
   outb(CMOS_PORT,  reg);
   microdelay(200);
@@ -180,8 +190,7 @@ cmos_read(uint reg)
   return inb(CMOS_RETURN);
 }
 
-static void
-fill_rtcdate(struct rtcdate *r)
+static void fill_rtcdate(struct rtcdate *r)
 {
   r->second = cmos_read(SECS);
   r->minute = cmos_read(MINS);
@@ -192,8 +201,7 @@ fill_rtcdate(struct rtcdate *r)
 }
 
 // qemu seems to use 24-hour GWT and the values are BCD encoded
-void
-cmostime(struct rtcdate *r)
+void cmostime(struct rtcdate *r)
 {
   struct rtcdate t1, t2;
   int sb, bcd;
@@ -203,17 +211,17 @@ cmostime(struct rtcdate *r)
   bcd = (sb & (1 << 2)) == 0;
 
   // make sure CMOS doesn't modify time while we read it
-  for(;;) {
+  for (;;) {
     fill_rtcdate(&t1);
-    if(cmos_read(CMOS_STATA) & CMOS_UIP)
+    if (cmos_read(CMOS_STATA) & CMOS_UIP)
         continue;
     fill_rtcdate(&t2);
-    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
+    if (memcmp(&t1, &t2, sizeof(t1)) == 0)
       break;
   }
 
   // convert
-  if(bcd) {
+  if (bcd) {
 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
     CONV(second);
     CONV(minute);
diff --git a/xv6-public/log.c b/xv6-paging/log.c
index a64c0f6..12db8ca 100644
--- a/xv6-public/log.c
+++ b/xv6-paging/log.c
@@ -2,7 +2,6 @@
 #include "defs.h"
 #include "param.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "buf.h"
 
@@ -32,7 +31,7 @@
 // Contents of the header block, used for both the on-disk header block
 // and to keep track in memory of logged block# before commit.
 struct logheader {
-  int n;
+  int n;   
   int block[LOGSIZE];
 };
 
@@ -66,7 +65,7 @@ initlog(int dev)
 }
 
 // Copy committed blocks from log to their home location
-static void
+static void 
 install_trans(void)
 {
   int tail;
@@ -76,7 +75,7 @@ install_trans(void)
     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
     memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
     bwrite(dbuf);  // write dst to disk
-    brelse(lbuf);
+    brelse(lbuf); 
     brelse(dbuf);
   }
 }
@@ -115,7 +114,7 @@ write_head(void)
 static void
 recover_from_log(void)
 {
-  read_head();
+  read_head();      
   install_trans(); // if committed, copy from log to disk
   log.lh.n = 0;
   write_head(); // clear the log
@@ -155,9 +154,7 @@ end_op(void)
     do_commit = 1;
     log.committing = 1;
   } else {
-    // begin_op() may be waiting for log space,
-    // and decrementing log.outstanding has decreased
-    // the amount of reserved space.
+    // begin_op() may be waiting for log space.
     wakeup(&log);
   }
   release(&log.lock);
@@ -174,7 +171,7 @@ end_op(void)
 }
 
 // Copy modified blocks from cache to log.
-static void
+static void 
 write_log(void)
 {
   int tail;
@@ -184,7 +181,7 @@ write_log(void)
     struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
     memmove(to->data, from->data, BSIZE);
     bwrite(to);  // write the log
-    brelse(from);
+    brelse(from); 
     brelse(to);
   }
 }
@@ -196,7 +193,7 @@ commit()
     write_log();     // Write modified blocks from cache to log
     write_head();    // Write header to disk -- the real commit
     install_trans(); // Now install writes to home locations
-    log.lh.n = 0;
+    log.lh.n = 0; 
     write_head();    // Erase the transaction from the log
   }
 }
diff --git a/xv6-public/ls.c b/xv6-paging/ls.c
index 2862913..b6ddd7f 100644
--- a/xv6-public/ls.c
+++ b/xv6-paging/ls.c
@@ -8,12 +8,12 @@ fmtname(char *path)
 {
   static char buf[DIRSIZ+1];
   char *p;
-
+  
   // Find first character after last slash.
   for(p=path+strlen(path); p >= path && *p != '/'; p--)
     ;
   p++;
-
+  
   // Return blank-padded name.
   if(strlen(p) >= DIRSIZ)
     return p;
@@ -29,23 +29,23 @@ ls(char *path)
   int fd;
   struct dirent de;
   struct stat st;
-
+  
   if((fd = open(path, 0)) < 0){
     printf(2, "ls: cannot open %s\n", path);
     return;
   }
-
+  
   if(fstat(fd, &st) < 0){
     printf(2, "ls: cannot stat %s\n", path);
     close(fd);
     return;
   }
-
+  
   switch(st.type){
   case T_FILE:
     printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
     break;
-
+  
   case T_DIR:
     if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
       printf(1, "ls: path too long\n");
diff --git a/xv6-paging/m.c b/xv6-paging/m.c
new file mode 100644
index 0000000..c7c48b6
--- /dev/null
+++ b/xv6-paging/m.c
@@ -0,0 +1,275 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "syscall.h"
+
+#define PGSIZE 4096
+#define DEBUG 0
+
+int
+main(int argc, char *argv[]){
+
+	#if FIFO
+
+	int i, j;
+	char *arr[14];
+	char input[10];
+	// Allocate all remaining 12 physical pages
+	for (i = 0; i < 12; ++i) {
+		arr[i] = sbrk(PGSIZE);
+		printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+	}
+	printf(1, "Called sbrk(PGSIZE) 12 times - all physical pages taken.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 15.
+	This allocation would cause page 0 to move to the swap file, but upon returning
+	to user space, a PGFLT would occur and pages 0,1 will be hot-swapped.
+	Afterwards, page 1 is in the swap file, the rest are in memory.
+	*/
+	arr[12] = sbrk(PGSIZE);
+	printf(1, "arr[12]=0x%x\n", arr[12]);
+	printf(1, "Called sbrk(PGSIZE) for the 13th time, a page fault should occur and one page in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 16.
+	This would cause page 2 to move to the swap file, but since it contains the
+	user stack, it would be hot-swapped with page 3.
+	Afterwards, pages 1 & 3 are in the swap file, the rest are in memory.
+	*/
+	arr[13] = sbrk(PGSIZE);
+	printf(1, "arr[13]=0x%x\n", arr[13]);
+	printf(1, "Called sbrk(PGSIZE) for the 14th time, a page fault should occur and two pages in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Access page 3, causing a PGFLT, since it is in the swap file. It would be
+	hot-swapped with page 4. Page 4 is accessed next, so another PGFLT is invoked,
+	and this process repeats a total of 5 times.
+	*/
+	for (i = 0; i < 5; i++) {
+		for (j = 0; j < PGSIZE; j++)
+			arr[i][j] = 'k';
+	}
+	printf(1, "5 page faults should have occurred.\nPress any key...\n");
+	gets(input, 10);
+
+	if (fork() == 0) {
+		printf(1, "Child code running.\n");
+		printf(1, "View statistics for pid %d, then press any key...\n", getpid());
+		gets(input, 10);
+
+		/*
+		The purpose of this write is to create a PGFLT in the child process, and
+		verify that it is caught and handled properly.
+		*/
+		arr[5][0] = 't';
+		printf(1, "A page fault should have occurred for page 8.\nPress any key to exit the child code.\n");
+		gets(input, 10);
+
+		exit();
+	}
+	else {
+		wait();
+
+		/*
+		Deallocate all the pages.
+		*/
+		sbrk(-14 * PGSIZE);
+		printf(1, "Deallocated all extra pages.\nPress any key to exit the father code.\n");
+		gets(input, 10);
+	}
+
+#elif SCFIFO
+	int i, j;
+	char *arr[14];
+	char input[10];
+
+	// TODO delete
+	printf(1, "myMemTest: testing SCFIFO... \n");
+
+	// Allocate all remaining 12 physical pages
+	for (i = 0; i < 12; ++i) {
+		arr[i] = sbrk(PGSIZE);
+		printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+	}
+	printf(1, "Called sbrk(PGSIZE) 12 times - all physical pages taken.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 15.
+	For this allocation, SCFIFO will consider moving page 0 to disk, but because it has been accessed, page 1 will be moved instead.
+	Afterwards, page 1 is in the swap file, the rest are in memory.
+	*/
+	arr[12] = sbrk(PGSIZE);
+	printf(1, "arr[12]=0x%x\n", arr[12]);
+	printf(1, "Called sbrk(PGSIZE) for the 13th time, no page fault should occur and one page in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 16.
+	For this allocation, SCFIFO will consider moving page 2 to disk, but because it has been accessed, page 3 will be moved instead.
+	Afterwards, pages 1 & 3 are in the swap file, the rest are in memory.
+	*/
+	arr[13] = sbrk(PGSIZE);
+	printf(1, "arr[13]=0x%x\n", arr[13]);
+	printf(1, "Called sbrk(PGSIZE) for the 14th time, no page fault should occur and two pages in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Access page 3, causing a PGFLT, since it is in the swap file. It would be
+	hot-swapped with page 4. Page 4 is accessed next, so another PGFLT is invoked,
+	and this process repeats a total of 5 times.
+	*/
+	for (i = 0; i < 5; i++) {
+		for (j = 0; j < PGSIZE; j++)
+			arr[i][j] = 'k';
+	}
+	printf(1, "5 page faults should have occurred.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	If DEBUG flag is defined as != 0 this is just another example showing 
+	that because SCFIFO doesn't page out accessed pages, no needless page faults occurr.
+	*/
+	if(DEBUG){
+		for (i = 0; i < 5; i++) {
+			printf(1, "Writing to address 0x%x\n", arr[i]);
+			arr[i][0] = 'k';
+		}
+		//printf(1, "No page faults should have occurred.\nPress any key...\n");
+		gets(input, 10);
+	}
+
+	if (fork() == 0) {
+		printf(1, "Child code running.\n");
+		printf(1, "View statistics for pid %d, then press any key...\n", getpid());
+		gets(input, 10);
+
+		/*
+		The purpose of this write is to create a PGFLT in the child process, and
+		verify that it is caught and handled properly.
+		*/
+		arr[5][0] = 'k';
+		printf(1, "A Page fault should have occurred in child proccess.\nPress any key to exit the child code.\n");
+		gets(input, 10);
+
+		exit();
+	}
+	else {
+		wait();
+
+		/*
+		Deallocate all the pages.
+		*/
+		sbrk(-14 * PGSIZE);
+		printf(1, "Deallocated all extra pages.\nPress any key to exit the father code.\n");
+		gets(input, 10);
+	}
+
+
+	#elif NFU
+	
+	int i, j;
+	char *arr[27];
+	char input[10];
+
+	// TODO delete
+	printf(1, "myMemTest: testing NFU... \n");
+
+	// Allocate all remaining 12 physical pages
+	for (i = 0; i < 12; ++i) {
+		arr[i] = sbrk(PGSIZE);
+		printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+	}
+	printf(1, "Called sbrk(PGSIZE) 12 times - all physical pages taken.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 15.
+	For this allocation, NFU will choose to move to disk the page that hasn't been accessed the longest (in this case page 1).
+	Afterwards, page 1 is in the swap file, the rest are in memory.
+	*/
+	arr[12] = sbrk(PGSIZE);
+	printf(1, "arr[12]=0x%x\n", arr[12]);
+	printf(1, "Called sbrk(PGSIZE) for the 13th time, no page fault should occur and one page in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 16.
+	For this allocation, NFU will choose to move to disk the page that hasn't been accessed the longest (in this case page 3)
+	Afterwards, pages 1 & 3 are in the swap file, the rest are in memory.
+	*/
+	arr[13] = sbrk(PGSIZE);
+	printf(1, "arr[13]=0x%x\n", arr[13]);
+	printf(1, "Called sbrk(PGSIZE) for the 14th time, no page fault should occur and two pages in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Access page 3, causing a PGFLT, since it is in the swap file. It would be
+	hot-swapped with page 4. Page 4 is accessed next, so another PGFLT is invoked,
+	and this process repeats a total of 5 times.
+	*/
+	for (i = 0; i < 5; i++) {
+		printf(1, "Writing to address 0x%x\n", arr[i]);
+		for (j = 0; j < PGSIZE; j++){
+			arr[i][j] = 'k';
+		}
+	}
+	printf(1, "5 page faults should have occurred.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	If DEBUG flag is defined as != 0 this is just another example showing 
+	that because NFU doesn't page out accessed pages, no needless page faults occurr.
+	*/
+	if(DEBUG){
+		for (i = 0; i < 5; i++){
+			printf(1, "Writing to address 0x%x\n", arr[i]);
+			arr[i][0] = 'k';
+		}
+		//printf(1, "No page faults should have occurred.\nPress any key...\n");
+		gets(input, 10);
+	}
+
+	if (fork() == 0) {
+		printf(1, "Child code running.\n");
+		printf(1, "View statistics for pid %d, then press any key...\n", getpid());
+		gets(input, 10);
+
+		/*
+		The purpose of this write is to create a PGFLT in the child process, and
+		verify that it is caught and handled properly.
+		*/
+		arr[5][0] = 'k';
+		//arr[5][0] = 't';
+		printf(1, "Page faults should have occurred in child proccess.\nPress any key to exit the child code.\n");
+		gets(input, 10);
+
+		exit();
+	}
+	else {
+		wait();
+
+		/*
+		Deallocate all the pages.
+		*/
+		sbrk(-14 * PGSIZE);
+		printf(1, "Deallocated all extra pages.\nPress any key to exit the father code.\n");
+		gets(input, 10);
+	}
+
+
+	#else
+	char* arr[50];
+	int i = 50;
+	printf(1, "Commencing user test for default paging policy.\nNo page faults should occur.\n");
+	for (i = 0; i < 50; i++) {
+		arr[i] = sbrk(PGSIZE);
+		printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+	}
+	#endif
+	exit();
+}
diff --git a/xv6-public/main.c b/xv6-paging/main.c
index 9924e64..40facc4 100644
--- a/xv6-public/main.c
+++ b/xv6-paging/main.c
@@ -19,29 +19,33 @@ main(void)
 {
   kinit1(end, P2V(4*1024*1024)); // phys page allocator
   kvmalloc();      // kernel page table
-  mpinit();        // detect other processors
-  lapicinit();     // interrupt controller
-  seginit();       // segment descriptors
-  picinit();       // disable pic
+  mpinit();        // collect info about this machine
+  lapicinit();
+  seginit();       // set up segments
+  cprintf("\ncpu%d: starting xv6\n\n", cpu->id);
+  picinit();       // interrupt controller
   ioapicinit();    // another interrupt controller
-  consoleinit();   // console hardware
+  consoleinit();   // I/O devices & their interrupts
   uartinit();      // serial port
   pinit();         // process table
   tvinit();        // trap vectors
   binit();         // buffer cache
   fileinit();      // file table
-  ideinit();       // disk 
+  ideinit();       // disk
+  if(!ismp)
+    timerinit();   // uniprocessor timer
   startothers();   // start other processors
   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
   userinit();      // first user process
-  mpmain();        // finish this processor's setup
+  // Finish setting up this processor in mpmain.
+  mpmain();
 }
 
 // Other CPUs jump here from entryother.S.
 static void
 mpenter(void)
 {
-  switchkvm();
+  switchkvm(); 
   seginit();
   lapicinit();
   mpmain();
@@ -51,9 +55,9 @@ mpenter(void)
 static void
 mpmain(void)
 {
-  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
+  cprintf("cpu%d: starting\n", cpu->id);
   idtinit();       // load idt register
-  xchg(&(mycpu()->started), 1); // tell startothers() we're up
+  xchg(&cpu->started, 1); // tell startothers() we're up
   scheduler();     // start running processes
 }
 
@@ -71,22 +75,22 @@ startothers(void)
   // Write entry code to unused memory at 0x7000.
   // The linker has placed the image of entryother.S in
   // _binary_entryother_start.
-  code = P2V(0x7000);
+  code = p2v(0x7000);
   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
 
   for(c = cpus; c < cpus+ncpu; c++){
-    if(c == mycpu())  // We've started already.
+    if(c == cpus+cpunum())  // We've started already.
       continue;
 
-    // Tell entryother.S what stack to use, where to enter, and what
+    // Tell entryother.S what stack to use, where to enter, and what 
     // pgdir to use. We cannot use kpgdir yet, because the AP processor
     // is running in low  memory, so we use entrypgdir for the APs too.
     stack = kalloc();
     *(void**)(code-4) = stack + KSTACKSIZE;
-    *(void(**)(void))(code-8) = mpenter;
-    *(int**)(code-12) = (void *) V2P(entrypgdir);
+    *(void**)(code-8) = mpenter;
+    *(int**)(code-12) = (void *) v2p(entrypgdir);
 
-    lapicstartap(c->apicid, V2P(code));
+    lapicstartap(c->id, v2p(code));
 
     // wait for cpu to finish mpmain()
     while(c->started == 0)
@@ -94,11 +98,10 @@ startothers(void)
   }
 }
 
-// The boot page table used in entry.S and entryother.S.
-// Page directories (and page tables) must start on page boundaries,
-// hence the __aligned__ attribute.
-// PTE_PS in a page directory entry enables 4Mbyte pages.
-
+// Boot page table used in entry.S and entryother.S.
+// Page directories (and page tables), must start on a page boundary,
+// hence the "__aligned__" attribute.  
+// Use PTE_PS in page directory entry to enable 4Mbyte pages.
 __attribute__((__aligned__(PGSIZE)))
 pde_t entrypgdir[NPDENTRIES] = {
   // Map VA's [0, 4MB) to PA's [0, 4MB)
@@ -113,4 +116,3 @@ pde_t entrypgdir[NPDENTRIES] = {
 // Blank page.
 //PAGEBREAK!
 // Blank page.
-
diff --git a/xv6-public/memide.c b/xv6-paging/memide.c
index ba267ac..91b7f92 100644
--- a/xv6-public/memide.c
+++ b/xv6-paging/memide.c
@@ -9,7 +9,6 @@
 #include "x86.h"
 #include "traps.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "buf.h"
 
@@ -32,7 +31,7 @@ ideintr(void)
   // no-op
 }
 
-// Sync buf with disk.
+// Sync buf with disk. 
 // If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
 // Else if B_VALID is not set, read buf from disk, set B_VALID.
 void
@@ -40,8 +39,8 @@ iderw(struct buf *b)
 {
   uchar *p;
 
-  if(!holdingsleep(&b->lock))
-    panic("iderw: buf not locked");
+  if(!(b->flags & B_BUSY))
+    panic("iderw: buf not busy");
   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
     panic("iderw: nothing to do");
   if(b->dev != 1)
@@ -50,7 +49,7 @@ iderw(struct buf *b)
     panic("iderw: block out of range");
 
   p = memdisk + b->blockno*BSIZE;
-
+  
   if(b->flags & B_DIRTY){
     b->flags &= ~B_DIRTY;
     memmove(p, b->data, BSIZE);
diff --git a/xv6-public/memlayout.h b/xv6-paging/memlayout.h
index d1615f7..ce9cdeb 100644
--- a/xv6-public/memlayout.h
+++ b/xv6-paging/memlayout.h
@@ -8,8 +8,15 @@
 #define KERNBASE 0x80000000         // First kernel virtual address
 #define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
 
+#ifndef __ASSEMBLER__
+
+static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }
+static inline void *p2v(uint a) { return (void *) ((a) + KERNBASE); }
+
+#endif
+
 #define V2P(a) (((uint) (a)) - KERNBASE)
-#define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
+#define P2V(a) (((void *) (a)) + KERNBASE)
 
 #define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
 #define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
diff --git a/xv6-public/mkfs.c b/xv6-paging/mkfs.c
index 8e011a7..0a10754 100644
--- a/xv6-public/mkfs.c
+++ b/xv6-paging/mkfs.c
@@ -22,7 +22,7 @@
 
 int nbitmap = FSSIZE/(BSIZE*8) + 1;
 int ninodeblocks = NINODES / IPB + 1;
-int nlog = LOGSIZE;
+int nlog = LOGSIZE;  
 int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
 int nblocks;  // Number of data blocks
 
@@ -134,7 +134,7 @@ main(int argc, char *argv[])
       perror(argv[i]);
       exit(1);
     }
-
+    
     // Skip leading _ in name when writing to file system.
     // The binaries are named _rm, _cat, etc. to keep the
     // build operating system from trying to execute them
diff --git a/xv6-public/mmu.h b/xv6-paging/mmu.h
index a82d8e2..c520a92 100644
--- a/xv6-public/mmu.h
+++ b/xv6-paging/mmu.h
@@ -2,25 +2,51 @@
 // x86 memory management unit (MMU).
 
 // Eflags register
+#define FL_CF           0x00000001      // Carry Flag
+#define FL_PF           0x00000004      // Parity Flag
+#define FL_AF           0x00000010      // Auxiliary carry Flag
+#define FL_ZF           0x00000040      // Zero Flag
+#define FL_SF           0x00000080      // Sign Flag
+#define FL_TF           0x00000100      // Trap Flag
 #define FL_IF           0x00000200      // Interrupt Enable
+#define FL_DF           0x00000400      // Direction Flag
+#define FL_OF           0x00000800      // Overflow Flag
+#define FL_IOPL_MASK    0x00003000      // I/O Privilege Level bitmask
+#define FL_IOPL_0       0x00000000      //   IOPL == 0
+#define FL_IOPL_1       0x00001000      //   IOPL == 1
+#define FL_IOPL_2       0x00002000      //   IOPL == 2
+#define FL_IOPL_3       0x00003000      //   IOPL == 3
+#define FL_NT           0x00004000      // Nested Task
+#define FL_RF           0x00010000      // Resume Flag
+#define FL_VM           0x00020000      // Virtual 8086 mode
+#define FL_AC           0x00040000      // Alignment Check
+#define FL_VIF          0x00080000      // Virtual Interrupt Flag
+#define FL_VIP          0x00100000      // Virtual Interrupt Pending
+#define FL_ID           0x00200000      // ID flag
 
 // Control Register flags
 #define CR0_PE          0x00000001      // Protection Enable
+#define CR0_MP          0x00000002      // Monitor coProcessor
+#define CR0_EM          0x00000004      // Emulation
+#define CR0_TS          0x00000008      // Task Switched
+#define CR0_ET          0x00000010      // Extension Type
+#define CR0_NE          0x00000020      // Numeric Errror
 #define CR0_WP          0x00010000      // Write Protect
+#define CR0_AM          0x00040000      // Alignment Mask
+#define CR0_NW          0x20000000      // Not Writethrough
+#define CR0_CD          0x40000000      // Cache Disable
 #define CR0_PG          0x80000000      // Paging
 
 #define CR4_PSE         0x00000010      // Page size extension
 
-// various segment selectors.
 #define SEG_KCODE 1  // kernel code
 #define SEG_KDATA 2  // kernel data+stack
-#define SEG_UCODE 3  // user code
-#define SEG_UDATA 4  // user data+stack
-#define SEG_TSS   5  // this process's task state
-
-// cpu->gdt[NSEGS] holds the above segments.
-#define NSEGS     6
+#define SEG_KCPU  3  // kernel per-cpu data
+#define SEG_UCODE 4  // user code
+#define SEG_UDATA 5  // user data+stack
+#define SEG_TSS   6  // this process's task state
 
+//PAGEBREAK!
 #ifndef __ASSEMBLER__
 // Segment Descriptor
 struct segdesc {
@@ -54,11 +80,23 @@ struct segdesc {
 
 // Application segment type bits
 #define STA_X       0x8     // Executable segment
+#define STA_E       0x4     // Expand down (non-executable segments)
+#define STA_C       0x4     // Conforming code segment (executable only)
 #define STA_W       0x2     // Writeable (non-executable segments)
 #define STA_R       0x2     // Readable (executable segments)
+#define STA_A       0x1     // Accessed
 
 // System segment type bits
+#define STS_T16A    0x1     // Available 16-bit TSS
+#define STS_LDT     0x2     // Local Descriptor Table
+#define STS_T16B    0x3     // Busy 16-bit TSS
+#define STS_CG16    0x4     // 16-bit Call Gate
+#define STS_TG      0x5     // Task Gate / Coum Transmitions
+#define STS_IG16    0x6     // 16-bit Interrupt Gate
+#define STS_TG16    0x7     // 16-bit Trap Gate
 #define STS_T32A    0x9     // Available 32-bit TSS
+#define STS_T32B    0xB     // Busy 32-bit TSS
+#define STS_CG32    0xC     // 32-bit Call Gate
 #define STS_IG32    0xE     // 32-bit Interrupt Gate
 #define STS_TG32    0xF     // 32-bit Trap Gate
 
@@ -84,6 +122,7 @@ struct segdesc {
 #define NPTENTRIES      1024    // # PTEs per page table
 #define PGSIZE          4096    // bytes mapped by a page
 
+#define PGSHIFT         12      // log2(PGSIZE)
 #define PTXSHIFT        12      // offset of PTX in a linear address
 #define PDXSHIFT        22      // offset of PDX in a linear address
 
@@ -94,7 +133,13 @@ struct segdesc {
 #define PTE_P           0x001   // Present
 #define PTE_W           0x002   // Writeable
 #define PTE_U           0x004   // User
+#define PTE_PWT         0x008   // Write-Through
+#define PTE_PCD         0x010   // Cache-Disable
+#define PTE_A           0x020   // Accessed
+#define PTE_D           0x040   // Dirty
 #define PTE_PS          0x080   // Page Size
+#define PTE_MBZ         0x180   // Bits must be zero
+#define PTE_PG          0x200   // Paged out to secondary storage
 
 // Address in page table or page directory entry
 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
@@ -144,13 +189,14 @@ struct taskstate {
   ushort iomb;       // I/O map base address
 };
 
+// PAGEBREAK: 12
 // Gate descriptors for interrupts and traps
 struct gatedesc {
   uint off_15_0 : 16;   // low 16 bits of offset in segment
   uint cs : 16;         // code segment selector
   uint args : 5;        // # args, 0 for interrupt/trap gates
   uint rsv1 : 3;        // reserved(should be zero I guess)
-  uint type : 4;        // type(STS_{IG32,TG32})
+  uint type : 4;        // type(STS_{TG,IG32,TG32})
   uint s : 1;           // must be 0 (system)
   uint dpl : 2;         // descriptor(meaning new) privilege level
   uint p : 1;           // Present
diff --git a/xv6-public/mp.c b/xv6-paging/mp.c
index 79bb0ad..5b52a98 100644
--- a/xv6-public/mp.c
+++ b/xv6-paging/mp.c
@@ -12,14 +12,22 @@
 #include "proc.h"
 
 struct cpu cpus[NCPU];
+static struct cpu *bcpu;
+int ismp;
 int ncpu;
 uchar ioapicid;
 
+int
+mpbcpu(void)
+{
+  return bcpu-cpus;
+}
+
 static uchar
 sum(uchar *addr, int len)
 {
   int i, sum;
-
+  
   sum = 0;
   for(i=0; i<len; i++)
     sum += addr[i];
@@ -32,7 +40,7 @@ mpsearch1(uint a, int len)
 {
   uchar *e, *p, *addr;
 
-  addr = P2V(a);
+  addr = p2v(a);
   e = addr+len;
   for(p = addr; p < e; p += sizeof(struct mp))
     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
@@ -77,7 +85,7 @@ mpconfig(struct mp **pmp)
 
   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
     return 0;
-  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+  conf = (struct mpconf*) p2v((uint) mp->physaddr);
   if(memcmp(conf, "PCMP", 4) != 0)
     return 0;
   if(conf->version != 1 && conf->version != 4)
@@ -92,24 +100,28 @@ void
 mpinit(void)
 {
   uchar *p, *e;
-  int ismp;
   struct mp *mp;
   struct mpconf *conf;
   struct mpproc *proc;
   struct mpioapic *ioapic;
 
+  bcpu = &cpus[0];
   if((conf = mpconfig(&mp)) == 0)
-    panic("Expect to run on an SMP");
+    return;
   ismp = 1;
   lapic = (uint*)conf->lapicaddr;
   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
     switch(*p){
     case MPPROC:
       proc = (struct mpproc*)p;
-      if(ncpu < NCPU) {
-        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
-        ncpu++;
+      if(ncpu != proc->apicid){
+        cprintf("mpinit: ncpu=%d apicid=%d\n", ncpu, proc->apicid);
+        ismp = 0;
       }
+      if(proc->flags & MPBOOT)
+        bcpu = &cpus[ncpu];
+      cpus[ncpu].id = ncpu;
+      ncpu++;
       p += sizeof(struct mpproc);
       continue;
     case MPIOAPIC:
@@ -123,12 +135,17 @@ mpinit(void)
       p += 8;
       continue;
     default:
+      cprintf("mpinit: unknown config type %x\n", *p);
       ismp = 0;
-      break;
     }
   }
-  if(!ismp)
-    panic("Didn't find a suitable machine");
+  if(!ismp){
+    // Didn't like what we found; fall back to no MP.
+    ncpu = 1;
+    lapic = 0;
+    ioapicid = 0;
+    return;
+  }
 
   if(mp->imcrp){
     // Bochs doesn't support IMCR, so this doesn't run on Bochs.
diff --git a/xv6-paging/myMemTest.c b/xv6-paging/myMemTest.c
new file mode 100644
index 0000000..c7c48b6
--- /dev/null
+++ b/xv6-paging/myMemTest.c
@@ -0,0 +1,275 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "syscall.h"
+
+#define PGSIZE 4096
+#define DEBUG 0
+
+int
+main(int argc, char *argv[]){
+
+	#if FIFO
+
+	int i, j;
+	char *arr[14];
+	char input[10];
+	// Allocate all remaining 12 physical pages
+	for (i = 0; i < 12; ++i) {
+		arr[i] = sbrk(PGSIZE);
+		printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+	}
+	printf(1, "Called sbrk(PGSIZE) 12 times - all physical pages taken.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 15.
+	This allocation would cause page 0 to move to the swap file, but upon returning
+	to user space, a PGFLT would occur and pages 0,1 will be hot-swapped.
+	Afterwards, page 1 is in the swap file, the rest are in memory.
+	*/
+	arr[12] = sbrk(PGSIZE);
+	printf(1, "arr[12]=0x%x\n", arr[12]);
+	printf(1, "Called sbrk(PGSIZE) for the 13th time, a page fault should occur and one page in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 16.
+	This would cause page 2 to move to the swap file, but since it contains the
+	user stack, it would be hot-swapped with page 3.
+	Afterwards, pages 1 & 3 are in the swap file, the rest are in memory.
+	*/
+	arr[13] = sbrk(PGSIZE);
+	printf(1, "arr[13]=0x%x\n", arr[13]);
+	printf(1, "Called sbrk(PGSIZE) for the 14th time, a page fault should occur and two pages in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Access page 3, causing a PGFLT, since it is in the swap file. It would be
+	hot-swapped with page 4. Page 4 is accessed next, so another PGFLT is invoked,
+	and this process repeats a total of 5 times.
+	*/
+	for (i = 0; i < 5; i++) {
+		for (j = 0; j < PGSIZE; j++)
+			arr[i][j] = 'k';
+	}
+	printf(1, "5 page faults should have occurred.\nPress any key...\n");
+	gets(input, 10);
+
+	if (fork() == 0) {
+		printf(1, "Child code running.\n");
+		printf(1, "View statistics for pid %d, then press any key...\n", getpid());
+		gets(input, 10);
+
+		/*
+		The purpose of this write is to create a PGFLT in the child process, and
+		verify that it is caught and handled properly.
+		*/
+		arr[5][0] = 't';
+		printf(1, "A page fault should have occurred for page 8.\nPress any key to exit the child code.\n");
+		gets(input, 10);
+
+		exit();
+	}
+	else {
+		wait();
+
+		/*
+		Deallocate all the pages.
+		*/
+		sbrk(-14 * PGSIZE);
+		printf(1, "Deallocated all extra pages.\nPress any key to exit the father code.\n");
+		gets(input, 10);
+	}
+
+#elif SCFIFO
+	int i, j;
+	char *arr[14];
+	char input[10];
+
+	// TODO delete
+	printf(1, "myMemTest: testing SCFIFO... \n");
+
+	// Allocate all remaining 12 physical pages
+	for (i = 0; i < 12; ++i) {
+		arr[i] = sbrk(PGSIZE);
+		printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+	}
+	printf(1, "Called sbrk(PGSIZE) 12 times - all physical pages taken.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 15.
+	For this allocation, SCFIFO will consider moving page 0 to disk, but because it has been accessed, page 1 will be moved instead.
+	Afterwards, page 1 is in the swap file, the rest are in memory.
+	*/
+	arr[12] = sbrk(PGSIZE);
+	printf(1, "arr[12]=0x%x\n", arr[12]);
+	printf(1, "Called sbrk(PGSIZE) for the 13th time, no page fault should occur and one page in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 16.
+	For this allocation, SCFIFO will consider moving page 2 to disk, but because it has been accessed, page 3 will be moved instead.
+	Afterwards, pages 1 & 3 are in the swap file, the rest are in memory.
+	*/
+	arr[13] = sbrk(PGSIZE);
+	printf(1, "arr[13]=0x%x\n", arr[13]);
+	printf(1, "Called sbrk(PGSIZE) for the 14th time, no page fault should occur and two pages in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Access page 3, causing a PGFLT, since it is in the swap file. It would be
+	hot-swapped with page 4. Page 4 is accessed next, so another PGFLT is invoked,
+	and this process repeats a total of 5 times.
+	*/
+	for (i = 0; i < 5; i++) {
+		for (j = 0; j < PGSIZE; j++)
+			arr[i][j] = 'k';
+	}
+	printf(1, "5 page faults should have occurred.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	If DEBUG flag is defined as != 0 this is just another example showing 
+	that because SCFIFO doesn't page out accessed pages, no needless page faults occurr.
+	*/
+	if(DEBUG){
+		for (i = 0; i < 5; i++) {
+			printf(1, "Writing to address 0x%x\n", arr[i]);
+			arr[i][0] = 'k';
+		}
+		//printf(1, "No page faults should have occurred.\nPress any key...\n");
+		gets(input, 10);
+	}
+
+	if (fork() == 0) {
+		printf(1, "Child code running.\n");
+		printf(1, "View statistics for pid %d, then press any key...\n", getpid());
+		gets(input, 10);
+
+		/*
+		The purpose of this write is to create a PGFLT in the child process, and
+		verify that it is caught and handled properly.
+		*/
+		arr[5][0] = 'k';
+		printf(1, "A Page fault should have occurred in child proccess.\nPress any key to exit the child code.\n");
+		gets(input, 10);
+
+		exit();
+	}
+	else {
+		wait();
+
+		/*
+		Deallocate all the pages.
+		*/
+		sbrk(-14 * PGSIZE);
+		printf(1, "Deallocated all extra pages.\nPress any key to exit the father code.\n");
+		gets(input, 10);
+	}
+
+
+	#elif NFU
+	
+	int i, j;
+	char *arr[27];
+	char input[10];
+
+	// TODO delete
+	printf(1, "myMemTest: testing NFU... \n");
+
+	// Allocate all remaining 12 physical pages
+	for (i = 0; i < 12; ++i) {
+		arr[i] = sbrk(PGSIZE);
+		printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+	}
+	printf(1, "Called sbrk(PGSIZE) 12 times - all physical pages taken.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 15.
+	For this allocation, NFU will choose to move to disk the page that hasn't been accessed the longest (in this case page 1).
+	Afterwards, page 1 is in the swap file, the rest are in memory.
+	*/
+	arr[12] = sbrk(PGSIZE);
+	printf(1, "arr[12]=0x%x\n", arr[12]);
+	printf(1, "Called sbrk(PGSIZE) for the 13th time, no page fault should occur and one page in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 16.
+	For this allocation, NFU will choose to move to disk the page that hasn't been accessed the longest (in this case page 3)
+	Afterwards, pages 1 & 3 are in the swap file, the rest are in memory.
+	*/
+	arr[13] = sbrk(PGSIZE);
+	printf(1, "arr[13]=0x%x\n", arr[13]);
+	printf(1, "Called sbrk(PGSIZE) for the 14th time, no page fault should occur and two pages in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Access page 3, causing a PGFLT, since it is in the swap file. It would be
+	hot-swapped with page 4. Page 4 is accessed next, so another PGFLT is invoked,
+	and this process repeats a total of 5 times.
+	*/
+	for (i = 0; i < 5; i++) {
+		printf(1, "Writing to address 0x%x\n", arr[i]);
+		for (j = 0; j < PGSIZE; j++){
+			arr[i][j] = 'k';
+		}
+	}
+	printf(1, "5 page faults should have occurred.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	If DEBUG flag is defined as != 0 this is just another example showing 
+	that because NFU doesn't page out accessed pages, no needless page faults occurr.
+	*/
+	if(DEBUG){
+		for (i = 0; i < 5; i++){
+			printf(1, "Writing to address 0x%x\n", arr[i]);
+			arr[i][0] = 'k';
+		}
+		//printf(1, "No page faults should have occurred.\nPress any key...\n");
+		gets(input, 10);
+	}
+
+	if (fork() == 0) {
+		printf(1, "Child code running.\n");
+		printf(1, "View statistics for pid %d, then press any key...\n", getpid());
+		gets(input, 10);
+
+		/*
+		The purpose of this write is to create a PGFLT in the child process, and
+		verify that it is caught and handled properly.
+		*/
+		arr[5][0] = 'k';
+		//arr[5][0] = 't';
+		printf(1, "Page faults should have occurred in child proccess.\nPress any key to exit the child code.\n");
+		gets(input, 10);
+
+		exit();
+	}
+	else {
+		wait();
+
+		/*
+		Deallocate all the pages.
+		*/
+		sbrk(-14 * PGSIZE);
+		printf(1, "Deallocated all extra pages.\nPress any key to exit the father code.\n");
+		gets(input, 10);
+	}
+
+
+	#else
+	char* arr[50];
+	int i = 50;
+	printf(1, "Commencing user test for default paging policy.\nNo page faults should occur.\n");
+	for (i = 0; i < 50; i++) {
+		arr[i] = sbrk(PGSIZE);
+		printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+	}
+	#endif
+	exit();
+}
diff --git a/xv6-public/picirq.c b/xv6-paging/picirq.c
index e26957f..ff86831 100644
--- a/xv6-public/picirq.c
+++ b/xv6-paging/picirq.c
@@ -1,3 +1,5 @@
+// Intel 8259A programmable interrupt controllers.
+
 #include "types.h"
 #include "x86.h"
 #include "traps.h"
@@ -6,14 +8,77 @@
 #define IO_PIC1         0x20    // Master (IRQs 0-7)
 #define IO_PIC2         0xA0    // Slave (IRQs 8-15)
 
-// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
+#define IRQ_SLAVE       2       // IRQ at which slave connects to master
+
+// Current IRQ mask.
+// Initial IRQ mask has interrupt 2 enabled (for slave 8259A).
+static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);
+
+static void
+picsetmask(ushort mask)
+{
+  irqmask = mask;
+  outb(IO_PIC1+1, mask);
+  outb(IO_PIC2+1, mask >> 8);
+}
+
+void
+picenable(int irq)
+{
+  picsetmask(irqmask & ~(1<<irq));
+}
+
+// Initialize the 8259A interrupt controllers.
 void
 picinit(void)
 {
   // mask all interrupts
   outb(IO_PIC1+1, 0xFF);
   outb(IO_PIC2+1, 0xFF);
-}
 
-//PAGEBREAK!
-// Blank page.
+  // Set up master (8259A-1)
+
+  // ICW1:  0001g0hi
+  //    g:  0 = edge triggering, 1 = level triggering
+  //    h:  0 = cascaded PICs, 1 = master only
+  //    i:  0 = no ICW4, 1 = ICW4 required
+  outb(IO_PIC1, 0x11);
+
+  // ICW2:  Vector offset
+  outb(IO_PIC1+1, T_IRQ0);
+
+  // ICW3:  (master PIC) bit mask of IR lines connected to slaves
+  //        (slave PIC) 3-bit # of slave's connection to master
+  outb(IO_PIC1+1, 1<<IRQ_SLAVE);
+
+  // ICW4:  000nbmap
+  //    n:  1 = special fully nested mode
+  //    b:  1 = buffered mode
+  //    m:  0 = slave PIC, 1 = master PIC
+  //      (ignored when b is 0, as the master/slave role
+  //      can be hardwired).
+  //    a:  1 = Automatic EOI mode
+  //    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
+  outb(IO_PIC1+1, 0x3);
+
+  // Set up slave (8259A-2)
+  outb(IO_PIC2, 0x11);                  // ICW1
+  outb(IO_PIC2+1, T_IRQ0 + 8);      // ICW2
+  outb(IO_PIC2+1, IRQ_SLAVE);           // ICW3
+  // NB Automatic EOI mode doesn't tend to work on the slave.
+  // Linux source code says it's "to be investigated".
+  outb(IO_PIC2+1, 0x3);                 // ICW4
+
+  // OCW3:  0ef01prs
+  //   ef:  0x = NOP, 10 = clear specific mask, 11 = set specific mask
+  //    p:  0 = no polling, 1 = polling mode
+  //   rs:  0x = NOP, 10 = read IRR, 11 = read ISR
+  outb(IO_PIC1, 0x68);             // clear specific mask
+  outb(IO_PIC1, 0x0a);             // read IRR by default
+
+  outb(IO_PIC2, 0x68);             // OCW3
+  outb(IO_PIC2, 0x0a);             // OCW3
+
+  if(irqmask != 0xFFFF)
+    picsetmask(irqmask);
+}
diff --git a/xv6-public/pipe.c b/xv6-paging/pipe.c
index e9abe7f..f76ed5c 100644
--- a/xv6-public/pipe.c
+++ b/xv6-paging/pipe.c
@@ -4,9 +4,8 @@
 #include "mmu.h"
 #include "proc.h"
 #include "fs.h"
-#include "spinlock.h"
-#include "sleeplock.h"
 #include "file.h"
+#include "spinlock.h"
 
 #define PIPESIZE 512
 
@@ -83,7 +82,7 @@ pipewrite(struct pipe *p, char *addr, int n)
   acquire(&p->lock);
   for(i = 0; i < n; i++){
     while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
-      if(p->readopen == 0 || myproc()->killed){
+      if(p->readopen == 0 || proc->killed){
         release(&p->lock);
         return -1;
       }
@@ -104,7 +103,7 @@ piperead(struct pipe *p, char *addr, int n)
 
   acquire(&p->lock);
   while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
-    if(myproc()->killed){
+    if(proc->killed){
       release(&p->lock);
       return -1;
     }
diff --git a/xv6-public/pr.pl b/xv6-paging/pr.pl
old mode 100755
new mode 100644
diff --git a/xv6-public/printf.c b/xv6-paging/printf.c
index b3298aa..9972b45 100644
--- a/xv6-public/printf.c
+++ b/xv6-paging/printf.c
@@ -37,7 +37,7 @@ printint(int fd, int xx, int base, int sgn)
 
 // Print to the given fd. Only understands %d, %x, %p, %s.
 void
-printf(int fd, const char *fmt, ...)
+printf(int fd, char *fmt, ...)
 {
   char *s;
   int c, i, state;
diff --git a/xv6-public/printpcs b/xv6-paging/printpcs
old mode 100755
new mode 100644
diff --git a/xv6-public/proc.c b/xv6-paging/proc.c
index 806b1b1..8e53d66 100644
--- a/xv6-public/proc.c
+++ b/xv6-paging/proc.c
@@ -6,7 +6,11 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "kalloc.h"
 
+//using 0x80000000 introduces "negative" numbers which r a pain in the ass!
+#define ADD_TO_AGE 0x40000000
+#define DEBUG 0
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
@@ -20,49 +24,54 @@ extern void trapret(void);
 
 static void wakeup1(void *chan);
 
-void
-pinit(void)
-{
-  initlock(&ptable.lock, "ptable");
-}
 
-// Must be called with interrupts disabled
-int
-cpuid() {
-  return mycpu()-cpus;
-}
+void
+NFUupdate(){
+  struct proc *p;
+  int i;
+  //TODO delete uint b4, after;//, newAge;
+  pte_t *pte, *pde, *pgtab;
 
-// Must be called with interrupts disabled to avoid the caller being
-// rescheduled between reading lapicid and running through the loop.
-struct cpu*
-mycpu(void)
-{
-  int apicid, i;
-  
-  if(readeflags()&FL_IF)
-    panic("mycpu called with interrupts enabled\n");
-  
-  apicid = lapicid();
-  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
-  // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i) {
-    if (cpus[i].apicid == apicid)
-      return &cpus[i];
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if((p->state == RUNNING || p->state == RUNNABLE || p->state == SLEEPING) && (p->pid > 2)){// && (strcmp(proc->name, "init") != 0 || strcmp(proc->name, "sh") != 0)) {
+      //TODO deletecprintf("NFUupdate: p->name: %s, update pages...\n", p->name);
+      for (i = 0; i < MAX_PSYC_PAGES; i++){
+        if (p->freepages[i].va == (char*)0xffffffff)
+          continue;
+        //TODO delete b4 = p->freepages[i].age;
+        ++p->freepages[i].age;
+        //after = p->freepages[i].age;
+        ++p->swappedpages[i].age;
+        //TODO delete p->freepages[i].age = p->freepages[i].age >> 1;
+
+        //only dealing with pages in RAM
+        //might mean we have to check access bit b4 moving a page to disk so we don't miss a tick
+        pde = &p->pgdir[PDX(p->freepages[i].va)];
+        if(*pde & PTE_P){
+          pgtab = (pte_t*)p2v(PTE_ADDR(*pde));
+          pte = &pgtab[PTX(p->freepages[i].va)];
+        }
+        else pte = 0;
+        if(pte)
+          //TODO verify if need to add this to where a page is moved to disc
+          if(*pte & PTE_A){
+            p->freepages[i].age = 0;
+            //p->freepages[i].age |= ADD_TO_AGE;
+            //(*pte) &= ~PTE_A;
+            //TODO delete newAge = p->freepages[i].age;
+            //cprintf("\n\n===== proc: %s,  page No. %d,  after: %d, bf: %d \n\n", p->name, i, after, b4);
+          }
+      }
+    }
   }
-  panic("unknown apicid\n");
+  release(&ptable.lock);
 }
 
-// Disable interrupts so that we are not rescheduled
-// while reading proc from the cpu structure
-struct proc*
-myproc(void) {
-  struct cpu *c;
-  struct proc *p;
-  pushcli();
-  c = mycpu();
-  p = c->proc;
-  popcli();
-  return p;
+void
+pinit(void)
+{
+  initlock(&ptable.lock, "ptable");
 }
 
 //PAGEBREAK: 32
@@ -75,20 +84,18 @@ allocproc(void)
 {
   struct proc *p;
   char *sp;
+  int i;
 
   acquire(&ptable.lock);
-
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
     if(p->state == UNUSED)
       goto found;
-
   release(&ptable.lock);
   return 0;
 
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
-
   release(&ptable.lock);
 
   // Allocate kernel stack.
@@ -112,6 +119,23 @@ found:
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
+  // initialize process's page data
+  for (i = 0; i < MAX_PSYC_PAGES; i++) {
+    p->freepages[i].va = (char*)0xffffffff;
+    p->freepages[i].next = 0;
+    p->freepages[i].prev = 0;
+    p->freepages[i].age = 0;
+    p->swappedpages[i].age = 0;
+    p->swappedpages[i].swaploc = 0;
+    p->swappedpages[i].va = (char*)0xffffffff;
+  }
+  p->pagesinmem = 0;
+  p->pagesinswapfile = 0;
+  p->totalPageFaultCount = 0;
+  p->totalPagedOutCount = 0;
+  p->head = 0;
+  p->tail = 0;
+
   return p;
 }
 
@@ -124,7 +148,6 @@ userinit(void)
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
-  
   initproc = p;
   if((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
@@ -142,15 +165,7 @@ userinit(void)
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
 
-  // this assignment to p->state lets other cores
-  // run this process. the acquire forces the above
-  // writes to be visible, and the lock is also needed
-  // because the assignment might not be atomic.
-  acquire(&ptable.lock);
-
   p->state = RUNNABLE;
-
-  release(&ptable.lock);
 }
 
 // Grow current process's memory by n bytes.
@@ -159,18 +174,20 @@ int
 growproc(int n)
 {
   uint sz;
-  struct proc *curproc = myproc();
 
-  sz = curproc->sz;
+  sz = proc->sz;
   if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+    // TODO delete cprintf("growproc:allocuvm pid%d n:%d\n", proc->pid, n);
+    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
       return -1;
   } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+    // TODO delete cprintf("growproc:deallocuvm\n");
+    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
       return -1;
+    // proc->pagesinmem -= ((PGROUNDUP(sz) - PGROUNDUP(proc->sz)) % PGSIZE);
   }
-  curproc->sz = sz;
-  switchuvm(curproc);
+  proc->sz = sz;
+  switchuvm(proc);
   return 0;
 }
 
@@ -180,81 +197,229 @@ growproc(int n)
 int
 fork(void)
 {
-  int i, pid;
+  int i, j, pid;
   struct proc *np;
-  struct proc *curproc = myproc();
+
+    // if(SELECTION==FIFO)
+    //   cprintf("\n\n FIFO chosen!\n\n");
 
   // Allocate process.
-  if((np = allocproc()) == 0){
+  if((np = allocproc()) == 0)
     return -1;
-  }
 
-  // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+  // Copy process state from p.
+  // TODO delete cprintf("fork:copyuvm proc->pagesinmem:%d\n", proc->pagesinmem);
+  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
     return -1;
   }
-  np->sz = curproc->sz;
-  np->parent = curproc;
-  *np->tf = *curproc->tf;
+  // TODO delete cprintf("fork:copyuvm proc->pagesinmem:%d\n", proc->pagesinmem);
+  np->pagesinmem = proc->pagesinmem;
+  np->pagesinswapfile = proc->pagesinswapfile;
+  np->sz = proc->sz;
+  np->parent = proc;
+  *np->tf = *proc->tf;
 
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
   for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
-      np->ofile[i] = filedup(curproc->ofile[i]);
-  np->cwd = idup(curproc->cwd);
+    if(proc->ofile[i])
+      np->ofile[i] = filedup(proc->ofile[i]);
+  np->cwd = idup(proc->cwd);
 
-  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+  safestrcpy(np->name, proc->name, sizeof(proc->name));
 
   pid = np->pid;
 
-  acquire(&ptable.lock);
+  // // initialize process's page data
+  // for (i = 0; i < MAX_TOTAL_PAGES; i++) {
+  //   np->pages[i].inswapfile = proc->pages[i].inswapfile;
+  //   np->pages[i].swaploc = proc->pages[i].swaploc;
+  // }
+  // np->pagesinmem = 0;
+  createSwapFile(np);
+  char buf[PGSIZE / 2] = "";
+  int offset = 0;
+  int nread = 0;
+  // read the parent's swap file in chunks of size PGDIR/2, otherwise for some
+  // reason, you get "panic acquire" if buf is ~4000 bytes
+  if (strcmp(proc->name, "init") != 0 && strcmp(proc->name, "sh") != 0) {
+    while ((nread = readFromSwapFile(proc, buf, offset, PGSIZE / 2)) != 0) {
+      if (writeToSwapFile(np, buf, offset, nread) == -1)
+        panic("fork: error while writing the parent's swap file to the child");
+      offset += nread;
+    }
+  }
 
-  np->state = RUNNABLE;
+  // no need for this after all
+  //np->totalPageFaultCount = proc->totalPageFaultCount;
+  //np->totalPagedOutCount = proc->totalPagedOutCount;
+
+/*
+  char *diff = (char*)(&proc->freepages[0] - &np->freepages[0]);
+
+  for (i = 0; i < MAX_PSYC_PAGES; i++) {
+    np->freepages[i].va = proc->freepages[i].va;
+    np->freepages[i].next = (struct freepg *)((uint)proc->freepages[i].next + (uint)diff);
+    np->freepages[i].prev = (struct freepg *)((uint)proc->freepages[i].prev + (uint)diff);
+    np->freepages[i].age = proc->freepages[i].age;
+    np->swappedpages[i].age = proc->swappedpages[i].age;
+    np->swappedpages[i].va = proc->swappedpages[i].va;
+    np->swappedpages[i].swaploc = proc->swappedpages[i].swaploc;
+  }
+*/
+  for (i = 0; i < MAX_PSYC_PAGES; i++) {
+    np->freepages[i].va = proc->freepages[i].va;
+    np->freepages[i].age = proc->freepages[i].age;
+    np->swappedpages[i].age = proc->swappedpages[i].age;
+    np->swappedpages[i].va = proc->swappedpages[i].va;
+    np->swappedpages[i].swaploc = proc->swappedpages[i].swaploc;
+  }
+
+  for (i = 0; i < MAX_PSYC_PAGES; i++) 
+    for (j = 0; j < MAX_PSYC_PAGES; ++j)
+      if(np->freepages[j].va == proc->freepages[i].next->va)
+        np->freepages[i].next = &np->freepages[j];
+      if(np->freepages[j].va == proc->freepages[i].prev->va)
+        np->freepages[i].prev = &np->freepages[j];
+
+      
+  
+
+#if FIFO 
+  for (i = 0; i < MAX_PSYC_PAGES; i++) {
+    if (proc->head->va == np->freepages[i].va){
+      //TODO delete cprintf("\nfork: head copied!\n\n");
+      np->head = &np->freepages[i];
+    }
+    if (proc->tail->va == np->freepages[i].va)
+      np->tail = &np->freepages[i];
+  }
+#endif
+
+#if SCFIFO
+  for (i = 0; i < MAX_PSYC_PAGES; i++) {
+    if (proc->head->va == np->freepages[i].va){
+      //TODO delete       cprintf("\nfork: head copied!\n\n");
+      np->head = &np->freepages[i];
+    }
+    if (proc->tail->va == np->freepages[i].va){
+      np->tail = &np->freepages[i];
+      //cprintf("\nfork: head copied!\n\n");
+    }
+  }
+#endif
 
+  // lock to force the compiler to emit the np->state write last.
+  acquire(&ptable.lock);
+  np->state = RUNNABLE;
   release(&ptable.lock);
 
   return pid;
 }
 
+void
+printProcMemPageInfo(struct proc *proc){
+  static char *states[] = {
+  [UNUSED]    "unused",
+  [EMBRYO]    "embryo",
+  [SLEEPING]  "sleeping",
+  [RUNNABLE]  "runnable",
+  [RUNNING]   "running",
+  [ZOMBIE]    "zombie"
+  };
+  int i;
+  char *state;
+  uint pc[10];
+  struct freepg *l;
+
+  if(proc->state >= 0 && proc->state < NELEM(states) && states[proc->state])
+    state = states[proc->state];
+  else
+    state = "???";
+
+  // regular xv6 procdump printing
+  cprintf("\npid:%d state:%s name:%s\n", proc->pid, state, proc->name);
+
+  //print out memory pages info:
+  cprintf("No. of pages currently in physical memory: %d,\n", proc->pagesinmem);
+  cprintf("No. of pages currently paged out: %d,\n", proc->pagesinswapfile);
+  cprintf("Total No. of page faults: %d,\n", proc->totalPageFaultCount);
+  cprintf("Total number of paged out pages: %d,\n\n", proc->totalPagedOutCount);
+
+  // regular xv6 procdump printing
+  if(proc->state == SLEEPING){
+    getcallerpcs((uint*)proc->context->ebp+2, pc);
+    for(i=0; i<10 && pc[i] != 0; i++)
+      cprintf(" %p", pc[i]);
+  }
+  if(DEBUG){
+    for (i = 0; i < MAX_PSYC_PAGES; ++i)
+    {
+      if(proc->freepages[i].va != (char*)0xffffffff)
+        cprintf("freepages[%d].va = 0x%x \n", i, proc->freepages[i].va);
+    }
+    i = 0;
+    l = proc->head;
+    if(l == 0)
+      cprintf("proc->head == 0");
+    else {
+      cprintf("proc->head == 0x%x , i=%d\n", l->va, ++i);
+      while(l->next != 0){
+        l = l->next;
+        cprintf("next->va == 0x%x , i=%d\n", l->va, ++i);
+      }
+      cprintf("next link is null, list is finished!\n");
+    }
+    if(proc->tail != 0)
+      cprintf("tail->va == 0x%x \n", proc->tail->va);
+    }
+}
+
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
 void
 exit(void)
 {
-  struct proc *curproc = myproc();
   struct proc *p;
   int fd;
 
-  if(curproc == initproc)
+  if(proc == initproc)
     panic("init exiting");
 
   // Close all open files.
   for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
-      fileclose(curproc->ofile[fd]);
-      curproc->ofile[fd] = 0;
+    if(proc->ofile[fd]){
+      fileclose(proc->ofile[fd]);
+      proc->ofile[fd] = 0;
     }
   }
 
+  if (removeSwapFile(proc) != 0)
+    panic("exit: error deleting swap file");
+
+  #if TRUE
+  // sending proc as arg just to share func with procdump
+  printProcMemPageInfo(proc);
+  #endif
+
   begin_op();
-  iput(curproc->cwd);
+  iput(proc->cwd);
   end_op();
-  curproc->cwd = 0;
+  proc->cwd = 0;
 
   acquire(&ptable.lock);
 
   // Parent might be sleeping in wait().
-  wakeup1(curproc->parent);
+  wakeup1(proc->parent);
 
   // Pass abandoned children to init.
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
+    if(p->parent == proc){
       p->parent = initproc;
       if(p->state == ZOMBIE)
         wakeup1(initproc);
@@ -262,7 +427,7 @@ exit(void)
   }
 
   // Jump into the scheduler, never to return.
-  curproc->state = ZOMBIE;
+  proc->state = ZOMBIE;
   sched();
   panic("zombie exit");
 }
@@ -274,14 +439,13 @@ wait(void)
 {
   struct proc *p;
   int havekids, pid;
-  struct proc *curproc = myproc();
-  
+
   acquire(&ptable.lock);
   for(;;){
-    // Scan through table looking for exited children.
+    // Scan through table looking for zombie children.
     havekids = 0;
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
+      if(p->parent != proc)
         continue;
       havekids = 1;
       if(p->state == ZOMBIE){
@@ -289,25 +453,26 @@ wait(void)
         pid = p->pid;
         kfree(p->kstack);
         p->kstack = 0;
+        // TODO delete cprintf("freevm(p->pgdir)\n");
         freevm(p->pgdir);
+        p->state = UNUSED;
         p->pid = 0;
         p->parent = 0;
         p->name[0] = 0;
         p->killed = 0;
-        p->state = UNUSED;
         release(&ptable.lock);
         return pid;
       }
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
+    if(!havekids || proc->killed){
       release(&ptable.lock);
       return -1;
     }
 
     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
   }
 }
 
@@ -323,9 +488,7 @@ void
 scheduler(void)
 {
   struct proc *p;
-  struct cpu *c = mycpu();
-  c->proc = 0;
-  
+
   for(;;){
     // Enable interrupts on this processor.
     sti();
@@ -339,16 +502,19 @@ scheduler(void)
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
-      c->proc = p;
+      proc = p;
       switchuvm(p);
-      p->state = RUNNING;
 
-      swtch(&(c->scheduler), p->context);
+      // if (proc-> pid == 1 && proc->swapFile == 0)
+      //   createSwapFile(proc);
+
+      p->state = RUNNING;
+      swtch(&cpu->scheduler, proc->context);
       switchkvm();
 
       // Process is done running for now.
       // It should have changed its p->state before coming back.
-      c->proc = 0;
+      proc = 0;
     }
     release(&ptable.lock);
 
@@ -356,29 +522,24 @@ scheduler(void)
 }
 
 // Enter scheduler.  Must hold only ptable.lock
-// and have changed proc->state. Saves and restores
-// intena because intena is a property of this
-// kernel thread, not this CPU. It should
-// be proc->intena and proc->ncli, but that would
-// break in the few places where a lock is held but
-// there's no process.
+// and have changed proc->state.
 void
 sched(void)
 {
   int intena;
-  struct proc *p = myproc();
 
   if(!holding(&ptable.lock))
     panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
+  // cprintf("ncli:%d\n", cpu->ncli);//TODO delete
+  if(cpu->ncli != 1)
     panic("sched locks");
-  if(p->state == RUNNING)
+  if(proc->state == RUNNING)
     panic("sched running");
   if(readeflags()&FL_IF)
     panic("sched interruptible");
-  intena = mycpu()->intena;
-  swtch(&p->context, mycpu()->scheduler);
-  mycpu()->intena = intena;
+  intena = cpu->intena;
+  swtch(&proc->context, cpu->scheduler);
+  cpu->intena = intena;
 }
 
 // Give up the CPU for one scheduling round.
@@ -386,7 +547,7 @@ void
 yield(void)
 {
   acquire(&ptable.lock);  //DOC: yieldlock
-  myproc()->state = RUNNABLE;
+  proc->state = RUNNABLE;
   sched();
   release(&ptable.lock);
 }
@@ -417,9 +578,7 @@ forkret(void)
 void
 sleep(void *chan, struct spinlock *lk)
 {
-  struct proc *p = myproc();
-  
-  if(p == 0)
+  if(proc == 0)
     panic("sleep");
 
   if(lk == 0)
@@ -435,14 +594,14 @@ sleep(void *chan, struct spinlock *lk)
     acquire(&ptable.lock);  //DOC: sleeplock1
     release(lk);
   }
-  // Go to sleep.
-  p->chan = chan;
-  p->state = SLEEPING;
 
+  // Go to sleep.
+  proc->chan = chan;
+  proc->state = SLEEPING;
   sched();
 
   // Tidy up.
-  p->chan = 0;
+  proc->chan = 0;
 
   // Reacquire original lock.
   if(lk != &ptable.lock){  //DOC: sleeplock2
@@ -503,32 +662,18 @@ kill(int pid)
 void
 procdump(void)
 {
-  static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
-  int i;
+  int percent;
   struct proc *p;
-  char *state;
-  uint pc[10];
 
+  // cprintf("cr2:%p\n", rcr2());
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->state == UNUSED)
       continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
-      state = states[p->state];
-    else
-      state = "???";
-    cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
-        cprintf(" %p", pc[i]);
-    }
-    cprintf("\n");
+    printProcMemPageInfo(p);
   }
+
+  // print general (not per-process) physical memory pages info
+  percent = physPagesCounts.currentFreePagesNo * 100 / physPagesCounts.initPagesNo;
+  cprintf("\n\nPercent of free physical pages: %d/%d ~ 0.%d%% \n",  physPagesCounts.currentFreePagesNo,
+                                                                    physPagesCounts.initPagesNo , percent);
 }
diff --git a/xv6-public/proc.h b/xv6-paging/proc.h
index 1647114..7f9d794 100644
--- a/xv6-public/proc.h
+++ b/xv6-paging/proc.h
@@ -1,18 +1,38 @@
+// Segments in proc->gdt.
+#define NSEGS     7
+
+#define MAX_PSYC_PAGES 15
+#define MAX_TOTAL_PAGES 30
+
 // Per-CPU state
 struct cpu {
-  uchar apicid;                // Local APIC ID
+  uchar id;                    // Local APIC ID; index into cpus[] below
   struct context *scheduler;   // swtch() here to enter scheduler
   struct taskstate ts;         // Used by x86 to find stack for interrupt
   struct segdesc gdt[NSEGS];   // x86 global descriptor table
   volatile uint started;       // Has the CPU started?
   int ncli;                    // Depth of pushcli nesting.
   int intena;                  // Were interrupts enabled before pushcli?
-  struct proc *proc;           // The process running on this cpu or null
+
+  // Cpu-local storage variables; see below
+  struct cpu *cpu;
+  struct proc *proc;           // The currently-running process.
 };
 
 extern struct cpu cpus[NCPU];
 extern int ncpu;
 
+// Per-CPU variables, holding pointers to the
+// current cpu and to the current process.
+// The asm suffix tells gcc to use "%gs:0" to refer to cpu
+// and "%gs:4" to refer to proc.  seginit sets up the
+// %gs segment register so that %gs refers to the memory
+// holding those two variables in the local cpu's struct cpu.
+// This is similar to how thread-local variables are implemented
+// in thread libraries such as Linux pthreads.
+extern struct cpu *cpu asm("%gs:0");       // &cpus[cpunum()]
+extern struct proc *proc asm("%gs:4");     // cpus[cpunum()].proc
+
 //PAGEBREAK: 17
 // Saved registers for kernel context switches.
 // Don't need to save all the segment registers (%cs, etc),
@@ -34,6 +54,19 @@ struct context {
 
 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
+struct pgdesc {
+  uint swaploc;
+  int age;
+  char *va;
+};
+
+struct freepg {
+  char *va;
+  int age;
+  struct freepg *next;
+  struct freepg *prev;
+};
+
 // Per-process state
 struct proc {
   uint sz;                     // Size of process memory (bytes)
@@ -49,6 +82,18 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+  //Swap file. must initiate with create swap file
+  struct file *swapFile;			//page file
+
+  int pagesinmem;             // No. of pages in physical memory
+  int pagesinswapfile;        // No. of pages in swap file
+  int totalPageFaultCount;    // Total number of page faults for this process
+  int totalPagedOutCount;     // Total number of pages that were placed in the swap file
+  struct freepg freepages[MAX_PSYC_PAGES];  // Pre-allocated space for the pages in physical memory linked list
+  struct pgdesc swappedpages[MAX_PSYC_PAGES];// Pre-allocated space for the pages in swap file array
+  struct freepg *head;        // Head of the pages in physical memory linked list
+  struct freepg *tail;        // End of the pages in physical memory linked list
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/xv6-public/runoff b/xv6-paging/runoff
old mode 100755
new mode 100644
index be362d0..26593af
--- a/xv6-public/runoff
+++ b/xv6-paging/runoff
@@ -14,7 +14,6 @@ pad()
 mkdir -p fmt
 rm -f fmt/*
 cp README fmt
-echo > fmt/blank
 files=`grep -v '^#' runoff.list | awk '{print $1}'`
 n=99
 for i in $files
@@ -215,9 +214,7 @@ awk '
 	# pr -t -2 t.defs | ../pr.pl -h "definitions" | pad
 	pr -t -l50 -2 refs | ../pr.pl -h "cross-references" | pad
 	# pr.pl -h "definitions" -2 t.defs | pad
-	# pr.pl -h "cross-references" -2 refs | pad
-	../pr.pl blank  # make sheet 1 start on left page
-	../pr.pl blank
+	# pr.pl -h "cross-references" -2 refs | pad 
 	for i in $files
 	do
 		../pr.pl -h "xv6/$i" $i
diff --git a/xv6-public/runoff.list b/xv6-paging/runoff.list
index 2df9b81..73d39f7 100644
--- a/xv6-public/runoff.list
+++ b/xv6-paging/runoff.list
@@ -7,7 +7,6 @@ x86.h
 asm.h
 mmu.h
 elf.h
-date.h
 
 # entering xv6
 entry.S
@@ -36,14 +35,12 @@ sysproc.c
 
 # file system
 buf.h
-sleeplock.h
 fcntl.h
 stat.h
 fs.h
 file.h
 ide.c
 bio.c
-sleeplock.c
 log.c
 fs.c
 file.c
@@ -61,9 +58,11 @@ mp.h
 mp.c
 lapic.c
 ioapic.c
+picirq.c
 kbd.h
 kbd.c
 console.c
+timer.c
 uart.c
 
 # user-level
@@ -76,5 +75,3 @@ sh.c
 bootasm.S
 bootmain.c
 
-# link
-kernel.ld
diff --git a/xv6-public/runoff1 b/xv6-paging/runoff1
old mode 100755
new mode 100644
diff --git a/xv6-public/sh.c b/xv6-paging/sh.c
index 054bab9..d6a49ee 100644
--- a/xv6-public/sh.c
+++ b/xv6-paging/sh.c
@@ -147,7 +147,7 @@ main(void)
   static char buf[100];
   int fd;
 
-  // Ensure that three file descriptors are open.
+  // Assumes three file descriptors open.
   while((fd = open("console", O_RDWR)) >= 0){
     if(fd >= 3){
       close(fd);
@@ -155,10 +155,31 @@ main(void)
     }
   }
 
+  #ifdef FIFO
+    printf(1, "Paging policy: FIFO\n");
+  #endif
+
+  #ifdef SCFIFO
+  printf(1, "Paging policy: SCFIFO\n");
+  #endif
+
+  #ifdef NFU
+  printf(1, "Paging policy: NFU\n");
+  #endif
+
+  #ifdef NONE
+  printf(1, "Paging policy: NONE\n");
+  #endif
+
+  #if TRUE
+  printf(1, "Verbose printing selected.\n");
+  #endif
+
   // Read and run input commands.
   while(getcmd(buf, sizeof(buf)) >= 0){
     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
-      // Chdir must be called by the parent, not the child.
+      // Clumsy but will have to do for now.
+      // Chdir has no effect on the parent if run in the child.
       buf[strlen(buf)-1] = 0;  // chop \n
       if(chdir(buf+3) < 0)
         printf(2, "cannot cd %s\n", buf+3);
@@ -196,7 +217,7 @@ struct cmd*
 execcmd(void)
 {
   struct execcmd *cmd;
-
+  // TODO delete printf(1, "execcmd:malloc pid %d size %d\n", getpid(), sizeof(*cmd));
   cmd = malloc(sizeof(*cmd));
   memset(cmd, 0, sizeof(*cmd));
   cmd->type = EXEC;
diff --git a/xv6-public/show1 b/xv6-paging/show1
old mode 100755
new mode 100644
diff --git a/xv6-public/sleeplock.c b/xv6-public/sleeplock.c
deleted file mode 100644
index e0750ea..0000000
--- a/xv6-public/sleeplock.c
+++ /dev/null
@@ -1,56 +0,0 @@
-// Sleeping locks
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "x86.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-
-void
-initsleeplock(struct sleeplock *lk, char *name)
-{
-  initlock(&lk->lk, "sleep lock");
-  lk->name = name;
-  lk->locked = 0;
-  lk->pid = 0;
-}
-
-void
-acquiresleep(struct sleeplock *lk)
-{
-  acquire(&lk->lk);
-  while (lk->locked) {
-    sleep(lk, &lk->lk);
-  }
-  lk->locked = 1;
-  lk->pid = myproc()->pid;
-  release(&lk->lk);
-}
-
-void
-releasesleep(struct sleeplock *lk)
-{
-  acquire(&lk->lk);
-  lk->locked = 0;
-  lk->pid = 0;
-  wakeup(lk);
-  release(&lk->lk);
-}
-
-int
-holdingsleep(struct sleeplock *lk)
-{
-  int r;
-  
-  acquire(&lk->lk);
-  r = lk->locked && (lk->pid == myproc()->pid);
-  release(&lk->lk);
-  return r;
-}
-
-
-
diff --git a/xv6-public/sleeplock.h b/xv6-public/sleeplock.h
deleted file mode 100644
index 110e6f3..0000000
--- a/xv6-public/sleeplock.h
+++ /dev/null
@@ -1,10 +0,0 @@
-// Long-term locks for processes
-struct sleeplock {
-  uint locked;       // Is the lock held?
-  struct spinlock lk; // spinlock protecting this sleep lock
-  
-  // For debugging:
-  char *name;        // Name of lock.
-  int pid;           // Process holding lock
-};
-
diff --git a/xv6-public/spinlock.c b/xv6-paging/spinlock.c
index 4020186..a332662 100644
--- a/xv6-public/spinlock.c
+++ b/xv6-paging/spinlock.c
@@ -25,20 +25,19 @@ void
 acquire(struct spinlock *lk)
 {
   pushcli(); // disable interrupts to avoid deadlock.
-  if(holding(lk))
+  if(holding(lk)) {
+    cprintf("panic follows, lock:%s\n", lk->name);
     panic("acquire");
+  }
 
   // The xchg is atomic.
+  // It also serializes, so that reads after acquire are not
+  // reordered before it.
   while(xchg(&lk->locked, 1) != 0)
     ;
 
-  // Tell the C compiler and the processor to not move loads or stores
-  // past this point, to ensure that the critical section's memory
-  // references happen after the lock is acquired.
-  __sync_synchronize();
-
   // Record info about lock acquisition for debugging.
-  lk->cpu = mycpu();
+  lk->cpu = cpu;
   getcallerpcs(&lk, lk->pcs);
 }
 
@@ -52,17 +51,16 @@ release(struct spinlock *lk)
   lk->pcs[0] = 0;
   lk->cpu = 0;
 
-  // Tell the C compiler and the processor to not move loads or stores
-  // past this point, to ensure that all the stores in the critical
-  // section are visible to other cores before the lock is released.
-  // Both the C compiler and the hardware may re-order loads and
-  // stores; __sync_synchronize() tells them both not to.
-  __sync_synchronize();
-
-  // Release the lock, equivalent to lk->locked = 0.
-  // This code can't use a C assignment, since it might
-  // not be atomic. A real OS would use C atomics here.
-  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+  // The xchg serializes, so that reads before release are
+  // not reordered after it.  The 1996 PentiumPro manual (Volume 3,
+  // 7.2) says reads can be carried out speculatively and in
+  // any order, which implies we need to serialize here.
+  // But the 2007 Intel 64 Architecture Memory Ordering White
+  // Paper says that Intel 64 and IA-32 will not move a load
+  // after a store. So lock->locked = 0 would work here.
+  // The xchg being asm volatile ensures gcc emits it after
+  // the above assignments (and after the critical section).
+  xchg(&lk->locked, 0);
 
   popcli();
 }
@@ -89,11 +87,7 @@ getcallerpcs(void *v, uint pcs[])
 int
 holding(struct spinlock *lock)
 {
-  int r;
-  pushcli();
-  r = lock->locked && lock->cpu == mycpu();
-  popcli();
-  return r;
+  return lock->locked && lock->cpu == cpu;
 }
 
 
@@ -105,12 +99,10 @@ void
 pushcli(void)
 {
   int eflags;
-
   eflags = readeflags();
   cli();
-  if(mycpu()->ncli == 0)
-    mycpu()->intena = eflags & FL_IF;
-  mycpu()->ncli += 1;
+  if(cpu->ncli++ == 0)
+    cpu->intena = eflags & FL_IF;
 }
 
 void
@@ -118,9 +110,8 @@ popcli(void)
 {
   if(readeflags()&FL_IF)
     panic("popcli - interruptible");
-  if(--mycpu()->ncli < 0)
+  if(--cpu->ncli < 0)
     panic("popcli");
-  if(mycpu()->ncli == 0 && mycpu()->intena)
+  if(cpu->ncli == 0 && cpu->intena)
     sti();
 }
-
diff --git a/xv6-public/spinlock.h b/xv6-paging/spinlock.h
index 0a9d8e2..fdda016 100644
--- a/xv6-public/spinlock.h
+++ b/xv6-paging/spinlock.h
@@ -1,7 +1,7 @@
 // Mutual exclusion lock.
 struct spinlock {
   uint locked;       // Is the lock held?
-
+  
   // For debugging:
   char *name;        // Name of lock.
   struct cpu *cpu;   // The cpu holding the lock.
diff --git a/xv6-public/spinp b/xv6-paging/spinp
old mode 100755
new mode 100644
diff --git a/xv6-public/stressfs.c b/xv6-paging/stressfs.c
index c0a4743..6369400 100644
--- a/xv6-public/stressfs.c
+++ b/xv6-paging/stressfs.c
@@ -44,6 +44,6 @@ main(int argc, char *argv[])
   close(fd);
 
   wait();
-
+  
   exit();
 }
diff --git a/xv6-public/string.c b/xv6-paging/string.c
index a7cc61f..9077d1e 100644
--- a/xv6-public/string.c
+++ b/xv6-paging/string.c
@@ -103,3 +103,10 @@ strlen(const char *s)
   return n;
 }
 
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+}
diff --git a/xv6-public/swtch.S b/xv6-paging/swtch.S
index 63a7dcc..8751317 100644
--- a/xv6-public/swtch.S
+++ b/xv6-paging/swtch.S
@@ -2,16 +2,15 @@
 #
 #   void swtch(struct context **old, struct context *new);
 # 
-# Save the current registers on the stack, creating
-# a struct context, and save its address in *old.
-# Switch stacks to new and pop previously-saved registers.
+# Save current register context in old
+# and then load register context from new.
 
 .globl swtch
 swtch:
   movl 4(%esp), %eax
   movl 8(%esp), %edx
 
-  # Save old callee-saved registers
+  # Save old callee-save registers
   pushl %ebp
   pushl %ebx
   pushl %esi
@@ -21,7 +20,7 @@ swtch:
   movl %esp, (%eax)
   movl %edx, %esp
 
-  # Load new callee-saved registers
+  # Load new callee-save registers
   popl %edi
   popl %esi
   popl %ebx
diff --git a/xv6-paging/symlink.patch b/xv6-paging/symlink.patch
new file mode 100644
index 0000000..c7caf23
--- /dev/null
+++ b/xv6-paging/symlink.patch
@@ -0,0 +1,151 @@
+diff -r f8a4e40ab1d6 fs.c
+--- a/fs.c	Thu Aug 30 14:32:06 2007 -0400
++++ b/fs.c	Thu Aug 30 14:29:02 2007 -0400
+@@ -577,12 +577,18 @@ skipelem(char *path, char *name)
+ // If parent != 0, return the inode for the parent and copy the final
+ // path element into name, which must have room for DIRSIZ bytes.
+ static struct inode*
+-_namei(char *path, int parent, char *name)
++_namei(struct inode *root, char *path, int parent, char *name, int depth)
+ {
+   struct inode *ip, *next;
++  char buf[100], tname[DIRSIZ];
++
++  if(depth > 5)
++    return 0;
+ 
+   if(*path == '/')
+     ip = iget(ROOTDEV, 1);
++  else if(root)
++    ip = idup(root);
+   else
+     ip = idup(cp->cwd);
+ 
+@@ -598,10 +604,24 @@ _namei(char *path, int parent, char *nam
+       return ip;
+     }
+     if((next = dirlookup(ip, name, 0)) == 0){
++      cprintf("did not find %s\n", name);
+       iunlockput(ip);
+       return 0;
+     }
+-    iunlockput(ip);
++    iunlock(ip);
++    ilock(next);
++    if(next->type == T_SYMLINK){
++      if(next->size >= sizeof(buf) || readi(next, buf, 0, next->size) != next->size){
++        iunlockput(next);
++        iput(ip);
++        return 0;
++      }
++      buf[next->size] = 0;
++      iunlockput(next);
++      next = _namei(ip, buf, 0, tname, depth+1);
++    }else
++      iunlock(next);
++    iput(ip);
+     ip = next;
+   }
+   if(parent){
+@@ -615,11 +635,11 @@ namei(char *path)
+ namei(char *path)
+ {
+   char name[DIRSIZ];
+-  return _namei(path, 0, name);
++  return _namei(0, path, 0, name, 0);
+ }
+ 
+ struct inode*
+ nameiparent(char *path, char *name)
+ {
+-  return _namei(path, 1, name);
+-}
++  return _namei(0, path, 1, name, 0);
++}
+diff -r f8a4e40ab1d6 fs.h
+--- a/fs.h	Thu Aug 30 14:32:06 2007 -0400
++++ b/fs.h	Thu Aug 30 13:05:43 2007 -0400
+@@ -33,6 +33,7 @@ struct dinode {
+ #define T_DIR  1   // Directory
+ #define T_FILE 2   // File
+ #define T_DEV  3   // Special device
++#define T_SYMLINK 4  // Symlink
+ 
+ // Inodes per block.
+ #define IPB           (BSIZE / sizeof(struct dinode))
+diff -r f8a4e40ab1d6 syscall.c
+--- a/syscall.c	Thu Aug 30 14:32:06 2007 -0400
++++ b/syscall.c	Thu Aug 30 13:05:29 2007 -0400
+@@ -96,6 +96,7 @@ extern int sys_unlink(void);
+ extern int sys_unlink(void);
+ extern int sys_wait(void);
+ extern int sys_write(void);
++extern int sys_symlink(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_chdir]   sys_chdir,
+@@ -118,6 +119,7 @@ static int (*syscalls[])(void) = {
+ [SYS_unlink]  sys_unlink,
+ [SYS_wait]    sys_wait,
+ [SYS_write]   sys_write,
++[SYS_symlink]	sys_symlink,
+ };
+ 
+ void
+diff -r f8a4e40ab1d6 syscall.h
+--- a/syscall.h	Thu Aug 30 14:32:06 2007 -0400
++++ b/syscall.h	Thu Aug 30 13:02:48 2007 -0400
+@@ -19,3 +19,4 @@
+ #define SYS_getpid 18
+ #define SYS_sbrk   19
+ #define SYS_sleep  20
++#define SYS_symlink 21
+diff -r f8a4e40ab1d6 sysfile.c
+--- a/sysfile.c	Thu Aug 30 14:32:06 2007 -0400
++++ b/sysfile.c	Thu Aug 30 13:10:31 2007 -0400
+@@ -257,6 +257,21 @@ create(char *path, int canexist, short t
+ }
+ 
+ int
++sys_symlink(void)
++{
++  char *old, *new;
++  struct inode *ip;
++  
++  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
++    return -1;
++  if((ip = create(new, 0, T_SYMLINK, 0, 0)) == 0)
++    return -1;
++  writei(ip, old, 0, strlen(old));
++  iunlockput(ip);
++  return 0;
++}
++
++int
+ sys_open(void)
+ {
+   char *path;
+@@ -393,3 +408,4 @@ sys_pipe(void)
+   fd[1] = fd1;
+   return 0;
+ }
++
+diff -r f8a4e40ab1d6 user.h
+--- a/user.h	Thu Aug 30 14:32:06 2007 -0400
++++ b/user.h	Thu Aug 30 13:02:34 2007 -0400
+@@ -21,6 +21,7 @@ int getpid();
+ int getpid();
+ char* sbrk(int);
+ int sleep(int);
++int symlink(int);
+ 
+ // ulib.c
+ int stat(char*, struct stat*);
+diff -r f8a4e40ab1d6 usys.S
+--- a/usys.S	Thu Aug 30 14:32:06 2007 -0400
++++ b/usys.S	Thu Aug 30 13:05:54 2007 -0400
+@@ -28,3 +28,4 @@ STUB(getpid)
+ STUB(getpid)
+ STUB(sbrk)
+ STUB(sleep)
++STUB(symlink)
diff --git a/xv6-public/syscall.c b/xv6-paging/syscall.c
index ee85261..799ebc2 100644
--- a/xv6-public/syscall.c
+++ b/xv6-paging/syscall.c
@@ -17,9 +17,7 @@
 int
 fetchint(uint addr, int *ip)
 {
-  struct proc *curproc = myproc();
-
-  if(addr >= curproc->sz || addr+4 > curproc->sz)
+  if(addr >= proc->sz || addr+4 > proc->sz)
     return -1;
   *ip = *(int*)(addr);
   return 0;
@@ -32,16 +30,14 @@ int
 fetchstr(uint addr, char **pp)
 {
   char *s, *ep;
-  struct proc *curproc = myproc();
 
-  if(addr >= curproc->sz)
+  if(addr >= proc->sz)
     return -1;
   *pp = (char*)addr;
-  ep = (char*)curproc->sz;
-  for(s = *pp; s < ep; s++){
+  ep = (char*)proc->sz;
+  for(s = *pp; s < ep; s++)
     if(*s == 0)
       return s - *pp;
-  }
   return -1;
 }
 
@@ -49,21 +45,20 @@ fetchstr(uint addr, char **pp)
 int
 argint(int n, int *ip)
 {
-  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+  return fetchint(proc->tf->esp + 4 + 4*n, ip);
 }
 
 // Fetch the nth word-sized system call argument as a pointer
-// to a block of memory of size bytes.  Check that the pointer
+// to a block of memory of size n bytes.  Check that the pointer
 // lies within the process address space.
 int
 argptr(int n, char **pp, int size)
 {
   int i;
-  struct proc *curproc = myproc();
- 
+  
   if(argint(n, &i) < 0)
     return -1;
-  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+  if((uint)i >= proc->sz || (uint)i+size > proc->sz)
     return -1;
   *pp = (char*)i;
   return 0;
@@ -132,14 +127,13 @@ void
 syscall(void)
 {
   int num;
-  struct proc *curproc = myproc();
 
-  num = curproc->tf->eax;
+  num = proc->tf->eax;
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
-    curproc->tf->eax = syscalls[num]();
+    proc->tf->eax = syscalls[num]();
   } else {
     cprintf("%d %s: unknown sys call %d\n",
-            curproc->pid, curproc->name, num);
-    curproc->tf->eax = -1;
+            proc->pid, proc->name, num);
+    proc->tf->eax = -1;
   }
 }
diff --git a/xv6-public/sysfile.c b/xv6-paging/sysfile.c
index bfe61b7..7ee9e9e 100644
--- a/xv6-public/sysfile.c
+++ b/xv6-paging/sysfile.c
@@ -11,8 +11,6 @@
 #include "mmu.h"
 #include "proc.h"
 #include "fs.h"
-#include "spinlock.h"
-#include "sleeplock.h"
 #include "file.h"
 #include "fcntl.h"
 
@@ -26,7 +24,7 @@ argfd(int n, int *pfd, struct file **pf)
 
   if(argint(n, &fd) < 0)
     return -1;
-  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+  if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
     return -1;
   if(pfd)
     *pfd = fd;
@@ -41,11 +39,10 @@ static int
 fdalloc(struct file *f)
 {
   int fd;
-  struct proc *curproc = myproc();
 
   for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd] == 0){
-      curproc->ofile[fd] = f;
+    if(proc->ofile[fd] == 0){
+      proc->ofile[fd] = f;
       return fd;
     }
   }
@@ -57,7 +54,7 @@ sys_dup(void)
 {
   struct file *f;
   int fd;
-
+  
   if(argfd(0, 0, &f) < 0)
     return -1;
   if((fd=fdalloc(f)) < 0)
@@ -95,10 +92,10 @@ sys_close(void)
 {
   int fd;
   struct file *f;
-
+  
   if(argfd(0, &fd, &f) < 0)
     return -1;
-  myproc()->ofile[fd] = 0;
+  proc->ofile[fd] = 0;
   fileclose(f);
   return 0;
 }
@@ -108,7 +105,7 @@ sys_fstat(void)
 {
   struct file *f;
   struct stat *st;
-
+  
   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
     return -1;
   return filestat(f, st);
@@ -165,7 +162,7 @@ bad:
 }
 
 // Is the directory dp empty except for "." and ".." ?
-static int
+int
 isdirempty(struct inode *dp)
 {
   int off;
@@ -238,9 +235,10 @@ bad:
   return -1;
 }
 
-static struct inode*
+struct inode*
 create(char *path, short type, short major, short minor)
 {
+  uint off;
   struct inode *ip, *dp;
   char name[DIRSIZ];
 
@@ -248,7 +246,7 @@ create(char *path, short type, short major, short minor)
     return 0;
   ilock(dp);
 
-  if((ip = dirlookup(dp, name, 0)) != 0){
+  if((ip = dirlookup(dp, name, &off)) != 0){
     iunlockput(dp);
     ilock(ip);
     if(type == T_FILE && ip->type == T_FILE)
@@ -353,10 +351,11 @@ sys_mknod(void)
 {
   struct inode *ip;
   char *path;
+  int len;
   int major, minor;
-
+  
   begin_op();
-  if((argstr(0, &path)) < 0 ||
+  if((len=argstr(0, &path)) < 0 ||
      argint(1, &major) < 0 ||
      argint(2, &minor) < 0 ||
      (ip = create(path, T_DEV, major, minor)) == 0){
@@ -373,8 +372,7 @@ sys_chdir(void)
 {
   char *path;
   struct inode *ip;
-  struct proc *curproc = myproc();
-  
+
   begin_op();
   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
     end_op();
@@ -387,9 +385,9 @@ sys_chdir(void)
     return -1;
   }
   iunlock(ip);
-  iput(curproc->cwd);
+  iput(proc->cwd);
   end_op();
-  curproc->cwd = ip;
+  proc->cwd = ip;
   return 0;
 }
 
@@ -433,7 +431,7 @@ sys_pipe(void)
   fd0 = -1;
   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
     if(fd0 >= 0)
-      myproc()->ofile[fd0] = 0;
+      proc->ofile[fd0] = 0;
     fileclose(rf);
     fileclose(wf);
     return -1;
diff --git a/xv6-public/sysproc.c b/xv6-paging/sysproc.c
index 0686d29..b507ef8 100644
--- a/xv6-public/sysproc.c
+++ b/xv6-paging/sysproc.c
@@ -39,7 +39,7 @@ sys_kill(void)
 int
 sys_getpid(void)
 {
-  return myproc()->pid;
+  return proc->pid;
 }
 
 int
@@ -50,7 +50,11 @@ sys_sbrk(void)
 
   if(argint(0, &n) < 0)
     return -1;
-  addr = myproc()->sz;
+  addr = proc->sz;
+  if(n == -1){
+    checkProcAccBit();
+    return -1;
+  }
   if(growproc(n) < 0)
     return -1;
   return addr;
@@ -61,13 +65,13 @@ sys_sleep(void)
 {
   int n;
   uint ticks0;
-
+  
   if(argint(0, &n) < 0)
     return -1;
   acquire(&tickslock);
   ticks0 = ticks;
   while(ticks - ticks0 < n){
-    if(myproc()->killed){
+    if(proc->killed){
       release(&tickslock);
       return -1;
     }
@@ -83,7 +87,7 @@ int
 sys_uptime(void)
 {
   uint xticks;
-
+  
   acquire(&tickslock);
   xticks = ticks;
   release(&tickslock);
diff --git a/xv6-paging/timer.c b/xv6-paging/timer.c
new file mode 100644
index 0000000..8df75a9
--- /dev/null
+++ b/xv6-paging/timer.c
@@ -0,0 +1,32 @@
+// Intel 8253/8254/82C54 Programmable Interval Timer (PIT).
+// Only used on uniprocessors;
+// SMP machines use the local APIC timer.
+
+#include "types.h"
+#include "defs.h"
+#include "traps.h"
+#include "x86.h"
+
+#define IO_TIMER1       0x040           // 8253 Timer #1
+
+// Frequency of all three count-down timers;
+// (TIMER_FREQ/freq) is the appropriate count
+// to generate a frequency of freq Hz.
+
+#define TIMER_FREQ      1193182
+#define TIMER_DIV(x)    ((TIMER_FREQ+(x)/2)/(x))
+
+#define TIMER_MODE      (IO_TIMER1 + 3) // timer mode port
+#define TIMER_SEL0      0x00    // select counter 0
+#define TIMER_RATEGEN   0x04    // mode 2, rate generator
+#define TIMER_16BIT     0x30    // r/w counter 16 bits, LSB first
+
+void
+timerinit(void)
+{
+  // Interrupt 100 times/sec.
+  outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
+  outb(IO_TIMER1, TIMER_DIV(100) % 256);
+  outb(IO_TIMER1, TIMER_DIV(100) / 256);
+  picenable(IRQ_TIMER);
+}
diff --git a/xv6-public/trap.c b/xv6-paging/trap.c
index 41c66eb..5574c43 100644
--- a/xv6-public/trap.c
+++ b/xv6-paging/trap.c
@@ -6,6 +6,7 @@
 #include "proc.h"
 #include "x86.h"
 #include "traps.h"
+#include "types.h"
 #include "spinlock.h"
 
 // Interrupt descriptor table (shared by all CPUs).
@@ -36,20 +37,30 @@ idtinit(void)
 void
 trap(struct trapframe *tf)
 {
+  uint addr;
+  pde_t *vaddr;
+
   if(tf->trapno == T_SYSCALL){
-    if(myproc()->killed)
+    if(proc->killed)
       exit();
-    myproc()->tf = tf;
+    proc->tf = tf;
     syscall();
-    if(myproc()->killed)
+    if(proc->killed)
       exit();
     return;
   }
 
   switch(tf->trapno){
   case T_IRQ0 + IRQ_TIMER:
-    if(cpuid() == 0){
+    if(cpu->id == 0){
       acquire(&tickslock);
+
+      //NFUupdate();
+
+      #if NFU
+        NFUupdate();
+      #endif
+
       ticks++;
       wakeup(&ticks);
       release(&tickslock);
@@ -74,39 +85,52 @@ trap(struct trapframe *tf)
   case T_IRQ0 + 7:
   case T_IRQ0 + IRQ_SPURIOUS:
     cprintf("cpu%d: spurious interrupt at %x:%x\n",
-            cpuid(), tf->cs, tf->eip);
+            cpu->id, tf->cs, tf->eip);
     lapiceoi();
     break;
 
+  case T_PGFLT:
+    addr = rcr2();
+    vaddr = &proc->pgdir[PDX(addr)];
+    // cprintf("addr:0x%x vaddr:0x%x PDX:0x%x PTX:0x%x FLAGS:0x%x\n", addr, vaddr, PDX(*vaddr),PTX(*vaddr),PTE_FLAGS(*vaddr)); //TODO delete
+    // cprintf("&PTE_PG:%x &PTE_P:%x\n", (((uint*)PTE_ADDR(P2V(*vaddr)))[PTX(addr)] & PTE_PG), ((((uint*)PTE_ADDR(P2V(*vaddr)))[PTX(addr)] & PTE_P))); //TODO delete
+    if (((int)(*vaddr) & PTE_P) != 0) { // if page table isn't present at page directory -> hard page fault
+      if (((uint*)PTE_ADDR(P2V(*vaddr)))[PTX(addr)] & PTE_PG) { // if the page is in the process's swap file
+        // cprintf("page is in swap file, pid %d, va %p\n", proc->pid, addr); //TODO delete
+        swapPages(PTE_ADDR(addr));
+        ++proc->totalPageFaultCount;
+        // cprintf("proc->totalPageFaultCount:%d\n", ++proc->totalPageFaultCount);//TODO delete
+        return;
+      }
+    }
   //PAGEBREAK: 13
   default:
-    if(myproc() == 0 || (tf->cs&3) == 0){
+    if(proc == 0 || (tf->cs&3) == 0){
       // In kernel, it must be our mistake.
       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
-              tf->trapno, cpuid(), tf->eip, rcr2());
+              tf->trapno, cpu->id, tf->eip, rcr2());
       panic("trap");
     }
     // In user space, assume process misbehaved.
     cprintf("pid %d %s: trap %d err %d on cpu %d "
             "eip 0x%x addr 0x%x--kill proc\n",
-            myproc()->pid, myproc()->name, tf->trapno,
-            tf->err, cpuid(), tf->eip, rcr2());
-    myproc()->killed = 1;
+            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip,
+            rcr2());
+    proc->killed = 1;
   }
 
   // Force process exit if it has been killed and is in user space.
   // (If it is still executing in the kernel, let it keep running
   // until it gets to the regular system call return.)
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
     exit();
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(myproc() && myproc()->state == RUNNING &&
-     tf->trapno == T_IRQ0+IRQ_TIMER)
+  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
     yield();
 
   // Check if the process has been killed since we yielded
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
     exit();
 }
diff --git a/xv6-public/trapasm.S b/xv6-paging/trapasm.S
index da8aefc..787727f 100644
--- a/xv6-public/trapasm.S
+++ b/xv6-paging/trapasm.S
@@ -10,10 +10,13 @@ alltraps:
   pushl %gs
   pushal
   
-  # Set up data segments.
+  # Set up data and per-cpu segments.
   movw $(SEG_KDATA<<3), %ax
   movw %ax, %ds
   movw %ax, %es
+  movw $(SEG_KCPU<<3), %ax
+  movw %ax, %fs
+  movw %ax, %gs
 
   # Call trap(tf), where tf=%esp
   pushl %esp
diff --git a/xv6-public/uart.c b/xv6-paging/uart.c
index b8946da..576e254 100644
--- a/xv6-public/uart.c
+++ b/xv6-paging/uart.c
@@ -5,7 +5,6 @@
 #include "param.h"
 #include "traps.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "file.h"
 #include "mmu.h"
@@ -23,7 +22,7 @@ uartinit(void)
 
   // Turn off the FIFO
   outb(COM1+2, 0);
-
+  
   // 9600 baud, 8 data bits, 1 stop bit, parity off.
   outb(COM1+3, 0x80);    // Unlock divisor
   outb(COM1+0, 115200/9600);
@@ -41,8 +40,9 @@ uartinit(void)
   // enable interrupts.
   inb(COM1+2);
   inb(COM1+0);
+  picenable(IRQ_COM1);
   ioapicenable(IRQ_COM1, 0);
-
+  
   // Announce that we're here.
   for(p="xv6...\n"; *p; p++)
     uartputc(*p);
diff --git a/xv6-public/ulib.c b/xv6-paging/ulib.c
index 8e1e1a2..dbbcfcf 100644
--- a/xv6-public/ulib.c
+++ b/xv6-paging/ulib.c
@@ -5,7 +5,7 @@
 #include "x86.h"
 
 char*
-strcpy(char *s, const char *t)
+strcpy(char *s, char *t)
 {
   char *os;
 
@@ -24,7 +24,7 @@ strcmp(const char *p, const char *q)
 }
 
 uint
-strlen(const char *s)
+strlen(char *s)
 {
   int n;
 
@@ -68,7 +68,7 @@ gets(char *buf, int max)
 }
 
 int
-stat(const char *n, struct stat *st)
+stat(char *n, struct stat *st)
 {
   int fd;
   int r;
@@ -93,11 +93,10 @@ atoi(const char *s)
 }
 
 void*
-memmove(void *vdst, const void *vsrc, int n)
+memmove(void *vdst, void *vsrc, int n)
 {
-  char *dst;
-  const char *src;
-
+  char *dst, *src;
+  
   dst = vdst;
   src = vsrc;
   while(n-- > 0)
diff --git a/xv6-public/user.h b/xv6-paging/user.h
index 4f99c52..f45b8d5 100644
--- a/xv6-public/user.h
+++ b/xv6-paging/user.h
@@ -6,18 +6,18 @@ int fork(void);
 int exit(void) __attribute__((noreturn));
 int wait(void);
 int pipe(int*);
-int write(int, const void*, int);
+int write(int, void*, int);
 int read(int, void*, int);
 int close(int);
 int kill(int);
 int exec(char*, char**);
-int open(const char*, int);
-int mknod(const char*, short, short);
-int unlink(const char*);
+int open(char*, int);
+int mknod(char*, short, short);
+int unlink(char*);
 int fstat(int fd, struct stat*);
-int link(const char*, const char*);
-int mkdir(const char*);
-int chdir(const char*);
+int link(char*, char*);
+int mkdir(char*);
+int chdir(char*);
 int dup(int);
 int getpid(void);
 char* sbrk(int);
@@ -25,14 +25,14 @@ int sleep(int);
 int uptime(void);
 
 // ulib.c
-int stat(const char*, struct stat*);
-char* strcpy(char*, const char*);
-void *memmove(void*, const void*, int);
+int stat(char*, struct stat*);
+char* strcpy(char*, char*);
+void *memmove(void*, void*, int);
 char* strchr(const char*, char c);
 int strcmp(const char*, const char*);
-void printf(int, const char*, ...);
+void printf(int, char*, ...);
 char* gets(char*, int max);
-uint strlen(const char*);
+uint strlen(char*);
 void* memset(void*, int, uint);
 void* malloc(uint);
 void free(void*);
diff --git a/xv6-public/usertests.c b/xv6-paging/usertests.c
index a1e97e7..22a7bfb 100644
--- a/xv6-public/usertests.c
+++ b/xv6-paging/usertests.c
@@ -539,7 +539,7 @@ fourfiles(void)
         printf(1, "create failed\n");
         exit();
       }
-
+      
       memset(buf, '0'+pi, 512);
       for(i = 0; i < 12; i++){
         if((n = write(fd, buf, 500)) != 500){
@@ -882,7 +882,7 @@ linkunlink()
 
   if(pid)
     wait();
-  else
+  else 
     exit();
 
   printf(1, "linkunlink ok\n");
@@ -951,7 +951,7 @@ subdir(void)
   }
   write(fd, "ff", 2);
   close(fd);
-
+  
   if(unlink("dd") >= 0){
     printf(1, "unlink dd (non-empty dir) succeeded!\n");
     exit();
@@ -1390,24 +1390,24 @@ forktest(void)
     if(pid == 0)
       exit();
   }
-
+  
   if(n == 1000){
     printf(1, "fork claimed to work 1000 times!\n");
     exit();
   }
-
+  
   for(; n > 0; n--){
     if(wait() < 0){
       printf(1, "wait stopped early\n");
       exit();
     }
   }
-
+  
   if(wait() != -1){
     printf(1, "wait got too many\n");
     exit();
   }
-
+  
   printf(1, "fork test OK\n");
 }
 
@@ -1424,7 +1424,7 @@ sbrktest(void)
   // can one sbrk() less than a page?
   a = sbrk(0);
   int i;
-  for(i = 0; i < 5000; i++){
+  for(i = 0; i < 5000; i++){ 
     b = sbrk(1);
     if(b != a){
       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
@@ -1453,7 +1453,7 @@ sbrktest(void)
   a = sbrk(0);
   amt = (BIG) - (uint)a;
   p = sbrk(amt);
-  if (p != a) {
+  if (p != a) { 
     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
     exit();
   }
@@ -1492,7 +1492,7 @@ sbrktest(void)
     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
     exit();
   }
-
+  
   // can we read the kernel's memory?
   for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
     ppid = getpid();
@@ -1695,48 +1695,6 @@ fsfull()
   printf(1, "fsfull test finished\n");
 }
 
-void
-uio()
-{
-  #define RTC_ADDR 0x70
-  #define RTC_DATA 0x71
-
-  ushort port = 0;
-  uchar val = 0;
-  int pid;
-
-  printf(1, "uio test\n");
-  pid = fork();
-  if(pid == 0){
-    port = RTC_ADDR;
-    val = 0x09;  /* year */
-    /* http://wiki.osdev.org/Inline_Assembly/Examples */
-    asm volatile("outb %0,%1"::"a"(val), "d" (port));
-    port = RTC_DATA;
-    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
-    printf(1, "uio: uio succeeded; test FAILED\n");
-    exit();
-  } else if(pid < 0){
-    printf (1, "fork failed\n");
-    exit();
-  }
-  wait();
-  printf(1, "uio test done\n");
-}
-
-void argptest()
-{
-  int fd;
-  fd = open("init", O_RDONLY);
-  if (fd < 0) {
-    printf(2, "open failed\n");
-    exit();
-  }
-  read(fd, sbrk(0) - 1, -1);
-  close(fd);
-  printf(1, "arg test passed\n");
-}
-
 unsigned long randstate = 1;
 unsigned int
 rand()
@@ -1756,7 +1714,6 @@ main(int argc, char *argv[])
   }
   close(open("usertests.ran", O_CREATE));
 
-  argptest();
   createdelete();
   linkunlink();
   concreate();
@@ -1794,9 +1751,6 @@ main(int argc, char *argv[])
   iref();
   forktest();
   bigdir(); // slow
-
-  uio();
-
   exectest();
 
   exit();
diff --git a/xv6-public/vectors.pl b/xv6-paging/vectors.pl
old mode 100755
new mode 100644
diff --git a/xv6-public/vm.c b/xv6-paging/vm.c
index 7134cff..682b18b 100644
--- a/xv6-public/vm.c
+++ b/xv6-paging/vm.c
@@ -7,9 +7,17 @@
 #include "proc.h"
 #include "elf.h"
 
+#define BUF_SIZE PGSIZE/4
+#define MAX_POSSIBLE ~0x80000000
+//using 0x80000000 introduces "negative" numbers which r a pain in the ass!
+#define ADD_TO_AGE 0x40000000
+#define DEBUG 0
+
 extern char data[];  // defined by kernel.ld
 pde_t *kpgdir;  // for use in scheduler()
+struct segdesc gdt[NSEGS];
 
+int deallocCount = 0;
 // Set up CPU's kernel segment descriptors.
 // Run once on entry on each CPU.
 void
@@ -21,12 +29,21 @@ seginit(void)
   // Cannot share a CODE descriptor for both kernel and user
   // because it would have to have DPL_USR, but the CPU forbids
   // an interrupt from CPL=0 to DPL=3.
-  c = &cpus[cpuid()];
+  c = &cpus[cpunum()];
   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+
+  // Map cpu, and curproc
+  c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
+
   lgdt(c->gdt, sizeof(c->gdt));
+  loadgs(SEG_KCPU << 3);
+
+  // Initialize cpu-local storage.
+  cpu = c;
+  proc = 0;
 }
 
 // Return the address of the PTE in page table pgdir
@@ -40,7 +57,7 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
 
   pde = &pgdir[PDX(va)];
   if(*pde & PTE_P){
-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+    pgtab = (pte_t*)p2v(PTE_ADDR(*pde));
   } else {
     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
       return 0;
@@ -49,11 +66,28 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
     // The permissions here are overly generous, but they can
     // be further restricted by the permissions in the page table
     // entries, if necessary.
-    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+    *pde = v2p(pgtab) | PTE_P | PTE_W | PTE_U;
   }
   return &pgtab[PTX(va)];
 }
 
+void
+checkProcAccBit(){
+  int i;
+  pte_t *pte1;
+
+  //cprintf("checkAccessedBit\n");
+  for (i = 0; i < MAX_PSYC_PAGES; i++)
+    if (proc->freepages[i].va != (char*)0xffffffff){
+      pte1 = walkpgdir(proc->pgdir, (void*)proc->freepages[i].va, 0);
+      if (!*pte1){
+        cprintf("checkAccessedBit: pte1 is empty\n");
+        continue;
+      }
+      cprintf("checkAccessedBit: pte1 & PTE_A == %d\n", (*pte1) & PTE_A);
+    }
+}
+
 // Create PTEs for virtual addresses starting at va that refer to
 // physical addresses starting at pa. va and size might not
 // be page-aligned.
@@ -124,14 +158,12 @@ setupkvm(void)
   if((pgdir = (pde_t*)kalloc()) == 0)
     return 0;
   memset(pgdir, 0, PGSIZE);
-  if (P2V(PHYSTOP) > (void*)DEVSPACE)
+  if (p2v(PHYSTOP) > (void*)DEVSPACE)
     panic("PHYSTOP too high");
   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
-                (uint)k->phys_start, k->perm) < 0) {
-      freevm(pgdir);
+                (uint)k->phys_start, k->perm) < 0)
       return 0;
-    }
   return pgdir;
 }
 
@@ -149,31 +181,22 @@ kvmalloc(void)
 void
 switchkvm(void)
 {
-  lcr3(V2P(kpgdir));   // switch to the kernel page table
+  lcr3(v2p(kpgdir));   // switch to the kernel page table
 }
 
 // Switch TSS and h/w page table to correspond to process p.
 void
 switchuvm(struct proc *p)
 {
-  if(p == 0)
-    panic("switchuvm: no process");
-  if(p->kstack == 0)
-    panic("switchuvm: no kstack");
-  if(p->pgdir == 0)
-    panic("switchuvm: no pgdir");
-
   pushcli();
-  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
-                                sizeof(mycpu()->ts)-1, 0);
-  mycpu()->gdt[SEG_TSS].s = 0;
-  mycpu()->ts.ss0 = SEG_KDATA << 3;
-  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
-  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
-  // forbids I/O instructions (e.g., inb and outb) from user space
-  mycpu()->ts.iomb = (ushort) 0xFFFF;
+  cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
+  cpu->gdt[SEG_TSS].s = 0;
+  cpu->ts.ss0 = SEG_KDATA << 3;
+  cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
   ltr(SEG_TSS << 3);
-  lcr3(V2P(p->pgdir));  // switch to process's address space
+  if(p->pgdir == 0)
+    panic("switchuvm: no pgdir");
+  lcr3(v2p(p->pgdir));  // switch to new address space
   popcli();
 }
 
@@ -188,7 +211,7 @@ inituvm(pde_t *pgdir, char *init, uint sz)
     panic("inituvm: more than a page");
   mem = kalloc();
   memset(mem, 0, PGSIZE);
-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+  mappages(pgdir, 0, PGSIZE, v2p(mem), PTE_W|PTE_U);
   memmove(mem, init, sz);
 }
 
@@ -210,12 +233,288 @@ loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
       n = sz - i;
     else
       n = PGSIZE;
-    if(readi(ip, P2V(pa), offset+i, n) != n)
+    if(readi(ip, p2v(pa), offset+i, n) != n)
       return -1;
   }
   return 0;
 }
 
+void fifoRecord(char *va){
+  int i;
+  //TODO delete cprintf("rnp pid:%d count:%d va:0x%x\n", proc->pid, proc->pagesinmem, va);
+  for (i = 0; i < MAX_PSYC_PAGES; i++)
+    if (proc->freepages[i].va == (char*)0xffffffff)
+      goto foundrnp;
+  cprintf("panic follows, pid:%d, name:%s\n", proc->pid, proc->name);
+  panic("recordNewPage: no free pages");
+foundrnp:
+  proc->freepages[i].va = va;
+  proc->freepages[i].next = proc->head;
+  proc->head = &proc->freepages[i];
+}
+
+void scRecord(char *va){
+  int i;
+  //TODO delete cprintf("scRecord!\n");
+  for (i = 0; i < MAX_PSYC_PAGES; i++)
+    if (proc->freepages[i].va == (char*)0xffffffff)
+      goto foundrnp;
+  cprintf("panic follows, pid:%d, name:%s\n", proc->pid, proc->name);
+  panic("recordNewPage: no free pages");
+foundrnp:
+  //TODO delete cprintf("found unused page!\n");
+  proc->freepages[i].va = va;
+  proc->freepages[i].next = proc->head;
+  proc->freepages[i].prev = 0;
+  if(proc->head != 0)// old head points back to new head
+    proc->head->prev = &proc->freepages[i];
+  else//head == 0 so first link inserted is also the tail
+    proc->tail = &proc->freepages[i];
+  proc->head = &proc->freepages[i];
+}
+
+void nfuRecord(char *va){
+  int i;
+  //TODO delete cprintf("nfuRecord!\n");
+  for (i = 0; i < MAX_PSYC_PAGES; i++)
+    if (proc->freepages[i].va == (char*)0xffffffff)
+      goto foundrnp;
+  cprintf("panic follows, pid:%d, name:%s\n", proc->pid, proc->name);
+  panic("recordNewPage: no free pages");
+foundrnp:
+  //TODO delete cprintf("found unused page!\n");
+  proc->freepages[i].va = va;
+}
+
+void recordNewPage(char *va) {
+  //TODO delete $$$
+
+#if FIFO
+  //TODO cprintf("recordNewPage: %s is calling fifoRecord with: 0x%x\n", proc->name, va);
+  fifoRecord(va);
+#else
+
+#if SCFIFO
+  //TODO cprintf("recordNewPage: %s is calling scRecord with: 0x%x\n", proc->name, va);
+  scRecord(va);
+#else
+
+#if NFU
+  nfuRecord(va);
+#endif
+#endif
+#endif
+
+  proc->pagesinmem++;
+  //TODO delete cprintf("\n++++++++++++++++++ proc->pagesinmem+++++++++++++ : %d\n", proc->pagesinmem);
+}
+
+struct freepg *fifoWrite() {
+  int i;
+  struct freepg *link, *l;
+  for (i = 0; i < MAX_PSYC_PAGES; i++){
+    if (proc->swappedpages[i].va == (char*)0xffffffff)
+      goto foundswappedpageslot;
+  }
+  panic("writePageToSwapFile: FIFO no slot for swapped page");
+foundswappedpageslot:
+  link = proc->head;
+  if (link == 0)
+    panic("fifoWrite: proc->head is NULL");
+  if (link->next == 0)
+    panic("fifoWrite: single page in phys mem");
+  // find the before-last link in the used pages list
+  while (link->next->next != 0)
+    link = link->next;
+  l = link->next;
+  link->next = 0;
+
+  if(DEBUG){
+    //cprintf("\naddress between 0x%x and 0x%x was accessed but was on disk.\n", addr, addr+PGSIZE);
+    cprintf("FIFO chose to page out page starting at 0x%x \n\n", l->va);
+  }
+
+  proc->swappedpages[i].va = l->va;
+  int num = 0;
+  if ((num = writeToSwapFile(proc, (char*)PTE_ADDR(l->va), i * PGSIZE, PGSIZE)) == 0)
+    return 0;
+  // cprintf("written %d bytes to swap file, pid:%d, va:0x%x\n", num, proc->pid, l->va);//TODO delete
+  pte_t *pte1 = walkpgdir(proc->pgdir, (void*)l->va, 0);
+  if (!*pte1)
+    panic("writePageToSwapFile: pte1 is empty");
+  // pte_t *pte2 = walkpgdir(proc->pgdir, addr, 1);
+  // // if (!*pte2)
+  // //   panic("writePageToSwapFile: pte2 is empty");
+  // *pte2 = PTE_ADDR(*pte1) | PTE_U | PTE_P | PTE_W;
+  kfree((char*)PTE_ADDR(P2V_WO(*walkpgdir(proc->pgdir, l->va, 0))));
+  *pte1 = PTE_W | PTE_U | PTE_PG;
+  ++proc->totalPagedOutCount;
+  ++proc->pagesinswapfile;
+  // cprintf("writePage:proc->totalPagedOutCount:%d\n", ++proc->totalPagedOutCount);//TODO delete
+  // cprintf("writePage:proc->pagesinswapfile:%d\n", ++proc->pagesinswapfile);//TODO delete
+  lcr3(v2p(proc->pgdir));
+  return l;
+}
+
+int checkAccBit(char *va){
+  uint accessed;
+  pte_t *pte = walkpgdir(proc->pgdir, (void*)va, 0);
+  if (!*pte)
+    panic("checkAccBit: pte1 is empty");
+  accessed = (*pte) & PTE_A;
+  (*pte) &= ~PTE_A;
+  return accessed;
+}
+
+struct freepg *scWrite(char *va) {
+  //TODO delete  cprintf("scWrite: ");
+  int i;
+  struct freepg *mover, *oldTail;
+  for (i = 0; i < MAX_PSYC_PAGES; i++){
+    if (proc->swappedpages[i].va == (char*)0xffffffff)
+      goto foundswappedpageslot;
+  }
+  panic("writePageToSwapFile: FIFO no slot for swapped page");
+
+foundswappedpageslot:
+    //link = proc->head;
+  if (proc->head == 0)
+    panic("scWrite: proc->head is NULL");
+  if (proc->head->next == 0)
+    panic("scWrite: single page in phys mem");
+
+  mover = proc->tail;
+  oldTail = proc->tail;// to avoid infinite loop if everyone was accessed
+  do{
+    //move mover from tail to head
+    proc->tail = proc->tail->prev;
+    proc->tail->next = 0;
+    mover->prev = 0;
+    mover->next = proc->head;
+    proc->head->prev = mover;
+    proc->head = mover;
+    mover = proc->tail;
+  }while(checkAccBit(proc->head->va) && mover != oldTail);
+
+  if(DEBUG){
+    //cprintf("address between 0x%x and 0x%x was accessed but was on disk.\n\n", addr, addr+PGSIZE);
+    cprintf("SCFIFO chose to page out page starting at 0x%x \n\n", proc->head->va);
+  }
+
+  //make the swap
+  proc->swappedpages[i].va = proc->head->va;
+  int num = 0;
+  if ((num = writeToSwapFile(proc, (char*)PTE_ADDR(proc->head->va), i * PGSIZE, PGSIZE)) == 0)
+    return 0;
+
+  pte_t *pte1 = walkpgdir(proc->pgdir, (void*)proc->head->va, 0);
+  if (!*pte1)
+    panic("writePageToSwapFile: pte1 is empty");
+
+  kfree((char*)PTE_ADDR(P2V_WO(*walkpgdir(proc->pgdir, proc->head->va, 0))));
+  *pte1 = PTE_W | PTE_U | PTE_PG;
+  ++proc->totalPagedOutCount;
+  ++proc->pagesinswapfile;
+
+  //TODO delete   cprintf("++proc->pagesinswapfile : %d", proc->pagesinswapfile);
+
+  lcr3(v2p(proc->pgdir));
+  proc->head->va = va;
+
+  //TODO cprintf("scWrite: new addr in head: 0x%x\n", va);
+
+  // unnecessary but will do for now
+  return proc->head;
+}
+
+struct freepg *nfuWrite(char *va) {
+  int i, j;
+  uint maxIndx = -1, maxAge = 0; //MAX_POSSIBLE;
+  struct freepg *chosen;
+
+  for (i = 0; i < MAX_PSYC_PAGES; i++){
+    if (proc->swappedpages[i].va == (char*)0xffffffff)
+      goto foundswappedpageslot;
+  }
+  panic("writePageToSwapFile: FIFO no slot for swapped page");
+
+foundswappedpageslot:
+  for (j = 0; j < MAX_PSYC_PAGES; j++)
+    if (proc->freepages[j].va != (char*)0xffffffff){
+      //TODO delete      if(proc->freepages[j].age > 0)        cprintf("i=%d, age=%d, || ", j, proc->freepages[j].age);
+      if (proc->freepages[j].age > maxAge){//TODO <= not <
+        maxAge = proc->freepages[j].age;
+        maxIndx = j;
+      }
+      //TODO delete else cprintf("proc->freepages[j].age = %d and maxAge = %d\n", proc->freepages[j].age, maxAge);
+    }
+
+  if(maxIndx == -1)
+    panic("nfuWrite: no free page to swap???");
+  chosen = &proc->freepages[maxIndx];
+
+  if(DEBUG){
+    //cprintf("\naddress between 0x%x and 0x%x was accessed but was on disk.\n", addr, addr+PGSIZE);
+    cprintf("NFU chose to page out page starting at 0x%x \n\n", chosen->va);
+  }
+
+  pte_t *pte1 = walkpgdir(proc->pgdir, (void*)chosen->va, 0);
+  if (!*pte1)
+    panic("writePageToSwapFile: pte1 is empty");
+
+//  TODO verify: b4 accessing by writing to file,
+//  update accessed bit and age in case it misses a clock tick?
+//  be extra careful not to double add by locking
+  acquire(&tickslock);
+  //TODO delete cprintf("acquire(&tickslock)\n");
+  if((*pte1) & PTE_A){
+    ++chosen->age;
+    *pte1 &= ~PTE_A;
+    //TODO delete cprintf("========\n\nWOW! Matan was right!\n(never saw this actually printed)=======\n\n");
+  }
+  release(&tickslock);
+
+  //make swap
+  proc->swappedpages[i].va = chosen->va;
+  int num = 0;
+  if ((num = writeToSwapFile(proc, (char*)PTE_ADDR(chosen->va), i * PGSIZE, PGSIZE)) == 0)
+    return 0;
+
+  kfree((char*)PTE_ADDR(P2V_WO(*walkpgdir(proc->pgdir, chosen->va, 0))));
+  *pte1 = PTE_W | PTE_U | PTE_PG;
+  ++proc->totalPagedOutCount;
+  ++proc->pagesinswapfile;
+
+  //TODO delete   cprintf("++proc->pagesinswapfile : %d", proc->pagesinswapfile);
+
+  lcr3(v2p(proc->pgdir));
+  chosen->va = va;
+
+  // unnecessary but will do for now
+  return chosen;
+}
+
+struct freepg *writePageToSwapFile(char* va) {
+  //TODO delete $$$
+
+#if FIFO
+  return fifoWrite();
+#else
+
+#if SCFIFO
+  //TODO cprintf("writePageToSwapFile: calling scWrite\n");
+  return scWrite(va);
+#else
+
+#if NFU
+  return nfuWrite(va);
+#endif
+#endif
+#endif
+  //TODO: delete cprintf("none of the above...\n");
+  return 0;
+}
+
 // Allocate page tables and physical memory to grow process from oldsz to
 // newsz, which need not be page aligned.  Returns new size or 0 on error.
 int
@@ -224,6 +523,11 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
   char *mem;
   uint a;
 
+#ifndef NONE
+  uint newpage = 1;
+  struct freepg *l;
+#endif
+
   if(newsz >= KERNBASE)
     return 0;
   if(newsz < oldsz)
@@ -231,19 +535,46 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 
   a = PGROUNDUP(oldsz);
   for(; a < newsz; a += PGSIZE){
+#ifndef NONE
+    //TODO delete     cprintf("inside #ifndef NONE: checking pages in mem: %d\n", proc->pagesinmem);
+    // TODO: check if we should add another test for init and shel here...
+    if(proc->pagesinmem >= MAX_PSYC_PAGES) {
+      // TODO delete cprintf("writing to swap file, proc->name: %s, pagesinmem: %d\n", proc->name, proc->pagesinmem);
+
+      //TODO remove l! it doesn't belong here
+      if ((l = writePageToSwapFile((char*)a)) == 0)
+        panic("allocuvm: error writing page to swap file");
+
+      //TODO: these FIFO specific steps don't belong here!
+      // they should move to a FIFO specific functiom!
+      #if FIFO
+      //TODO cprintf("allocuvm: FIFO's little part\n");
+      l->va = (char*)a;
+      l->next = proc->head;
+      proc->head = l;
+      #endif
+
+      newpage = 0;
+    }
+#endif
     mem = kalloc();
     if(mem == 0){
       cprintf("allocuvm out of memory\n");
       deallocuvm(pgdir, newsz, oldsz);
+      // TODO delete proc->pagesNo--;
       return 0;
     }
-    memset(mem, 0, PGSIZE);
-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
-      cprintf("allocuvm out of memory (2)\n");
-      deallocuvm(pgdir, newsz, oldsz);
-      kfree(mem);
-      return 0;
+    #ifndef NONE
+    if (newpage){
+      //TODO delete cprintf("nepage = 1");
+      //if(proc->pagesinmem >= 11)
+        //TODO delete cprintf("recorded new page, proc->name: %s, pagesinmem: %d\n", proc->name, proc->pagesinmem);
+      recordNewPage((char*)a);
     }
+    #endif
+    memset(mem, 0, PGSIZE);
+    //TODO delete cprintf("mappages(pgdir, (char*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);\n");
+    mappages(pgdir, (char*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);
   }
   return newsz;
 }
@@ -257,6 +588,7 @@ deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 {
   pte_t *pte;
   uint a, pa;
+  int i;
 
   if(newsz >= oldsz)
     return oldsz;
@@ -265,15 +597,145 @@ deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
   for(; a  < oldsz; a += PGSIZE){
     pte = walkpgdir(pgdir, (char*)a, 0);
     if(!pte)
-      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+      a += (NPTENTRIES - 1) * PGSIZE;
     else if((*pte & PTE_P) != 0){
       pa = PTE_ADDR(*pte);
       if(pa == 0)
         panic("kfree");
-      char *v = P2V(pa);
+      if (proc->pgdir == pgdir) {
+        /*
+        The process itself is deallocating pages via sbrk() with a negative
+        argument. Update proc's data structure accordingly.
+        */
+#ifndef NONE
+        for (i = 0; i < MAX_PSYC_PAGES; i++) {
+          if (proc->freepages[i].va == (char*)a)
+            goto founddeallocuvmPTEP;
+        }
+
+        panic("deallocuvm: entry not found in proc->freepages");
+founddeallocuvmPTEP:
+        proc->freepages[i].va = (char*) 0xffffffff;
+#if FIFO
+        if (proc->head == &proc->freepages[i])
+          proc->head = proc->freepages[i].next;
+        else {
+          struct freepg *l = proc->head;
+          while (l->next != &proc->freepages[i])
+            l = l->next;
+          l->next = proc->freepages[i].next;
+        }
+        proc->freepages[i].next = 0;
+
+//#endif
+#elif SCFIFO
+        //TODO  cprintf("deallocuvm: entering SCFIFO part\n");
+
+        if (proc->head == &proc->freepages[i]){
+          proc->head = proc->freepages[i].next;
+          if(proc->head != 0)
+            proc->head->prev = 0;
+          goto doneLooking;
+        }
+        if (proc->tail == &proc->freepages[i]){
+          proc->tail = proc->freepages[i].prev;
+          if(proc->tail != 0)// should allways be true but lets be extra safe...
+            proc->tail->next = 0;
+          goto doneLooking;
+        }
+        struct freepg *l = proc->head;
+        while (l->next != 0 && l->next != &proc->freepages[i]){
+          l = l->next;
+        }
+        l->next = proc->freepages[i].next;
+        if (proc->freepages[i].next != 0){
+          proc->freepages[i].next->prev = l;
+        }
+
+doneLooking:
+        //TODO delete cprintf("deallocCount = %d\n", ++deallocCount);
+        proc->freepages[i].next = 0;
+        proc->freepages[i].prev = 0;
+
+/*
+this messy version is commented out
+
+        if (proc->head == &proc->freepages[i]){
+          cprintf("deallocuvm: deleting head\n");
+          proc->head = proc->freepages[i].next;
+          if(proc->head != 0)
+            proc->head->prev = 0;
+          goto doneLooking;
+        }
+        if (proc->tail == &proc->freepages[i]){
+          cprintf("deallocuvm: deleting tail\n");
+          proc->tail = proc->freepages[i].prev;
+          if(proc->tail != 0)// should allways be true but lets be extra safe...
+            proc->tail->next = 0;
+          goto doneLooking;
+        }
+        struct freepg *l = proc->head;
+        cprintf("deallocuvm: find someone between\n");
+        while (l->next != 0 && l->next != &proc->freepages[i]){
+          cprintf("deallocuvm: l = l->next\n");
+          l = l->next;
+        }
+        if(l->next == 0)
+          cprintf("l->next == 0\n");
+        else
+          cprintf("deallocuvm: found link to delete in the middle\n");
+        l->next = proc->freepages[i].next;
+        if (proc->freepages[i].next != 0){
+          cprintf("proc->freepages[i].next != 0\n");
+          proc->freepages[i].next->prev = l;
+        }
+*/
+        
+/*
+  cprintf("first version\n");
+  if (proc->head == &proc->freepages[i])
+    proc->head = proc->freepages[i].next;
+  if (proc->tail == &proc->freepages[i])
+    proc->tail = proc->freepages[i].prev;
+  else {
+    struct freepg *l = proc->head;
+    while (l->next != &proc->freepages[i])
+      l = l->next;
+      l->next = proc->freepages[i].next;
+      if (proc->freepages[i].next != 0)
+        proc->freepages[i].next->prev = l;
+  }
+  proc->freepages[i].next = 0;
+  proc->freepages[i].prev = 0;
+*/
+//#if NFU
+#elif NFU
+        proc->freepages[i].age = 0;
+#endif
+#endif
+
+        proc->pagesinmem--;
+      }
+      char *v = p2v(pa);
       kfree(v);
       *pte = 0;
     }
+    else if (*pte & PTE_PG && proc->pgdir == pgdir) {
+      /*
+      The process itself is deallocating pages via sbrk() with a negative
+      argument. Update proc's data structure accordingly.
+      */
+        for (i = 0; i < MAX_PSYC_PAGES; i++) {
+          if (proc->swappedpages[i].va == (char*)a)
+            goto founddeallocuvmPTEPG;
+        }
+        panic("deallocuvm: entry not found in proc->swappedpages");
+founddeallocuvmPTEPG:
+        proc->swappedpages[i].va = (char*) 0xffffffff;
+        proc->swappedpages[i].age = 0;
+        proc->swappedpages[i].swaploc = 0;
+        proc->pagesinswapfile--;
+    }
   }
   return newsz;
 }
@@ -287,10 +749,11 @@ freevm(pde_t *pgdir)
 
   if(pgdir == 0)
     panic("freevm: no pgdir");
+  // TODO delete cprintf("freevm pid %d\n", proc->pid);
   deallocuvm(pgdir, KERNBASE, 0);
   for(i = 0; i < NPDENTRIES; i++){
     if(pgdir[i] & PTE_P){
-      char * v = P2V(PTE_ADDR(pgdir[i]));
+      char * v = p2v(PTE_ADDR(pgdir[i]));
       kfree(v);
     }
   }
@@ -325,17 +788,23 @@ copyuvm(pde_t *pgdir, uint sz)
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
       panic("copyuvm: pte should exist");
-    if(!(*pte & PTE_P))
+    if(!(*pte & PTE_P) && !(*pte & PTE_PG))
       panic("copyuvm: page not present");
+    if (*pte & PTE_PG) {
+      // cprintf("copyuvm PTR_PG\n"); // TODO delete
+      pte = walkpgdir(d, (void*) i, 1);
+      *pte = PTE_U | PTE_W | PTE_PG;
+      continue;
+    }
     pa = PTE_ADDR(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
       goto bad;
-    memmove(mem, (char*)P2V(pa), PGSIZE);
-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
-      kfree(mem);
+
+    // TODO delete cprintf("copyuvm:kalloc pid %d\n", proc->pid);
+    memmove(mem, (char*)p2v(pa), PGSIZE);
+    if(mappages(d, (void*)i, PGSIZE, v2p(mem), flags) < 0)
       goto bad;
-    }
   }
   return d;
 
@@ -356,7 +825,7 @@ uva2ka(pde_t *pgdir, char *uva)
     return 0;
   if((*pte & PTE_U) == 0)
     return 0;
-  return (char*)P2V(PTE_ADDR(*pte));
+  return (char*)p2v(PTE_ADDR(*pte));
 }
 
 // Copy len bytes from p to user address va in page table pgdir.
@@ -385,10 +854,269 @@ copyout(pde_t *pgdir, uint va, void *p, uint len)
   return 0;
 }
 
+void fifoSwap(uint addr){
+  int i, j;
+  char buf[BUF_SIZE];
+  pte_t *pte1, *pte2;
+
+  struct freepg *link = proc->head;
+  struct freepg *l;
+  if (link == 0)
+    panic("fifoSwap: proc->head is NULL");
+  if (link->next == 0)
+    panic("fifoSwap: single page in phys mem");
+  // find the before-last link in the used pages list
+  while (link->next->next != 0)
+    link = link->next;
+  l = link->next;
+  link->next = 0;
+
+  if(DEBUG){
+    //cprintf("\naddress between 0x%x and 0x%x was accessed but was on disk.\n", addr, addr+PGSIZE);
+    cprintf("FIFO chose to page out page starting at 0x%x \n\n", l->va);
+  }
+
+  //find the address of the page table entry to copy into the swap file
+  pte1 = walkpgdir(proc->pgdir, (void*)l->va, 0);
+  if (!*pte1)
+    panic("swapFile: FIFO pte1 is empty");
+  //find a swap file page descriptor slot
+  for (i = 0; i < MAX_PSYC_PAGES; i++)
+    if (proc->swappedpages[i].va == (char*)PTE_ADDR(addr))
+      goto foundswappedslot;
+  panic("swappages");
+foundswappedslot:
+  //update relevant fields in proc
+  // proc->swappedpages[i].va = (char*)P2V_WO(PTE_ADDR(*pte1)); // WRONG!!!
+  proc->swappedpages[i].va = l->va;
+  //assign the physical page to addr in the relevant page table
+  pte2 = walkpgdir(proc->pgdir, (void*)addr, 0);
+  if (!*pte2)
+    panic("swapFile: FIFO pte2 is empty");
+  //set page table entry
+  *pte2 = PTE_ADDR(*pte1) | PTE_U | PTE_W | PTE_P;
+  for (j = 0; j < 4; j++) {
+    int loc = (i * PGSIZE) + ((PGSIZE / 4) * j);
+    // cprintf("i:%d j:%d loc:0x%x\n", i,j,loc);//TODO delete
+    int addroffset = ((PGSIZE / 4) * j);
+    // int read, written;
+    memset(buf, 0, BUF_SIZE);
+    //copy the new page from the swap file to buf
+    // read =
+    readFromSwapFile(proc, buf, loc, BUF_SIZE);
+    // cprintf("read:%d\n", read);//TODO delete
+    //copy the old page from the memory to the swap file
+    //written =
+    writeToSwapFile(proc, (char*)(P2V_WO(PTE_ADDR(*pte1)) + addroffset), loc, BUF_SIZE);
+    // cprintf("written:%d\n", written);//TODO delete
+    //copy the new page from buf to the memory
+    memmove((void*)(PTE_ADDR(addr) + addroffset), (void*)buf, BUF_SIZE);
+  }
+  //update the page table entry flags, reset the physical page address
+  *pte1 = PTE_U | PTE_W | PTE_PG;
+  //update l to hold the new va
+  l->next = proc->head;
+  proc->head = l;
+  l->va = (char*)PTE_ADDR(addr);
+}
+
+void scSwap(uint addr) {
+  int i, j;
+  char buf[BUF_SIZE];
+  pte_t *pte1, *pte2;
+  struct freepg *mover, *oldTail;
+
+  if (proc->head == 0)
+    panic("scSwap: proc->head is NULL");
+  if (proc->head->next == 0)
+    panic("scSwap: single page in phys mem");
+
+  mover = proc->tail;
+  oldTail = proc->tail;// to avoid infinite loop if somehow everyone was accessed
+  do{
+    //move mover from tail to head
+    proc->tail = proc->tail->prev;
+    proc->tail->next = 0;
+    mover->prev = 0;
+    mover->next = proc->head;
+    proc->head->prev = mover;
+    proc->head = mover;
+    mover = proc->tail;
+  }while(checkAccBit(proc->head->va) && mover != oldTail);
+
+  if(DEBUG){
+    //cprintf("\naddress between 0x%x and 0x%x was accessed but was on disk.\n", addr, addr+PGSIZE);
+    cprintf("SCFIFO chose to page out page starting at 0x%x \n\n", proc->head->va);
+  }
+
+  //find the address of the page table entry to copy into the swap file
+  pte1 = walkpgdir(proc->pgdir, (void*)proc->head->va, 0);
+  if (!*pte1)
+    panic("swapFile: SCFIFO pte1 is empty");
+
+  //find a swap file page descriptor slot
+  for (i = 0; i < MAX_PSYC_PAGES; i++){
+    if (proc->swappedpages[i].va == (char*)PTE_ADDR(addr))
+      goto foundswappedpageslot;
+  }
+  panic("scSwap: SCFIFO no slot for swapped page");
+
+foundswappedpageslot:
+
+  proc->swappedpages[i].va = proc->head->va;
+  //assign the physical page to addr in the relevant page table
+  pte2 = walkpgdir(proc->pgdir, (void*)addr, 0);
+  if (!*pte2)
+    panic("swapFile: SCFIFO pte2 is empty");
+  //set page table entry
+  //TODO verify we're not setting PTE_U where we shouldn't be...
+  *pte2 = PTE_ADDR(*pte1) | PTE_U | PTE_W | PTE_P;// access bit is zeroed...
+
+  for (j = 0; j < 4; j++) {
+    int loc = (i * PGSIZE) + ((PGSIZE / 4) * j);
+    // cprintf("i:%d j:%d loc:0x%x\n", i,j,loc);//TODO delete
+    int addroffset = ((PGSIZE / 4) * j);
+    // int read, written;
+    memset(buf, 0, BUF_SIZE);
+    //copy the new page from the swap file to buf
+    // read =
+    readFromSwapFile(proc, buf, loc, BUF_SIZE);
+    // cprintf("read:%d\n", read);//TODO delete
+    //copy the old page from the memory to the swap file
+    //written =
+    writeToSwapFile(proc, (char*)(P2V_WO(PTE_ADDR(*pte1)) + addroffset), loc, BUF_SIZE);
+    // cprintf("written:%d\n", written);//TODO delete
+    //copy the new page from buf to the memory
+    memmove((void*)(PTE_ADDR(addr) + addroffset), (void*)buf, BUF_SIZE);
+  }
+  //update the page table entry flags, reset the physical page address
+  *pte1 = PTE_U | PTE_W | PTE_PG;
+  //update l to hold the new va
+  //l->next = proc->head;
+  //proc->head = l;
+  proc->head->va = (char*)PTE_ADDR(addr);
+
+}
+
+void nfuSwap(uint addr) {
+  int i, j;
+  uint maxIndx = -1, maxAge = 0;// MAX_POSSIBLE;
+  char buf[BUF_SIZE];
+  pte_t *pte1, *pte2;
+  struct freepg *chosen;
+
+  //TODO delete   cprintf("MAX_POSSIBLE = %d\n", MAX_POSSIBLE);
+
+  for (j = 0; j < MAX_PSYC_PAGES; j++)
+    if (proc->freepages[j].va != (char*)0xffffffff){
+      //TODO delete      if(proc->freepages[j].age > 0)      cprintf("i=%d, age=%d, || ", j, proc->freepages[j].age);
+      if (proc->freepages[j].age > maxAge){//TODO should be <= not < just wanted to see different indexes than 14
+        maxAge = proc->freepages[j].age;
+        maxIndx = j;
+      }
+    }
+
+  if(maxIndx == -1)
+    panic("nfuSwap: no free page to swap???");
+  chosen = &proc->freepages[maxIndx];
+
+  if(DEBUG){
+    //cprintf("\naddress between 0x%x and 0x%x was accessed but was on disk.\n", addr, addr+PGSIZE);
+    cprintf("NFU chose to page out page starting at 0x%x \n\n", chosen->va);
+  }
+
+  //find the address of the page table entry to copy into the swap file
+  pte1 = walkpgdir(proc->pgdir, (void*)chosen->va, 0);
+  if (!*pte1)
+    panic("nfuSwap: pte1 is empty");
+
+//  TODO verify: b4 accessing by writing to file,
+//  update accessed bit and age in case it misses a clock tick?
+//  be extra careful not to double add by locking
+  acquire(&tickslock);
+  //TODO delete cprintf("acquire(&tickslock)\n");
+  if((*pte1) & PTE_A){
+    ++chosen->age;
+    *pte1 &= ~PTE_A;
+    //TODO delete cprintf("========\n\nWOW! Matan was right!\n(never saw this actually printed)=======\n\n");
+  }
+  release(&tickslock);
+
+  //find a swap file page descriptor slot
+  for (i = 0; i < MAX_PSYC_PAGES; i++){
+    if (proc->swappedpages[i].va == (char*)PTE_ADDR(addr))
+      goto foundswappedpageslot;
+  }
+  panic("nfuSwap: no slot for swapped page");
+
+foundswappedpageslot:
+
+  proc->swappedpages[i].va = chosen->va;
+  //assign the physical page to addr in the relevant page table
+  pte2 = walkpgdir(proc->pgdir, (void*)addr, 0);
+  if (!*pte2)
+    panic("nfuSwap: pte2 is empty");
+  //set page table entry
+  //TODO verify we're not setting PTE_U where we shouldn't be...
+  *pte2 = PTE_ADDR(*pte1) | PTE_U | PTE_W | PTE_P;// access bit is zeroed...
+
+  for (j = 0; j < 4; j++) {
+    int loc = (i * PGSIZE) + ((PGSIZE / 4) * j);
+    // cprintf("i:%d j:%d loc:0x%x\n", i,j,loc);//TODO delete
+    int addroffset = ((PGSIZE / 4) * j);
+    // int read, written;
+    memset(buf, 0, BUF_SIZE);
+    //copy the new page from the swap file to buf
+    // read =
+    readFromSwapFile(proc, buf, loc, BUF_SIZE);
+    // cprintf("read:%d\n", read);//TODO delete
+    //copy the old page from the memory to the swap file
+    //written =
+    writeToSwapFile(proc, (char*)(P2V_WO(PTE_ADDR(*pte1)) + addroffset), loc, BUF_SIZE);
+    // cprintf("written:%d\n", written);//TODO delete
+    //copy the new page from buf to the memory
+    memmove((void*)(PTE_ADDR(addr) + addroffset), (void*)buf, BUF_SIZE);
+  }
+  //update the page table entry flags, reset the physical page address
+  *pte1 = PTE_U | PTE_W | PTE_PG;
+  //update l to hold the new va
+  //l->next = proc->head;
+  //proc->head = l;
+  chosen->va = (char*)PTE_ADDR(addr);
+  // was this missed some how???
+  chosen->age = 0;
+}
+
+void swapPages(uint addr) {
+  //TODO delet   cprintf("resched swapPages!\n");
+  if (strcmp(proc->name, "init") == 0 || strcmp(proc->name, "sh") == 0) {
+    proc->pagesinmem++;
+    return;
+  }
+//TODO delete $$$
+
+#if FIFO
+  fifoSwap(addr);
+#else
+
+#if SCFIFO
+  //cprintf("swapPages: calling scSwap\n");
+  scSwap(addr);
+#else
+
+#if NFU
+  nfuSwap(addr);
+#endif
+#endif
+#endif
+  lcr3(v2p(proc->pgdir));
+  ++proc->totalPagedOutCount;
+  // cprintf("swapPages:proc->totalPagedOutCount:%d\n", ++proc->totalPagedOutCount);//TODO delete
+}
+
 //PAGEBREAK!
 // Blank page.
 //PAGEBREAK!
 // Blank page.
 //PAGEBREAK!
 // Blank page.
-
diff --git a/xv6-public/zombie.c b/xv6-paging/zombie.c
index ee817da..077c02c 100644
--- a/xv6-public/zombie.c
+++ b/xv6-paging/zombie.c
@@ -1,4 +1,4 @@
-// Create a zombie process that
+// Create a zombie process that 
 // must be reparented at exit.
 
 #include "types.h"
